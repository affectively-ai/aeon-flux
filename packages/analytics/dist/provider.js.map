{
  "version": 3,
  "sources": ["../src/provider.tsx", "../src/use-analytics.ts", "../src/data-layer.ts", "../src/gtm-loader.ts", "../src/context-bridge.ts", "../src/merkle-tree.ts", "../src/click-tracker.ts"],
  "sourcesContent": [
    "/**\n * Aeon Analytics Provider\n *\n * React context provider for analytics configuration.\n * Wraps useAeonAnalytics in a provider pattern for easier usage.\n */\n\nimport React, { createContext, useContext, useMemo } from 'react';\nimport type { AnalyticsConfig, MerkleTree } from './types';\nimport { useAeonAnalytics, type UseAnalyticsReturn } from './use-analytics';\n\n// ============================================================================\n// Context\n// ============================================================================\n\ninterface AnalyticsContextValue extends UseAnalyticsReturn {\n  config: AnalyticsConfig;\n}\n\nconst AnalyticsContext = createContext<AnalyticsContextValue | null>(null);\n\n// ============================================================================\n// Provider Props\n// ============================================================================\n\nexport interface AeonAnalyticsProviderProps extends AnalyticsConfig {\n  children: React.ReactNode;\n}\n\n// ============================================================================\n// Provider Component\n// ============================================================================\n\n/**\n * Aeon Analytics Provider\n *\n * Wrap your app with this provider to enable automatic click tracking.\n *\n * @example\n * ```tsx\n * import { AeonAnalyticsProvider } from '@affectively/aeon-pages-analytics/react';\n *\n * export default function App({ Component, pageProps }) {\n *   return (\n *     <AeonAnalyticsProvider\n *       gtmContainerId=\"GTM-XXXXXX\"\n *       trackClicks={true}\n *       syncESIContext={true}\n *     >\n *       <Component {...pageProps} />\n *     </AeonAnalyticsProvider>\n *   );\n * }\n * ```\n */\nexport function AeonAnalyticsProvider({\n  children,\n  ...config\n}: AeonAnalyticsProviderProps): React.JSX.Element {\n  // Initialize analytics\n  const analytics = useAeonAnalytics(config);\n\n  // Memoize context value\n  const contextValue = useMemo<AnalyticsContextValue>(\n    () => ({\n      ...analytics,\n      config,\n    }),\n    [\n      analytics.isInitialized,\n      analytics.isGTMReady,\n      config.gtmContainerId,\n      config.trackClicks,\n      config.trackPageViews,\n      config.syncESIContext,\n    ],\n  );\n\n  return (\n    <AnalyticsContext.Provider value={contextValue}>\n      {children}\n    </AnalyticsContext.Provider>\n  );\n}\n\n// ============================================================================\n// Hook to use Analytics Context\n// ============================================================================\n\n/**\n * Use analytics context in a component\n *\n * @example\n * ```tsx\n * function MyComponent() {\n *   const { trackClick, trackInteraction } = useAnalytics();\n *\n *   return (\n *     <button onClick={(e) => trackInteraction('custom_action', { value: 123 })}>\n *       Track Me\n *     </button>\n *   );\n * }\n * ```\n */\nexport function useAnalytics(): AnalyticsContextValue {\n  const context = useContext(AnalyticsContext);\n\n  if (!context) {\n    throw new Error(\n      'useAnalytics must be used within an AeonAnalyticsProvider. ' +\n        'Wrap your app with <AeonAnalyticsProvider gtmContainerId=\"GTM-XXXXXX\">.',\n    );\n  }\n\n  return context;\n}\n\n/**\n * Optional analytics context (returns null if not in provider)\n */\nexport function useAnalyticsOptional(): AnalyticsContextValue | null {\n  return useContext(AnalyticsContext);\n}\n\n// ============================================================================\n// Higher-Order Component\n// ============================================================================\n\n/**\n * HOC to inject analytics props into a component\n */\nexport function withAnalytics<P extends object>(\n  Component: React.ComponentType<P & { analytics: AnalyticsContextValue }>,\n): React.FC<P> {\n  return function WrappedComponent(props: P) {\n    const analytics = useAnalytics();\n    return <Component {...props} analytics={analytics} />;\n  };\n}\n\n// ============================================================================\n// Render Props Component\n// ============================================================================\n\ninterface AnalyticsRenderProps {\n  children: (analytics: AnalyticsContextValue) => React.ReactNode;\n}\n\n/**\n * Render props component for analytics\n *\n * @example\n * ```tsx\n * <Analytics>\n *   {({ trackInteraction }) => (\n *     <button onClick={() => trackInteraction('click', {})}>\n *       Click me\n *     </button>\n *   )}\n * </Analytics>\n * ```\n */\nexport function Analytics({ children }: AnalyticsRenderProps): React.ReactNode {\n  const analytics = useAnalytics();\n  return children(analytics);\n}\n\n// ============================================================================\n// Merkle Tree Provider\n// ============================================================================\n\ninterface MerkleTreeProviderProps {\n  tree: MerkleTree;\n  children: React.ReactNode;\n}\n\n/**\n * Provide Merkle tree for current page\n *\n * Use this when you have a Merkle tree from SSR/build time.\n */\nexport function MerkleTreeProvider({\n  tree,\n  children,\n}: MerkleTreeProviderProps): React.JSX.Element {\n  const analytics = useAnalyticsOptional();\n\n  // Set Merkle tree on mount\n  React.useEffect(() => {\n    if (analytics) {\n      analytics.setMerkleTree(tree);\n    } else {\n      // No provider, set directly on window\n      window.__AEON_MERKLE_TREE__ = tree;\n    }\n  }, [tree, analytics]);\n\n  return <>{children}</>;\n}\n\n// ============================================================================\n// Track Component\n// ============================================================================\n\ninterface TrackProps {\n  /** Tracking event name */\n  event: string;\n  /** Additional data to track */\n  data?: Record<string, unknown>;\n  /** Track on mount */\n  onMount?: boolean;\n  /** Track on click */\n  onClick?: boolean;\n  /** Track on visibility */\n  onVisible?: boolean;\n  /** Children to render */\n  children: React.ReactElement;\n}\n\n/**\n * Wrapper component that automatically tracks events\n *\n * @example\n * ```tsx\n * <Track event=\"cta_view\" onVisible data={{ variant: 'A' }}>\n *   <button>Sign Up</button>\n * </Track>\n * ```\n */\nexport function Track({\n  event,\n  data = {},\n  onMount = false,\n  onClick = false,\n  onVisible = false,\n  children,\n}: TrackProps): React.ReactElement {\n  const analytics = useAnalyticsOptional();\n  const ref = React.useRef<HTMLElement>(null);\n  const hasTrackedVisibility = React.useRef(false);\n\n  // Track on mount\n  React.useEffect(() => {\n    if (onMount && analytics) {\n      analytics.trackInteraction(event, { ...data, trigger: 'mount' });\n    }\n  }, [onMount, event]);\n\n  // Track on visibility\n  React.useEffect(() => {\n    if (!onVisible || !analytics || hasTrackedVisibility.current) {\n      return;\n    }\n\n    const element = ref.current;\n    if (!element) return;\n\n    const observer = new IntersectionObserver(\n      (entries) => {\n        for (const entry of entries) {\n          if (entry.isIntersecting && !hasTrackedVisibility.current) {\n            hasTrackedVisibility.current = true;\n            analytics.trackInteraction(\n              event,\n              { ...data, trigger: 'visible' },\n              element,\n            );\n            observer.disconnect();\n          }\n        }\n      },\n      { threshold: 0.5 },\n    );\n\n    observer.observe(element);\n\n    return () => observer.disconnect();\n  }, [onVisible, event, analytics]);\n\n  // Clone child with click handler\n  if (onClick && analytics) {\n    return React.cloneElement(children, {\n      ref,\n      onClick: (e: React.MouseEvent<HTMLElement>) => {\n        analytics.trackInteraction(\n          event,\n          { ...data, trigger: 'click' },\n          e.currentTarget,\n        );\n        // Call original onClick if exists\n        if (children.props.onClick) {\n          children.props.onClick(e);\n        }\n      },\n    });\n  }\n\n  return React.cloneElement(children, { ref });\n}\n",
    "/**\n * React Hook for Aeon Analytics\n *\n * Initializes GTM, syncs ESI context, and starts click tracking.\n * One hook to rule them all.\n */\n\nimport { useEffect, useRef, useCallback } from 'react';\nimport type { AnalyticsConfig, MerkleTree } from './types';\nimport { initializeGTM, waitForGTM } from './gtm-loader';\nimport { initContextBridge, pushPageView, getESIState } from './context-bridge';\nimport {\n  initClickTracker,\n  trackClick,\n  trackInteraction,\n} from './click-tracker';\nimport { setDebugMode } from './data-layer';\n\n// ============================================================================\n// Hook Return Type\n// ============================================================================\n\nexport interface UseAnalyticsReturn {\n  /** Whether analytics is initialized */\n  isInitialized: boolean;\n\n  /** Whether GTM is loaded and ready */\n  isGTMReady: boolean;\n\n  /** Manually track a click on an element */\n  trackClick: (element: HTMLElement, event?: MouseEvent) => void;\n\n  /** Track a custom interaction */\n  trackInteraction: (\n    name: string,\n    data: Record<string, unknown>,\n    element?: HTMLElement,\n  ) => void;\n\n  /** Manually push a page view */\n  pushPageView: (merkleRoot?: string) => void;\n\n  /** Set the current Merkle tree (for page view tracking) */\n  setMerkleTree: (tree: MerkleTree) => void;\n}\n\n// ============================================================================\n// Main Hook\n// ============================================================================\n\n/**\n * Initialize Aeon Analytics with automatic click tracking\n *\n * @example\n * ```tsx\n * function App() {\n *   useAeonAnalytics({\n *     gtmContainerId: 'GTM-XXXXXX',\n *     trackClicks: true,\n *     syncESIContext: true,\n *   });\n *\n *   return <div>My App</div>;\n * }\n * ```\n */\nexport function useAeonAnalytics(config: AnalyticsConfig): UseAnalyticsReturn {\n  const initializedRef = useRef(false);\n  const gtmReadyRef = useRef(false);\n  const cleanupRef = useRef<(() => void) | null>(null);\n  const merkleTreeRef = useRef<MerkleTree | null>(null);\n  const configRef = useRef(config);\n\n  // Keep config ref updated\n  configRef.current = config;\n\n  // Initialize on mount\n  useEffect(() => {\n    // Prevent double initialization\n    if (initializedRef.current || window.__AEON_ANALYTICS_INITIALIZED__) {\n      return;\n    }\n\n    initializedRef.current = true;\n    window.__AEON_ANALYTICS_INITIALIZED__ = true;\n\n    // Enable debug mode if configured\n    if (config.debug) {\n      setDebugMode(true);\n    }\n\n    const cleanupFunctions: (() => void)[] = [];\n\n    // 1. Initialize GTM\n    if (config.gtmContainerId) {\n      initializeGTM({\n        containerId: config.gtmContainerId,\n        dataLayerName: config.dataLayerName,\n      });\n\n      // Wait for GTM to be ready\n      waitForGTM().then((ready) => {\n        gtmReadyRef.current = ready;\n      });\n    }\n\n    // 2. Initialize ESI context bridge\n    if (config.syncESIContext !== false) {\n      const cleanup = initContextBridge({\n        dataLayerName: config.dataLayerName,\n        eventPrefix: config.eventPrefix,\n        syncESIContext: config.syncESIContext,\n      });\n      cleanupFunctions.push(cleanup);\n    }\n\n    // 3. Initialize click tracking\n    if (config.trackClicks !== false) {\n      const cleanup = initClickTracker(config);\n      cleanupFunctions.push(cleanup);\n    }\n\n    // 4. Push initial page view\n    if (config.trackPageViews !== false) {\n      const merkleRoot = merkleTreeRef.current?.rootHash || '';\n      pushPageView(\n        {\n          dataLayerName: config.dataLayerName,\n          eventPrefix: config.eventPrefix,\n        },\n        merkleRoot,\n      );\n    }\n\n    // Store cleanup function\n    cleanupRef.current = () => {\n      for (const cleanup of cleanupFunctions) {\n        cleanup();\n      }\n      window.__AEON_ANALYTICS_INITIALIZED__ = false;\n    };\n\n    // Cleanup on unmount\n    return () => {\n      if (cleanupRef.current) {\n        cleanupRef.current();\n        cleanupRef.current = null;\n      }\n      initializedRef.current = false;\n    };\n  }, []); // Only run once on mount\n\n  // Handle route changes\n  useEffect(() => {\n    if (!initializedRef.current || config.trackPageViews === false) {\n      return;\n    }\n\n    // Push page view on pathname change\n    const merkleRoot = merkleTreeRef.current?.rootHash || '';\n    pushPageView(\n      {\n        dataLayerName: config.dataLayerName,\n        eventPrefix: config.eventPrefix,\n      },\n      merkleRoot,\n    );\n  }, [typeof window !== 'undefined' ? window.location.pathname : '']);\n\n  // Manual track click\n  const handleTrackClick = useCallback(\n    (element: HTMLElement, event?: MouseEvent) => {\n      trackClick(element, event, {\n        dataLayerName: configRef.current.dataLayerName,\n        eventPrefix: configRef.current.eventPrefix,\n        clickOptions: configRef.current.clickOptions,\n      });\n    },\n    [],\n  );\n\n  // Manual track interaction\n  const handleTrackInteraction = useCallback(\n    (name: string, data: Record<string, unknown>, element?: HTMLElement) => {\n      trackInteraction(name, data, element, {\n        dataLayerName: configRef.current.dataLayerName,\n        eventPrefix: configRef.current.eventPrefix,\n      });\n    },\n    [],\n  );\n\n  // Manual push page view\n  const handlePushPageView = useCallback((merkleRoot?: string) => {\n    pushPageView(\n      {\n        dataLayerName: configRef.current.dataLayerName,\n        eventPrefix: configRef.current.eventPrefix,\n      },\n      merkleRoot || merkleTreeRef.current?.rootHash || '',\n    );\n  }, []);\n\n  // Set Merkle tree\n  const handleSetMerkleTree = useCallback((tree: MerkleTree) => {\n    merkleTreeRef.current = tree;\n    window.__AEON_MERKLE_TREE__ = tree;\n  }, []);\n\n  return {\n    isInitialized: initializedRef.current,\n    isGTMReady: gtmReadyRef.current,\n    trackClick: handleTrackClick,\n    trackInteraction: handleTrackInteraction,\n    pushPageView: handlePushPageView,\n    setMerkleTree: handleSetMerkleTree,\n  };\n}\n\n// ============================================================================\n// Utility Hooks\n// ============================================================================\n\n/**\n * Get current ESI state in a component\n */\nexport function useESIState() {\n  return getESIState();\n}\n\n/**\n * Track when a component mounts/unmounts\n */\nexport function useTrackMount(\n  componentName: string,\n  config?: Pick<AnalyticsConfig, 'dataLayerName' | 'eventPrefix'>,\n) {\n  useEffect(() => {\n    trackInteraction(\n      'component.mount',\n      { component: componentName },\n      undefined,\n      config,\n    );\n\n    return () => {\n      trackInteraction(\n        'component.unmount',\n        { component: componentName },\n        undefined,\n        config,\n      );\n    };\n  }, [componentName]);\n}\n\n/**\n * Track visibility of an element using IntersectionObserver\n */\nexport function useTrackVisibility(\n  ref: React.RefObject<HTMLElement>,\n  componentName: string,\n  config?: Pick<AnalyticsConfig, 'dataLayerName' | 'eventPrefix'>,\n) {\n  const hasTracked = useRef(false);\n\n  useEffect(() => {\n    if (!ref.current || hasTracked.current) {\n      return;\n    }\n\n    const observer = new IntersectionObserver(\n      (entries) => {\n        for (const entry of entries) {\n          if (entry.isIntersecting && !hasTracked.current) {\n            hasTracked.current = true;\n            trackInteraction(\n              'component.visible',\n              { component: componentName },\n              ref.current || undefined,\n              config,\n            );\n            observer.disconnect();\n          }\n        }\n      },\n      { threshold: 0.5 },\n    );\n\n    observer.observe(ref.current);\n\n    return () => {\n      observer.disconnect();\n    };\n  }, [componentName]);\n}\n",
    "/**\n * GTM dataLayer Integration\n *\n * Manages the dataLayer array and provides typed event pushing.\n * Ensures dataLayer exists and handles event formatting.\n */\n\nimport type {\n  AnalyticsConfig,\n  AeonEventBase,\n  ContextEvent,\n  PageViewEvent,\n  ClickEvent,\n  DataLayerEvent,\n  ESIState,\n  ElementInfo,\n  PositionInfo,\n} from './types';\n\n// ============================================================================\n// Constants\n// ============================================================================\n\n/** Current analytics version */\nexport const ANALYTICS_VERSION = '1.0.0';\n\n// ============================================================================\n// dataLayer Management\n// ============================================================================\n\n/**\n * Ensure dataLayer array exists on window\n */\nexport function ensureDataLayer(name = 'dataLayer'): unknown[] {\n  const w = window as unknown as Record<string, unknown>;\n\n  if (!w[name]) {\n    w[name] = [];\n  }\n\n  return w[name] as unknown[];\n}\n\n/**\n * Push event to dataLayer\n */\nexport function pushToDataLayer(\n  event: DataLayerEvent,\n  dataLayerName = 'dataLayer',\n): void {\n  const dataLayer = ensureDataLayer(dataLayerName);\n  dataLayer.push(event);\n\n  // Debug logging\n  if (\n    (window as Window & { __AEON_ANALYTICS_DEBUG__?: boolean })\n      .__AEON_ANALYTICS_DEBUG__\n  ) {\n    console.log('[Aeon Analytics]', event.event, event);\n  }\n}\n\n// ============================================================================\n// Event Builders\n// ============================================================================\n\n/**\n * Create base event structure\n */\nfunction createBaseEvent(eventName: string, prefix = 'aeon'): AeonEventBase {\n  return {\n    event: prefix ? `${prefix}.${eventName}` : eventName,\n    aeon: {\n      version: ANALYTICS_VERSION,\n      timestamp: Date.now(),\n    },\n  };\n}\n\n/**\n * Build context event from ESI state\n */\nexport function buildContextEvent(\n  esiState: ESIState,\n  prefix = 'aeon',\n): ContextEvent {\n  return {\n    ...createBaseEvent('context', prefix),\n    event: `${prefix}.context` as 'aeon.context',\n    user: {\n      tier: esiState.userTier,\n      id: esiState.userId,\n      sessionId: esiState.sessionId,\n      isNewSession: esiState.isNewSession,\n    },\n    emotion: esiState.emotionState,\n    preferences: esiState.preferences,\n    features: esiState.features,\n    device: {\n      viewport: esiState.viewport,\n      connection: esiState.connection,\n    },\n    time: {\n      localHour: esiState.localHour,\n      timezone: esiState.timezone,\n    },\n    recentPages: esiState.recentPages,\n  };\n}\n\n/**\n * Build page view event\n */\nexport function buildPageViewEvent(\n  path: string,\n  title: string,\n  merkleRoot: string,\n  esiState: ESIState,\n  prefix = 'aeon',\n): PageViewEvent {\n  return {\n    ...createBaseEvent('pageview', prefix),\n    event: `${prefix}.pageview` as 'aeon.pageview',\n    page: {\n      path,\n      title,\n      merkleRoot,\n    },\n    user: {\n      tier: esiState.userTier,\n      id: esiState.userId,\n      sessionId: esiState.sessionId,\n      isNewSession: esiState.isNewSession,\n    },\n    emotion: esiState.emotionState,\n    features: esiState.features,\n    device: {\n      viewport: esiState.viewport,\n      connection: esiState.connection,\n      reducedMotion: esiState.preferences.reducedMotion,\n    },\n    time: {\n      localHour: esiState.localHour,\n      timezone: esiState.timezone,\n    },\n  };\n}\n\n/**\n * Build click event\n */\nexport function buildClickEvent(\n  merkleHash: string,\n  treePath: string[],\n  treePathHashes: string[],\n  element: ElementInfo,\n  position: PositionInfo,\n  context: Partial<ESIState>,\n  prefix = 'aeon',\n): ClickEvent {\n  return {\n    ...createBaseEvent('click', prefix),\n    event: `${prefix}.click` as 'aeon.click',\n    click: {\n      merkleHash,\n      treePath,\n      treePathHashes,\n      element,\n      position,\n    },\n    context,\n  };\n}\n\n// ============================================================================\n// Element Info Extraction\n// ============================================================================\n\n/**\n * Extract element info for tracking\n */\nexport function extractElementInfo(\n  element: HTMLElement,\n  maxTextLength = 100,\n): ElementInfo {\n  // Get text content, truncated\n  let text = element.innerText || element.textContent || '';\n  if (text.length > maxTextLength) {\n    text = text.slice(0, maxTextLength) + '...';\n  }\n  // Clean whitespace\n  text = text.replace(/\\s+/g, ' ').trim();\n\n  return {\n    tagName: element.tagName,\n    text,\n    ariaLabel: element.getAttribute('aria-label') || undefined,\n    role: element.getAttribute('role') || undefined,\n    href: (element as HTMLAnchorElement).href || undefined,\n    id: element.id || undefined,\n    className: element.className || undefined,\n  };\n}\n\n/**\n * Extract position info from mouse event\n */\nexport function extractPositionInfo(event: MouseEvent): PositionInfo {\n  return {\n    x: event.pageX,\n    y: event.pageY,\n    viewportX: event.clientX,\n    viewportY: event.clientY,\n  };\n}\n\n// ============================================================================\n// Push Helpers\n// ============================================================================\n\n/**\n * Push context event to dataLayer\n */\nexport function pushContextEvent(\n  esiState: ESIState,\n  config: Pick<AnalyticsConfig, 'dataLayerName' | 'eventPrefix'>,\n): void {\n  const event = buildContextEvent(esiState, config.eventPrefix);\n  pushToDataLayer(event, config.dataLayerName);\n}\n\n/**\n * Push page view event to dataLayer\n */\nexport function pushPageViewEvent(\n  path: string,\n  title: string,\n  merkleRoot: string,\n  esiState: ESIState,\n  config: Pick<AnalyticsConfig, 'dataLayerName' | 'eventPrefix'>,\n): void {\n  const event = buildPageViewEvent(\n    path,\n    title,\n    merkleRoot,\n    esiState,\n    config.eventPrefix,\n  );\n  pushToDataLayer(event, config.dataLayerName);\n}\n\n/**\n * Push click event to dataLayer\n */\nexport function pushClickEvent(\n  merkleHash: string,\n  treePath: string[],\n  treePathHashes: string[],\n  element: ElementInfo,\n  position: PositionInfo,\n  context: Partial<ESIState>,\n  config: Pick<AnalyticsConfig, 'dataLayerName' | 'eventPrefix'>,\n): void {\n  const event = buildClickEvent(\n    merkleHash,\n    treePath,\n    treePathHashes,\n    element,\n    position,\n    context,\n    config.eventPrefix,\n  );\n  pushToDataLayer(event, config.dataLayerName);\n}\n\n// ============================================================================\n// Debug Mode\n// ============================================================================\n\n/**\n * Enable/disable debug logging\n */\nexport function setDebugMode(enabled: boolean): void {\n  (\n    window as Window & { __AEON_ANALYTICS_DEBUG__?: boolean }\n  ).__AEON_ANALYTICS_DEBUG__ = enabled;\n}\n\n/**\n * Get current dataLayer contents (for debugging)\n */\nexport function getDataLayer(name = 'dataLayer'): unknown[] {\n  return ensureDataLayer(name);\n}\n\n/**\n * Clear dataLayer (for testing)\n */\nexport function clearDataLayer(name = 'dataLayer'): void {\n  const w = window as unknown as Record<string, unknown>;\n  w[name] = [];\n}\n",
    "/**\n * GTM Script Loader\n *\n * Injects Google Tag Manager script and noscript iframe.\n * Handles async loading and ensures proper initialization order.\n */\n\nimport type { GTMConfig } from './types';\nimport { ensureDataLayer } from './data-layer';\n\n// ============================================================================\n// GTM Script Injection\n// ============================================================================\n\n/** Track if GTM has been injected */\nlet gtmInjected = false;\n\n/**\n * Generate GTM script inline code\n */\nfunction generateGTMScript(containerId: string, dataLayerName: string): string {\n  return `(function(w,d,s,l,i){w[l]=w[l]||[];w[l].push({'gtm.start':\nnew Date().getTime(),event:'gtm.js'});var f=d.getElementsByTagName(s)[0],\nj=d.createElement(s),dl=l!='dataLayer'?'&l='+l:'';j.async=true;j.src=\n'https://www.googletagmanager.com/gtm.js?id='+i+dl;f.parentNode.insertBefore(j,f);\n})(window,document,'script','${dataLayerName}','${containerId}');`;\n}\n\n/**\n * Validate GTM container ID format\n */\nfunction validateContainerId(containerId: string): boolean {\n  // GTM container ID format: GTM-XXXXXX (6-8 alphanumeric characters)\n  return /^GTM-[A-Z0-9]{6,8}$/i.test(containerId);\n}\n\n/**\n * Inject GTM script into document head\n */\nexport function injectGTM(config: GTMConfig): boolean {\n  // Prevent double injection\n  if (gtmInjected) {\n    console.warn('[Aeon Analytics] GTM already injected');\n    return false;\n  }\n\n  // Validate container ID\n  if (!validateContainerId(config.containerId)) {\n    console.error(\n      `[Aeon Analytics] Invalid GTM container ID: ${config.containerId}. ` +\n        'Expected format: GTM-XXXXXX',\n    );\n    return false;\n  }\n\n  // Ensure dataLayer exists before GTM loads\n  const dataLayerName = config.dataLayerName || 'dataLayer';\n  ensureDataLayer(dataLayerName);\n\n  // Create and inject script element\n  const script = document.createElement('script');\n  script.innerHTML = generateGTMScript(config.containerId, dataLayerName);\n\n  // Insert at beginning of head for earliest execution\n  if (document.head.firstChild) {\n    document.head.insertBefore(script, document.head.firstChild);\n  } else {\n    document.head.appendChild(script);\n  }\n\n  gtmInjected = true;\n  return true;\n}\n\n/**\n * Inject GTM noscript iframe into document body\n * For tracking when JavaScript is disabled\n */\nexport function injectGTMNoScript(containerId: string): boolean {\n  // Validate container ID\n  if (!validateContainerId(containerId)) {\n    return false;\n  }\n\n  // Check if noscript already exists\n  const existingNoscript = document.querySelector(\n    `noscript iframe[src*=\"googletagmanager.com/ns.html?id=${containerId}\"]`,\n  );\n  if (existingNoscript) {\n    return false;\n  }\n\n  // Create noscript element with iframe\n  const noscript = document.createElement('noscript');\n  const iframe = document.createElement('iframe');\n\n  iframe.src = `https://www.googletagmanager.com/ns.html?id=${containerId}`;\n  iframe.height = '0';\n  iframe.width = '0';\n  iframe.style.display = 'none';\n  iframe.style.visibility = 'hidden';\n\n  noscript.appendChild(iframe);\n\n  // Insert at beginning of body\n  if (document.body.firstChild) {\n    document.body.insertBefore(noscript, document.body.firstChild);\n  } else {\n    document.body.appendChild(noscript);\n  }\n\n  return true;\n}\n\n/**\n * Initialize GTM with full configuration\n */\nexport function initializeGTM(config: GTMConfig): boolean {\n  const scriptInjected = injectGTM(config);\n\n  // Only inject noscript if script was successfully injected\n  if (scriptInjected) {\n    injectGTMNoScript(config.containerId);\n  }\n\n  return scriptInjected;\n}\n\n// ============================================================================\n// Server-Side Rendering Helpers\n// ============================================================================\n\n/**\n * Generate GTM script tag for SSR\n * Returns HTML string to inject into <head>\n */\nexport function generateGTMScriptTag(config: GTMConfig): string {\n  if (!validateContainerId(config.containerId)) {\n    return '';\n  }\n\n  const dataLayerName = config.dataLayerName || 'dataLayer';\n\n  return `<script>${generateGTMScript(config.containerId, dataLayerName)}</script>`;\n}\n\n/**\n * Generate GTM noscript tag for SSR\n * Returns HTML string to inject at start of <body>\n */\nexport function generateGTMNoScriptTag(containerId: string): string {\n  if (!validateContainerId(containerId)) {\n    return '';\n  }\n\n  return `<noscript><iframe src=\"https://www.googletagmanager.com/ns.html?id=${containerId}\" height=\"0\" width=\"0\" style=\"display:none;visibility:hidden\"></iframe></noscript>`;\n}\n\n/**\n * Generate dataLayer initialization script for SSR\n * Use this before GTM script to pre-populate data\n */\nexport function generateDataLayerScript(\n  initialData: Record<string, unknown>,\n  dataLayerName = 'dataLayer',\n): string {\n  const dataJson = JSON.stringify(initialData);\n  return `<script>window.${dataLayerName}=window.${dataLayerName}||[];window.${dataLayerName}.push(${dataJson});</script>`;\n}\n\n// ============================================================================\n// Status Helpers\n// ============================================================================\n\n/**\n * Check if GTM has been injected\n */\nexport function isGTMInjected(): boolean {\n  return gtmInjected;\n}\n\n/**\n * Check if GTM is loaded and ready\n */\nexport function isGTMReady(): boolean {\n  if (!gtmInjected) return false;\n\n  // Check for gtm.js event in dataLayer\n  const dataLayer = (window as Window & { dataLayer?: unknown[] }).dataLayer;\n  if (!dataLayer) return false;\n\n  return dataLayer.some(\n    (item) =>\n      typeof item === 'object' &&\n      item !== null &&\n      (item as Record<string, unknown>).event === 'gtm.js',\n  );\n}\n\n/**\n * Wait for GTM to be ready\n */\nexport function waitForGTM(timeout = 5000): Promise<boolean> {\n  return new Promise((resolve) => {\n    if (isGTMReady()) {\n      resolve(true);\n      return;\n    }\n\n    const startTime = Date.now();\n\n    const check = () => {\n      if (isGTMReady()) {\n        resolve(true);\n        return;\n      }\n\n      if (Date.now() - startTime > timeout) {\n        resolve(false);\n        return;\n      }\n\n      requestAnimationFrame(check);\n    };\n\n    check();\n  });\n}\n\n// ============================================================================\n// Reset (for testing)\n// ============================================================================\n\n/**\n * Reset GTM injection state (for testing only)\n */\nexport function resetGTMState(): void {\n  gtmInjected = false;\n}\n",
    "/**\n * ESI Context Bridge\n *\n * Syncs ESI state from window.__AEON_ESI_STATE__ to GTM dataLayer.\n * Handles initial sync and subscribes to state changes.\n */\n\nimport type { AnalyticsConfig, ESIState } from './types';\nimport { pushContextEvent, pushPageViewEvent } from './data-layer';\n\n// ============================================================================\n// ESI State Access\n// ============================================================================\n\n/**\n * Get current ESI state from window\n */\nexport function getESIState(): ESIState | null {\n  return window.__AEON_ESI_STATE__ || null;\n}\n\n/**\n * Check if ESI state is available\n */\nexport function hasESIState(): boolean {\n  return !!window.__AEON_ESI_STATE__;\n}\n\n/**\n * Get specific ESI state property\n */\nexport function getESIProperty<K extends keyof ESIState>(\n  key: K,\n): ESIState[K] | undefined {\n  const state = getESIState();\n  return state ? state[key] : undefined;\n}\n\n// ============================================================================\n// ESI State Subscription\n// ============================================================================\n\n/** Active subscription cleanup function */\nlet unsubscribe: (() => void) | null = null;\n\n/**\n * Subscribe to ESI state changes\n */\nexport function subscribeToESIChanges(\n  callback: (state: ESIState) => void,\n): () => void {\n  const state = window.__AEON_ESI_STATE__;\n\n  if (state?.subscribe) {\n    return state.subscribe(callback);\n  }\n\n  // No subscribe method available - return no-op\n  return () => {};\n}\n\n// ============================================================================\n// DataLayer Sync\n// ============================================================================\n\n/**\n * Sync current ESI state to dataLayer\n */\nexport function syncESIToDataLayer(\n  config: Pick<AnalyticsConfig, 'dataLayerName' | 'eventPrefix'>,\n): boolean {\n  const esiState = getESIState();\n\n  if (!esiState) {\n    return false;\n  }\n\n  pushContextEvent(esiState, config);\n  return true;\n}\n\n/**\n * Push page view with current ESI context\n */\nexport function pushPageView(\n  config: Pick<AnalyticsConfig, 'dataLayerName' | 'eventPrefix'>,\n  merkleRoot = '',\n): boolean {\n  const esiState = getESIState();\n\n  if (!esiState) {\n    return false;\n  }\n\n  pushPageViewEvent(\n    window.location.pathname,\n    document.title,\n    merkleRoot,\n    esiState,\n    config,\n  );\n\n  return true;\n}\n\n// ============================================================================\n// Watch Mode\n// ============================================================================\n\n/**\n * Start watching for ESI state changes and sync to dataLayer\n */\nexport function watchESIChanges(\n  config: Pick<AnalyticsConfig, 'dataLayerName' | 'eventPrefix'>,\n): () => void {\n  // Clean up any existing subscription\n  if (unsubscribe) {\n    unsubscribe();\n  }\n\n  // Subscribe to changes\n  unsubscribe = subscribeToESIChanges(() => {\n    syncESIToDataLayer(config);\n  });\n\n  return () => {\n    if (unsubscribe) {\n      unsubscribe();\n      unsubscribe = null;\n    }\n  };\n}\n\n// ============================================================================\n// Initialization\n// ============================================================================\n\n/**\n * Initialize context bridge with full sync\n */\nexport function initContextBridge(\n  config: Pick<\n    AnalyticsConfig,\n    'dataLayerName' | 'eventPrefix' | 'syncESIContext'\n  >,\n): () => void {\n  if (config.syncESIContext === false) {\n    return () => {};\n  }\n\n  // Initial sync\n  syncESIToDataLayer(config);\n\n  // Watch for changes\n  return watchESIChanges(config);\n}\n\n// ============================================================================\n// Retry Logic\n// ============================================================================\n\n/**\n * Wait for ESI state to be available\n */\nexport function waitForESIState(timeout = 5000): Promise<ESIState | null> {\n  return new Promise((resolve) => {\n    // Check immediately\n    const state = getESIState();\n    if (state) {\n      resolve(state);\n      return;\n    }\n\n    const startTime = Date.now();\n\n    const check = () => {\n      const state = getESIState();\n      if (state) {\n        resolve(state);\n        return;\n      }\n\n      if (Date.now() - startTime > timeout) {\n        resolve(null);\n        return;\n      }\n\n      requestAnimationFrame(check);\n    };\n\n    check();\n  });\n}\n\n/**\n * Initialize context bridge with retry\n */\nexport async function initContextBridgeWithRetry(\n  config: Pick<\n    AnalyticsConfig,\n    'dataLayerName' | 'eventPrefix' | 'syncESIContext'\n  >,\n  timeout = 5000,\n): Promise<() => void> {\n  if (config.syncESIContext === false) {\n    return () => {};\n  }\n\n  // Wait for ESI state\n  const state = await waitForESIState(timeout);\n\n  if (!state) {\n    console.warn('[Aeon Analytics] ESI state not available after timeout');\n    return () => {};\n  }\n\n  // Now initialize\n  return initContextBridge(config);\n}\n\n// ============================================================================\n// Utilities\n// ============================================================================\n\n/**\n * Get partial ESI state for click events\n */\nexport function getESIContextSnapshot(): Partial<ESIState> {\n  const state = getESIState();\n\n  if (!state) {\n    return {};\n  }\n\n  // Return relevant context for click tracking\n  return {\n    userTier: state.userTier,\n    isAdmin: state.isAdmin,\n    userId: state.userId,\n    sessionId: state.sessionId,\n    isNewSession: state.isNewSession,\n    emotionState: state.emotionState,\n    features: state.features,\n    viewport: state.viewport,\n    connection: state.connection,\n    localHour: state.localHour,\n    timezone: state.timezone,\n  };\n}\n\n/**\n * Check if current user is an admin\n * Admins bypass all tier restrictions\n */\nexport function isAdmin(): boolean {\n  const state = getESIState();\n  return state?.isAdmin === true || state?.userTier === 'admin';\n}\n\n/**\n * Check if user has specific feature enabled\n * Admins always have access to all features\n */\nexport function hasFeature(feature: keyof ESIState['features']): boolean {\n  const state = getESIState();\n\n  // Admins bypass all tier restrictions\n  if (state?.isAdmin === true || state?.userTier === 'admin') {\n    return true;\n  }\n\n  return state?.features?.[feature] ?? false;\n}\n\n/**\n * Check if user meets minimum tier requirement\n * Admins always meet any tier requirement\n */\nexport function meetsTierRequirement(\n  requiredTier: ESIState['userTier'],\n): boolean {\n  const state = getESIState();\n\n  if (!state) {\n    return false;\n  }\n\n  // Admins bypass all tier restrictions\n  if (state.isAdmin === true || state.userTier === 'admin') {\n    return true;\n  }\n\n  // Tier hierarchy: free < starter < pro < enterprise\n  const tierOrder: ESIState['userTier'][] = [\n    'free',\n    'starter',\n    'pro',\n    'enterprise',\n    'admin',\n  ];\n  const userTierIndex = tierOrder.indexOf(state.userTier);\n  const requiredTierIndex = tierOrder.indexOf(requiredTier);\n\n  return userTierIndex >= requiredTierIndex;\n}\n\n/**\n * Get user tier\n */\nexport function getUserTier(): ESIState['userTier'] | null {\n  return getESIProperty('userTier') ?? null;\n}\n\n/**\n * Get emotion state\n */\nexport function getEmotionState(): ESIState['emotionState'] | null {\n  return getESIProperty('emotionState') ?? null;\n}\n",
    "/**\n * Merkle Tree Node Identification\n *\n * Generates deterministic, content-addressable hashes for component tree nodes.\n * Uses SHA-256 with children hashes to create a Merkle tree structure.\n *\n * Benefits:\n * - Stable IDs across renders (if content unchanged)\n * - Content-addressable (same content = same hash)\n * - Tree-aware (parent hash changes if any child changes)\n * - Position-independent (moves don't change hash)\n */\n\nimport type {\n  ComponentNode,\n  ComponentTree,\n  MerkleNode,\n  MerkleTree,\n  MERKLE_ATTR,\n  PATH_ATTR,\n  PATH_HASHES_ATTR,\n  TYPE_ATTR,\n} from './types';\n\n// ============================================================================\n// Crypto Utilities\n// ============================================================================\n\n/**\n * SHA-256 hash with Web Crypto API (works in browser and Bun/Node)\n */\nasync function sha256(message: string): Promise<string> {\n  const encoder = new TextEncoder();\n  const data = encoder.encode(message);\n\n  // Use Web Crypto API\n  const hashBuffer = await crypto.subtle.digest('SHA-256', data);\n  const hashArray = Array.from(new Uint8Array(hashBuffer));\n  const hashHex = hashArray\n    .map((b) => b.toString(16).padStart(2, '0'))\n    .join('');\n\n  return hashHex;\n}\n\n/**\n * Synchronous hash using simple djb2 algorithm for performance\n * Used for quick hashing when async is not desired\n */\nfunction djb2Hash(str: string): string {\n  let hash = 5381;\n  for (let i = 0; i < str.length; i++) {\n    hash = (hash * 33) ^ str.charCodeAt(i);\n  }\n  // Convert to positive hex, pad to 12 chars\n  return ((hash >>> 0).toString(16) + (hash >>> 0).toString(16)).slice(0, 12);\n}\n\n/**\n * Truncate hash to 12 characters for compact storage\n */\nfunction truncateHash(hash: string): string {\n  return hash.slice(0, 12);\n}\n\n// ============================================================================\n// Key Sorting for Deterministic JSON\n// ============================================================================\n\n/**\n * Sort object keys recursively for deterministic serialization\n */\nfunction sortKeys(obj: unknown): unknown {\n  if (obj === null || typeof obj !== 'object') {\n    return obj;\n  }\n\n  if (Array.isArray(obj)) {\n    return obj.map(sortKeys);\n  }\n\n  const sorted: Record<string, unknown> = {};\n  const keys = Object.keys(obj as Record<string, unknown>).sort();\n\n  for (const key of keys) {\n    sorted[key] = sortKeys((obj as Record<string, unknown>)[key]);\n  }\n\n  return sorted;\n}\n\n/**\n * Sanitize props for hashing - remove functions, symbols, etc.\n */\nfunction sanitizeProps(\n  props: Record<string, unknown> | undefined,\n): Record<string, unknown> {\n  if (!props) return {};\n\n  const sanitized: Record<string, unknown> = {};\n\n  for (const [key, value] of Object.entries(props)) {\n    // Skip functions, symbols, and React internals\n    if (\n      typeof value === 'function' ||\n      typeof value === 'symbol' ||\n      key.startsWith('_') ||\n      key === 'children' ||\n      key === 'ref' ||\n      key === 'key'\n    ) {\n      continue;\n    }\n\n    // Recursively sanitize nested objects\n    if (value !== null && typeof value === 'object') {\n      sanitized[key] = sanitizeProps(value as Record<string, unknown>);\n    } else {\n      sanitized[key] = value;\n    }\n  }\n\n  return sanitized;\n}\n\n// ============================================================================\n// Hash Generation\n// ============================================================================\n\n/**\n * Generate deterministic hash for a single node\n * Hash = SHA-256(type + sortedProps + childHashes)\n */\nexport async function hashNodeAsync(\n  type: string,\n  props: Record<string, unknown>,\n  childHashes: string[],\n): Promise<string> {\n  const content = JSON.stringify({\n    type,\n    props: sortKeys(sanitizeProps(props)),\n    children: childHashes.sort(), // Sort for consistency\n  });\n\n  const fullHash = await sha256(content);\n  return truncateHash(fullHash);\n}\n\n/**\n * Synchronous hash generation using djb2\n * Faster but less collision-resistant\n */\nexport function hashNodeSync(\n  type: string,\n  props: Record<string, unknown>,\n  childHashes: string[],\n): string {\n  const content = JSON.stringify({\n    type,\n    props: sortKeys(sanitizeProps(props)),\n    children: childHashes.sort(),\n  });\n\n  return djb2Hash(content);\n}\n\n// ============================================================================\n// Merkle Tree Builder\n// ============================================================================\n\ninterface BuildContext {\n  nodes: Map<string, MerkleNode>;\n  hashToId: Map<string, string>;\n  tree: ComponentTree;\n}\n\n/**\n * Recursively build MerkleNode for a node and its children\n * Uses post-order traversal (children first, then parent)\n */\nasync function buildNodeAsync(\n  nodeId: string,\n  parentPath: string[],\n  parentPathHashes: string[],\n  depth: number,\n  ctx: BuildContext,\n): Promise<MerkleNode | null> {\n  const node = ctx.tree.getNode(nodeId);\n  if (!node) return null;\n\n  // Process children first (post-order)\n  const childHashes: string[] = [];\n  const children = ctx.tree.getChildren(nodeId);\n\n  for (const child of children) {\n    const childNode = await buildNodeAsync(\n      child.id,\n      [...parentPath, node.type],\n      [...parentPathHashes], // Will be filled after we compute our hash\n      depth + 1,\n      ctx,\n    );\n    if (childNode) {\n      childHashes.push(childNode.hash);\n    }\n  }\n\n  // Now hash this node\n  const hash = await hashNodeAsync(node.type, node.props || {}, childHashes);\n\n  // Build path with hashes\n  const path = [...parentPath, node.type];\n  const pathHashes = [...parentPathHashes, hash];\n\n  const merkleNode: MerkleNode = {\n    hash,\n    originalId: nodeId,\n    type: node.type,\n    props: sanitizeProps(node.props),\n    childHashes,\n    path,\n    pathHashes,\n    depth,\n  };\n\n  ctx.nodes.set(nodeId, merkleNode);\n  ctx.hashToId.set(hash, nodeId);\n\n  // Update children with correct parent path hashes\n  for (const child of children) {\n    const childMerkle = ctx.nodes.get(child.id);\n    if (childMerkle) {\n      childMerkle.pathHashes = [...pathHashes, childMerkle.hash];\n    }\n  }\n\n  return merkleNode;\n}\n\n/**\n * Synchronous version for server-side rendering\n */\nfunction buildNodeSync(\n  nodeId: string,\n  parentPath: string[],\n  parentPathHashes: string[],\n  depth: number,\n  ctx: BuildContext,\n): MerkleNode | null {\n  const node = ctx.tree.getNode(nodeId);\n  if (!node) return null;\n\n  // Process children first (post-order)\n  const childHashes: string[] = [];\n  const children = ctx.tree.getChildren(nodeId);\n\n  for (const child of children) {\n    const childNode = buildNodeSync(\n      child.id,\n      [...parentPath, node.type],\n      [...parentPathHashes],\n      depth + 1,\n      ctx,\n    );\n    if (childNode) {\n      childHashes.push(childNode.hash);\n    }\n  }\n\n  // Hash this node\n  const hash = hashNodeSync(node.type, node.props || {}, childHashes);\n\n  // Build path with hashes\n  const path = [...parentPath, node.type];\n  const pathHashes = [...parentPathHashes, hash];\n\n  const merkleNode: MerkleNode = {\n    hash,\n    originalId: nodeId,\n    type: node.type,\n    props: sanitizeProps(node.props),\n    childHashes,\n    path,\n    pathHashes,\n    depth,\n  };\n\n  ctx.nodes.set(nodeId, merkleNode);\n  ctx.hashToId.set(hash, nodeId);\n\n  // Update children with correct parent path hashes\n  for (const child of children) {\n    const childMerkle = ctx.nodes.get(child.id);\n    if (childMerkle) {\n      childMerkle.pathHashes = [...pathHashes, childMerkle.hash];\n    }\n  }\n\n  return merkleNode;\n}\n\n/**\n * Build complete Merkle tree from ComponentTree (async)\n */\nexport async function buildMerkleTree(\n  tree: ComponentTree,\n): Promise<MerkleTree> {\n  const ctx: BuildContext = {\n    nodes: new Map(),\n    hashToId: new Map(),\n    tree,\n  };\n\n  const rootNode = await buildNodeAsync(tree.rootId, [], [], 0, ctx);\n\n  const merkleTree: MerkleTree = {\n    rootHash: rootNode?.hash || '',\n    nodes: ctx.nodes,\n\n    getNode(id: string): MerkleNode | undefined {\n      return ctx.nodes.get(id);\n    },\n\n    getNodeByHash(hash: string): MerkleNode | undefined {\n      const id = ctx.hashToId.get(hash);\n      return id ? ctx.nodes.get(id) : undefined;\n    },\n\n    getNodesAtDepth(depth: number): MerkleNode[] {\n      return Array.from(ctx.nodes.values()).filter((n) => n.depth === depth);\n    },\n  };\n\n  return merkleTree;\n}\n\n/**\n * Build complete Merkle tree from ComponentTree (sync)\n */\nexport function buildMerkleTreeSync(tree: ComponentTree): MerkleTree {\n  const ctx: BuildContext = {\n    nodes: new Map(),\n    hashToId: new Map(),\n    tree,\n  };\n\n  const rootNode = buildNodeSync(tree.rootId, [], [], 0, ctx);\n\n  const merkleTree: MerkleTree = {\n    rootHash: rootNode?.hash || '',\n    nodes: ctx.nodes,\n\n    getNode(id: string): MerkleNode | undefined {\n      return ctx.nodes.get(id);\n    },\n\n    getNodeByHash(hash: string): MerkleNode | undefined {\n      const id = ctx.hashToId.get(hash);\n      return id ? ctx.nodes.get(id) : undefined;\n    },\n\n    getNodesAtDepth(depth: number): MerkleNode[] {\n      return Array.from(ctx.nodes.values()).filter((n) => n.depth === depth);\n    },\n  };\n\n  return merkleTree;\n}\n\n// ============================================================================\n// DOM Attribute Helpers\n// ============================================================================\n\n/**\n * Generate data attributes for a DOM element\n */\nexport function getMerkleAttributes(\n  merkleNode: MerkleNode,\n): Record<string, string> {\n  return {\n    'data-aeon-merkle': merkleNode.hash,\n    'data-aeon-path': JSON.stringify(merkleNode.path),\n    'data-aeon-path-hashes': JSON.stringify(merkleNode.pathHashes),\n    'data-aeon-type': merkleNode.type,\n  };\n}\n\n/**\n * Parse Merkle info from DOM element\n */\nexport function parseMerkleFromElement(element: HTMLElement): {\n  hash: string;\n  path: string[];\n  pathHashes: string[];\n  type: string;\n} | null {\n  const hash = element.getAttribute('data-aeon-merkle');\n  if (!hash) return null;\n\n  const pathStr = element.getAttribute('data-aeon-path');\n  const pathHashesStr = element.getAttribute('data-aeon-path-hashes');\n  const type = element.getAttribute('data-aeon-type') || 'unknown';\n\n  let path: string[] = [];\n  let pathHashes: string[] = [];\n\n  try {\n    if (pathStr) path = JSON.parse(pathStr);\n    if (pathHashesStr) pathHashes = JSON.parse(pathHashesStr);\n  } catch {\n    // Invalid JSON, use empty arrays\n  }\n\n  return { hash, path, pathHashes, type };\n}\n\n/**\n * Find nearest ancestor with Merkle attributes\n */\nexport function findNearestMerkleElement(\n  element: HTMLElement,\n): HTMLElement | null {\n  let current: HTMLElement | null = element;\n\n  while (current) {\n    if (current.hasAttribute('data-aeon-merkle')) {\n      return current;\n    }\n    current = current.parentElement;\n  }\n\n  return null;\n}\n\n// ============================================================================\n// Verification Utilities\n// ============================================================================\n\n/**\n * Verify tree integrity by recomputing root hash\n */\nexport async function verifyMerkleTree(\n  tree: MerkleTree,\n  componentTree: ComponentTree,\n): Promise<boolean> {\n  const rebuilt = await buildMerkleTree(componentTree);\n  return rebuilt.rootHash === tree.rootHash;\n}\n\n/**\n * Find nodes that have changed between two Merkle trees\n */\nexport function diffMerkleTrees(\n  oldTree: MerkleTree,\n  newTree: MerkleTree,\n): { added: MerkleNode[]; removed: MerkleNode[]; changed: MerkleNode[] } {\n  const added: MerkleNode[] = [];\n  const removed: MerkleNode[] = [];\n  const changed: MerkleNode[] = [];\n\n  const oldHashes = new Set(\n    Array.from(oldTree.nodes.values()).map((n) => n.hash),\n  );\n  const newHashes = new Set(\n    Array.from(newTree.nodes.values()).map((n) => n.hash),\n  );\n\n  // Find added nodes (in new but not in old)\n  for (const [, node] of newTree.nodes) {\n    if (!oldHashes.has(node.hash)) {\n      // Check if originalId exists in old tree (changed) or not (added)\n      const oldNode = oldTree.getNode(node.originalId);\n      if (oldNode) {\n        changed.push(node);\n      } else {\n        added.push(node);\n      }\n    }\n  }\n\n  // Find removed nodes (in old but not in new by ID)\n  for (const [id, node] of oldTree.nodes) {\n    if (!newTree.getNode(id)) {\n      removed.push(node);\n    }\n  }\n\n  return { added, removed, changed };\n}\n",
    "/**\n * Automatic Click Tracker\n *\n * Intercepts all clicks using event delegation and automatically\n * tracks them to GTM dataLayer with Merkle tree context.\n *\n * Features:\n * - Single delegated listener (no per-element handlers)\n * - Walks up DOM to find Merkle-annotated ancestor\n * - Captures full tree path and element metadata\n * - Includes ESI context snapshot with each click\n */\n\nimport type { AnalyticsConfig, ClickTrackingOptions, ESIState } from './types';\nimport {\n  extractElementInfo,\n  extractPositionInfo,\n  pushClickEvent,\n} from './data-layer';\nimport {\n  parseMerkleFromElement,\n  findNearestMerkleElement,\n} from './merkle-tree';\nimport { getESIContextSnapshot } from './context-bridge';\n\n// ============================================================================\n// Types\n// ============================================================================\n\ninterface ClickHandler {\n  listener: (event: MouseEvent) => void;\n  cleanup: () => void;\n}\n\n// ============================================================================\n// State\n// ============================================================================\n\n/** Active click handler */\nlet activeHandler: ClickHandler | null = null;\n\n/** Debounce timer */\nlet debounceTimer: ReturnType<typeof setTimeout> | null = null;\n\n/** Last click timestamp for debouncing */\nlet lastClickTime = 0;\n\n// ============================================================================\n// Click Handler\n// ============================================================================\n\n/**\n * Check if element should be excluded from tracking\n */\nfunction shouldExclude(\n  element: HTMLElement,\n  excludeSelectors: string[],\n): boolean {\n  for (const selector of excludeSelectors) {\n    if (element.matches(selector) || element.closest(selector)) {\n      return true;\n    }\n  }\n  return false;\n}\n\n/**\n * Create click event handler\n */\nfunction createClickHandler(\n  config: AnalyticsConfig,\n  options: ClickTrackingOptions,\n): (event: MouseEvent) => void {\n  return (event: MouseEvent) => {\n    const target = event.target as HTMLElement;\n\n    if (!target || !(target instanceof HTMLElement)) {\n      return;\n    }\n\n    // Check exclusions\n    if (options.excludeSelectors?.length) {\n      if (shouldExclude(target, options.excludeSelectors)) {\n        return;\n      }\n    }\n\n    // Debounce if configured\n    if (options.debounceMs && options.debounceMs > 0) {\n      const now = Date.now();\n      if (now - lastClickTime < options.debounceMs) {\n        return;\n      }\n      lastClickTime = now;\n    }\n\n    // Find nearest element with Merkle attributes\n    const merkleElement = findNearestMerkleElement(target);\n\n    // Parse Merkle info\n    let merkleHash = 'unknown';\n    let treePath: string[] = [];\n    let treePathHashes: string[] = [];\n\n    if (merkleElement) {\n      const merkleInfo = parseMerkleFromElement(merkleElement);\n      if (merkleInfo) {\n        merkleHash = merkleInfo.hash;\n        treePath = options.includeTreePath !== false ? merkleInfo.path : [];\n        treePathHashes =\n          options.includeTreePath !== false ? merkleInfo.pathHashes : [];\n      }\n    } else {\n      // No Merkle element found - generate path from DOM structure\n      treePath = generateDOMPath(target);\n    }\n\n    // Extract element info (from clicked element, not Merkle ancestor)\n    const elementInfo = extractElementInfo(target, options.maxTextLength);\n\n    // Extract position if enabled\n    const position =\n      options.includePosition !== false\n        ? extractPositionInfo(event)\n        : { x: 0, y: 0, viewportX: 0, viewportY: 0 };\n\n    // Get ESI context snapshot\n    const context = getESIContextSnapshot();\n\n    // Push to dataLayer\n    pushClickEvent(\n      merkleHash,\n      treePath,\n      treePathHashes,\n      elementInfo,\n      position,\n      context,\n      {\n        dataLayerName: config.dataLayerName,\n        eventPrefix: config.eventPrefix,\n      },\n    );\n  };\n}\n\n/**\n * Generate DOM path for elements without Merkle attributes\n */\nfunction generateDOMPath(element: HTMLElement): string[] {\n  const path: string[] = [];\n  let current: HTMLElement | null = element;\n\n  while (current && current !== document.body) {\n    let identifier = current.tagName.toLowerCase();\n\n    // Add ID if present\n    if (current.id) {\n      identifier += `#${current.id}`;\n    }\n    // Or first meaningful class\n    else if (current.className && typeof current.className === 'string') {\n      const classes = current.className.split(' ').filter(Boolean);\n      const meaningfulClass = classes.find(\n        (c) => !c.startsWith('_') && !c.match(/^[a-z]{1,3}\\d+/),\n      );\n      if (meaningfulClass) {\n        identifier += `.${meaningfulClass}`;\n      }\n    }\n\n    path.unshift(identifier);\n    current = current.parentElement;\n  }\n\n  // Limit depth\n  if (path.length > 10) {\n    return ['...', ...path.slice(-9)];\n  }\n\n  return path;\n}\n\n// ============================================================================\n// Initialization\n// ============================================================================\n\n/**\n * Initialize click tracking\n */\nexport function initClickTracker(config: AnalyticsConfig): () => void {\n  // Skip if disabled\n  if (config.trackClicks === false) {\n    return () => {};\n  }\n\n  // Clean up existing handler\n  if (activeHandler) {\n    activeHandler.cleanup();\n  }\n\n  const options: ClickTrackingOptions = {\n    debounceMs: 0,\n    maxTextLength: 100,\n    excludeSelectors: [],\n    includePosition: true,\n    includeTreePath: true,\n    ...config.clickOptions,\n  };\n\n  // Create handler\n  const listener = createClickHandler(config, options);\n\n  // Add event listener with capture for earliest interception\n  document.addEventListener('click', listener, {\n    capture: true,\n    passive: true,\n  });\n\n  // Cleanup function\n  const cleanup = () => {\n    document.removeEventListener('click', listener, { capture: true });\n\n    if (debounceTimer) {\n      clearTimeout(debounceTimer);\n      debounceTimer = null;\n    }\n\n    activeHandler = null;\n  };\n\n  activeHandler = { listener, cleanup };\n\n  return cleanup;\n}\n\n/**\n * Stop click tracking\n */\nexport function stopClickTracker(): void {\n  if (activeHandler) {\n    activeHandler.cleanup();\n  }\n}\n\n/**\n * Check if click tracking is active\n */\nexport function isClickTrackerActive(): boolean {\n  return activeHandler !== null;\n}\n\n// ============================================================================\n// Manual Tracking\n// ============================================================================\n\n/**\n * Manually track a click event\n * Useful for custom elements or programmatic clicks\n */\nexport function trackClick(\n  element: HTMLElement,\n  event?: MouseEvent,\n  config?: Pick<\n    AnalyticsConfig,\n    'dataLayerName' | 'eventPrefix' | 'clickOptions'\n  >,\n): void {\n  const options = config?.clickOptions || {};\n\n  // Find Merkle element\n  const merkleElement = findNearestMerkleElement(element);\n\n  let merkleHash = 'unknown';\n  let treePath: string[] = [];\n  let treePathHashes: string[] = [];\n\n  if (merkleElement) {\n    const merkleInfo = parseMerkleFromElement(merkleElement);\n    if (merkleInfo) {\n      merkleHash = merkleInfo.hash;\n      treePath = merkleInfo.path;\n      treePathHashes = merkleInfo.pathHashes;\n    }\n  } else {\n    treePath = generateDOMPath(element);\n  }\n\n  // Extract element info\n  const elementInfo = extractElementInfo(element, options.maxTextLength || 100);\n\n  // Extract position if event provided\n  const position = event\n    ? extractPositionInfo(event)\n    : { x: 0, y: 0, viewportX: 0, viewportY: 0 };\n\n  // Get context\n  const context = getESIContextSnapshot();\n\n  // Push to dataLayer\n  pushClickEvent(\n    merkleHash,\n    treePath,\n    treePathHashes,\n    elementInfo,\n    position,\n    context,\n    {\n      dataLayerName: config?.dataLayerName || 'dataLayer',\n      eventPrefix: config?.eventPrefix || 'aeon',\n    },\n  );\n}\n\n// ============================================================================\n// Custom Event Tracking\n// ============================================================================\n\n/**\n * Track a custom interaction (not necessarily a click)\n */\nexport function trackInteraction(\n  name: string,\n  data: Record<string, unknown>,\n  element?: HTMLElement,\n  config?: Pick<AnalyticsConfig, 'dataLayerName' | 'eventPrefix'>,\n): void {\n  const context = getESIContextSnapshot();\n\n  let treePath: string[] = [];\n  let merkleHash = 'none';\n\n  if (element) {\n    const merkleElement = findNearestMerkleElement(element);\n    if (merkleElement) {\n      const merkleInfo = parseMerkleFromElement(merkleElement);\n      if (merkleInfo) {\n        merkleHash = merkleInfo.hash;\n        treePath = merkleInfo.path;\n      }\n    } else {\n      treePath = generateDOMPath(element);\n    }\n  }\n\n  const dataLayerName = config?.dataLayerName || 'dataLayer';\n  const eventPrefix = config?.eventPrefix || 'aeon';\n\n  const event = {\n    event: `${eventPrefix}.interaction`,\n    aeon: {\n      version: '1.0.0',\n      timestamp: Date.now(),\n    },\n    interaction: {\n      name,\n      merkleHash,\n      treePath,\n      data,\n    },\n    context,\n  };\n\n  const w = window as unknown as Record<string, unknown[]>;\n  const dataLayer = w[dataLayerName];\n  if (dataLayer) {\n    dataLayer.push(event);\n  }\n}\n"
  ],
  "mappings": "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",
  "debugId": "36C4AFA20745E37B64756E2164756E21",
  "names": []
}