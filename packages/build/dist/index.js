import { createRequire } from "node:module";
var __create = Object.create;
var __getProtoOf = Object.getPrototypeOf;
var __defProp = Object.defineProperty;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __toESM = (mod, isNodeMode, target) => {
  target = mod != null ? __create(__getProtoOf(mod)) : {};
  const to = isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target;
  for (let key of __getOwnPropNames(mod))
    if (!__hasOwnProp.call(to, key))
      __defProp(to, key, {
        get: () => mod[key],
        enumerable: true
      });
  return to;
};
var __commonJS = (cb, mod) => () => (mod || cb((mod = { exports: {} }).exports, mod), mod.exports);
var __require = /* @__PURE__ */ createRequire(import.meta.url);

// ../../../../node_modules/.bun/@trysound+sax@0.2.0/node_modules/@trysound/sax/lib/sax.js
var require_sax = __commonJS((exports) => {
  (function(sax) {
    sax.parser = function(strict, opt) {
      return new SAXParser(strict, opt);
    };
    sax.SAXParser = SAXParser;
    sax.MAX_BUFFER_LENGTH = 64 * 1024;
    var buffers = [
      "comment",
      "sgmlDecl",
      "textNode",
      "tagName",
      "doctype",
      "procInstName",
      "procInstBody",
      "entity",
      "attribName",
      "attribValue",
      "cdata",
      "script"
    ];
    sax.EVENTS = [
      "text",
      "processinginstruction",
      "sgmldeclaration",
      "doctype",
      "comment",
      "opentagstart",
      "attribute",
      "opentag",
      "closetag",
      "opencdata",
      "cdata",
      "closecdata",
      "error",
      "end",
      "ready",
      "script",
      "opennamespace",
      "closenamespace"
    ];
    function SAXParser(strict, opt) {
      if (!(this instanceof SAXParser)) {
        return new SAXParser(strict, opt);
      }
      var parser = this;
      clearBuffers(parser);
      parser.q = parser.c = "";
      parser.bufferCheckPosition = sax.MAX_BUFFER_LENGTH;
      parser.opt = opt || {};
      parser.opt.lowercase = parser.opt.lowercase || parser.opt.lowercasetags;
      parser.looseCase = parser.opt.lowercase ? "toLowerCase" : "toUpperCase";
      parser.tags = [];
      parser.closed = parser.closedRoot = parser.sawRoot = false;
      parser.tag = parser.error = null;
      parser.strict = !!strict;
      parser.noscript = !!(strict || parser.opt.noscript);
      parser.state = S.BEGIN;
      parser.strictEntities = parser.opt.strictEntities;
      parser.ENTITIES = parser.strictEntities ? Object.create(sax.XML_ENTITIES) : Object.create(sax.ENTITIES);
      parser.attribList = [];
      if (parser.opt.xmlns) {
        parser.ns = Object.create(rootNS);
      }
      parser.trackPosition = parser.opt.position !== false;
      if (parser.trackPosition) {
        parser.position = parser.line = parser.column = 0;
      }
      emit(parser, "onready");
    }
    if (!Object.create) {
      Object.create = function(o) {
        function F() {}
        F.prototype = o;
        var newf = new F;
        return newf;
      };
    }
    if (!Object.keys) {
      Object.keys = function(o) {
        var a = [];
        for (var i in o)
          if (o.hasOwnProperty(i))
            a.push(i);
        return a;
      };
    }
    function checkBufferLength(parser) {
      var maxAllowed = Math.max(sax.MAX_BUFFER_LENGTH, 10);
      var maxActual = 0;
      for (var i = 0, l = buffers.length;i < l; i++) {
        var len = parser[buffers[i]].length;
        if (len > maxAllowed) {
          switch (buffers[i]) {
            case "textNode":
              closeText(parser);
              break;
            case "cdata":
              emitNode(parser, "oncdata", parser.cdata);
              parser.cdata = "";
              break;
            case "script":
              emitNode(parser, "onscript", parser.script);
              parser.script = "";
              break;
            default:
              error(parser, "Max buffer length exceeded: " + buffers[i]);
          }
        }
        maxActual = Math.max(maxActual, len);
      }
      var m = sax.MAX_BUFFER_LENGTH - maxActual;
      parser.bufferCheckPosition = m + parser.position;
    }
    function clearBuffers(parser) {
      for (var i = 0, l = buffers.length;i < l; i++) {
        parser[buffers[i]] = "";
      }
    }
    function flushBuffers(parser) {
      closeText(parser);
      if (parser.cdata !== "") {
        emitNode(parser, "oncdata", parser.cdata);
        parser.cdata = "";
      }
      if (parser.script !== "") {
        emitNode(parser, "onscript", parser.script);
        parser.script = "";
      }
    }
    SAXParser.prototype = {
      end: function() {
        end(this);
      },
      write,
      resume: function() {
        this.error = null;
        return this;
      },
      close: function() {
        return this.write(null);
      },
      flush: function() {
        flushBuffers(this);
      }
    };
    var CDATA = "[CDATA[";
    var DOCTYPE = "DOCTYPE";
    var XML_NAMESPACE = "http://www.w3.org/XML/1998/namespace";
    var XMLNS_NAMESPACE = "http://www.w3.org/2000/xmlns/";
    var rootNS = { xml: XML_NAMESPACE, xmlns: XMLNS_NAMESPACE };
    var nameStart = /[:_A-Za-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD]/;
    var nameBody = /[:_A-Za-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD\u00B7\u0300-\u036F\u203F-\u2040.\d-]/;
    var entityStart = /[#:_A-Za-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD]/;
    var entityBody = /[#:_A-Za-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD\u00B7\u0300-\u036F\u203F-\u2040.\d-]/;
    function isWhitespace(c) {
      return c === " " || c === `
` || c === "\r" || c === "\t";
    }
    function isQuote(c) {
      return c === '"' || c === "'";
    }
    function isAttribEnd(c) {
      return c === ">" || isWhitespace(c);
    }
    function isMatch(regex, c) {
      return regex.test(c);
    }
    function notMatch(regex, c) {
      return !isMatch(regex, c);
    }
    var S = 0;
    sax.STATE = {
      BEGIN: S++,
      BEGIN_WHITESPACE: S++,
      TEXT: S++,
      TEXT_ENTITY: S++,
      OPEN_WAKA: S++,
      SGML_DECL: S++,
      SGML_DECL_QUOTED: S++,
      DOCTYPE: S++,
      DOCTYPE_QUOTED: S++,
      DOCTYPE_DTD: S++,
      DOCTYPE_DTD_QUOTED: S++,
      COMMENT_STARTING: S++,
      COMMENT: S++,
      COMMENT_ENDING: S++,
      COMMENT_ENDED: S++,
      CDATA: S++,
      CDATA_ENDING: S++,
      CDATA_ENDING_2: S++,
      PROC_INST: S++,
      PROC_INST_BODY: S++,
      PROC_INST_ENDING: S++,
      OPEN_TAG: S++,
      OPEN_TAG_SLASH: S++,
      ATTRIB: S++,
      ATTRIB_NAME: S++,
      ATTRIB_NAME_SAW_WHITE: S++,
      ATTRIB_VALUE: S++,
      ATTRIB_VALUE_QUOTED: S++,
      ATTRIB_VALUE_CLOSED: S++,
      ATTRIB_VALUE_UNQUOTED: S++,
      ATTRIB_VALUE_ENTITY_Q: S++,
      ATTRIB_VALUE_ENTITY_U: S++,
      CLOSE_TAG: S++,
      CLOSE_TAG_SAW_WHITE: S++,
      SCRIPT: S++,
      SCRIPT_ENDING: S++
    };
    sax.XML_ENTITIES = {
      amp: "&",
      gt: ">",
      lt: "<",
      quot: '"',
      apos: "'"
    };
    sax.ENTITIES = {
      amp: "&",
      gt: ">",
      lt: "<",
      quot: '"',
      apos: "'",
      AElig: 198,
      Aacute: 193,
      Acirc: 194,
      Agrave: 192,
      Aring: 197,
      Atilde: 195,
      Auml: 196,
      Ccedil: 199,
      ETH: 208,
      Eacute: 201,
      Ecirc: 202,
      Egrave: 200,
      Euml: 203,
      Iacute: 205,
      Icirc: 206,
      Igrave: 204,
      Iuml: 207,
      Ntilde: 209,
      Oacute: 211,
      Ocirc: 212,
      Ograve: 210,
      Oslash: 216,
      Otilde: 213,
      Ouml: 214,
      THORN: 222,
      Uacute: 218,
      Ucirc: 219,
      Ugrave: 217,
      Uuml: 220,
      Yacute: 221,
      aacute: 225,
      acirc: 226,
      aelig: 230,
      agrave: 224,
      aring: 229,
      atilde: 227,
      auml: 228,
      ccedil: 231,
      eacute: 233,
      ecirc: 234,
      egrave: 232,
      eth: 240,
      euml: 235,
      iacute: 237,
      icirc: 238,
      igrave: 236,
      iuml: 239,
      ntilde: 241,
      oacute: 243,
      ocirc: 244,
      ograve: 242,
      oslash: 248,
      otilde: 245,
      ouml: 246,
      szlig: 223,
      thorn: 254,
      uacute: 250,
      ucirc: 251,
      ugrave: 249,
      uuml: 252,
      yacute: 253,
      yuml: 255,
      copy: 169,
      reg: 174,
      nbsp: 160,
      iexcl: 161,
      cent: 162,
      pound: 163,
      curren: 164,
      yen: 165,
      brvbar: 166,
      sect: 167,
      uml: 168,
      ordf: 170,
      laquo: 171,
      not: 172,
      shy: 173,
      macr: 175,
      deg: 176,
      plusmn: 177,
      sup1: 185,
      sup2: 178,
      sup3: 179,
      acute: 180,
      micro: 181,
      para: 182,
      middot: 183,
      cedil: 184,
      ordm: 186,
      raquo: 187,
      frac14: 188,
      frac12: 189,
      frac34: 190,
      iquest: 191,
      times: 215,
      divide: 247,
      OElig: 338,
      oelig: 339,
      Scaron: 352,
      scaron: 353,
      Yuml: 376,
      fnof: 402,
      circ: 710,
      tilde: 732,
      Alpha: 913,
      Beta: 914,
      Gamma: 915,
      Delta: 916,
      Epsilon: 917,
      Zeta: 918,
      Eta: 919,
      Theta: 920,
      Iota: 921,
      Kappa: 922,
      Lambda: 923,
      Mu: 924,
      Nu: 925,
      Xi: 926,
      Omicron: 927,
      Pi: 928,
      Rho: 929,
      Sigma: 931,
      Tau: 932,
      Upsilon: 933,
      Phi: 934,
      Chi: 935,
      Psi: 936,
      Omega: 937,
      alpha: 945,
      beta: 946,
      gamma: 947,
      delta: 948,
      epsilon: 949,
      zeta: 950,
      eta: 951,
      theta: 952,
      iota: 953,
      kappa: 954,
      lambda: 955,
      mu: 956,
      nu: 957,
      xi: 958,
      omicron: 959,
      pi: 960,
      rho: 961,
      sigmaf: 962,
      sigma: 963,
      tau: 964,
      upsilon: 965,
      phi: 966,
      chi: 967,
      psi: 968,
      omega: 969,
      thetasym: 977,
      upsih: 978,
      piv: 982,
      ensp: 8194,
      emsp: 8195,
      thinsp: 8201,
      zwnj: 8204,
      zwj: 8205,
      lrm: 8206,
      rlm: 8207,
      ndash: 8211,
      mdash: 8212,
      lsquo: 8216,
      rsquo: 8217,
      sbquo: 8218,
      ldquo: 8220,
      rdquo: 8221,
      bdquo: 8222,
      dagger: 8224,
      Dagger: 8225,
      bull: 8226,
      hellip: 8230,
      permil: 8240,
      prime: 8242,
      Prime: 8243,
      lsaquo: 8249,
      rsaquo: 8250,
      oline: 8254,
      frasl: 8260,
      euro: 8364,
      image: 8465,
      weierp: 8472,
      real: 8476,
      trade: 8482,
      alefsym: 8501,
      larr: 8592,
      uarr: 8593,
      rarr: 8594,
      darr: 8595,
      harr: 8596,
      crarr: 8629,
      lArr: 8656,
      uArr: 8657,
      rArr: 8658,
      dArr: 8659,
      hArr: 8660,
      forall: 8704,
      part: 8706,
      exist: 8707,
      empty: 8709,
      nabla: 8711,
      isin: 8712,
      notin: 8713,
      ni: 8715,
      prod: 8719,
      sum: 8721,
      minus: 8722,
      lowast: 8727,
      radic: 8730,
      prop: 8733,
      infin: 8734,
      ang: 8736,
      and: 8743,
      or: 8744,
      cap: 8745,
      cup: 8746,
      int: 8747,
      there4: 8756,
      sim: 8764,
      cong: 8773,
      asymp: 8776,
      ne: 8800,
      equiv: 8801,
      le: 8804,
      ge: 8805,
      sub: 8834,
      sup: 8835,
      nsub: 8836,
      sube: 8838,
      supe: 8839,
      oplus: 8853,
      otimes: 8855,
      perp: 8869,
      sdot: 8901,
      lceil: 8968,
      rceil: 8969,
      lfloor: 8970,
      rfloor: 8971,
      lang: 9001,
      rang: 9002,
      loz: 9674,
      spades: 9824,
      clubs: 9827,
      hearts: 9829,
      diams: 9830
    };
    Object.keys(sax.ENTITIES).forEach(function(key) {
      var e = sax.ENTITIES[key];
      var s2 = typeof e === "number" ? String.fromCharCode(e) : e;
      sax.ENTITIES[key] = s2;
    });
    for (var s in sax.STATE) {
      sax.STATE[sax.STATE[s]] = s;
    }
    S = sax.STATE;
    function emit(parser, event, data) {
      parser[event] && parser[event](data);
    }
    function emitNode(parser, nodeType, data) {
      if (parser.textNode)
        closeText(parser);
      emit(parser, nodeType, data);
    }
    function closeText(parser) {
      parser.textNode = textopts(parser.opt, parser.textNode);
      if (parser.textNode)
        emit(parser, "ontext", parser.textNode);
      parser.textNode = "";
    }
    function textopts(opt, text) {
      if (opt.trim)
        text = text.trim();
      if (opt.normalize)
        text = text.replace(/\s+/g, " ");
      return text;
    }
    function error(parser, reason) {
      closeText(parser);
      const message = reason + `
Line: ` + parser.line + `
Column: ` + parser.column + `
Char: ` + parser.c;
      const error2 = new Error(message);
      error2.reason = reason;
      error2.line = parser.line;
      error2.column = parser.column;
      parser.error = error2;
      emit(parser, "onerror", error2);
      return parser;
    }
    function end(parser) {
      if (parser.sawRoot && !parser.closedRoot)
        strictFail(parser, "Unclosed root tag");
      if (parser.state !== S.BEGIN && parser.state !== S.BEGIN_WHITESPACE && parser.state !== S.TEXT) {
        error(parser, "Unexpected end");
      }
      closeText(parser);
      parser.c = "";
      parser.closed = true;
      emit(parser, "onend");
      SAXParser.call(parser, parser.strict, parser.opt);
      return parser;
    }
    function strictFail(parser, message) {
      if (typeof parser !== "object" || !(parser instanceof SAXParser)) {
        throw new Error("bad call to strictFail");
      }
      if (parser.strict) {
        error(parser, message);
      }
    }
    function newTag(parser) {
      if (!parser.strict)
        parser.tagName = parser.tagName[parser.looseCase]();
      var parent = parser.tags[parser.tags.length - 1] || parser;
      var tag = parser.tag = { name: parser.tagName, attributes: {} };
      if (parser.opt.xmlns) {
        tag.ns = parent.ns;
      }
      parser.attribList.length = 0;
      emitNode(parser, "onopentagstart", tag);
    }
    function qname(name, attribute) {
      var i = name.indexOf(":");
      var qualName = i < 0 ? ["", name] : name.split(":");
      var prefix = qualName[0];
      var local = qualName[1];
      if (attribute && name === "xmlns") {
        prefix = "xmlns";
        local = "";
      }
      return { prefix, local };
    }
    function attrib(parser) {
      if (!parser.strict) {
        parser.attribName = parser.attribName[parser.looseCase]();
      }
      if (parser.attribList.indexOf(parser.attribName) !== -1 || parser.tag.attributes.hasOwnProperty(parser.attribName)) {
        parser.attribName = parser.attribValue = "";
        return;
      }
      if (parser.opt.xmlns) {
        var qn = qname(parser.attribName, true);
        var prefix = qn.prefix;
        var local = qn.local;
        if (prefix === "xmlns") {
          if (local === "xml" && parser.attribValue !== XML_NAMESPACE) {
            strictFail(parser, "xml: prefix must be bound to " + XML_NAMESPACE + `
` + "Actual: " + parser.attribValue);
          } else if (local === "xmlns" && parser.attribValue !== XMLNS_NAMESPACE) {
            strictFail(parser, "xmlns: prefix must be bound to " + XMLNS_NAMESPACE + `
` + "Actual: " + parser.attribValue);
          } else {
            var tag = parser.tag;
            var parent = parser.tags[parser.tags.length - 1] || parser;
            if (tag.ns === parent.ns) {
              tag.ns = Object.create(parent.ns);
            }
            tag.ns[local] = parser.attribValue;
          }
        }
        parser.attribList.push([parser.attribName, parser.attribValue]);
      } else {
        parser.tag.attributes[parser.attribName] = parser.attribValue;
        emitNode(parser, "onattribute", {
          name: parser.attribName,
          value: parser.attribValue
        });
      }
      parser.attribName = parser.attribValue = "";
    }
    function openTag(parser, selfClosing) {
      if (parser.opt.xmlns) {
        var tag = parser.tag;
        var qn = qname(parser.tagName);
        tag.prefix = qn.prefix;
        tag.local = qn.local;
        tag.uri = tag.ns[qn.prefix] || "";
        if (tag.prefix && !tag.uri) {
          strictFail(parser, "Unbound namespace prefix: " + JSON.stringify(parser.tagName));
          tag.uri = qn.prefix;
        }
        var parent = parser.tags[parser.tags.length - 1] || parser;
        if (tag.ns && parent.ns !== tag.ns) {
          Object.keys(tag.ns).forEach(function(p) {
            emitNode(parser, "onopennamespace", {
              prefix: p,
              uri: tag.ns[p]
            });
          });
        }
        for (var i = 0, l = parser.attribList.length;i < l; i++) {
          var nv = parser.attribList[i];
          var name = nv[0];
          var value = nv[1];
          var qualName = qname(name, true);
          var prefix = qualName.prefix;
          var local = qualName.local;
          var uri = prefix === "" ? "" : tag.ns[prefix] || "";
          var a = {
            name,
            value,
            prefix,
            local,
            uri
          };
          if (prefix && prefix !== "xmlns" && !uri) {
            strictFail(parser, "Unbound namespace prefix: " + JSON.stringify(prefix));
            a.uri = prefix;
          }
          parser.tag.attributes[name] = a;
          emitNode(parser, "onattribute", a);
        }
        parser.attribList.length = 0;
      }
      parser.tag.isSelfClosing = !!selfClosing;
      parser.sawRoot = true;
      parser.tags.push(parser.tag);
      emitNode(parser, "onopentag", parser.tag);
      if (!selfClosing) {
        if (!parser.noscript && parser.tagName.toLowerCase() === "script") {
          parser.state = S.SCRIPT;
        } else {
          parser.state = S.TEXT;
        }
        parser.tag = null;
        parser.tagName = "";
      }
      parser.attribName = parser.attribValue = "";
      parser.attribList.length = 0;
    }
    function closeTag(parser) {
      if (!parser.tagName) {
        strictFail(parser, "Weird empty close tag.");
        parser.textNode += "</>";
        parser.state = S.TEXT;
        return;
      }
      if (parser.script) {
        if (parser.tagName !== "script") {
          parser.script += "</" + parser.tagName + ">";
          parser.tagName = "";
          parser.state = S.SCRIPT;
          return;
        }
        emitNode(parser, "onscript", parser.script);
        parser.script = "";
      }
      var t = parser.tags.length;
      var tagName = parser.tagName;
      if (!parser.strict) {
        tagName = tagName[parser.looseCase]();
      }
      var closeTo = tagName;
      while (t--) {
        var close = parser.tags[t];
        if (close.name !== closeTo) {
          strictFail(parser, "Unexpected close tag");
        } else {
          break;
        }
      }
      if (t < 0) {
        strictFail(parser, "Unmatched closing tag: " + parser.tagName);
        parser.textNode += "</" + parser.tagName + ">";
        parser.state = S.TEXT;
        return;
      }
      parser.tagName = tagName;
      var s2 = parser.tags.length;
      while (s2-- > t) {
        var tag = parser.tag = parser.tags.pop();
        parser.tagName = parser.tag.name;
        emitNode(parser, "onclosetag", parser.tagName);
        var x = {};
        for (var i in tag.ns) {
          x[i] = tag.ns[i];
        }
        var parent = parser.tags[parser.tags.length - 1] || parser;
        if (parser.opt.xmlns && tag.ns !== parent.ns) {
          Object.keys(tag.ns).forEach(function(p) {
            var n = tag.ns[p];
            emitNode(parser, "onclosenamespace", { prefix: p, uri: n });
          });
        }
      }
      if (t === 0)
        parser.closedRoot = true;
      parser.tagName = parser.attribValue = parser.attribName = "";
      parser.attribList.length = 0;
      parser.state = S.TEXT;
    }
    function parseEntity(parser) {
      var entity = parser.entity;
      var entityLC = entity.toLowerCase();
      var num;
      var numStr = "";
      if (parser.ENTITIES[entity]) {
        return parser.ENTITIES[entity];
      }
      if (parser.ENTITIES[entityLC]) {
        return parser.ENTITIES[entityLC];
      }
      entity = entityLC;
      if (entity.charAt(0) === "#") {
        if (entity.charAt(1) === "x") {
          entity = entity.slice(2);
          num = parseInt(entity, 16);
          numStr = num.toString(16);
        } else {
          entity = entity.slice(1);
          num = parseInt(entity, 10);
          numStr = num.toString(10);
        }
      }
      entity = entity.replace(/^0+/, "");
      if (isNaN(num) || numStr.toLowerCase() !== entity) {
        strictFail(parser, "Invalid character entity");
        return "&" + parser.entity + ";";
      }
      return String.fromCodePoint(num);
    }
    function beginWhiteSpace(parser, c) {
      if (c === "<") {
        parser.state = S.OPEN_WAKA;
        parser.startTagPosition = parser.position;
      } else if (!isWhitespace(c)) {
        strictFail(parser, "Non-whitespace before first tag.");
        parser.textNode = c;
        parser.state = S.TEXT;
      }
    }
    function charAt(chunk, i) {
      var result = "";
      if (i < chunk.length) {
        result = chunk.charAt(i);
      }
      return result;
    }
    function write(chunk) {
      var parser = this;
      if (this.error) {
        throw this.error;
      }
      if (parser.closed) {
        return error(parser, "Cannot write after close. Assign an onready handler.");
      }
      if (chunk === null) {
        return end(parser);
      }
      if (typeof chunk === "object") {
        chunk = chunk.toString();
      }
      var i = 0;
      var c = "";
      while (true) {
        c = charAt(chunk, i++);
        parser.c = c;
        if (!c) {
          break;
        }
        if (parser.trackPosition) {
          parser.position++;
          if (c === `
`) {
            parser.line++;
            parser.column = 0;
          } else {
            parser.column++;
          }
        }
        switch (parser.state) {
          case S.BEGIN:
            parser.state = S.BEGIN_WHITESPACE;
            if (c === "\uFEFF") {
              continue;
            }
            beginWhiteSpace(parser, c);
            continue;
          case S.BEGIN_WHITESPACE:
            beginWhiteSpace(parser, c);
            continue;
          case S.TEXT:
            if (parser.sawRoot && !parser.closedRoot) {
              var starti = i - 1;
              while (c && c !== "<" && c !== "&") {
                c = charAt(chunk, i++);
                if (c && parser.trackPosition) {
                  parser.position++;
                  if (c === `
`) {
                    parser.line++;
                    parser.column = 0;
                  } else {
                    parser.column++;
                  }
                }
              }
              parser.textNode += chunk.substring(starti, i - 1);
            }
            if (c === "<" && !(parser.sawRoot && parser.closedRoot && !parser.strict)) {
              parser.state = S.OPEN_WAKA;
              parser.startTagPosition = parser.position;
            } else {
              if (!isWhitespace(c) && (!parser.sawRoot || parser.closedRoot)) {
                strictFail(parser, "Text data outside of root node.");
              }
              if (c === "&") {
                parser.state = S.TEXT_ENTITY;
              } else {
                parser.textNode += c;
              }
            }
            continue;
          case S.SCRIPT:
            if (c === "<") {
              parser.state = S.SCRIPT_ENDING;
            } else {
              parser.script += c;
            }
            continue;
          case S.SCRIPT_ENDING:
            if (c === "/") {
              parser.state = S.CLOSE_TAG;
            } else {
              parser.script += "<" + c;
              parser.state = S.SCRIPT;
            }
            continue;
          case S.OPEN_WAKA:
            if (c === "!") {
              parser.state = S.SGML_DECL;
              parser.sgmlDecl = "";
            } else if (isWhitespace(c)) {} else if (isMatch(nameStart, c)) {
              parser.state = S.OPEN_TAG;
              parser.tagName = c;
            } else if (c === "/") {
              parser.state = S.CLOSE_TAG;
              parser.tagName = "";
            } else if (c === "?") {
              parser.state = S.PROC_INST;
              parser.procInstName = parser.procInstBody = "";
            } else {
              strictFail(parser, "Unencoded <");
              if (parser.startTagPosition + 1 < parser.position) {
                var pad = parser.position - parser.startTagPosition;
                c = new Array(pad).join(" ") + c;
              }
              parser.textNode += "<" + c;
              parser.state = S.TEXT;
            }
            continue;
          case S.SGML_DECL:
            if ((parser.sgmlDecl + c).toUpperCase() === CDATA) {
              emitNode(parser, "onopencdata");
              parser.state = S.CDATA;
              parser.sgmlDecl = "";
              parser.cdata = "";
            } else if (parser.sgmlDecl + c === "--") {
              parser.state = S.COMMENT;
              parser.comment = "";
              parser.sgmlDecl = "";
            } else if ((parser.sgmlDecl + c).toUpperCase() === DOCTYPE) {
              parser.state = S.DOCTYPE;
              if (parser.doctype || parser.sawRoot) {
                strictFail(parser, "Inappropriately located doctype declaration");
              }
              parser.doctype = "";
              parser.sgmlDecl = "";
            } else if (c === ">") {
              emitNode(parser, "onsgmldeclaration", parser.sgmlDecl);
              parser.sgmlDecl = "";
              parser.state = S.TEXT;
            } else if (isQuote(c)) {
              parser.state = S.SGML_DECL_QUOTED;
              parser.sgmlDecl += c;
            } else {
              parser.sgmlDecl += c;
            }
            continue;
          case S.SGML_DECL_QUOTED:
            if (c === parser.q) {
              parser.state = S.SGML_DECL;
              parser.q = "";
            }
            parser.sgmlDecl += c;
            continue;
          case S.DOCTYPE:
            if (c === ">") {
              parser.state = S.TEXT;
              emitNode(parser, "ondoctype", parser.doctype);
              parser.doctype = true;
            } else {
              parser.doctype += c;
              if (c === "[") {
                parser.state = S.DOCTYPE_DTD;
              } else if (isQuote(c)) {
                parser.state = S.DOCTYPE_QUOTED;
                parser.q = c;
              }
            }
            continue;
          case S.DOCTYPE_QUOTED:
            parser.doctype += c;
            if (c === parser.q) {
              parser.q = "";
              parser.state = S.DOCTYPE;
            }
            continue;
          case S.DOCTYPE_DTD:
            parser.doctype += c;
            if (c === "]") {
              parser.state = S.DOCTYPE;
            } else if (isQuote(c)) {
              parser.state = S.DOCTYPE_DTD_QUOTED;
              parser.q = c;
            }
            continue;
          case S.DOCTYPE_DTD_QUOTED:
            parser.doctype += c;
            if (c === parser.q) {
              parser.state = S.DOCTYPE_DTD;
              parser.q = "";
            }
            continue;
          case S.COMMENT:
            if (c === "-") {
              parser.state = S.COMMENT_ENDING;
            } else {
              parser.comment += c;
            }
            continue;
          case S.COMMENT_ENDING:
            if (c === "-") {
              parser.state = S.COMMENT_ENDED;
              parser.comment = textopts(parser.opt, parser.comment);
              if (parser.comment) {
                emitNode(parser, "oncomment", parser.comment);
              }
              parser.comment = "";
            } else {
              parser.comment += "-" + c;
              parser.state = S.COMMENT;
            }
            continue;
          case S.COMMENT_ENDED:
            if (c !== ">") {
              strictFail(parser, "Malformed comment");
              parser.comment += "--" + c;
              parser.state = S.COMMENT;
            } else {
              parser.state = S.TEXT;
            }
            continue;
          case S.CDATA:
            if (c === "]") {
              parser.state = S.CDATA_ENDING;
            } else {
              parser.cdata += c;
            }
            continue;
          case S.CDATA_ENDING:
            if (c === "]") {
              parser.state = S.CDATA_ENDING_2;
            } else {
              parser.cdata += "]" + c;
              parser.state = S.CDATA;
            }
            continue;
          case S.CDATA_ENDING_2:
            if (c === ">") {
              if (parser.cdata) {
                emitNode(parser, "oncdata", parser.cdata);
              }
              emitNode(parser, "onclosecdata");
              parser.cdata = "";
              parser.state = S.TEXT;
            } else if (c === "]") {
              parser.cdata += "]";
            } else {
              parser.cdata += "]]" + c;
              parser.state = S.CDATA;
            }
            continue;
          case S.PROC_INST:
            if (c === "?") {
              parser.state = S.PROC_INST_ENDING;
            } else if (isWhitespace(c)) {
              parser.state = S.PROC_INST_BODY;
            } else {
              parser.procInstName += c;
            }
            continue;
          case S.PROC_INST_BODY:
            if (!parser.procInstBody && isWhitespace(c)) {
              continue;
            } else if (c === "?") {
              parser.state = S.PROC_INST_ENDING;
            } else {
              parser.procInstBody += c;
            }
            continue;
          case S.PROC_INST_ENDING:
            if (c === ">") {
              emitNode(parser, "onprocessinginstruction", {
                name: parser.procInstName,
                body: parser.procInstBody
              });
              parser.procInstName = parser.procInstBody = "";
              parser.state = S.TEXT;
            } else {
              parser.procInstBody += "?" + c;
              parser.state = S.PROC_INST_BODY;
            }
            continue;
          case S.OPEN_TAG:
            if (isMatch(nameBody, c)) {
              parser.tagName += c;
            } else {
              newTag(parser);
              if (c === ">") {
                openTag(parser);
              } else if (c === "/") {
                parser.state = S.OPEN_TAG_SLASH;
              } else {
                if (!isWhitespace(c)) {
                  strictFail(parser, "Invalid character in tag name");
                }
                parser.state = S.ATTRIB;
              }
            }
            continue;
          case S.OPEN_TAG_SLASH:
            if (c === ">") {
              openTag(parser, true);
              closeTag(parser);
            } else {
              strictFail(parser, "Forward-slash in opening tag not followed by >");
              parser.state = S.ATTRIB;
            }
            continue;
          case S.ATTRIB:
            if (isWhitespace(c)) {
              continue;
            } else if (c === ">") {
              openTag(parser);
            } else if (c === "/") {
              parser.state = S.OPEN_TAG_SLASH;
            } else if (isMatch(nameStart, c)) {
              parser.attribName = c;
              parser.attribValue = "";
              parser.state = S.ATTRIB_NAME;
            } else {
              strictFail(parser, "Invalid attribute name");
            }
            continue;
          case S.ATTRIB_NAME:
            if (c === "=") {
              parser.state = S.ATTRIB_VALUE;
            } else if (c === ">") {
              strictFail(parser, "Attribute without value");
              parser.attribValue = parser.attribName;
              attrib(parser);
              openTag(parser);
            } else if (isWhitespace(c)) {
              parser.state = S.ATTRIB_NAME_SAW_WHITE;
            } else if (isMatch(nameBody, c)) {
              parser.attribName += c;
            } else {
              strictFail(parser, "Invalid attribute name");
            }
            continue;
          case S.ATTRIB_NAME_SAW_WHITE:
            if (c === "=") {
              parser.state = S.ATTRIB_VALUE;
            } else if (isWhitespace(c)) {
              continue;
            } else {
              strictFail(parser, "Attribute without value");
              parser.tag.attributes[parser.attribName] = "";
              parser.attribValue = "";
              emitNode(parser, "onattribute", {
                name: parser.attribName,
                value: ""
              });
              parser.attribName = "";
              if (c === ">") {
                openTag(parser);
              } else if (isMatch(nameStart, c)) {
                parser.attribName = c;
                parser.state = S.ATTRIB_NAME;
              } else {
                strictFail(parser, "Invalid attribute name");
                parser.state = S.ATTRIB;
              }
            }
            continue;
          case S.ATTRIB_VALUE:
            if (isWhitespace(c)) {
              continue;
            } else if (isQuote(c)) {
              parser.q = c;
              parser.state = S.ATTRIB_VALUE_QUOTED;
            } else {
              strictFail(parser, "Unquoted attribute value");
              parser.state = S.ATTRIB_VALUE_UNQUOTED;
              parser.attribValue = c;
            }
            continue;
          case S.ATTRIB_VALUE_QUOTED:
            if (c !== parser.q) {
              if (c === "&") {
                parser.state = S.ATTRIB_VALUE_ENTITY_Q;
              } else {
                parser.attribValue += c;
              }
              continue;
            }
            attrib(parser);
            parser.q = "";
            parser.state = S.ATTRIB_VALUE_CLOSED;
            continue;
          case S.ATTRIB_VALUE_CLOSED:
            if (isWhitespace(c)) {
              parser.state = S.ATTRIB;
            } else if (c === ">") {
              openTag(parser);
            } else if (c === "/") {
              parser.state = S.OPEN_TAG_SLASH;
            } else if (isMatch(nameStart, c)) {
              strictFail(parser, "No whitespace between attributes");
              parser.attribName = c;
              parser.attribValue = "";
              parser.state = S.ATTRIB_NAME;
            } else {
              strictFail(parser, "Invalid attribute name");
            }
            continue;
          case S.ATTRIB_VALUE_UNQUOTED:
            if (!isAttribEnd(c)) {
              if (c === "&") {
                parser.state = S.ATTRIB_VALUE_ENTITY_U;
              } else {
                parser.attribValue += c;
              }
              continue;
            }
            attrib(parser);
            if (c === ">") {
              openTag(parser);
            } else {
              parser.state = S.ATTRIB;
            }
            continue;
          case S.CLOSE_TAG:
            if (!parser.tagName) {
              if (isWhitespace(c)) {
                continue;
              } else if (notMatch(nameStart, c)) {
                if (parser.script) {
                  parser.script += "</" + c;
                  parser.state = S.SCRIPT;
                } else {
                  strictFail(parser, "Invalid tagname in closing tag.");
                }
              } else {
                parser.tagName = c;
              }
            } else if (c === ">") {
              closeTag(parser);
            } else if (isMatch(nameBody, c)) {
              parser.tagName += c;
            } else if (parser.script) {
              parser.script += "</" + parser.tagName;
              parser.tagName = "";
              parser.state = S.SCRIPT;
            } else {
              if (!isWhitespace(c)) {
                strictFail(parser, "Invalid tagname in closing tag");
              }
              parser.state = S.CLOSE_TAG_SAW_WHITE;
            }
            continue;
          case S.CLOSE_TAG_SAW_WHITE:
            if (isWhitespace(c)) {
              continue;
            }
            if (c === ">") {
              closeTag(parser);
            } else {
              strictFail(parser, "Invalid characters in closing tag");
            }
            continue;
          case S.TEXT_ENTITY:
          case S.ATTRIB_VALUE_ENTITY_Q:
          case S.ATTRIB_VALUE_ENTITY_U:
            var returnState;
            var buffer;
            switch (parser.state) {
              case S.TEXT_ENTITY:
                returnState = S.TEXT;
                buffer = "textNode";
                break;
              case S.ATTRIB_VALUE_ENTITY_Q:
                returnState = S.ATTRIB_VALUE_QUOTED;
                buffer = "attribValue";
                break;
              case S.ATTRIB_VALUE_ENTITY_U:
                returnState = S.ATTRIB_VALUE_UNQUOTED;
                buffer = "attribValue";
                break;
            }
            if (c === ";") {
              var parsedEntity = parseEntity(parser);
              if (parser.state === S.TEXT_ENTITY && !sax.ENTITIES[parser.entity] && parsedEntity !== "&" + parser.entity + ";") {
                chunk = chunk.slice(0, i) + parsedEntity + chunk.slice(i);
              } else {
                parser[buffer] += parsedEntity;
              }
              parser.entity = "";
              parser.state = returnState;
            } else if (isMatch(parser.entity.length ? entityBody : entityStart, c)) {
              parser.entity += c;
            } else {
              strictFail(parser, "Invalid character in entity name");
              parser[buffer] += "&" + parser.entity + c;
              parser.entity = "";
              parser.state = returnState;
            }
            continue;
          default:
            throw new Error(parser, "Unknown state: " + parser.state);
        }
      }
      if (parser.position >= parser.bufferCheckPosition) {
        checkBufferLength(parser);
      }
      return parser;
    }
  })(typeof exports === "undefined" ? exports.sax = {} : exports);
});

// ../../../../node_modules/.bun/svgo@3.3.2/node_modules/svgo/plugins/_collections.js
var require__collections = __commonJS((exports) => {
  exports.elemsGroups = {
    animation: new Set([
      "animate",
      "animateColor",
      "animateMotion",
      "animateTransform",
      "set"
    ]),
    descriptive: new Set(["desc", "metadata", "title"]),
    shape: new Set([
      "circle",
      "ellipse",
      "line",
      "path",
      "polygon",
      "polyline",
      "rect"
    ]),
    structural: new Set(["defs", "g", "svg", "symbol", "use"]),
    paintServer: new Set([
      "hatch",
      "linearGradient",
      "meshGradient",
      "pattern",
      "radialGradient",
      "solidColor"
    ]),
    nonRendering: new Set([
      "clipPath",
      "filter",
      "linearGradient",
      "marker",
      "mask",
      "pattern",
      "radialGradient",
      "solidColor",
      "symbol"
    ]),
    container: new Set([
      "a",
      "defs",
      "foreignObject",
      "g",
      "marker",
      "mask",
      "missing-glyph",
      "pattern",
      "svg",
      "switch",
      "symbol"
    ]),
    textContent: new Set([
      "altGlyph",
      "altGlyphDef",
      "altGlyphItem",
      "glyph",
      "glyphRef",
      "text",
      "textPath",
      "tref",
      "tspan"
    ]),
    textContentChild: new Set(["altGlyph", "textPath", "tref", "tspan"]),
    lightSource: new Set([
      "feDiffuseLighting",
      "feDistantLight",
      "fePointLight",
      "feSpecularLighting",
      "feSpotLight"
    ]),
    filterPrimitive: new Set([
      "feBlend",
      "feColorMatrix",
      "feComponentTransfer",
      "feComposite",
      "feConvolveMatrix",
      "feDiffuseLighting",
      "feDisplacementMap",
      "feDropShadow",
      "feFlood",
      "feFuncA",
      "feFuncB",
      "feFuncG",
      "feFuncR",
      "feGaussianBlur",
      "feImage",
      "feMerge",
      "feMergeNode",
      "feMorphology",
      "feOffset",
      "feSpecularLighting",
      "feTile",
      "feTurbulence"
    ])
  };
  exports.textElems = new Set([
    ...exports.elemsGroups.textContent,
    "pre",
    "title"
  ]);
  exports.pathElems = new Set(["glyph", "missing-glyph", "path"]);
  exports.attrsGroups = {
    animationAddition: new Set(["additive", "accumulate"]),
    animationAttributeTarget: new Set(["attributeType", "attributeName"]),
    animationEvent: new Set(["onbegin", "onend", "onrepeat", "onload"]),
    animationTiming: new Set([
      "begin",
      "dur",
      "end",
      "fill",
      "max",
      "min",
      "repeatCount",
      "repeatDur",
      "restart"
    ]),
    animationValue: new Set([
      "by",
      "calcMode",
      "from",
      "keySplines",
      "keyTimes",
      "to",
      "values"
    ]),
    conditionalProcessing: new Set([
      "requiredExtensions",
      "requiredFeatures",
      "systemLanguage"
    ]),
    core: new Set(["id", "tabindex", "xml:base", "xml:lang", "xml:space"]),
    graphicalEvent: new Set([
      "onactivate",
      "onclick",
      "onfocusin",
      "onfocusout",
      "onload",
      "onmousedown",
      "onmousemove",
      "onmouseout",
      "onmouseover",
      "onmouseup"
    ]),
    presentation: new Set([
      "alignment-baseline",
      "baseline-shift",
      "clip-path",
      "clip-rule",
      "clip",
      "color-interpolation-filters",
      "color-interpolation",
      "color-profile",
      "color-rendering",
      "color",
      "cursor",
      "direction",
      "display",
      "dominant-baseline",
      "enable-background",
      "fill-opacity",
      "fill-rule",
      "fill",
      "filter",
      "flood-color",
      "flood-opacity",
      "font-family",
      "font-size-adjust",
      "font-size",
      "font-stretch",
      "font-style",
      "font-variant",
      "font-weight",
      "glyph-orientation-horizontal",
      "glyph-orientation-vertical",
      "image-rendering",
      "letter-spacing",
      "lighting-color",
      "marker-end",
      "marker-mid",
      "marker-start",
      "mask",
      "opacity",
      "overflow",
      "paint-order",
      "pointer-events",
      "shape-rendering",
      "stop-color",
      "stop-opacity",
      "stroke-dasharray",
      "stroke-dashoffset",
      "stroke-linecap",
      "stroke-linejoin",
      "stroke-miterlimit",
      "stroke-opacity",
      "stroke-width",
      "stroke",
      "text-anchor",
      "text-decoration",
      "text-overflow",
      "text-rendering",
      "transform-origin",
      "transform",
      "unicode-bidi",
      "vector-effect",
      "visibility",
      "word-spacing",
      "writing-mode"
    ]),
    xlink: new Set([
      "xlink:actuate",
      "xlink:arcrole",
      "xlink:href",
      "xlink:role",
      "xlink:show",
      "xlink:title",
      "xlink:type"
    ]),
    documentEvent: new Set([
      "onabort",
      "onerror",
      "onresize",
      "onscroll",
      "onunload",
      "onzoom"
    ]),
    documentElementEvent: new Set(["oncopy", "oncut", "onpaste"]),
    globalEvent: new Set([
      "oncancel",
      "oncanplay",
      "oncanplaythrough",
      "onchange",
      "onclick",
      "onclose",
      "oncuechange",
      "ondblclick",
      "ondrag",
      "ondragend",
      "ondragenter",
      "ondragleave",
      "ondragover",
      "ondragstart",
      "ondrop",
      "ondurationchange",
      "onemptied",
      "onended",
      "onerror",
      "onfocus",
      "oninput",
      "oninvalid",
      "onkeydown",
      "onkeypress",
      "onkeyup",
      "onload",
      "onloadeddata",
      "onloadedmetadata",
      "onloadstart",
      "onmousedown",
      "onmouseenter",
      "onmouseleave",
      "onmousemove",
      "onmouseout",
      "onmouseover",
      "onmouseup",
      "onmousewheel",
      "onpause",
      "onplay",
      "onplaying",
      "onprogress",
      "onratechange",
      "onreset",
      "onresize",
      "onscroll",
      "onseeked",
      "onseeking",
      "onselect",
      "onshow",
      "onstalled",
      "onsubmit",
      "onsuspend",
      "ontimeupdate",
      "ontoggle",
      "onvolumechange",
      "onwaiting"
    ]),
    filterPrimitive: new Set(["x", "y", "width", "height", "result"]),
    transferFunction: new Set([
      "amplitude",
      "exponent",
      "intercept",
      "offset",
      "slope",
      "tableValues",
      "type"
    ])
  };
  exports.attrsGroupsDefaults = {
    core: { "xml:space": "default" },
    presentation: {
      clip: "auto",
      "clip-path": "none",
      "clip-rule": "nonzero",
      mask: "none",
      opacity: "1",
      "stop-color": "#000",
      "stop-opacity": "1",
      "fill-opacity": "1",
      "fill-rule": "nonzero",
      fill: "#000",
      stroke: "none",
      "stroke-width": "1",
      "stroke-linecap": "butt",
      "stroke-linejoin": "miter",
      "stroke-miterlimit": "4",
      "stroke-dasharray": "none",
      "stroke-dashoffset": "0",
      "stroke-opacity": "1",
      "paint-order": "normal",
      "vector-effect": "none",
      display: "inline",
      visibility: "visible",
      "marker-start": "none",
      "marker-mid": "none",
      "marker-end": "none",
      "color-interpolation": "sRGB",
      "color-interpolation-filters": "linearRGB",
      "color-rendering": "auto",
      "shape-rendering": "auto",
      "text-rendering": "auto",
      "image-rendering": "auto",
      "font-style": "normal",
      "font-variant": "normal",
      "font-weight": "normal",
      "font-stretch": "normal",
      "font-size": "medium",
      "font-size-adjust": "none",
      kerning: "auto",
      "letter-spacing": "normal",
      "word-spacing": "normal",
      "text-decoration": "none",
      "text-anchor": "start",
      "text-overflow": "clip",
      "writing-mode": "lr-tb",
      "glyph-orientation-vertical": "auto",
      "glyph-orientation-horizontal": "0deg",
      direction: "ltr",
      "unicode-bidi": "normal",
      "dominant-baseline": "auto",
      "alignment-baseline": "baseline",
      "baseline-shift": "baseline"
    },
    transferFunction: {
      slope: "1",
      intercept: "0",
      amplitude: "1",
      exponent: "1",
      offset: "0"
    }
  };
  exports.elems = {
    a: {
      attrsGroups: new Set([
        "conditionalProcessing",
        "core",
        "graphicalEvent",
        "presentation",
        "xlink"
      ]),
      attrs: new Set([
        "class",
        "externalResourcesRequired",
        "style",
        "target",
        "transform"
      ]),
      defaults: {
        target: "_self"
      },
      contentGroups: new Set([
        "animation",
        "descriptive",
        "paintServer",
        "shape",
        "structural"
      ]),
      content: new Set([
        "a",
        "altGlyphDef",
        "clipPath",
        "color-profile",
        "cursor",
        "filter",
        "font-face",
        "font",
        "foreignObject",
        "image",
        "marker",
        "mask",
        "pattern",
        "script",
        "style",
        "switch",
        "text",
        "view",
        "tspan"
      ])
    },
    altGlyph: {
      attrsGroups: new Set([
        "conditionalProcessing",
        "core",
        "graphicalEvent",
        "presentation",
        "xlink"
      ]),
      attrs: new Set([
        "class",
        "dx",
        "dy",
        "externalResourcesRequired",
        "format",
        "glyphRef",
        "rotate",
        "style",
        "x",
        "y"
      ])
    },
    altGlyphDef: {
      attrsGroups: new Set(["core"]),
      content: new Set(["glyphRef"])
    },
    altGlyphItem: {
      attrsGroups: new Set(["core"]),
      content: new Set(["glyphRef", "altGlyphItem"])
    },
    animate: {
      attrsGroups: new Set([
        "animationAddition",
        "animationAttributeTarget",
        "animationEvent",
        "animationTiming",
        "animationValue",
        "conditionalProcessing",
        "core",
        "presentation",
        "xlink"
      ]),
      attrs: new Set(["externalResourcesRequired"]),
      contentGroups: new Set(["descriptive"])
    },
    animateColor: {
      attrsGroups: new Set([
        "animationAddition",
        "animationAttributeTarget",
        "animationEvent",
        "animationTiming",
        "animationValue",
        "conditionalProcessing",
        "core",
        "presentation",
        "xlink"
      ]),
      attrs: new Set(["externalResourcesRequired"]),
      contentGroups: new Set(["descriptive"])
    },
    animateMotion: {
      attrsGroups: new Set([
        "animationAddition",
        "animationEvent",
        "animationTiming",
        "animationValue",
        "conditionalProcessing",
        "core",
        "xlink"
      ]),
      attrs: new Set([
        "externalResourcesRequired",
        "keyPoints",
        "origin",
        "path",
        "rotate"
      ]),
      defaults: {
        rotate: "0"
      },
      contentGroups: new Set(["descriptive"]),
      content: new Set(["mpath"])
    },
    animateTransform: {
      attrsGroups: new Set([
        "animationAddition",
        "animationAttributeTarget",
        "animationEvent",
        "animationTiming",
        "animationValue",
        "conditionalProcessing",
        "core",
        "xlink"
      ]),
      attrs: new Set(["externalResourcesRequired", "type"]),
      contentGroups: new Set(["descriptive"])
    },
    circle: {
      attrsGroups: new Set([
        "conditionalProcessing",
        "core",
        "graphicalEvent",
        "presentation"
      ]),
      attrs: new Set([
        "class",
        "cx",
        "cy",
        "externalResourcesRequired",
        "r",
        "style",
        "transform"
      ]),
      defaults: {
        cx: "0",
        cy: "0"
      },
      contentGroups: new Set(["animation", "descriptive"])
    },
    clipPath: {
      attrsGroups: new Set(["conditionalProcessing", "core", "presentation"]),
      attrs: new Set([
        "class",
        "clipPathUnits",
        "externalResourcesRequired",
        "style",
        "transform"
      ]),
      defaults: {
        clipPathUnits: "userSpaceOnUse"
      },
      contentGroups: new Set(["animation", "descriptive", "shape"]),
      content: new Set(["text", "use"])
    },
    "color-profile": {
      attrsGroups: new Set(["core", "xlink"]),
      attrs: new Set(["local", "name", "rendering-intent"]),
      defaults: {
        name: "sRGB",
        "rendering-intent": "auto"
      },
      contentGroups: new Set(["descriptive"])
    },
    cursor: {
      attrsGroups: new Set(["core", "conditionalProcessing", "xlink"]),
      attrs: new Set(["externalResourcesRequired", "x", "y"]),
      defaults: {
        x: "0",
        y: "0"
      },
      contentGroups: new Set(["descriptive"])
    },
    defs: {
      attrsGroups: new Set([
        "conditionalProcessing",
        "core",
        "graphicalEvent",
        "presentation"
      ]),
      attrs: new Set([
        "class",
        "externalResourcesRequired",
        "style",
        "transform"
      ]),
      contentGroups: new Set([
        "animation",
        "descriptive",
        "paintServer",
        "shape",
        "structural"
      ]),
      content: new Set([
        "a",
        "altGlyphDef",
        "clipPath",
        "color-profile",
        "cursor",
        "filter",
        "font-face",
        "font",
        "foreignObject",
        "image",
        "marker",
        "mask",
        "pattern",
        "script",
        "style",
        "switch",
        "text",
        "view"
      ])
    },
    desc: {
      attrsGroups: new Set(["core"]),
      attrs: new Set(["class", "style"])
    },
    ellipse: {
      attrsGroups: new Set([
        "conditionalProcessing",
        "core",
        "graphicalEvent",
        "presentation"
      ]),
      attrs: new Set([
        "class",
        "cx",
        "cy",
        "externalResourcesRequired",
        "rx",
        "ry",
        "style",
        "transform"
      ]),
      defaults: {
        cx: "0",
        cy: "0"
      },
      contentGroups: new Set(["animation", "descriptive"])
    },
    feBlend: {
      attrsGroups: new Set(["core", "presentation", "filterPrimitive"]),
      attrs: new Set([
        "class",
        "style",
        "in",
        "in2",
        "mode"
      ]),
      defaults: {
        mode: "normal"
      },
      content: new Set(["animate", "set"])
    },
    feColorMatrix: {
      attrsGroups: new Set(["core", "presentation", "filterPrimitive"]),
      attrs: new Set(["class", "style", "in", "type", "values"]),
      defaults: {
        type: "matrix"
      },
      content: new Set(["animate", "set"])
    },
    feComponentTransfer: {
      attrsGroups: new Set(["core", "presentation", "filterPrimitive"]),
      attrs: new Set(["class", "style", "in"]),
      content: new Set(["feFuncA", "feFuncB", "feFuncG", "feFuncR"])
    },
    feComposite: {
      attrsGroups: new Set(["core", "presentation", "filterPrimitive"]),
      attrs: new Set([
        "class",
        "in",
        "in2",
        "k1",
        "k2",
        "k3",
        "k4",
        "operator",
        "style"
      ]),
      defaults: {
        operator: "over",
        k1: "0",
        k2: "0",
        k3: "0",
        k4: "0"
      },
      content: new Set(["animate", "set"])
    },
    feConvolveMatrix: {
      attrsGroups: new Set(["core", "presentation", "filterPrimitive"]),
      attrs: new Set([
        "class",
        "in",
        "kernelMatrix",
        "order",
        "style",
        "bias",
        "divisor",
        "edgeMode",
        "targetX",
        "targetY",
        "kernelUnitLength",
        "preserveAlpha"
      ]),
      defaults: {
        order: "3",
        bias: "0",
        edgeMode: "duplicate",
        preserveAlpha: "false"
      },
      content: new Set(["animate", "set"])
    },
    feDiffuseLighting: {
      attrsGroups: new Set(["core", "presentation", "filterPrimitive"]),
      attrs: new Set([
        "class",
        "diffuseConstant",
        "in",
        "kernelUnitLength",
        "style",
        "surfaceScale"
      ]),
      defaults: {
        surfaceScale: "1",
        diffuseConstant: "1"
      },
      contentGroups: new Set(["descriptive"]),
      content: new Set([
        "feDistantLight",
        "fePointLight",
        "feSpotLight"
      ])
    },
    feDisplacementMap: {
      attrsGroups: new Set(["core", "presentation", "filterPrimitive"]),
      attrs: new Set([
        "class",
        "in",
        "in2",
        "scale",
        "style",
        "xChannelSelector",
        "yChannelSelector"
      ]),
      defaults: {
        scale: "0",
        xChannelSelector: "A",
        yChannelSelector: "A"
      },
      content: new Set(["animate", "set"])
    },
    feDistantLight: {
      attrsGroups: new Set(["core"]),
      attrs: new Set(["azimuth", "elevation"]),
      defaults: {
        azimuth: "0",
        elevation: "0"
      },
      content: new Set(["animate", "set"])
    },
    feFlood: {
      attrsGroups: new Set(["core", "presentation", "filterPrimitive"]),
      attrs: new Set(["class", "style"]),
      content: new Set(["animate", "animateColor", "set"])
    },
    feFuncA: {
      attrsGroups: new Set(["core", "transferFunction"]),
      content: new Set(["set", "animate"])
    },
    feFuncB: {
      attrsGroups: new Set(["core", "transferFunction"]),
      content: new Set(["set", "animate"])
    },
    feFuncG: {
      attrsGroups: new Set(["core", "transferFunction"]),
      content: new Set(["set", "animate"])
    },
    feFuncR: {
      attrsGroups: new Set(["core", "transferFunction"]),
      content: new Set(["set", "animate"])
    },
    feGaussianBlur: {
      attrsGroups: new Set(["core", "presentation", "filterPrimitive"]),
      attrs: new Set(["class", "style", "in", "stdDeviation"]),
      defaults: {
        stdDeviation: "0"
      },
      content: new Set(["set", "animate"])
    },
    feImage: {
      attrsGroups: new Set(["core", "presentation", "filterPrimitive", "xlink"]),
      attrs: new Set([
        "class",
        "externalResourcesRequired",
        "href",
        "preserveAspectRatio",
        "style",
        "xlink:href"
      ]),
      defaults: {
        preserveAspectRatio: "xMidYMid meet"
      },
      content: new Set(["animate", "animateTransform", "set"])
    },
    feMerge: {
      attrsGroups: new Set(["core", "presentation", "filterPrimitive"]),
      attrs: new Set(["class", "style"]),
      content: new Set(["feMergeNode"])
    },
    feMergeNode: {
      attrsGroups: new Set(["core"]),
      attrs: new Set(["in"]),
      content: new Set(["animate", "set"])
    },
    feMorphology: {
      attrsGroups: new Set(["core", "presentation", "filterPrimitive"]),
      attrs: new Set(["class", "style", "in", "operator", "radius"]),
      defaults: {
        operator: "erode",
        radius: "0"
      },
      content: new Set(["animate", "set"])
    },
    feOffset: {
      attrsGroups: new Set(["core", "presentation", "filterPrimitive"]),
      attrs: new Set(["class", "style", "in", "dx", "dy"]),
      defaults: {
        dx: "0",
        dy: "0"
      },
      content: new Set(["animate", "set"])
    },
    fePointLight: {
      attrsGroups: new Set(["core"]),
      attrs: new Set(["x", "y", "z"]),
      defaults: {
        x: "0",
        y: "0",
        z: "0"
      },
      content: new Set(["animate", "set"])
    },
    feSpecularLighting: {
      attrsGroups: new Set(["core", "presentation", "filterPrimitive"]),
      attrs: new Set([
        "class",
        "in",
        "kernelUnitLength",
        "specularConstant",
        "specularExponent",
        "style",
        "surfaceScale"
      ]),
      defaults: {
        surfaceScale: "1",
        specularConstant: "1",
        specularExponent: "1"
      },
      contentGroups: new Set([
        "descriptive",
        "lightSource"
      ])
    },
    feSpotLight: {
      attrsGroups: new Set(["core"]),
      attrs: new Set([
        "limitingConeAngle",
        "pointsAtX",
        "pointsAtY",
        "pointsAtZ",
        "specularExponent",
        "x",
        "y",
        "z"
      ]),
      defaults: {
        x: "0",
        y: "0",
        z: "0",
        pointsAtX: "0",
        pointsAtY: "0",
        pointsAtZ: "0",
        specularExponent: "1"
      },
      content: new Set(["animate", "set"])
    },
    feTile: {
      attrsGroups: new Set(["core", "presentation", "filterPrimitive"]),
      attrs: new Set(["class", "style", "in"]),
      content: new Set(["animate", "set"])
    },
    feTurbulence: {
      attrsGroups: new Set(["core", "presentation", "filterPrimitive"]),
      attrs: new Set([
        "baseFrequency",
        "class",
        "numOctaves",
        "seed",
        "stitchTiles",
        "style",
        "type"
      ]),
      defaults: {
        baseFrequency: "0",
        numOctaves: "1",
        seed: "0",
        stitchTiles: "noStitch",
        type: "turbulence"
      },
      content: new Set(["animate", "set"])
    },
    filter: {
      attrsGroups: new Set(["core", "presentation", "xlink"]),
      attrs: new Set([
        "class",
        "externalResourcesRequired",
        "filterRes",
        "filterUnits",
        "height",
        "href",
        "primitiveUnits",
        "style",
        "width",
        "x",
        "xlink:href",
        "y"
      ]),
      defaults: {
        primitiveUnits: "userSpaceOnUse",
        x: "-10%",
        y: "-10%",
        width: "120%",
        height: "120%"
      },
      contentGroups: new Set(["descriptive", "filterPrimitive"]),
      content: new Set(["animate", "set"])
    },
    font: {
      attrsGroups: new Set(["core", "presentation"]),
      attrs: new Set([
        "class",
        "externalResourcesRequired",
        "horiz-adv-x",
        "horiz-origin-x",
        "horiz-origin-y",
        "style",
        "vert-adv-y",
        "vert-origin-x",
        "vert-origin-y"
      ]),
      defaults: {
        "horiz-origin-x": "0",
        "horiz-origin-y": "0"
      },
      contentGroups: new Set(["descriptive"]),
      content: new Set(["font-face", "glyph", "hkern", "missing-glyph", "vkern"])
    },
    "font-face": {
      attrsGroups: new Set(["core"]),
      attrs: new Set([
        "font-family",
        "font-style",
        "font-variant",
        "font-weight",
        "font-stretch",
        "font-size",
        "unicode-range",
        "units-per-em",
        "panose-1",
        "stemv",
        "stemh",
        "slope",
        "cap-height",
        "x-height",
        "accent-height",
        "ascent",
        "descent",
        "widths",
        "bbox",
        "ideographic",
        "alphabetic",
        "mathematical",
        "hanging",
        "v-ideographic",
        "v-alphabetic",
        "v-mathematical",
        "v-hanging",
        "underline-position",
        "underline-thickness",
        "strikethrough-position",
        "strikethrough-thickness",
        "overline-position",
        "overline-thickness"
      ]),
      defaults: {
        "font-style": "all",
        "font-variant": "normal",
        "font-weight": "all",
        "font-stretch": "normal",
        "unicode-range": "U+0-10FFFF",
        "units-per-em": "1000",
        "panose-1": "0 0 0 0 0 0 0 0 0 0",
        slope: "0"
      },
      contentGroups: new Set(["descriptive"]),
      content: new Set([
        "font-face-src"
      ])
    },
    "font-face-format": {
      attrsGroups: new Set(["core"]),
      attrs: new Set(["string"])
    },
    "font-face-name": {
      attrsGroups: new Set(["core"]),
      attrs: new Set(["name"])
    },
    "font-face-src": {
      attrsGroups: new Set(["core"]),
      content: new Set(["font-face-name", "font-face-uri"])
    },
    "font-face-uri": {
      attrsGroups: new Set(["core", "xlink"]),
      attrs: new Set(["href", "xlink:href"]),
      content: new Set(["font-face-format"])
    },
    foreignObject: {
      attrsGroups: new Set([
        "conditionalProcessing",
        "core",
        "graphicalEvent",
        "presentation"
      ]),
      attrs: new Set([
        "class",
        "externalResourcesRequired",
        "height",
        "style",
        "transform",
        "width",
        "x",
        "y"
      ]),
      defaults: {
        x: "0",
        y: "0"
      }
    },
    g: {
      attrsGroups: new Set([
        "conditionalProcessing",
        "core",
        "graphicalEvent",
        "presentation"
      ]),
      attrs: new Set([
        "class",
        "externalResourcesRequired",
        "style",
        "transform"
      ]),
      contentGroups: new Set([
        "animation",
        "descriptive",
        "paintServer",
        "shape",
        "structural"
      ]),
      content: new Set([
        "a",
        "altGlyphDef",
        "clipPath",
        "color-profile",
        "cursor",
        "filter",
        "font-face",
        "font",
        "foreignObject",
        "image",
        "marker",
        "mask",
        "pattern",
        "script",
        "style",
        "switch",
        "text",
        "view"
      ])
    },
    glyph: {
      attrsGroups: new Set(["core", "presentation"]),
      attrs: new Set([
        "arabic-form",
        "class",
        "d",
        "glyph-name",
        "horiz-adv-x",
        "lang",
        "orientation",
        "style",
        "unicode",
        "vert-adv-y",
        "vert-origin-x",
        "vert-origin-y"
      ]),
      defaults: {
        "arabic-form": "initial"
      },
      contentGroups: new Set([
        "animation",
        "descriptive",
        "paintServer",
        "shape",
        "structural"
      ]),
      content: new Set([
        "a",
        "altGlyphDef",
        "clipPath",
        "color-profile",
        "cursor",
        "filter",
        "font-face",
        "font",
        "foreignObject",
        "image",
        "marker",
        "mask",
        "pattern",
        "script",
        "style",
        "switch",
        "text",
        "view"
      ])
    },
    glyphRef: {
      attrsGroups: new Set(["core", "presentation"]),
      attrs: new Set([
        "class",
        "d",
        "horiz-adv-x",
        "style",
        "vert-adv-y",
        "vert-origin-x",
        "vert-origin-y"
      ]),
      contentGroups: new Set([
        "animation",
        "descriptive",
        "paintServer",
        "shape",
        "structural"
      ]),
      content: new Set([
        "a",
        "altGlyphDef",
        "clipPath",
        "color-profile",
        "cursor",
        "filter",
        "font-face",
        "font",
        "foreignObject",
        "image",
        "marker",
        "mask",
        "pattern",
        "script",
        "style",
        "switch",
        "text",
        "view"
      ])
    },
    hatch: {
      attrsGroups: new Set(["core", "presentation", "xlink"]),
      attrs: new Set([
        "class",
        "hatchContentUnits",
        "hatchUnits",
        "pitch",
        "rotate",
        "style",
        "transform",
        "x",
        "y"
      ]),
      defaults: {
        hatchUnits: "objectBoundingBox",
        hatchContentUnits: "userSpaceOnUse",
        x: "0",
        y: "0",
        pitch: "0",
        rotate: "0"
      },
      contentGroups: new Set(["animation", "descriptive"]),
      content: new Set(["hatchPath"])
    },
    hatchPath: {
      attrsGroups: new Set(["core", "presentation", "xlink"]),
      attrs: new Set(["class", "style", "d", "offset"]),
      defaults: {
        offset: "0"
      },
      contentGroups: new Set(["animation", "descriptive"])
    },
    hkern: {
      attrsGroups: new Set(["core"]),
      attrs: new Set(["u1", "g1", "u2", "g2", "k"])
    },
    image: {
      attrsGroups: new Set([
        "conditionalProcessing",
        "core",
        "graphicalEvent",
        "presentation",
        "xlink"
      ]),
      attrs: new Set([
        "class",
        "externalResourcesRequired",
        "height",
        "href",
        "preserveAspectRatio",
        "style",
        "transform",
        "width",
        "x",
        "xlink:href",
        "y"
      ]),
      defaults: {
        x: "0",
        y: "0",
        preserveAspectRatio: "xMidYMid meet"
      },
      contentGroups: new Set(["animation", "descriptive"])
    },
    line: {
      attrsGroups: new Set([
        "conditionalProcessing",
        "core",
        "graphicalEvent",
        "presentation"
      ]),
      attrs: new Set([
        "class",
        "externalResourcesRequired",
        "style",
        "transform",
        "x1",
        "x2",
        "y1",
        "y2"
      ]),
      defaults: {
        x1: "0",
        y1: "0",
        x2: "0",
        y2: "0"
      },
      contentGroups: new Set(["animation", "descriptive"])
    },
    linearGradient: {
      attrsGroups: new Set(["core", "presentation", "xlink"]),
      attrs: new Set([
        "class",
        "externalResourcesRequired",
        "gradientTransform",
        "gradientUnits",
        "href",
        "spreadMethod",
        "style",
        "x1",
        "x2",
        "xlink:href",
        "y1",
        "y2"
      ]),
      defaults: {
        x1: "0",
        y1: "0",
        x2: "100%",
        y2: "0",
        spreadMethod: "pad"
      },
      contentGroups: new Set(["descriptive"]),
      content: new Set(["animate", "animateTransform", "set", "stop"])
    },
    marker: {
      attrsGroups: new Set(["core", "presentation"]),
      attrs: new Set([
        "class",
        "externalResourcesRequired",
        "markerHeight",
        "markerUnits",
        "markerWidth",
        "orient",
        "preserveAspectRatio",
        "refX",
        "refY",
        "style",
        "viewBox"
      ]),
      defaults: {
        markerUnits: "strokeWidth",
        refX: "0",
        refY: "0",
        markerWidth: "3",
        markerHeight: "3"
      },
      contentGroups: new Set([
        "animation",
        "descriptive",
        "paintServer",
        "shape",
        "structural"
      ]),
      content: new Set([
        "a",
        "altGlyphDef",
        "clipPath",
        "color-profile",
        "cursor",
        "filter",
        "font-face",
        "font",
        "foreignObject",
        "image",
        "marker",
        "mask",
        "pattern",
        "script",
        "style",
        "switch",
        "text",
        "view"
      ])
    },
    mask: {
      attrsGroups: new Set(["conditionalProcessing", "core", "presentation"]),
      attrs: new Set([
        "class",
        "externalResourcesRequired",
        "height",
        "mask-type",
        "maskContentUnits",
        "maskUnits",
        "style",
        "width",
        "x",
        "y"
      ]),
      defaults: {
        maskUnits: "objectBoundingBox",
        maskContentUnits: "userSpaceOnUse",
        x: "-10%",
        y: "-10%",
        width: "120%",
        height: "120%"
      },
      contentGroups: new Set([
        "animation",
        "descriptive",
        "paintServer",
        "shape",
        "structural"
      ]),
      content: new Set([
        "a",
        "altGlyphDef",
        "clipPath",
        "color-profile",
        "cursor",
        "filter",
        "font-face",
        "font",
        "foreignObject",
        "image",
        "marker",
        "mask",
        "pattern",
        "script",
        "style",
        "switch",
        "text",
        "view"
      ])
    },
    metadata: {
      attrsGroups: new Set(["core"])
    },
    "missing-glyph": {
      attrsGroups: new Set(["core", "presentation"]),
      attrs: new Set([
        "class",
        "d",
        "horiz-adv-x",
        "style",
        "vert-adv-y",
        "vert-origin-x",
        "vert-origin-y"
      ]),
      contentGroups: new Set([
        "animation",
        "descriptive",
        "paintServer",
        "shape",
        "structural"
      ]),
      content: new Set([
        "a",
        "altGlyphDef",
        "clipPath",
        "color-profile",
        "cursor",
        "filter",
        "font-face",
        "font",
        "foreignObject",
        "image",
        "marker",
        "mask",
        "pattern",
        "script",
        "style",
        "switch",
        "text",
        "view"
      ])
    },
    mpath: {
      attrsGroups: new Set(["core", "xlink"]),
      attrs: new Set(["externalResourcesRequired", "href", "xlink:href"]),
      contentGroups: new Set(["descriptive"])
    },
    path: {
      attrsGroups: new Set([
        "conditionalProcessing",
        "core",
        "graphicalEvent",
        "presentation"
      ]),
      attrs: new Set([
        "class",
        "d",
        "externalResourcesRequired",
        "pathLength",
        "style",
        "transform"
      ]),
      contentGroups: new Set(["animation", "descriptive"])
    },
    pattern: {
      attrsGroups: new Set([
        "conditionalProcessing",
        "core",
        "presentation",
        "xlink"
      ]),
      attrs: new Set([
        "class",
        "externalResourcesRequired",
        "height",
        "href",
        "patternContentUnits",
        "patternTransform",
        "patternUnits",
        "preserveAspectRatio",
        "style",
        "viewBox",
        "width",
        "x",
        "xlink:href",
        "y"
      ]),
      defaults: {
        patternUnits: "objectBoundingBox",
        patternContentUnits: "userSpaceOnUse",
        x: "0",
        y: "0",
        width: "0",
        height: "0",
        preserveAspectRatio: "xMidYMid meet"
      },
      contentGroups: new Set([
        "animation",
        "descriptive",
        "paintServer",
        "shape",
        "structural"
      ]),
      content: new Set([
        "a",
        "altGlyphDef",
        "clipPath",
        "color-profile",
        "cursor",
        "filter",
        "font-face",
        "font",
        "foreignObject",
        "image",
        "marker",
        "mask",
        "pattern",
        "script",
        "style",
        "switch",
        "text",
        "view"
      ])
    },
    polygon: {
      attrsGroups: new Set([
        "conditionalProcessing",
        "core",
        "graphicalEvent",
        "presentation"
      ]),
      attrs: new Set([
        "class",
        "externalResourcesRequired",
        "points",
        "style",
        "transform"
      ]),
      contentGroups: new Set(["animation", "descriptive"])
    },
    polyline: {
      attrsGroups: new Set([
        "conditionalProcessing",
        "core",
        "graphicalEvent",
        "presentation"
      ]),
      attrs: new Set([
        "class",
        "externalResourcesRequired",
        "points",
        "style",
        "transform"
      ]),
      contentGroups: new Set(["animation", "descriptive"])
    },
    radialGradient: {
      attrsGroups: new Set(["core", "presentation", "xlink"]),
      attrs: new Set([
        "class",
        "cx",
        "cy",
        "externalResourcesRequired",
        "fr",
        "fx",
        "fy",
        "gradientTransform",
        "gradientUnits",
        "href",
        "r",
        "spreadMethod",
        "style",
        "xlink:href"
      ]),
      defaults: {
        gradientUnits: "objectBoundingBox",
        cx: "50%",
        cy: "50%",
        r: "50%"
      },
      contentGroups: new Set(["descriptive"]),
      content: new Set(["animate", "animateTransform", "set", "stop"])
    },
    meshGradient: {
      attrsGroups: new Set(["core", "presentation", "xlink"]),
      attrs: new Set(["class", "style", "x", "y", "gradientUnits", "transform"]),
      contentGroups: new Set(["descriptive", "paintServer", "animation"]),
      content: new Set(["meshRow"])
    },
    meshRow: {
      attrsGroups: new Set(["core", "presentation"]),
      attrs: new Set(["class", "style"]),
      contentGroups: new Set(["descriptive"]),
      content: new Set(["meshPatch"])
    },
    meshPatch: {
      attrsGroups: new Set(["core", "presentation"]),
      attrs: new Set(["class", "style"]),
      contentGroups: new Set(["descriptive"]),
      content: new Set(["stop"])
    },
    rect: {
      attrsGroups: new Set([
        "conditionalProcessing",
        "core",
        "graphicalEvent",
        "presentation"
      ]),
      attrs: new Set([
        "class",
        "externalResourcesRequired",
        "height",
        "rx",
        "ry",
        "style",
        "transform",
        "width",
        "x",
        "y"
      ]),
      defaults: {
        x: "0",
        y: "0"
      },
      contentGroups: new Set(["animation", "descriptive"])
    },
    script: {
      attrsGroups: new Set(["core", "xlink"]),
      attrs: new Set(["externalResourcesRequired", "type", "href", "xlink:href"])
    },
    set: {
      attrsGroups: new Set([
        "animation",
        "animationAttributeTarget",
        "animationTiming",
        "conditionalProcessing",
        "core",
        "xlink"
      ]),
      attrs: new Set(["externalResourcesRequired", "to"]),
      contentGroups: new Set(["descriptive"])
    },
    solidColor: {
      attrsGroups: new Set(["core", "presentation"]),
      attrs: new Set(["class", "style"]),
      contentGroups: new Set(["paintServer"])
    },
    stop: {
      attrsGroups: new Set(["core", "presentation"]),
      attrs: new Set(["class", "style", "offset", "path"]),
      content: new Set(["animate", "animateColor", "set"])
    },
    style: {
      attrsGroups: new Set(["core"]),
      attrs: new Set(["type", "media", "title"]),
      defaults: {
        type: "text/css"
      }
    },
    svg: {
      attrsGroups: new Set([
        "conditionalProcessing",
        "core",
        "documentEvent",
        "graphicalEvent",
        "presentation"
      ]),
      attrs: new Set([
        "baseProfile",
        "class",
        "contentScriptType",
        "contentStyleType",
        "height",
        "preserveAspectRatio",
        "style",
        "version",
        "viewBox",
        "width",
        "x",
        "y",
        "zoomAndPan"
      ]),
      defaults: {
        x: "0",
        y: "0",
        width: "100%",
        height: "100%",
        preserveAspectRatio: "xMidYMid meet",
        zoomAndPan: "magnify",
        version: "1.1",
        baseProfile: "none",
        contentScriptType: "application/ecmascript",
        contentStyleType: "text/css"
      },
      contentGroups: new Set([
        "animation",
        "descriptive",
        "paintServer",
        "shape",
        "structural"
      ]),
      content: new Set([
        "a",
        "altGlyphDef",
        "clipPath",
        "color-profile",
        "cursor",
        "filter",
        "font-face",
        "font",
        "foreignObject",
        "image",
        "marker",
        "mask",
        "pattern",
        "script",
        "style",
        "switch",
        "text",
        "view"
      ])
    },
    switch: {
      attrsGroups: new Set([
        "conditionalProcessing",
        "core",
        "graphicalEvent",
        "presentation"
      ]),
      attrs: new Set([
        "class",
        "externalResourcesRequired",
        "style",
        "transform"
      ]),
      contentGroups: new Set(["animation", "descriptive", "shape"]),
      content: new Set([
        "a",
        "foreignObject",
        "g",
        "image",
        "svg",
        "switch",
        "text",
        "use"
      ])
    },
    symbol: {
      attrsGroups: new Set(["core", "graphicalEvent", "presentation"]),
      attrs: new Set([
        "class",
        "externalResourcesRequired",
        "preserveAspectRatio",
        "refX",
        "refY",
        "style",
        "viewBox"
      ]),
      defaults: {
        refX: "0",
        refY: "0"
      },
      contentGroups: new Set([
        "animation",
        "descriptive",
        "paintServer",
        "shape",
        "structural"
      ]),
      content: new Set([
        "a",
        "altGlyphDef",
        "clipPath",
        "color-profile",
        "cursor",
        "filter",
        "font-face",
        "font",
        "foreignObject",
        "image",
        "marker",
        "mask",
        "pattern",
        "script",
        "style",
        "switch",
        "text",
        "view"
      ])
    },
    text: {
      attrsGroups: new Set([
        "conditionalProcessing",
        "core",
        "graphicalEvent",
        "presentation"
      ]),
      attrs: new Set([
        "class",
        "dx",
        "dy",
        "externalResourcesRequired",
        "lengthAdjust",
        "rotate",
        "style",
        "textLength",
        "transform",
        "x",
        "y"
      ]),
      defaults: {
        x: "0",
        y: "0",
        lengthAdjust: "spacing"
      },
      contentGroups: new Set(["animation", "descriptive", "textContentChild"]),
      content: new Set(["a"])
    },
    textPath: {
      attrsGroups: new Set([
        "conditionalProcessing",
        "core",
        "graphicalEvent",
        "presentation",
        "xlink"
      ]),
      attrs: new Set([
        "class",
        "d",
        "externalResourcesRequired",
        "href",
        "method",
        "spacing",
        "startOffset",
        "style",
        "xlink:href"
      ]),
      defaults: {
        startOffset: "0",
        method: "align",
        spacing: "exact"
      },
      contentGroups: new Set(["descriptive"]),
      content: new Set([
        "a",
        "altGlyph",
        "animate",
        "animateColor",
        "set",
        "tref",
        "tspan"
      ])
    },
    title: {
      attrsGroups: new Set(["core"]),
      attrs: new Set(["class", "style"])
    },
    tref: {
      attrsGroups: new Set([
        "conditionalProcessing",
        "core",
        "graphicalEvent",
        "presentation",
        "xlink"
      ]),
      attrs: new Set([
        "class",
        "externalResourcesRequired",
        "href",
        "style",
        "xlink:href"
      ]),
      contentGroups: new Set(["descriptive"]),
      content: new Set(["animate", "animateColor", "set"])
    },
    tspan: {
      attrsGroups: new Set([
        "conditionalProcessing",
        "core",
        "graphicalEvent",
        "presentation"
      ]),
      attrs: new Set([
        "class",
        "dx",
        "dy",
        "externalResourcesRequired",
        "lengthAdjust",
        "rotate",
        "style",
        "textLength",
        "x",
        "y"
      ]),
      contentGroups: new Set(["descriptive"]),
      content: new Set([
        "a",
        "altGlyph",
        "animate",
        "animateColor",
        "set",
        "tref",
        "tspan"
      ])
    },
    use: {
      attrsGroups: new Set([
        "conditionalProcessing",
        "core",
        "graphicalEvent",
        "presentation",
        "xlink"
      ]),
      attrs: new Set([
        "class",
        "externalResourcesRequired",
        "height",
        "href",
        "style",
        "transform",
        "width",
        "x",
        "xlink:href",
        "y"
      ]),
      defaults: {
        x: "0",
        y: "0"
      },
      contentGroups: new Set(["animation", "descriptive"])
    },
    view: {
      attrsGroups: new Set(["core"]),
      attrs: new Set([
        "externalResourcesRequired",
        "preserveAspectRatio",
        "viewBox",
        "viewTarget",
        "zoomAndPan"
      ]),
      contentGroups: new Set(["descriptive"])
    },
    vkern: {
      attrsGroups: new Set(["core"]),
      attrs: new Set(["u1", "g1", "u2", "g2", "k"])
    }
  };
  exports.editorNamespaces = new Set([
    "http://creativecommons.org/ns#",
    "http://inkscape.sourceforge.net/DTD/sodipodi-0.dtd",
    "http://ns.adobe.com/AdobeIllustrator/10.0/",
    "http://ns.adobe.com/AdobeSVGViewerExtensions/3.0/",
    "http://ns.adobe.com/Extensibility/1.0/",
    "http://ns.adobe.com/Flows/1.0/",
    "http://ns.adobe.com/GenericCustomNamespace/1.0/",
    "http://ns.adobe.com/Graphs/1.0/",
    "http://ns.adobe.com/ImageReplacement/1.0/",
    "http://ns.adobe.com/SaveForWeb/1.0/",
    "http://ns.adobe.com/Variables/1.0/",
    "http://ns.adobe.com/XPath/1.0/",
    "http://purl.org/dc/elements/1.1/",
    "http://schemas.microsoft.com/visio/2003/SVGExtensions/",
    "http://sodipodi.sourceforge.net/DTD/sodipodi-0.dtd",
    "http://taptrix.com/vectorillustrator/svg_extensions",
    "http://www.bohemiancoding.com/sketch/ns",
    "http://www.figma.com/figma/ns",
    "http://www.inkscape.org/namespaces/inkscape",
    "http://www.serif.com/",
    "http://www.vector.evaxdesign.sk",
    "http://www.w3.org/1999/02/22-rdf-syntax-ns#"
  ]);
  exports.referencesProps = new Set([
    "clip-path",
    "color-profile",
    "fill",
    "filter",
    "marker-end",
    "marker-mid",
    "marker-start",
    "mask",
    "stroke",
    "style"
  ]);
  exports.inheritableAttrs = new Set([
    "clip-rule",
    "color-interpolation-filters",
    "color-interpolation",
    "color-profile",
    "color-rendering",
    "color",
    "cursor",
    "direction",
    "dominant-baseline",
    "fill-opacity",
    "fill-rule",
    "fill",
    "font-family",
    "font-size-adjust",
    "font-size",
    "font-stretch",
    "font-style",
    "font-variant",
    "font-weight",
    "font",
    "glyph-orientation-horizontal",
    "glyph-orientation-vertical",
    "image-rendering",
    "letter-spacing",
    "marker-end",
    "marker-mid",
    "marker-start",
    "marker",
    "paint-order",
    "pointer-events",
    "shape-rendering",
    "stroke-dasharray",
    "stroke-dashoffset",
    "stroke-linecap",
    "stroke-linejoin",
    "stroke-miterlimit",
    "stroke-opacity",
    "stroke-width",
    "stroke",
    "text-anchor",
    "text-rendering",
    "transform",
    "visibility",
    "word-spacing",
    "writing-mode"
  ]);
  exports.presentationNonInheritableGroupAttrs = new Set([
    "clip-path",
    "display",
    "filter",
    "mask",
    "opacity",
    "text-decoration",
    "transform",
    "unicode-bidi"
  ]);
  exports.colorsNames = {
    aliceblue: "#f0f8ff",
    antiquewhite: "#faebd7",
    aqua: "#0ff",
    aquamarine: "#7fffd4",
    azure: "#f0ffff",
    beige: "#f5f5dc",
    bisque: "#ffe4c4",
    black: "#000",
    blanchedalmond: "#ffebcd",
    blue: "#00f",
    blueviolet: "#8a2be2",
    brown: "#a52a2a",
    burlywood: "#deb887",
    cadetblue: "#5f9ea0",
    chartreuse: "#7fff00",
    chocolate: "#d2691e",
    coral: "#ff7f50",
    cornflowerblue: "#6495ed",
    cornsilk: "#fff8dc",
    crimson: "#dc143c",
    cyan: "#0ff",
    darkblue: "#00008b",
    darkcyan: "#008b8b",
    darkgoldenrod: "#b8860b",
    darkgray: "#a9a9a9",
    darkgreen: "#006400",
    darkgrey: "#a9a9a9",
    darkkhaki: "#bdb76b",
    darkmagenta: "#8b008b",
    darkolivegreen: "#556b2f",
    darkorange: "#ff8c00",
    darkorchid: "#9932cc",
    darkred: "#8b0000",
    darksalmon: "#e9967a",
    darkseagreen: "#8fbc8f",
    darkslateblue: "#483d8b",
    darkslategray: "#2f4f4f",
    darkslategrey: "#2f4f4f",
    darkturquoise: "#00ced1",
    darkviolet: "#9400d3",
    deeppink: "#ff1493",
    deepskyblue: "#00bfff",
    dimgray: "#696969",
    dimgrey: "#696969",
    dodgerblue: "#1e90ff",
    firebrick: "#b22222",
    floralwhite: "#fffaf0",
    forestgreen: "#228b22",
    fuchsia: "#f0f",
    gainsboro: "#dcdcdc",
    ghostwhite: "#f8f8ff",
    gold: "#ffd700",
    goldenrod: "#daa520",
    gray: "#808080",
    green: "#008000",
    greenyellow: "#adff2f",
    grey: "#808080",
    honeydew: "#f0fff0",
    hotpink: "#ff69b4",
    indianred: "#cd5c5c",
    indigo: "#4b0082",
    ivory: "#fffff0",
    khaki: "#f0e68c",
    lavender: "#e6e6fa",
    lavenderblush: "#fff0f5",
    lawngreen: "#7cfc00",
    lemonchiffon: "#fffacd",
    lightblue: "#add8e6",
    lightcoral: "#f08080",
    lightcyan: "#e0ffff",
    lightgoldenrodyellow: "#fafad2",
    lightgray: "#d3d3d3",
    lightgreen: "#90ee90",
    lightgrey: "#d3d3d3",
    lightpink: "#ffb6c1",
    lightsalmon: "#ffa07a",
    lightseagreen: "#20b2aa",
    lightskyblue: "#87cefa",
    lightslategray: "#789",
    lightslategrey: "#789",
    lightsteelblue: "#b0c4de",
    lightyellow: "#ffffe0",
    lime: "#0f0",
    limegreen: "#32cd32",
    linen: "#faf0e6",
    magenta: "#f0f",
    maroon: "#800000",
    mediumaquamarine: "#66cdaa",
    mediumblue: "#0000cd",
    mediumorchid: "#ba55d3",
    mediumpurple: "#9370db",
    mediumseagreen: "#3cb371",
    mediumslateblue: "#7b68ee",
    mediumspringgreen: "#00fa9a",
    mediumturquoise: "#48d1cc",
    mediumvioletred: "#c71585",
    midnightblue: "#191970",
    mintcream: "#f5fffa",
    mistyrose: "#ffe4e1",
    moccasin: "#ffe4b5",
    navajowhite: "#ffdead",
    navy: "#000080",
    oldlace: "#fdf5e6",
    olive: "#808000",
    olivedrab: "#6b8e23",
    orange: "#ffa500",
    orangered: "#ff4500",
    orchid: "#da70d6",
    palegoldenrod: "#eee8aa",
    palegreen: "#98fb98",
    paleturquoise: "#afeeee",
    palevioletred: "#db7093",
    papayawhip: "#ffefd5",
    peachpuff: "#ffdab9",
    peru: "#cd853f",
    pink: "#ffc0cb",
    plum: "#dda0dd",
    powderblue: "#b0e0e6",
    purple: "#800080",
    rebeccapurple: "#639",
    red: "#f00",
    rosybrown: "#bc8f8f",
    royalblue: "#4169e1",
    saddlebrown: "#8b4513",
    salmon: "#fa8072",
    sandybrown: "#f4a460",
    seagreen: "#2e8b57",
    seashell: "#fff5ee",
    sienna: "#a0522d",
    silver: "#c0c0c0",
    skyblue: "#87ceeb",
    slateblue: "#6a5acd",
    slategray: "#708090",
    slategrey: "#708090",
    snow: "#fffafa",
    springgreen: "#00ff7f",
    steelblue: "#4682b4",
    tan: "#d2b48c",
    teal: "#008080",
    thistle: "#d8bfd8",
    tomato: "#ff6347",
    turquoise: "#40e0d0",
    violet: "#ee82ee",
    wheat: "#f5deb3",
    white: "#fff",
    whitesmoke: "#f5f5f5",
    yellow: "#ff0",
    yellowgreen: "#9acd32"
  };
  exports.colorsShortNames = {
    "#f0ffff": "azure",
    "#f5f5dc": "beige",
    "#ffe4c4": "bisque",
    "#a52a2a": "brown",
    "#ff7f50": "coral",
    "#ffd700": "gold",
    "#808080": "gray",
    "#008000": "green",
    "#4b0082": "indigo",
    "#fffff0": "ivory",
    "#f0e68c": "khaki",
    "#faf0e6": "linen",
    "#800000": "maroon",
    "#000080": "navy",
    "#808000": "olive",
    "#ffa500": "orange",
    "#da70d6": "orchid",
    "#cd853f": "peru",
    "#ffc0cb": "pink",
    "#dda0dd": "plum",
    "#800080": "purple",
    "#f00": "red",
    "#ff0000": "red",
    "#fa8072": "salmon",
    "#a0522d": "sienna",
    "#c0c0c0": "silver",
    "#fffafa": "snow",
    "#d2b48c": "tan",
    "#008080": "teal",
    "#ff6347": "tomato",
    "#ee82ee": "violet",
    "#f5deb3": "wheat"
  };
  exports.colorsProps = new Set([
    "color",
    "fill",
    "flood-color",
    "lighting-color",
    "stop-color",
    "stroke"
  ]);
  exports.pseudoClasses = {
    displayState: new Set(["fullscreen", "modal", "picture-in-picture"]),
    input: new Set([
      "autofill",
      "blank",
      "checked",
      "default",
      "disabled",
      "enabled",
      "in-range",
      "indetermined",
      "invalid",
      "optional",
      "out-of-range",
      "placeholder-shown",
      "read-only",
      "read-write",
      "required",
      "user-invalid",
      "valid"
    ]),
    linguistic: new Set(["dir", "lang"]),
    location: new Set([
      "any-link",
      "link",
      "local-link",
      "scope",
      "target-within",
      "target",
      "visited"
    ]),
    resourceState: new Set(["playing", "paused"]),
    timeDimensional: new Set(["current", "past", "future"]),
    treeStructural: new Set([
      "empty",
      "first-child",
      "first-of-type",
      "last-child",
      "last-of-type",
      "nth-child",
      "nth-last-child",
      "nth-last-of-type",
      "nth-of-type",
      "only-child",
      "only-of-type",
      "root"
    ]),
    userAction: new Set([
      "active",
      "focus-visible",
      "focus-within",
      "focus",
      "hover"
    ]),
    functional: new Set(["is", "not", "where", "has"])
  };
});

// ../../../../node_modules/.bun/svgo@3.3.2/node_modules/svgo/lib/parser.js
var require_parser = __commonJS((exports) => {
  var SAX = require_sax();
  var { textElems } = require__collections();

  class SvgoParserError extends Error {
    constructor(message, line, column, source, file) {
      super(message);
      this.name = "SvgoParserError";
      this.message = `${file || "<input>"}:${line}:${column}: ${message}`;
      this.reason = message;
      this.line = line;
      this.column = column;
      this.source = source;
      if (Error.captureStackTrace) {
        Error.captureStackTrace(this, SvgoParserError);
      }
    }
    toString() {
      const lines = this.source.split(/\r?\n/);
      const startLine = Math.max(this.line - 3, 0);
      const endLine = Math.min(this.line + 2, lines.length);
      const lineNumberWidth = String(endLine).length;
      const startColumn = Math.max(this.column - 54, 0);
      const endColumn = Math.max(this.column + 20, 80);
      const code = lines.slice(startLine, endLine).map((line, index) => {
        const lineSlice = line.slice(startColumn, endColumn);
        let ellipsisPrefix = "";
        let ellipsisSuffix = "";
        if (startColumn !== 0) {
          ellipsisPrefix = startColumn > line.length - 1 ? " " : "";
        }
        if (endColumn < line.length - 1) {
          ellipsisSuffix = "";
        }
        const number = startLine + 1 + index;
        const gutter = ` ${number.toString().padStart(lineNumberWidth)} | `;
        if (number === this.line) {
          const gutterSpacing = gutter.replace(/[^|]/g, " ");
          const lineSpacing = (ellipsisPrefix + line.slice(startColumn, this.column - 1)).replace(/[^\t]/g, " ");
          const spacing = gutterSpacing + lineSpacing;
          return `>${gutter}${ellipsisPrefix}${lineSlice}${ellipsisSuffix}
 ${spacing}^`;
        }
        return ` ${gutter}${ellipsisPrefix}${lineSlice}${ellipsisSuffix}`;
      }).join(`
`);
      return `${this.name}: ${this.message}

${code}
`;
    }
  }
  var entityDeclaration = /<!ENTITY\s+(\S+)\s+(?:'([^']+)'|"([^"]+)")\s*>/g;
  var config = {
    strict: true,
    trim: false,
    normalize: false,
    lowercase: true,
    xmlns: true,
    position: true
  };
  var parseSvg = (data, from) => {
    const sax = SAX.parser(config.strict, config);
    const root = { type: "root", children: [] };
    let current = root;
    const stack = [root];
    const pushToContent = (node) => {
      Object.defineProperty(node, "parentNode", {
        writable: true,
        value: current
      });
      current.children.push(node);
    };
    sax.ondoctype = (doctype) => {
      const node = {
        type: "doctype",
        name: "svg",
        data: {
          doctype
        }
      };
      pushToContent(node);
      const subsetStart = doctype.indexOf("[");
      if (subsetStart >= 0) {
        entityDeclaration.lastIndex = subsetStart;
        let entityMatch = entityDeclaration.exec(data);
        while (entityMatch != null) {
          sax.ENTITIES[entityMatch[1]] = entityMatch[2] || entityMatch[3];
          entityMatch = entityDeclaration.exec(data);
        }
      }
    };
    sax.onprocessinginstruction = (data2) => {
      const node = {
        type: "instruction",
        name: data2.name,
        value: data2.body
      };
      pushToContent(node);
    };
    sax.oncomment = (comment) => {
      const node = {
        type: "comment",
        value: comment.trim()
      };
      pushToContent(node);
    };
    sax.oncdata = (cdata) => {
      const node = {
        type: "cdata",
        value: cdata
      };
      pushToContent(node);
    };
    sax.onopentag = (data2) => {
      let element = {
        type: "element",
        name: data2.name,
        attributes: {},
        children: []
      };
      for (const [name, attr] of Object.entries(data2.attributes)) {
        element.attributes[name] = attr.value;
      }
      pushToContent(element);
      current = element;
      stack.push(element);
    };
    sax.ontext = (text) => {
      if (current.type === "element") {
        if (textElems.has(current.name)) {
          const node = {
            type: "text",
            value: text
          };
          pushToContent(node);
        } else if (/\S/.test(text)) {
          const node = {
            type: "text",
            value: text.trim()
          };
          pushToContent(node);
        }
      }
    };
    sax.onclosetag = () => {
      stack.pop();
      current = stack[stack.length - 1];
    };
    sax.onerror = (e) => {
      const error = new SvgoParserError(e.reason, e.line + 1, e.column, data, from);
      if (e.message.indexOf("Unexpected end") === -1) {
        throw error;
      }
    };
    sax.write(data).close();
    return root;
  };
  exports.parseSvg = parseSvg;
});

// ../../../../node_modules/.bun/svgo@3.3.2/node_modules/svgo/lib/stringifier.js
var require_stringifier = __commonJS((exports) => {
  var { textElems } = require__collections();
  var encodeEntity = (char) => {
    return entities[char];
  };
  var defaults = {
    doctypeStart: "<!DOCTYPE",
    doctypeEnd: ">",
    procInstStart: "<?",
    procInstEnd: "?>",
    tagOpenStart: "<",
    tagOpenEnd: ">",
    tagCloseStart: "</",
    tagCloseEnd: ">",
    tagShortStart: "<",
    tagShortEnd: "/>",
    attrStart: '="',
    attrEnd: '"',
    commentStart: "<!--",
    commentEnd: "-->",
    cdataStart: "<![CDATA[",
    cdataEnd: "]]>",
    textStart: "",
    textEnd: "",
    indent: 4,
    regEntities: /[&'"<>]/g,
    regValEntities: /[&"<>]/g,
    encodeEntity,
    pretty: false,
    useShortTags: true,
    eol: "lf",
    finalNewline: false
  };
  var entities = {
    "&": "&amp;",
    "'": "&apos;",
    '"': "&quot;",
    ">": "&gt;",
    "<": "&lt;"
  };
  var stringifySvg = (data, userOptions = {}) => {
    const config = { ...defaults, ...userOptions };
    const indent = config.indent;
    let newIndent = "    ";
    if (typeof indent === "number" && Number.isNaN(indent) === false) {
      newIndent = indent < 0 ? "\t" : " ".repeat(indent);
    } else if (typeof indent === "string") {
      newIndent = indent;
    }
    const state = {
      indent: newIndent,
      textContext: null,
      indentLevel: 0
    };
    const eol = config.eol === "crlf" ? `\r
` : `
`;
    if (config.pretty) {
      config.doctypeEnd += eol;
      config.procInstEnd += eol;
      config.commentEnd += eol;
      config.cdataEnd += eol;
      config.tagShortEnd += eol;
      config.tagOpenEnd += eol;
      config.tagCloseEnd += eol;
      config.textEnd += eol;
    }
    let svg = stringifyNode(data, config, state);
    if (config.finalNewline && svg.length > 0 && !svg.endsWith(`
`)) {
      svg += eol;
    }
    return svg;
  };
  exports.stringifySvg = stringifySvg;
  var stringifyNode = (data, config, state) => {
    let svg = "";
    state.indentLevel += 1;
    for (const item of data.children) {
      if (item.type === "element") {
        svg += stringifyElement(item, config, state);
      }
      if (item.type === "text") {
        svg += stringifyText(item, config, state);
      }
      if (item.type === "doctype") {
        svg += stringifyDoctype(item, config);
      }
      if (item.type === "instruction") {
        svg += stringifyInstruction(item, config);
      }
      if (item.type === "comment") {
        svg += stringifyComment(item, config);
      }
      if (item.type === "cdata") {
        svg += stringifyCdata(item, config, state);
      }
    }
    state.indentLevel -= 1;
    return svg;
  };
  var createIndent = (config, state) => {
    let indent = "";
    if (config.pretty && state.textContext == null) {
      indent = state.indent.repeat(state.indentLevel - 1);
    }
    return indent;
  };
  var stringifyDoctype = (node, config) => {
    return config.doctypeStart + node.data.doctype + config.doctypeEnd;
  };
  var stringifyInstruction = (node, config) => {
    return config.procInstStart + node.name + " " + node.value + config.procInstEnd;
  };
  var stringifyComment = (node, config) => {
    return config.commentStart + node.value + config.commentEnd;
  };
  var stringifyCdata = (node, config, state) => {
    return createIndent(config, state) + config.cdataStart + node.value + config.cdataEnd;
  };
  var stringifyElement = (node, config, state) => {
    if (node.children.length === 0) {
      if (config.useShortTags) {
        return createIndent(config, state) + config.tagShortStart + node.name + stringifyAttributes(node, config) + config.tagShortEnd;
      } else {
        return createIndent(config, state) + config.tagShortStart + node.name + stringifyAttributes(node, config) + config.tagOpenEnd + config.tagCloseStart + node.name + config.tagCloseEnd;
      }
    } else {
      let tagOpenStart = config.tagOpenStart;
      let tagOpenEnd = config.tagOpenEnd;
      let tagCloseStart = config.tagCloseStart;
      let tagCloseEnd = config.tagCloseEnd;
      let openIndent = createIndent(config, state);
      let closeIndent = createIndent(config, state);
      if (state.textContext) {
        tagOpenStart = defaults.tagOpenStart;
        tagOpenEnd = defaults.tagOpenEnd;
        tagCloseStart = defaults.tagCloseStart;
        tagCloseEnd = defaults.tagCloseEnd;
        openIndent = "";
      } else if (textElems.has(node.name)) {
        tagOpenEnd = defaults.tagOpenEnd;
        tagCloseStart = defaults.tagCloseStart;
        closeIndent = "";
        state.textContext = node;
      }
      const children = stringifyNode(node, config, state);
      if (state.textContext === node) {
        state.textContext = null;
      }
      return openIndent + tagOpenStart + node.name + stringifyAttributes(node, config) + tagOpenEnd + children + closeIndent + tagCloseStart + node.name + tagCloseEnd;
    }
  };
  var stringifyAttributes = (node, config) => {
    let attrs = "";
    for (const [name, value] of Object.entries(node.attributes)) {
      if (value !== undefined) {
        const encodedValue = value.toString().replace(config.regValEntities, config.encodeEntity);
        attrs += " " + name + config.attrStart + encodedValue + config.attrEnd;
      } else {
        attrs += " " + name;
      }
    }
    return attrs;
  };
  var stringifyText = (node, config, state) => {
    return createIndent(config, state) + config.textStart + node.value.replace(config.regEntities, config.encodeEntity) + (state.textContext ? "" : config.textEnd);
  };
});

// ../../../../node_modules/.bun/domelementtype@2.3.0/node_modules/domelementtype/lib/index.js
var require_lib = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.Doctype = exports.CDATA = exports.Tag = exports.Style = exports.Script = exports.Comment = exports.Directive = exports.Text = exports.Root = exports.isTag = exports.ElementType = undefined;
  var ElementType;
  (function(ElementType2) {
    ElementType2["Root"] = "root";
    ElementType2["Text"] = "text";
    ElementType2["Directive"] = "directive";
    ElementType2["Comment"] = "comment";
    ElementType2["Script"] = "script";
    ElementType2["Style"] = "style";
    ElementType2["Tag"] = "tag";
    ElementType2["CDATA"] = "cdata";
    ElementType2["Doctype"] = "doctype";
  })(ElementType = exports.ElementType || (exports.ElementType = {}));
  function isTag(elem) {
    return elem.type === ElementType.Tag || elem.type === ElementType.Script || elem.type === ElementType.Style;
  }
  exports.isTag = isTag;
  exports.Root = ElementType.Root;
  exports.Text = ElementType.Text;
  exports.Directive = ElementType.Directive;
  exports.Comment = ElementType.Comment;
  exports.Script = ElementType.Script;
  exports.Style = ElementType.Style;
  exports.Tag = ElementType.Tag;
  exports.CDATA = ElementType.CDATA;
  exports.Doctype = ElementType.Doctype;
});

// ../../../../node_modules/.bun/domhandler@5.0.3/node_modules/domhandler/lib/node.js
var require_node = __commonJS((exports) => {
  var __extends = exports && exports.__extends || function() {
    var extendStatics = function(d, b) {
      extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
        d2.__proto__ = b2;
      } || function(d2, b2) {
        for (var p in b2)
          if (Object.prototype.hasOwnProperty.call(b2, p))
            d2[p] = b2[p];
      };
      return extendStatics(d, b);
    };
    return function(d, b) {
      if (typeof b !== "function" && b !== null)
        throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
      extendStatics(d, b);
      function __() {
        this.constructor = d;
      }
      d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __);
    };
  }();
  var __assign = exports && exports.__assign || function() {
    __assign = Object.assign || function(t) {
      for (var s, i = 1, n = arguments.length;i < n; i++) {
        s = arguments[i];
        for (var p in s)
          if (Object.prototype.hasOwnProperty.call(s, p))
            t[p] = s[p];
      }
      return t;
    };
    return __assign.apply(this, arguments);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.cloneNode = exports.hasChildren = exports.isDocument = exports.isDirective = exports.isComment = exports.isText = exports.isCDATA = exports.isTag = exports.Element = exports.Document = exports.CDATA = exports.NodeWithChildren = exports.ProcessingInstruction = exports.Comment = exports.Text = exports.DataNode = exports.Node = undefined;
  var domelementtype_1 = require_lib();
  var Node = function() {
    function Node2() {
      this.parent = null;
      this.prev = null;
      this.next = null;
      this.startIndex = null;
      this.endIndex = null;
    }
    Object.defineProperty(Node2.prototype, "parentNode", {
      get: function() {
        return this.parent;
      },
      set: function(parent) {
        this.parent = parent;
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(Node2.prototype, "previousSibling", {
      get: function() {
        return this.prev;
      },
      set: function(prev) {
        this.prev = prev;
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(Node2.prototype, "nextSibling", {
      get: function() {
        return this.next;
      },
      set: function(next) {
        this.next = next;
      },
      enumerable: false,
      configurable: true
    });
    Node2.prototype.cloneNode = function(recursive) {
      if (recursive === undefined) {
        recursive = false;
      }
      return cloneNode(this, recursive);
    };
    return Node2;
  }();
  exports.Node = Node;
  var DataNode = function(_super) {
    __extends(DataNode2, _super);
    function DataNode2(data) {
      var _this = _super.call(this) || this;
      _this.data = data;
      return _this;
    }
    Object.defineProperty(DataNode2.prototype, "nodeValue", {
      get: function() {
        return this.data;
      },
      set: function(data) {
        this.data = data;
      },
      enumerable: false,
      configurable: true
    });
    return DataNode2;
  }(Node);
  exports.DataNode = DataNode;
  var Text = function(_super) {
    __extends(Text2, _super);
    function Text2() {
      var _this = _super !== null && _super.apply(this, arguments) || this;
      _this.type = domelementtype_1.ElementType.Text;
      return _this;
    }
    Object.defineProperty(Text2.prototype, "nodeType", {
      get: function() {
        return 3;
      },
      enumerable: false,
      configurable: true
    });
    return Text2;
  }(DataNode);
  exports.Text = Text;
  var Comment = function(_super) {
    __extends(Comment2, _super);
    function Comment2() {
      var _this = _super !== null && _super.apply(this, arguments) || this;
      _this.type = domelementtype_1.ElementType.Comment;
      return _this;
    }
    Object.defineProperty(Comment2.prototype, "nodeType", {
      get: function() {
        return 8;
      },
      enumerable: false,
      configurable: true
    });
    return Comment2;
  }(DataNode);
  exports.Comment = Comment;
  var ProcessingInstruction = function(_super) {
    __extends(ProcessingInstruction2, _super);
    function ProcessingInstruction2(name, data) {
      var _this = _super.call(this, data) || this;
      _this.name = name;
      _this.type = domelementtype_1.ElementType.Directive;
      return _this;
    }
    Object.defineProperty(ProcessingInstruction2.prototype, "nodeType", {
      get: function() {
        return 1;
      },
      enumerable: false,
      configurable: true
    });
    return ProcessingInstruction2;
  }(DataNode);
  exports.ProcessingInstruction = ProcessingInstruction;
  var NodeWithChildren = function(_super) {
    __extends(NodeWithChildren2, _super);
    function NodeWithChildren2(children) {
      var _this = _super.call(this) || this;
      _this.children = children;
      return _this;
    }
    Object.defineProperty(NodeWithChildren2.prototype, "firstChild", {
      get: function() {
        var _a;
        return (_a = this.children[0]) !== null && _a !== undefined ? _a : null;
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(NodeWithChildren2.prototype, "lastChild", {
      get: function() {
        return this.children.length > 0 ? this.children[this.children.length - 1] : null;
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(NodeWithChildren2.prototype, "childNodes", {
      get: function() {
        return this.children;
      },
      set: function(children) {
        this.children = children;
      },
      enumerable: false,
      configurable: true
    });
    return NodeWithChildren2;
  }(Node);
  exports.NodeWithChildren = NodeWithChildren;
  var CDATA = function(_super) {
    __extends(CDATA2, _super);
    function CDATA2() {
      var _this = _super !== null && _super.apply(this, arguments) || this;
      _this.type = domelementtype_1.ElementType.CDATA;
      return _this;
    }
    Object.defineProperty(CDATA2.prototype, "nodeType", {
      get: function() {
        return 4;
      },
      enumerable: false,
      configurable: true
    });
    return CDATA2;
  }(NodeWithChildren);
  exports.CDATA = CDATA;
  var Document = function(_super) {
    __extends(Document2, _super);
    function Document2() {
      var _this = _super !== null && _super.apply(this, arguments) || this;
      _this.type = domelementtype_1.ElementType.Root;
      return _this;
    }
    Object.defineProperty(Document2.prototype, "nodeType", {
      get: function() {
        return 9;
      },
      enumerable: false,
      configurable: true
    });
    return Document2;
  }(NodeWithChildren);
  exports.Document = Document;
  var Element = function(_super) {
    __extends(Element2, _super);
    function Element2(name, attribs, children, type) {
      if (children === undefined) {
        children = [];
      }
      if (type === undefined) {
        type = name === "script" ? domelementtype_1.ElementType.Script : name === "style" ? domelementtype_1.ElementType.Style : domelementtype_1.ElementType.Tag;
      }
      var _this = _super.call(this, children) || this;
      _this.name = name;
      _this.attribs = attribs;
      _this.type = type;
      return _this;
    }
    Object.defineProperty(Element2.prototype, "nodeType", {
      get: function() {
        return 1;
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(Element2.prototype, "tagName", {
      get: function() {
        return this.name;
      },
      set: function(name) {
        this.name = name;
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(Element2.prototype, "attributes", {
      get: function() {
        var _this = this;
        return Object.keys(this.attribs).map(function(name) {
          var _a, _b;
          return {
            name,
            value: _this.attribs[name],
            namespace: (_a = _this["x-attribsNamespace"]) === null || _a === undefined ? undefined : _a[name],
            prefix: (_b = _this["x-attribsPrefix"]) === null || _b === undefined ? undefined : _b[name]
          };
        });
      },
      enumerable: false,
      configurable: true
    });
    return Element2;
  }(NodeWithChildren);
  exports.Element = Element;
  function isTag(node) {
    return (0, domelementtype_1.isTag)(node);
  }
  exports.isTag = isTag;
  function isCDATA(node) {
    return node.type === domelementtype_1.ElementType.CDATA;
  }
  exports.isCDATA = isCDATA;
  function isText(node) {
    return node.type === domelementtype_1.ElementType.Text;
  }
  exports.isText = isText;
  function isComment(node) {
    return node.type === domelementtype_1.ElementType.Comment;
  }
  exports.isComment = isComment;
  function isDirective(node) {
    return node.type === domelementtype_1.ElementType.Directive;
  }
  exports.isDirective = isDirective;
  function isDocument(node) {
    return node.type === domelementtype_1.ElementType.Root;
  }
  exports.isDocument = isDocument;
  function hasChildren(node) {
    return Object.prototype.hasOwnProperty.call(node, "children");
  }
  exports.hasChildren = hasChildren;
  function cloneNode(node, recursive) {
    if (recursive === undefined) {
      recursive = false;
    }
    var result;
    if (isText(node)) {
      result = new Text(node.data);
    } else if (isComment(node)) {
      result = new Comment(node.data);
    } else if (isTag(node)) {
      var children = recursive ? cloneChildren(node.children) : [];
      var clone_1 = new Element(node.name, __assign({}, node.attribs), children);
      children.forEach(function(child) {
        return child.parent = clone_1;
      });
      if (node.namespace != null) {
        clone_1.namespace = node.namespace;
      }
      if (node["x-attribsNamespace"]) {
        clone_1["x-attribsNamespace"] = __assign({}, node["x-attribsNamespace"]);
      }
      if (node["x-attribsPrefix"]) {
        clone_1["x-attribsPrefix"] = __assign({}, node["x-attribsPrefix"]);
      }
      result = clone_1;
    } else if (isCDATA(node)) {
      var children = recursive ? cloneChildren(node.children) : [];
      var clone_2 = new CDATA(children);
      children.forEach(function(child) {
        return child.parent = clone_2;
      });
      result = clone_2;
    } else if (isDocument(node)) {
      var children = recursive ? cloneChildren(node.children) : [];
      var clone_3 = new Document(children);
      children.forEach(function(child) {
        return child.parent = clone_3;
      });
      if (node["x-mode"]) {
        clone_3["x-mode"] = node["x-mode"];
      }
      result = clone_3;
    } else if (isDirective(node)) {
      var instruction = new ProcessingInstruction(node.name, node.data);
      if (node["x-name"] != null) {
        instruction["x-name"] = node["x-name"];
        instruction["x-publicId"] = node["x-publicId"];
        instruction["x-systemId"] = node["x-systemId"];
      }
      result = instruction;
    } else {
      throw new Error("Not implemented yet: ".concat(node.type));
    }
    result.startIndex = node.startIndex;
    result.endIndex = node.endIndex;
    if (node.sourceCodeLocation != null) {
      result.sourceCodeLocation = node.sourceCodeLocation;
    }
    return result;
  }
  exports.cloneNode = cloneNode;
  function cloneChildren(childs) {
    var children = childs.map(function(child) {
      return cloneNode(child, true);
    });
    for (var i = 1;i < children.length; i++) {
      children[i].prev = children[i - 1];
      children[i - 1].next = children[i];
    }
    return children;
  }
});

// ../../../../node_modules/.bun/domhandler@5.0.3/node_modules/domhandler/lib/index.js
var require_lib2 = __commonJS((exports) => {
  var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() {
        return m[k];
      } };
    }
    Object.defineProperty(o, k2, desc);
  } : function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    o[k2] = m[k];
  });
  var __exportStar = exports && exports.__exportStar || function(m, exports2) {
    for (var p in m)
      if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p))
        __createBinding(exports2, m, p);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.DomHandler = undefined;
  var domelementtype_1 = require_lib();
  var node_js_1 = require_node();
  __exportStar(require_node(), exports);
  var defaultOpts = {
    withStartIndices: false,
    withEndIndices: false,
    xmlMode: false
  };
  var DomHandler = function() {
    function DomHandler2(callback, options, elementCB) {
      this.dom = [];
      this.root = new node_js_1.Document(this.dom);
      this.done = false;
      this.tagStack = [this.root];
      this.lastNode = null;
      this.parser = null;
      if (typeof options === "function") {
        elementCB = options;
        options = defaultOpts;
      }
      if (typeof callback === "object") {
        options = callback;
        callback = undefined;
      }
      this.callback = callback !== null && callback !== undefined ? callback : null;
      this.options = options !== null && options !== undefined ? options : defaultOpts;
      this.elementCB = elementCB !== null && elementCB !== undefined ? elementCB : null;
    }
    DomHandler2.prototype.onparserinit = function(parser) {
      this.parser = parser;
    };
    DomHandler2.prototype.onreset = function() {
      this.dom = [];
      this.root = new node_js_1.Document(this.dom);
      this.done = false;
      this.tagStack = [this.root];
      this.lastNode = null;
      this.parser = null;
    };
    DomHandler2.prototype.onend = function() {
      if (this.done)
        return;
      this.done = true;
      this.parser = null;
      this.handleCallback(null);
    };
    DomHandler2.prototype.onerror = function(error) {
      this.handleCallback(error);
    };
    DomHandler2.prototype.onclosetag = function() {
      this.lastNode = null;
      var elem = this.tagStack.pop();
      if (this.options.withEndIndices) {
        elem.endIndex = this.parser.endIndex;
      }
      if (this.elementCB)
        this.elementCB(elem);
    };
    DomHandler2.prototype.onopentag = function(name, attribs) {
      var type = this.options.xmlMode ? domelementtype_1.ElementType.Tag : undefined;
      var element = new node_js_1.Element(name, attribs, undefined, type);
      this.addNode(element);
      this.tagStack.push(element);
    };
    DomHandler2.prototype.ontext = function(data) {
      var lastNode = this.lastNode;
      if (lastNode && lastNode.type === domelementtype_1.ElementType.Text) {
        lastNode.data += data;
        if (this.options.withEndIndices) {
          lastNode.endIndex = this.parser.endIndex;
        }
      } else {
        var node = new node_js_1.Text(data);
        this.addNode(node);
        this.lastNode = node;
      }
    };
    DomHandler2.prototype.oncomment = function(data) {
      if (this.lastNode && this.lastNode.type === domelementtype_1.ElementType.Comment) {
        this.lastNode.data += data;
        return;
      }
      var node = new node_js_1.Comment(data);
      this.addNode(node);
      this.lastNode = node;
    };
    DomHandler2.prototype.oncommentend = function() {
      this.lastNode = null;
    };
    DomHandler2.prototype.oncdatastart = function() {
      var text = new node_js_1.Text("");
      var node = new node_js_1.CDATA([text]);
      this.addNode(node);
      text.parent = node;
      this.lastNode = text;
    };
    DomHandler2.prototype.oncdataend = function() {
      this.lastNode = null;
    };
    DomHandler2.prototype.onprocessinginstruction = function(name, data) {
      var node = new node_js_1.ProcessingInstruction(name, data);
      this.addNode(node);
    };
    DomHandler2.prototype.handleCallback = function(error) {
      if (typeof this.callback === "function") {
        this.callback(error, this.dom);
      } else if (error) {
        throw error;
      }
    };
    DomHandler2.prototype.addNode = function(node) {
      var parent = this.tagStack[this.tagStack.length - 1];
      var previousSibling = parent.children[parent.children.length - 1];
      if (this.options.withStartIndices) {
        node.startIndex = this.parser.startIndex;
      }
      if (this.options.withEndIndices) {
        node.endIndex = this.parser.endIndex;
      }
      parent.children.push(node);
      if (previousSibling) {
        node.prev = previousSibling;
        previousSibling.next = node;
      }
      node.parent = parent;
      this.lastNode = null;
    };
    return DomHandler2;
  }();
  exports.DomHandler = DomHandler;
  exports.default = DomHandler;
});

// ../../../../node_modules/.bun/entities@4.5.0/node_modules/entities/lib/generated/decode-data-html.js
var require_decode_data_html = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.default = new Uint16Array("<\x00\x00\x00\x00\x00\x00EMabcfglmnoprstu\\bfmsligP&cutereve;iyx}rc;r;\uD835\uDD04ravepha;acr;d;gpon;f;\uD835\uDD38plyFunction;ingcsr;\uD835\uDC9Cign;ildemlaceforsucrkslash;;ed;y;crtause;noullis;a;r;\uD835\uDD05pf;\uD835\uDD39eve;cmpeq;HOacdefhilorsucy;PYcpyute;;italDifferentialD;leys;aeioron;dilrc;nint;ot;dnilla;terDot;i;rcleDMPTot;inus;lus;imes;ocskwiseContourIntegral;eCurlyDQoubleQuote;uote;lnpuon;e;gitruent;nt;ourIntegral;fr;oduct;nterClockwiseContourIntegral;oss;cr;\uD835\uDC9Ep;Cap;DJSZacefios;otrahd;cy;cy;cy;grsger;r;hv;ayron;;l;ta;r;\uD835\uDD07afcmriticalADGTcute;o;bleAcute;rave;ilde;ond;ferentialD;\x00\x00\x00\x00f;\uD835\uDD3B;DEot;qual;bleCDLRUVontourIntegrao\x00\x00nArrow;eoftARTrrow;ightArrow;engLReftARrrow;ightArrow;ightArrow;ightATrrow;ee;p\x00\x00rrow;ownArrow;erticalBar;nABLRTarrow;BUar;pArrow;reve;eft\x00\x00ightVector;eeVector;ector;Bar;ight\x00eeVector;ector;Bar;ee;Arrow;ctr;\uD835\uDC9Frok;NTacdfglmopqstuxG;Hcuteaiyron;rc;ot;r;\uD835\uDD08raveement;apcr;ty\x00\x00mallSquare;erySmallSquare;gpon;f;\uD835\uDD3Csilon;uail;Tilde;librium;cir;m;a;mlipsts;onentialE;cfiosy;r;\uD835\uDD09lled\x00\x00mallSquare;erySmallSquare;\x00\x00\x00f;\uD835\uDD3DAll;riertrf;cJTabcdfgorstcy;>mma;d;reve;eiydil;rc;;ot;r;\uD835\uDD0A;pf;\uD835\uDD3EeaterEFGLSTqual;Less;ullEqual;reater;ess;lantEqual;ilde;cr;\uD835\uDCA2;AacfiosuRDcy;ctek;;irc;r;lbertSpace;\x00f;izontalLine;ctrok;mpownHumqual;EJOacdfgmnostucy;lig;cy;cuteiyrc;ot;r;rave;apcgr;inaryI;lie\x00;egrral;section;isibleCTomma;imes;gpton;f;\uD835\uDD40a;cr;ilde;\x00cy;lcfosuiyrc;;r;\uD835\uDD0Dpf;\uD835\uDD41\x00r;\uD835\uDCA5rcy;kcy;HJacfoscy;cy;ppa;eydil;;r;\uD835\uDD0Epf;\uD835\uDD42cr;\uD835\uDCA6JTaceflmostcy;<cmnprute;bda;g;lacetrf;r;aeyron;dil;;fstACDFRTUVarnrgleBracket;row;BRar;ightArrow;eiling;o\x00bleBracket;n\x00eeVector;ector;Bar;loor;ightAVrrow;ector;ere;AVrrow;ector;iangle;BEar;qual;pDTVownVector;eeVector;ector;Bar;ector;Bar;ightsEFGLSTqualGreater;ullEqual;reater;ess;lantEqual;ilde;r;\uD835\uDD0F;eftarrow;idot;npwgLRlreftARrrow;ightArrow;ightArrow;eftarightightf;\uD835\uDD43erLReftArrow;ightArrow;cht;rok;;acefiosup;y;dliumSpace;lintrf;r;\uD835\uDD10nusPlus;pf;\uD835\uDD44c;Jacefostucy;cute;aeyron;dil;;gswativeMTVediumSpace;hicneryThitedGLreaterGreateessLesLine;r;\uD835\uDD11Bnptreak;BreakingSpace;f;;CDEGHLNPRSTVoungruent;pCap;oubleVerticalBar;lqxement;ual;Tilde;ists;reater;EFGLSTqual;ullEqual;reater;ess;lantEqual;ilde;umpownHump;qual;efstTriangle;BEar;qual;s;EGLSTqual;reater;ess;lantEqual;ilde;estedGLreaterGreater;essLess;recedes;ESqual;lantEqual;eiverseElement;ghtTriangle;BEar;qual;quuareSubpset;Equal;erset;Equal;bcpset;Equal;ceeds;ESTqual;lantEqual;ilde;erset;Equal;ilde;EFTqual;ullEqual;ilde;erticalBar;cr;\uD835\uDCA9ilde;Eacdfgmoprstuvlig;cuteiyrc;blac;r;\uD835\uDD12raveaeicr;ga;cron;pf;\uD835\uDD46enCurlyDQoubleQuote;uote;;clr;\uD835\uDCAAashidees;mlerBParr;acek;et;arenthesis;acfhilorsrtialD;y;r;\uD835\uDD13i;;usMinus;ipncareplanf;;eiocedes;ESTqual;lantEqual;ilde;me;dpuct;ortion;al;cir;\uD835\uDCAB;UfosOT\"r;\uD835\uDD14pf;cr;\uD835\uDCACBEacefhiorsuarr;Gcnrute;g;r;tl;aeyron;dil;;;verseEUlqement;uilibrium;pEquilibrium;ro;ghtACDFTUVanrgleBracket;row;BLar;eftArrow;eiling;o\x00bleBracket;n\x00eeVector;ector;Bar;loor;ere;AVrrow;ector;iangle;BEar;qual;pDTVownVector;eeVector;ector;Bar;ector;Bar;puf;ndImplies;ightarrow;chr;;leDelayed;HOacfhimoqstuCcHcy;y;FTcy;cute;;aeiyron;dil;rc;;r;\uD835\uDD16ortDLRUownArroweftArrowightArrowpArrow;gma;allCircle;pf;\uD835\uDD4A\x00\x00t;are;ISUntersection;ubpset;Equal;erset;Equal;nion;cr;\uD835\uDCAEar;bcmp;set;Equal;cheeds;ESTqual;lantEqual;ilde;Th;;esrset;Equal;etHRSacfhiorsORNADE;Hccy;y;bu;;aeyron;dil;;r;\uD835\uDD17ei\x00efore;a;cnkSpace;Space;lde;EFTqual;ullEqual;ilde;pf;\uD835\uDD4BipleDot;ctr;\uD835\uDCAFrok;\x00\x00\x00\x00\x00\x00\x00cruter;ocir;r\x00y;ve;iyrc;blac;r;\uD835\uDD18raveacr;dierBParr;acek;et;arenthesis;on;Plus;gpon;f;\uD835\uDD4CADETadpsrrow;BDar;ownArrow;ownArrow;quilibrium;ee;Arrow;ownerLReftArrow;ightArrow;i;lon;ing;cr;\uD835\uDCB0ilde;mlDbcdefosvash;ar;y;ash;l;er;btyar;;icalBLSTar;ine;eparator;ilde;ThinSpace;r;\uD835\uDD19pf;\uD835\uDD4Dcr;\uD835\uDCB1dash;cefosirc;dge;r;\uD835\uDD1Apf;\uD835\uDD4Ecr;\uD835\uDCB2fiosr;\uD835\uDD1B;pf;\uD835\uDD4Fcr;\uD835\uDCB3AIUacfosucy;cy;cy;cuteiyrc;;r;\uD835\uDD1Cpf;\uD835\uDD50cr;\uD835\uDCB4ml;Hacdefoscy;cute;ayron;;ot;\x00oWidta;r;pf;cr;\uD835\uDCB5\x00\x00\x00\x00\x00\x00\x00cutereve;;Ediuy;;rcte;lig;r;\uD835\uDD1Eraveepfpsym;ha;apcclr;g;\x00\x00;adsvnd;;lope;;;elmrsz;esd;a;;;;;;;;t;vb;d;pth;arr;gpon;f;\uD835\uDD52;Eaeiop;cir;;d;s;rox;eingctyr;\uD835\uDCB6;mp;eildemlcioninnt;Nabcdefiklnoprsuot;crkcepsong;psilon;rime;im;eq;ee;ed;gerk;tbrk;oy;quo;cmprtaus;eptyv;snoahw;;een;r;\uD835\uDD1Fgcostuvwaiurc;pdptot;lus;imes;\x00\x00cup;ar;riangleduown;p;plus;earow;akocnklstozenge;riangle;dlrown;eft;ight;k;\x00\x00;;4;ck;eo;q=uiv;t;ptwxf;\uD835\uDD53;tomtie;DHUVbdhmptuvLRlr;;;;;DUdu;;;;LRlr;;;;;HLRhlr;;;;;;ox;LRlr;;;;;DUdu;;;;inus;lus;imes;LRlr;;;;;HLRhlr;;;;;;evbarceior;\uD835\uDCB7mi;m;el;bh;sub;l;etp;Ee;;q\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00cprute;;abcdsnd;rcup;aup;p;ot;;eot;aeiu\x00s;on;dilrc;ps;sm;ot;dmnilptyv;t;err;\uD835\uDD20ceiy;ck;mark;r;Ecefms;;elq;e\x00\x00rrowlreft;ight;RSacd;st;irc;ash;nint;id;cir;ubs;uit\x00on;e;q\x00\x00a;t;;flemxente\x00;dot;nfry;\uD835\uDD54o;sr;aorr;ss;cur;\uD835\uDCB8bp;e;;e;dot;delprvwarrlr;;\x00\x00r;c;arr;p;;bcdosrcap;aup;p;ot;r;;alrvrr;m;yevwq\x00\x00reuee;edge;enearrowlreftightecioninnt;lcty;AHabcdefhijlorstuwzrar;glrsger;eth;h;varow;aayron;;;aogrr;tseq;glmta;ptyv;irsht;;\uD835\uDD21arlraegsvm;osnd;suit;amma;in;;iode;ontimes;ncy;c\x00\x00rn;op;lptuwlar;f;\uD835\uDD55;empsq;dot;inus;lus;quare;blebarwedgnadhownarrowarpoonlrefighkaro\x00\x00rn;op;cotry;\uD835\uDCB9;l;rok;drot;i;fahraangle;ciy;grarr;DacdefglmnopqrstuxDoocsuteter;aioyron;r;clon;;ot;Drot;;\uD835\uDD22;rsave;dot;;ilsnters;;;dot;apscr;ty;svetp1;;;gs;p;gpon;f;\uD835\uDD56alsr;sl;us;i;lvon;csuviorc\x00\x00antgltressaeils;st;v;DD;parsl;Daot;rr;cdir;oah;mrlo;cipl;seoctationential\x00\x00\x00\x00\x00\x00\x00llingdotsey;male;ilrlig;\x00\x00g;ig;;\uD835\uDD23lig;lig;fjaltt;ig;ns;of;\x00f;\uD835\uDD57ak;v;artint;aocs\x00\x00;;;;\x00;;\x00\x00;;5;\x00;;8;l;wn;cr;\uD835\uDCBBEabcdefgijlnorstv;l;cmpute;ma;d;reve;iyrc;;ot;;lqs;qslan;cdlc;ot;o;l;;es;r;\uD835\uDD24;gmel;cy;;Eaj;;;Eaes;p;prox;q;qim;pf;\uD835\uDD58cir;m;el;;>;cdlqrci;r;ot;Par;uest;adels\x00pror;qlqlesienrtneqq;Aabcefkosyrilmrrsfildrcy;;cwir;;ar;irc;alrrts;uitlip;con;r;\uD835\uDD25sewarow;arow;amoprrr;tht;klreftarrow;ightarrow;f;\uD835\uDD59bar;cltr;\uD835\uDCBDasrok;bpull;hen\x00\x00\x00\x00\x00\x00cute;iyrc;cxy;clfr;\uD835\uDD26rave;inoinnt;t;fin;ta;lig;aopcgtr;elpinarh;f;ed;;cfotare;in;tie;do;celpal;grerarhk;rod;cgpty;on;f;\uD835\uDD5Aa;uestcir;\uD835\uDCBEn;Edsv;ot;;v;;ilde;\x00cy;lcfmosuiyrc;;r;\uD835\uDD27ath;pf;\uD835\uDD5B\x00r;\uD835\uDCBFrcy;kcy;acfghjosppa;v;eydil;;r;\uD835\uDD28reen;cy;cy;pf;\uD835\uDD5Ccr;\uD835\uDCC0ABEHabcdefghjlmnoprstuvartrail;arr;;g;ar;\x00\x00\x00\x00\x00\x00\x00\x00\x00ute;mptyv;rabda;g;dl;;uor;bfhlpst;fs;s;p;l;im;l;;aeil;;s;abrrr;rk;akcek;;es;ldu;;aeuyron;diil;;cqrsa;uo;rduhar;shar;h;;fgqstahlrtrrow;taarpoonduownpeftarrows;ightahsrrow;sarpoonquigarrohreetimes;;qslan;cdgsc;ot;o;r;;es;adegspproot;qgqgtiilrsht;;\uD835\uDD29;E;rdu;l;lk;cy;;achtrorneard;ri;iodot;ust;acheEaes;p;prox;q;qim;abnoptwznrg;r;rglmreftarightapsto;ightparrowlrefight;aflr;;\uD835\uDD5Dus;imes;st;;efngear;lt;achmtrornear;d;;ri;achiqtquo;r;\uD835\uDCC1m;eg;;buo;r;rok;<;cdhilqrci;r;remes;arr;uest;Piar;;efrdushar;har;enrtneqq;DacdefhilnopsuDot;clprret;;ese;sto;dluowefker;oymma;;ash;asuredangler;\uD835\uDD2Ao;cdnro;acdsir;otus;bd;u;p;dpels;f;\uD835\uDD5Ectr;\uD835\uDCC2pos;lmtimap;GLRVabcdefghijlmoprstuvwgt;;veltftarrrow;ightarrow;;;vightarrow;Ddash;ash;bcnptlaute;g;;Eiop;d;s;rour;al;s\x00pmp;eaeouy\x00;on;dil;ng;dot;p;;ash;;Aadqsxrr;rhrk;;oot;uieiar;ist;sr;\uD835\uDD2BEest;qs;qslani;rAaprrr;ar;;sv;d;cy;AEadestr;rr;r;;fqstarrroightarro;qslan;si;ri;eiptf;\uD835\uDD5F;inn;Edv;ot;;;i;v;;aorr;astllel;;lint;;ceu;c;eAaitrrr;cw;;ghtarrowri;echimpqu;ceru;\uD835\uDCC3ort\x00\x00arm;e;qsubpbcp;Ees;et;eq;qc;e;Ees;et;eq;qgilrldeianglelreft;eight;e;m;esro;p;DHadgilrsash;arr;p;ash;et;;>nfin;Aetrr;;;r<ie;Atrr;rie;im;Aanrr;rhrk;;oear;\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00csuteiyr;c;abioslac;v;old;lig;crir;;\uD835\uDD2C\x00\x00\x00n;ave;bmar;acitrirr;oss;n;aeicr;ga;cdnron;;pf;\uD835\uDD60aelr;rp;;adiosvr;efmr;ofgof;r;lope;;cloashl;idees;as;mlbar;\x00\x00\x00\x00\x00\x00\x00\x00\x00r;ast;lle\x00\x00m;;y;rcimptnt;od;il;enk;r;\uD835\uDD2Dimo;v;mane;;tvchfork;aunckk;h;s;abcdemstcir;ir;ou;;nim;wo;ipuntint;f;\uD835\uDD61nd;Eaceinosu;p;u;c;acenspprourlyeaespprox;qq;im;ime;sEasdfpalslar;ine;urf;;trel;cir;\uD835\uDCC5;ncsp;fiopsur;\uD835\uDD2Epf;\uD835\uDD62rime;cr;\uD835\uDCC6aeoteirnionnt;st;eABHabcdefhilmnoprstuxartrail;arar;cdenqrteu;te;imptyv;g;del;;uor;abcfhlpstwp;;fs;;s;l;im;l;;aiil;o;nalabrrrk;akcek;;es;ldu;;aeuyron;diil;;clqsa;dhar;uo;rh;acgl;ipsnart;ilrsht;;\uD835\uDD2Faordu;l;;v;gnshtahlrstrrow;taarpoonduowpeftahrrowarpoonightarrows;quigarrohreetimes;g;ingdotseahmra;oust;achemid;abptnrg;r;raflr;;\uD835\uDD63us;imes;apr;gt;olint;arachqquo;r;\uD835\uDCC7buo;rhirremes;i;efltri;luhar;;\x00\x00\x00\x00\x00\x00\x00cute;qu;Eaceinpsy;\x00;on;u;dil;rc;Eas;p;im;olint;i;ot;be;Aacmstxrr;rhr;oti;war;minnut;r;o\uD835\uDD30acoyrp;hycy;;rt\x00\x00iaragmma;fv;;deglnprot;;q;E;;E;e;lus;arr;araeitlslsetmhp;parsl;dle;;e;s;flptcy;;b;ar;f;\uD835\uDD64adres;uitcsuaup;s;p;s;ubp;eset;e;eset;e;afrarcemtr;\uD835\uDCC8tmiararr;fanighteppsilohsbcmnp;Edemnprs;ot;;dot;ult;Ee;;lus;arr;eiut;enq;qeq;qm;bp;;c;acenspprourlyeaespproqg;123;Edehlmnps;ost;ub;;dot;soul;b;arr;ult;Ee;;lus;eiut;enq;qeq;qm;bp;;Aanrr;rhr;owar;lig\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00get;;raeyron;dil;;lrec;r;\uD835\uDD31eiko\x00e4fa;svym;cnkaspproimsasrnes;bd;ar;;eps;bcfot;ir;;o\uD835\uDD65rk;rime;aipdadempstngle;dlqrowneft;e;ight;eot;inus;lus;b;ime;ezium;chtry;\uD835\uDCC9;cy;rok;ioxheadlreftarroightarrowAHabcdfghlmoprstuwrar;cruter\x00y;ve;iyrc;abhrlac;airsht;;\uD835\uDD32raverlrlk;ct\x00\x00rn;erop;ri;alcr;gpon;f;\uD835\uDD66adhlsuownarpoonlrefighi;hlonparrows;cit\x00\x00rn;erop;ng;ri;cr;\uD835\uDCCAdirot;lde;i;famrlangle;ABDacdeflnoprszrar;v;asnrgrt;eknprstappothinhirop;hiugmbpsetneq;q;setneq;q;hretianglelreftighty;ashelr;bear;q;lip;btar;\uD835\uDD33trsubppf;\uD835\uDD67rotrcur;\uD835\uDCCBbpnEenEeigzag;cefoprsirc;dibgar;e;q;erp;r;\uD835\uDD34pf;\uD835\uDD68;eatcr;\uD835\uDCCC\x00\x00\x00\x00\x00\x00\x00trr;\uD835\uDD35Aarr;Aarrais;dptfl;\uD835\uDD69imAarrcqr;\uD835\uDCCDptracefiosucuyte;iyrc;;nr;\uD835\uDD36cy;pf;\uD835\uDD6Acr;\uD835\uDCCEcmy;lacdefhioswcute;ayron;;ot;ettra;r;\uD835\uDD37cy;grarr;pf;\uD835\uDD6Bcr;\uD835\uDCCFjn;j;".split("").map(function(c) {
    return c.charCodeAt(0);
  }));
});

// ../../../../node_modules/.bun/entities@4.5.0/node_modules/entities/lib/generated/decode-data-xml.js
var require_decode_data_xml = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.default = new Uint16Array("aglq\t\x15\x18\x1B\x0F\x00\x00\x12p;os;t;t;uot;".split("").map(function(c) {
    return c.charCodeAt(0);
  }));
});

// ../../../../node_modules/.bun/entities@4.5.0/node_modules/entities/lib/decode_codepoint.js
var require_decode_codepoint = __commonJS((exports) => {
  var _a;
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.replaceCodePoint = exports.fromCodePoint = undefined;
  var decodeMap = new Map([
    [0, 65533],
    [128, 8364],
    [130, 8218],
    [131, 402],
    [132, 8222],
    [133, 8230],
    [134, 8224],
    [135, 8225],
    [136, 710],
    [137, 8240],
    [138, 352],
    [139, 8249],
    [140, 338],
    [142, 381],
    [145, 8216],
    [146, 8217],
    [147, 8220],
    [148, 8221],
    [149, 8226],
    [150, 8211],
    [151, 8212],
    [152, 732],
    [153, 8482],
    [154, 353],
    [155, 8250],
    [156, 339],
    [158, 382],
    [159, 376]
  ]);
  exports.fromCodePoint = (_a = String.fromCodePoint) !== null && _a !== undefined ? _a : function(codePoint) {
    var output = "";
    if (codePoint > 65535) {
      codePoint -= 65536;
      output += String.fromCharCode(codePoint >>> 10 & 1023 | 55296);
      codePoint = 56320 | codePoint & 1023;
    }
    output += String.fromCharCode(codePoint);
    return output;
  };
  function replaceCodePoint(codePoint) {
    var _a2;
    if (codePoint >= 55296 && codePoint <= 57343 || codePoint > 1114111) {
      return 65533;
    }
    return (_a2 = decodeMap.get(codePoint)) !== null && _a2 !== undefined ? _a2 : codePoint;
  }
  exports.replaceCodePoint = replaceCodePoint;
  function decodeCodePoint(codePoint) {
    return (0, exports.fromCodePoint)(replaceCodePoint(codePoint));
  }
  exports.default = decodeCodePoint;
});

// ../../../../node_modules/.bun/entities@4.5.0/node_modules/entities/lib/decode.js
var require_decode = __commonJS((exports) => {
  var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() {
        return m[k];
      } };
    }
    Object.defineProperty(o, k2, desc);
  } : function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    o[k2] = m[k];
  });
  var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
  } : function(o, v) {
    o["default"] = v;
  });
  var __importStar = exports && exports.__importStar || function(mod) {
    if (mod && mod.__esModule)
      return mod;
    var result = {};
    if (mod != null) {
      for (var k in mod)
        if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
          __createBinding(result, mod, k);
    }
    __setModuleDefault(result, mod);
    return result;
  };
  var __importDefault = exports && exports.__importDefault || function(mod) {
    return mod && mod.__esModule ? mod : { default: mod };
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.decodeXML = exports.decodeHTMLStrict = exports.decodeHTMLAttribute = exports.decodeHTML = exports.determineBranch = exports.EntityDecoder = exports.DecodingMode = exports.BinTrieFlags = exports.fromCodePoint = exports.replaceCodePoint = exports.decodeCodePoint = exports.xmlDecodeTree = exports.htmlDecodeTree = undefined;
  var decode_data_html_js_1 = __importDefault(require_decode_data_html());
  exports.htmlDecodeTree = decode_data_html_js_1.default;
  var decode_data_xml_js_1 = __importDefault(require_decode_data_xml());
  exports.xmlDecodeTree = decode_data_xml_js_1.default;
  var decode_codepoint_js_1 = __importStar(require_decode_codepoint());
  exports.decodeCodePoint = decode_codepoint_js_1.default;
  var decode_codepoint_js_2 = require_decode_codepoint();
  Object.defineProperty(exports, "replaceCodePoint", { enumerable: true, get: function() {
    return decode_codepoint_js_2.replaceCodePoint;
  } });
  Object.defineProperty(exports, "fromCodePoint", { enumerable: true, get: function() {
    return decode_codepoint_js_2.fromCodePoint;
  } });
  var CharCodes;
  (function(CharCodes2) {
    CharCodes2[CharCodes2["NUM"] = 35] = "NUM";
    CharCodes2[CharCodes2["SEMI"] = 59] = "SEMI";
    CharCodes2[CharCodes2["EQUALS"] = 61] = "EQUALS";
    CharCodes2[CharCodes2["ZERO"] = 48] = "ZERO";
    CharCodes2[CharCodes2["NINE"] = 57] = "NINE";
    CharCodes2[CharCodes2["LOWER_A"] = 97] = "LOWER_A";
    CharCodes2[CharCodes2["LOWER_F"] = 102] = "LOWER_F";
    CharCodes2[CharCodes2["LOWER_X"] = 120] = "LOWER_X";
    CharCodes2[CharCodes2["LOWER_Z"] = 122] = "LOWER_Z";
    CharCodes2[CharCodes2["UPPER_A"] = 65] = "UPPER_A";
    CharCodes2[CharCodes2["UPPER_F"] = 70] = "UPPER_F";
    CharCodes2[CharCodes2["UPPER_Z"] = 90] = "UPPER_Z";
  })(CharCodes || (CharCodes = {}));
  var TO_LOWER_BIT = 32;
  var BinTrieFlags;
  (function(BinTrieFlags2) {
    BinTrieFlags2[BinTrieFlags2["VALUE_LENGTH"] = 49152] = "VALUE_LENGTH";
    BinTrieFlags2[BinTrieFlags2["BRANCH_LENGTH"] = 16256] = "BRANCH_LENGTH";
    BinTrieFlags2[BinTrieFlags2["JUMP_TABLE"] = 127] = "JUMP_TABLE";
  })(BinTrieFlags = exports.BinTrieFlags || (exports.BinTrieFlags = {}));
  function isNumber(code) {
    return code >= CharCodes.ZERO && code <= CharCodes.NINE;
  }
  function isHexadecimalCharacter(code) {
    return code >= CharCodes.UPPER_A && code <= CharCodes.UPPER_F || code >= CharCodes.LOWER_A && code <= CharCodes.LOWER_F;
  }
  function isAsciiAlphaNumeric(code) {
    return code >= CharCodes.UPPER_A && code <= CharCodes.UPPER_Z || code >= CharCodes.LOWER_A && code <= CharCodes.LOWER_Z || isNumber(code);
  }
  function isEntityInAttributeInvalidEnd(code) {
    return code === CharCodes.EQUALS || isAsciiAlphaNumeric(code);
  }
  var EntityDecoderState;
  (function(EntityDecoderState2) {
    EntityDecoderState2[EntityDecoderState2["EntityStart"] = 0] = "EntityStart";
    EntityDecoderState2[EntityDecoderState2["NumericStart"] = 1] = "NumericStart";
    EntityDecoderState2[EntityDecoderState2["NumericDecimal"] = 2] = "NumericDecimal";
    EntityDecoderState2[EntityDecoderState2["NumericHex"] = 3] = "NumericHex";
    EntityDecoderState2[EntityDecoderState2["NamedEntity"] = 4] = "NamedEntity";
  })(EntityDecoderState || (EntityDecoderState = {}));
  var DecodingMode;
  (function(DecodingMode2) {
    DecodingMode2[DecodingMode2["Legacy"] = 0] = "Legacy";
    DecodingMode2[DecodingMode2["Strict"] = 1] = "Strict";
    DecodingMode2[DecodingMode2["Attribute"] = 2] = "Attribute";
  })(DecodingMode = exports.DecodingMode || (exports.DecodingMode = {}));
  var EntityDecoder = function() {
    function EntityDecoder2(decodeTree, emitCodePoint, errors) {
      this.decodeTree = decodeTree;
      this.emitCodePoint = emitCodePoint;
      this.errors = errors;
      this.state = EntityDecoderState.EntityStart;
      this.consumed = 1;
      this.result = 0;
      this.treeIndex = 0;
      this.excess = 1;
      this.decodeMode = DecodingMode.Strict;
    }
    EntityDecoder2.prototype.startEntity = function(decodeMode) {
      this.decodeMode = decodeMode;
      this.state = EntityDecoderState.EntityStart;
      this.result = 0;
      this.treeIndex = 0;
      this.excess = 1;
      this.consumed = 1;
    };
    EntityDecoder2.prototype.write = function(str, offset) {
      switch (this.state) {
        case EntityDecoderState.EntityStart: {
          if (str.charCodeAt(offset) === CharCodes.NUM) {
            this.state = EntityDecoderState.NumericStart;
            this.consumed += 1;
            return this.stateNumericStart(str, offset + 1);
          }
          this.state = EntityDecoderState.NamedEntity;
          return this.stateNamedEntity(str, offset);
        }
        case EntityDecoderState.NumericStart: {
          return this.stateNumericStart(str, offset);
        }
        case EntityDecoderState.NumericDecimal: {
          return this.stateNumericDecimal(str, offset);
        }
        case EntityDecoderState.NumericHex: {
          return this.stateNumericHex(str, offset);
        }
        case EntityDecoderState.NamedEntity: {
          return this.stateNamedEntity(str, offset);
        }
      }
    };
    EntityDecoder2.prototype.stateNumericStart = function(str, offset) {
      if (offset >= str.length) {
        return -1;
      }
      if ((str.charCodeAt(offset) | TO_LOWER_BIT) === CharCodes.LOWER_X) {
        this.state = EntityDecoderState.NumericHex;
        this.consumed += 1;
        return this.stateNumericHex(str, offset + 1);
      }
      this.state = EntityDecoderState.NumericDecimal;
      return this.stateNumericDecimal(str, offset);
    };
    EntityDecoder2.prototype.addToNumericResult = function(str, start, end, base) {
      if (start !== end) {
        var digitCount = end - start;
        this.result = this.result * Math.pow(base, digitCount) + parseInt(str.substr(start, digitCount), base);
        this.consumed += digitCount;
      }
    };
    EntityDecoder2.prototype.stateNumericHex = function(str, offset) {
      var startIdx = offset;
      while (offset < str.length) {
        var char = str.charCodeAt(offset);
        if (isNumber(char) || isHexadecimalCharacter(char)) {
          offset += 1;
        } else {
          this.addToNumericResult(str, startIdx, offset, 16);
          return this.emitNumericEntity(char, 3);
        }
      }
      this.addToNumericResult(str, startIdx, offset, 16);
      return -1;
    };
    EntityDecoder2.prototype.stateNumericDecimal = function(str, offset) {
      var startIdx = offset;
      while (offset < str.length) {
        var char = str.charCodeAt(offset);
        if (isNumber(char)) {
          offset += 1;
        } else {
          this.addToNumericResult(str, startIdx, offset, 10);
          return this.emitNumericEntity(char, 2);
        }
      }
      this.addToNumericResult(str, startIdx, offset, 10);
      return -1;
    };
    EntityDecoder2.prototype.emitNumericEntity = function(lastCp, expectedLength) {
      var _a;
      if (this.consumed <= expectedLength) {
        (_a = this.errors) === null || _a === undefined || _a.absenceOfDigitsInNumericCharacterReference(this.consumed);
        return 0;
      }
      if (lastCp === CharCodes.SEMI) {
        this.consumed += 1;
      } else if (this.decodeMode === DecodingMode.Strict) {
        return 0;
      }
      this.emitCodePoint((0, decode_codepoint_js_1.replaceCodePoint)(this.result), this.consumed);
      if (this.errors) {
        if (lastCp !== CharCodes.SEMI) {
          this.errors.missingSemicolonAfterCharacterReference();
        }
        this.errors.validateNumericCharacterReference(this.result);
      }
      return this.consumed;
    };
    EntityDecoder2.prototype.stateNamedEntity = function(str, offset) {
      var decodeTree = this.decodeTree;
      var current = decodeTree[this.treeIndex];
      var valueLength = (current & BinTrieFlags.VALUE_LENGTH) >> 14;
      for (;offset < str.length; offset++, this.excess++) {
        var char = str.charCodeAt(offset);
        this.treeIndex = determineBranch(decodeTree, current, this.treeIndex + Math.max(1, valueLength), char);
        if (this.treeIndex < 0) {
          return this.result === 0 || this.decodeMode === DecodingMode.Attribute && (valueLength === 0 || isEntityInAttributeInvalidEnd(char)) ? 0 : this.emitNotTerminatedNamedEntity();
        }
        current = decodeTree[this.treeIndex];
        valueLength = (current & BinTrieFlags.VALUE_LENGTH) >> 14;
        if (valueLength !== 0) {
          if (char === CharCodes.SEMI) {
            return this.emitNamedEntityData(this.treeIndex, valueLength, this.consumed + this.excess);
          }
          if (this.decodeMode !== DecodingMode.Strict) {
            this.result = this.treeIndex;
            this.consumed += this.excess;
            this.excess = 0;
          }
        }
      }
      return -1;
    };
    EntityDecoder2.prototype.emitNotTerminatedNamedEntity = function() {
      var _a;
      var _b = this, result = _b.result, decodeTree = _b.decodeTree;
      var valueLength = (decodeTree[result] & BinTrieFlags.VALUE_LENGTH) >> 14;
      this.emitNamedEntityData(result, valueLength, this.consumed);
      (_a = this.errors) === null || _a === undefined || _a.missingSemicolonAfterCharacterReference();
      return this.consumed;
    };
    EntityDecoder2.prototype.emitNamedEntityData = function(result, valueLength, consumed) {
      var decodeTree = this.decodeTree;
      this.emitCodePoint(valueLength === 1 ? decodeTree[result] & ~BinTrieFlags.VALUE_LENGTH : decodeTree[result + 1], consumed);
      if (valueLength === 3) {
        this.emitCodePoint(decodeTree[result + 2], consumed);
      }
      return consumed;
    };
    EntityDecoder2.prototype.end = function() {
      var _a;
      switch (this.state) {
        case EntityDecoderState.NamedEntity: {
          return this.result !== 0 && (this.decodeMode !== DecodingMode.Attribute || this.result === this.treeIndex) ? this.emitNotTerminatedNamedEntity() : 0;
        }
        case EntityDecoderState.NumericDecimal: {
          return this.emitNumericEntity(0, 2);
        }
        case EntityDecoderState.NumericHex: {
          return this.emitNumericEntity(0, 3);
        }
        case EntityDecoderState.NumericStart: {
          (_a = this.errors) === null || _a === undefined || _a.absenceOfDigitsInNumericCharacterReference(this.consumed);
          return 0;
        }
        case EntityDecoderState.EntityStart: {
          return 0;
        }
      }
    };
    return EntityDecoder2;
  }();
  exports.EntityDecoder = EntityDecoder;
  function getDecoder(decodeTree) {
    var ret = "";
    var decoder = new EntityDecoder(decodeTree, function(str) {
      return ret += (0, decode_codepoint_js_1.fromCodePoint)(str);
    });
    return function decodeWithTrie(str, decodeMode) {
      var lastIndex = 0;
      var offset = 0;
      while ((offset = str.indexOf("&", offset)) >= 0) {
        ret += str.slice(lastIndex, offset);
        decoder.startEntity(decodeMode);
        var len = decoder.write(str, offset + 1);
        if (len < 0) {
          lastIndex = offset + decoder.end();
          break;
        }
        lastIndex = offset + len;
        offset = len === 0 ? lastIndex + 1 : lastIndex;
      }
      var result = ret + str.slice(lastIndex);
      ret = "";
      return result;
    };
  }
  function determineBranch(decodeTree, current, nodeIdx, char) {
    var branchCount = (current & BinTrieFlags.BRANCH_LENGTH) >> 7;
    var jumpOffset = current & BinTrieFlags.JUMP_TABLE;
    if (branchCount === 0) {
      return jumpOffset !== 0 && char === jumpOffset ? nodeIdx : -1;
    }
    if (jumpOffset) {
      var value = char - jumpOffset;
      return value < 0 || value >= branchCount ? -1 : decodeTree[nodeIdx + value] - 1;
    }
    var lo = nodeIdx;
    var hi = lo + branchCount - 1;
    while (lo <= hi) {
      var mid = lo + hi >>> 1;
      var midVal = decodeTree[mid];
      if (midVal < char) {
        lo = mid + 1;
      } else if (midVal > char) {
        hi = mid - 1;
      } else {
        return decodeTree[mid + branchCount];
      }
    }
    return -1;
  }
  exports.determineBranch = determineBranch;
  var htmlDecoder = getDecoder(decode_data_html_js_1.default);
  var xmlDecoder = getDecoder(decode_data_xml_js_1.default);
  function decodeHTML(str, mode) {
    if (mode === undefined) {
      mode = DecodingMode.Legacy;
    }
    return htmlDecoder(str, mode);
  }
  exports.decodeHTML = decodeHTML;
  function decodeHTMLAttribute(str) {
    return htmlDecoder(str, DecodingMode.Attribute);
  }
  exports.decodeHTMLAttribute = decodeHTMLAttribute;
  function decodeHTMLStrict(str) {
    return htmlDecoder(str, DecodingMode.Strict);
  }
  exports.decodeHTMLStrict = decodeHTMLStrict;
  function decodeXML(str) {
    return xmlDecoder(str, DecodingMode.Strict);
  }
  exports.decodeXML = decodeXML;
});

// ../../../../node_modules/.bun/entities@4.5.0/node_modules/entities/lib/generated/encode-html.js
var require_encode_html = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  function restoreDiff(arr) {
    for (var i = 1;i < arr.length; i++) {
      arr[i][0] += arr[i - 1][0] + 1;
    }
    return arr;
  }
  exports.default = new Map(/* @__PURE__ */ restoreDiff([[9, "&Tab;"], [0, "&NewLine;"], [22, "&excl;"], [0, "&quot;"], [0, "&num;"], [0, "&dollar;"], [0, "&percnt;"], [0, "&amp;"], [0, "&apos;"], [0, "&lpar;"], [0, "&rpar;"], [0, "&ast;"], [0, "&plus;"], [0, "&comma;"], [1, "&period;"], [0, "&sol;"], [10, "&colon;"], [0, "&semi;"], [0, { v: "&lt;", n: 8402, o: "&nvlt;" }], [0, { v: "&equals;", n: 8421, o: "&bne;" }], [0, { v: "&gt;", n: 8402, o: "&nvgt;" }], [0, "&quest;"], [0, "&commat;"], [26, "&lbrack;"], [0, "&bsol;"], [0, "&rbrack;"], [0, "&Hat;"], [0, "&lowbar;"], [0, "&DiacriticalGrave;"], [5, { n: 106, o: "&fjlig;" }], [20, "&lbrace;"], [0, "&verbar;"], [0, "&rbrace;"], [34, "&nbsp;"], [0, "&iexcl;"], [0, "&cent;"], [0, "&pound;"], [0, "&curren;"], [0, "&yen;"], [0, "&brvbar;"], [0, "&sect;"], [0, "&die;"], [0, "&copy;"], [0, "&ordf;"], [0, "&laquo;"], [0, "&not;"], [0, "&shy;"], [0, "&circledR;"], [0, "&macr;"], [0, "&deg;"], [0, "&PlusMinus;"], [0, "&sup2;"], [0, "&sup3;"], [0, "&acute;"], [0, "&micro;"], [0, "&para;"], [0, "&centerdot;"], [0, "&cedil;"], [0, "&sup1;"], [0, "&ordm;"], [0, "&raquo;"], [0, "&frac14;"], [0, "&frac12;"], [0, "&frac34;"], [0, "&iquest;"], [0, "&Agrave;"], [0, "&Aacute;"], [0, "&Acirc;"], [0, "&Atilde;"], [0, "&Auml;"], [0, "&angst;"], [0, "&AElig;"], [0, "&Ccedil;"], [0, "&Egrave;"], [0, "&Eacute;"], [0, "&Ecirc;"], [0, "&Euml;"], [0, "&Igrave;"], [0, "&Iacute;"], [0, "&Icirc;"], [0, "&Iuml;"], [0, "&ETH;"], [0, "&Ntilde;"], [0, "&Ograve;"], [0, "&Oacute;"], [0, "&Ocirc;"], [0, "&Otilde;"], [0, "&Ouml;"], [0, "&times;"], [0, "&Oslash;"], [0, "&Ugrave;"], [0, "&Uacute;"], [0, "&Ucirc;"], [0, "&Uuml;"], [0, "&Yacute;"], [0, "&THORN;"], [0, "&szlig;"], [0, "&agrave;"], [0, "&aacute;"], [0, "&acirc;"], [0, "&atilde;"], [0, "&auml;"], [0, "&aring;"], [0, "&aelig;"], [0, "&ccedil;"], [0, "&egrave;"], [0, "&eacute;"], [0, "&ecirc;"], [0, "&euml;"], [0, "&igrave;"], [0, "&iacute;"], [0, "&icirc;"], [0, "&iuml;"], [0, "&eth;"], [0, "&ntilde;"], [0, "&ograve;"], [0, "&oacute;"], [0, "&ocirc;"], [0, "&otilde;"], [0, "&ouml;"], [0, "&div;"], [0, "&oslash;"], [0, "&ugrave;"], [0, "&uacute;"], [0, "&ucirc;"], [0, "&uuml;"], [0, "&yacute;"], [0, "&thorn;"], [0, "&yuml;"], [0, "&Amacr;"], [0, "&amacr;"], [0, "&Abreve;"], [0, "&abreve;"], [0, "&Aogon;"], [0, "&aogon;"], [0, "&Cacute;"], [0, "&cacute;"], [0, "&Ccirc;"], [0, "&ccirc;"], [0, "&Cdot;"], [0, "&cdot;"], [0, "&Ccaron;"], [0, "&ccaron;"], [0, "&Dcaron;"], [0, "&dcaron;"], [0, "&Dstrok;"], [0, "&dstrok;"], [0, "&Emacr;"], [0, "&emacr;"], [2, "&Edot;"], [0, "&edot;"], [0, "&Eogon;"], [0, "&eogon;"], [0, "&Ecaron;"], [0, "&ecaron;"], [0, "&Gcirc;"], [0, "&gcirc;"], [0, "&Gbreve;"], [0, "&gbreve;"], [0, "&Gdot;"], [0, "&gdot;"], [0, "&Gcedil;"], [1, "&Hcirc;"], [0, "&hcirc;"], [0, "&Hstrok;"], [0, "&hstrok;"], [0, "&Itilde;"], [0, "&itilde;"], [0, "&Imacr;"], [0, "&imacr;"], [2, "&Iogon;"], [0, "&iogon;"], [0, "&Idot;"], [0, "&imath;"], [0, "&IJlig;"], [0, "&ijlig;"], [0, "&Jcirc;"], [0, "&jcirc;"], [0, "&Kcedil;"], [0, "&kcedil;"], [0, "&kgreen;"], [0, "&Lacute;"], [0, "&lacute;"], [0, "&Lcedil;"], [0, "&lcedil;"], [0, "&Lcaron;"], [0, "&lcaron;"], [0, "&Lmidot;"], [0, "&lmidot;"], [0, "&Lstrok;"], [0, "&lstrok;"], [0, "&Nacute;"], [0, "&nacute;"], [0, "&Ncedil;"], [0, "&ncedil;"], [0, "&Ncaron;"], [0, "&ncaron;"], [0, "&napos;"], [0, "&ENG;"], [0, "&eng;"], [0, "&Omacr;"], [0, "&omacr;"], [2, "&Odblac;"], [0, "&odblac;"], [0, "&OElig;"], [0, "&oelig;"], [0, "&Racute;"], [0, "&racute;"], [0, "&Rcedil;"], [0, "&rcedil;"], [0, "&Rcaron;"], [0, "&rcaron;"], [0, "&Sacute;"], [0, "&sacute;"], [0, "&Scirc;"], [0, "&scirc;"], [0, "&Scedil;"], [0, "&scedil;"], [0, "&Scaron;"], [0, "&scaron;"], [0, "&Tcedil;"], [0, "&tcedil;"], [0, "&Tcaron;"], [0, "&tcaron;"], [0, "&Tstrok;"], [0, "&tstrok;"], [0, "&Utilde;"], [0, "&utilde;"], [0, "&Umacr;"], [0, "&umacr;"], [0, "&Ubreve;"], [0, "&ubreve;"], [0, "&Uring;"], [0, "&uring;"], [0, "&Udblac;"], [0, "&udblac;"], [0, "&Uogon;"], [0, "&uogon;"], [0, "&Wcirc;"], [0, "&wcirc;"], [0, "&Ycirc;"], [0, "&ycirc;"], [0, "&Yuml;"], [0, "&Zacute;"], [0, "&zacute;"], [0, "&Zdot;"], [0, "&zdot;"], [0, "&Zcaron;"], [0, "&zcaron;"], [19, "&fnof;"], [34, "&imped;"], [63, "&gacute;"], [65, "&jmath;"], [142, "&circ;"], [0, "&caron;"], [16, "&breve;"], [0, "&DiacriticalDot;"], [0, "&ring;"], [0, "&ogon;"], [0, "&DiacriticalTilde;"], [0, "&dblac;"], [51, "&DownBreve;"], [127, "&Alpha;"], [0, "&Beta;"], [0, "&Gamma;"], [0, "&Delta;"], [0, "&Epsilon;"], [0, "&Zeta;"], [0, "&Eta;"], [0, "&Theta;"], [0, "&Iota;"], [0, "&Kappa;"], [0, "&Lambda;"], [0, "&Mu;"], [0, "&Nu;"], [0, "&Xi;"], [0, "&Omicron;"], [0, "&Pi;"], [0, "&Rho;"], [1, "&Sigma;"], [0, "&Tau;"], [0, "&Upsilon;"], [0, "&Phi;"], [0, "&Chi;"], [0, "&Psi;"], [0, "&ohm;"], [7, "&alpha;"], [0, "&beta;"], [0, "&gamma;"], [0, "&delta;"], [0, "&epsi;"], [0, "&zeta;"], [0, "&eta;"], [0, "&theta;"], [0, "&iota;"], [0, "&kappa;"], [0, "&lambda;"], [0, "&mu;"], [0, "&nu;"], [0, "&xi;"], [0, "&omicron;"], [0, "&pi;"], [0, "&rho;"], [0, "&sigmaf;"], [0, "&sigma;"], [0, "&tau;"], [0, "&upsi;"], [0, "&phi;"], [0, "&chi;"], [0, "&psi;"], [0, "&omega;"], [7, "&thetasym;"], [0, "&Upsi;"], [2, "&phiv;"], [0, "&piv;"], [5, "&Gammad;"], [0, "&digamma;"], [18, "&kappav;"], [0, "&rhov;"], [3, "&epsiv;"], [0, "&backepsilon;"], [10, "&IOcy;"], [0, "&DJcy;"], [0, "&GJcy;"], [0, "&Jukcy;"], [0, "&DScy;"], [0, "&Iukcy;"], [0, "&YIcy;"], [0, "&Jsercy;"], [0, "&LJcy;"], [0, "&NJcy;"], [0, "&TSHcy;"], [0, "&KJcy;"], [1, "&Ubrcy;"], [0, "&DZcy;"], [0, "&Acy;"], [0, "&Bcy;"], [0, "&Vcy;"], [0, "&Gcy;"], [0, "&Dcy;"], [0, "&IEcy;"], [0, "&ZHcy;"], [0, "&Zcy;"], [0, "&Icy;"], [0, "&Jcy;"], [0, "&Kcy;"], [0, "&Lcy;"], [0, "&Mcy;"], [0, "&Ncy;"], [0, "&Ocy;"], [0, "&Pcy;"], [0, "&Rcy;"], [0, "&Scy;"], [0, "&Tcy;"], [0, "&Ucy;"], [0, "&Fcy;"], [0, "&KHcy;"], [0, "&TScy;"], [0, "&CHcy;"], [0, "&SHcy;"], [0, "&SHCHcy;"], [0, "&HARDcy;"], [0, "&Ycy;"], [0, "&SOFTcy;"], [0, "&Ecy;"], [0, "&YUcy;"], [0, "&YAcy;"], [0, "&acy;"], [0, "&bcy;"], [0, "&vcy;"], [0, "&gcy;"], [0, "&dcy;"], [0, "&iecy;"], [0, "&zhcy;"], [0, "&zcy;"], [0, "&icy;"], [0, "&jcy;"], [0, "&kcy;"], [0, "&lcy;"], [0, "&mcy;"], [0, "&ncy;"], [0, "&ocy;"], [0, "&pcy;"], [0, "&rcy;"], [0, "&scy;"], [0, "&tcy;"], [0, "&ucy;"], [0, "&fcy;"], [0, "&khcy;"], [0, "&tscy;"], [0, "&chcy;"], [0, "&shcy;"], [0, "&shchcy;"], [0, "&hardcy;"], [0, "&ycy;"], [0, "&softcy;"], [0, "&ecy;"], [0, "&yucy;"], [0, "&yacy;"], [1, "&iocy;"], [0, "&djcy;"], [0, "&gjcy;"], [0, "&jukcy;"], [0, "&dscy;"], [0, "&iukcy;"], [0, "&yicy;"], [0, "&jsercy;"], [0, "&ljcy;"], [0, "&njcy;"], [0, "&tshcy;"], [0, "&kjcy;"], [1, "&ubrcy;"], [0, "&dzcy;"], [7074, "&ensp;"], [0, "&emsp;"], [0, "&emsp13;"], [0, "&emsp14;"], [1, "&numsp;"], [0, "&puncsp;"], [0, "&ThinSpace;"], [0, "&hairsp;"], [0, "&NegativeMediumSpace;"], [0, "&zwnj;"], [0, "&zwj;"], [0, "&lrm;"], [0, "&rlm;"], [0, "&dash;"], [2, "&ndash;"], [0, "&mdash;"], [0, "&horbar;"], [0, "&Verbar;"], [1, "&lsquo;"], [0, "&CloseCurlyQuote;"], [0, "&lsquor;"], [1, "&ldquo;"], [0, "&CloseCurlyDoubleQuote;"], [0, "&bdquo;"], [1, "&dagger;"], [0, "&Dagger;"], [0, "&bull;"], [2, "&nldr;"], [0, "&hellip;"], [9, "&permil;"], [0, "&pertenk;"], [0, "&prime;"], [0, "&Prime;"], [0, "&tprime;"], [0, "&backprime;"], [3, "&lsaquo;"], [0, "&rsaquo;"], [3, "&oline;"], [2, "&caret;"], [1, "&hybull;"], [0, "&frasl;"], [10, "&bsemi;"], [7, "&qprime;"], [7, { v: "&MediumSpace;", n: 8202, o: "&ThickSpace;" }], [0, "&NoBreak;"], [0, "&af;"], [0, "&InvisibleTimes;"], [0, "&ic;"], [72, "&euro;"], [46, "&tdot;"], [0, "&DotDot;"], [37, "&complexes;"], [2, "&incare;"], [4, "&gscr;"], [0, "&hamilt;"], [0, "&Hfr;"], [0, "&Hopf;"], [0, "&planckh;"], [0, "&hbar;"], [0, "&imagline;"], [0, "&Ifr;"], [0, "&lagran;"], [0, "&ell;"], [1, "&naturals;"], [0, "&numero;"], [0, "&copysr;"], [0, "&weierp;"], [0, "&Popf;"], [0, "&Qopf;"], [0, "&realine;"], [0, "&real;"], [0, "&reals;"], [0, "&rx;"], [3, "&trade;"], [1, "&integers;"], [2, "&mho;"], [0, "&zeetrf;"], [0, "&iiota;"], [2, "&bernou;"], [0, "&Cayleys;"], [1, "&escr;"], [0, "&Escr;"], [0, "&Fouriertrf;"], [1, "&Mellintrf;"], [0, "&order;"], [0, "&alefsym;"], [0, "&beth;"], [0, "&gimel;"], [0, "&daleth;"], [12, "&CapitalDifferentialD;"], [0, "&dd;"], [0, "&ee;"], [0, "&ii;"], [10, "&frac13;"], [0, "&frac23;"], [0, "&frac15;"], [0, "&frac25;"], [0, "&frac35;"], [0, "&frac45;"], [0, "&frac16;"], [0, "&frac56;"], [0, "&frac18;"], [0, "&frac38;"], [0, "&frac58;"], [0, "&frac78;"], [49, "&larr;"], [0, "&ShortUpArrow;"], [0, "&rarr;"], [0, "&darr;"], [0, "&harr;"], [0, "&updownarrow;"], [0, "&nwarr;"], [0, "&nearr;"], [0, "&LowerRightArrow;"], [0, "&LowerLeftArrow;"], [0, "&nlarr;"], [0, "&nrarr;"], [1, { v: "&rarrw;", n: 824, o: "&nrarrw;" }], [0, "&Larr;"], [0, "&Uarr;"], [0, "&Rarr;"], [0, "&Darr;"], [0, "&larrtl;"], [0, "&rarrtl;"], [0, "&LeftTeeArrow;"], [0, "&mapstoup;"], [0, "&map;"], [0, "&DownTeeArrow;"], [1, "&hookleftarrow;"], [0, "&hookrightarrow;"], [0, "&larrlp;"], [0, "&looparrowright;"], [0, "&harrw;"], [0, "&nharr;"], [1, "&lsh;"], [0, "&rsh;"], [0, "&ldsh;"], [0, "&rdsh;"], [1, "&crarr;"], [0, "&cularr;"], [0, "&curarr;"], [2, "&circlearrowleft;"], [0, "&circlearrowright;"], [0, "&leftharpoonup;"], [0, "&DownLeftVector;"], [0, "&RightUpVector;"], [0, "&LeftUpVector;"], [0, "&rharu;"], [0, "&DownRightVector;"], [0, "&dharr;"], [0, "&dharl;"], [0, "&RightArrowLeftArrow;"], [0, "&udarr;"], [0, "&LeftArrowRightArrow;"], [0, "&leftleftarrows;"], [0, "&upuparrows;"], [0, "&rightrightarrows;"], [0, "&ddarr;"], [0, "&leftrightharpoons;"], [0, "&Equilibrium;"], [0, "&nlArr;"], [0, "&nhArr;"], [0, "&nrArr;"], [0, "&DoubleLeftArrow;"], [0, "&DoubleUpArrow;"], [0, "&DoubleRightArrow;"], [0, "&dArr;"], [0, "&DoubleLeftRightArrow;"], [0, "&DoubleUpDownArrow;"], [0, "&nwArr;"], [0, "&neArr;"], [0, "&seArr;"], [0, "&swArr;"], [0, "&lAarr;"], [0, "&rAarr;"], [1, "&zigrarr;"], [6, "&larrb;"], [0, "&rarrb;"], [15, "&DownArrowUpArrow;"], [7, "&loarr;"], [0, "&roarr;"], [0, "&hoarr;"], [0, "&forall;"], [0, "&comp;"], [0, { v: "&part;", n: 824, o: "&npart;" }], [0, "&exist;"], [0, "&nexist;"], [0, "&empty;"], [1, "&Del;"], [0, "&Element;"], [0, "&NotElement;"], [1, "&ni;"], [0, "&notni;"], [2, "&prod;"], [0, "&coprod;"], [0, "&sum;"], [0, "&minus;"], [0, "&MinusPlus;"], [0, "&dotplus;"], [1, "&Backslash;"], [0, "&lowast;"], [0, "&compfn;"], [1, "&radic;"], [2, "&prop;"], [0, "&infin;"], [0, "&angrt;"], [0, { v: "&ang;", n: 8402, o: "&nang;" }], [0, "&angmsd;"], [0, "&angsph;"], [0, "&mid;"], [0, "&nmid;"], [0, "&DoubleVerticalBar;"], [0, "&NotDoubleVerticalBar;"], [0, "&and;"], [0, "&or;"], [0, { v: "&cap;", n: 65024, o: "&caps;" }], [0, { v: "&cup;", n: 65024, o: "&cups;" }], [0, "&int;"], [0, "&Int;"], [0, "&iiint;"], [0, "&conint;"], [0, "&Conint;"], [0, "&Cconint;"], [0, "&cwint;"], [0, "&ClockwiseContourIntegral;"], [0, "&awconint;"], [0, "&there4;"], [0, "&becaus;"], [0, "&ratio;"], [0, "&Colon;"], [0, "&dotminus;"], [1, "&mDDot;"], [0, "&homtht;"], [0, { v: "&sim;", n: 8402, o: "&nvsim;" }], [0, { v: "&backsim;", n: 817, o: "&race;" }], [0, { v: "&ac;", n: 819, o: "&acE;" }], [0, "&acd;"], [0, "&VerticalTilde;"], [0, "&NotTilde;"], [0, { v: "&eqsim;", n: 824, o: "&nesim;" }], [0, "&sime;"], [0, "&NotTildeEqual;"], [0, "&cong;"], [0, "&simne;"], [0, "&ncong;"], [0, "&ap;"], [0, "&nap;"], [0, "&ape;"], [0, { v: "&apid;", n: 824, o: "&napid;" }], [0, "&backcong;"], [0, { v: "&asympeq;", n: 8402, o: "&nvap;" }], [0, { v: "&bump;", n: 824, o: "&nbump;" }], [0, { v: "&bumpe;", n: 824, o: "&nbumpe;" }], [0, { v: "&doteq;", n: 824, o: "&nedot;" }], [0, "&doteqdot;"], [0, "&efDot;"], [0, "&erDot;"], [0, "&Assign;"], [0, "&ecolon;"], [0, "&ecir;"], [0, "&circeq;"], [1, "&wedgeq;"], [0, "&veeeq;"], [1, "&triangleq;"], [2, "&equest;"], [0, "&ne;"], [0, { v: "&Congruent;", n: 8421, o: "&bnequiv;" }], [0, "&nequiv;"], [1, { v: "&le;", n: 8402, o: "&nvle;" }], [0, { v: "&ge;", n: 8402, o: "&nvge;" }], [0, { v: "&lE;", n: 824, o: "&nlE;" }], [0, { v: "&gE;", n: 824, o: "&ngE;" }], [0, { v: "&lnE;", n: 65024, o: "&lvertneqq;" }], [0, { v: "&gnE;", n: 65024, o: "&gvertneqq;" }], [0, { v: "&ll;", n: new Map(/* @__PURE__ */ restoreDiff([[824, "&nLtv;"], [7577, "&nLt;"]])) }], [0, { v: "&gg;", n: new Map(/* @__PURE__ */ restoreDiff([[824, "&nGtv;"], [7577, "&nGt;"]])) }], [0, "&between;"], [0, "&NotCupCap;"], [0, "&nless;"], [0, "&ngt;"], [0, "&nle;"], [0, "&nge;"], [0, "&lesssim;"], [0, "&GreaterTilde;"], [0, "&nlsim;"], [0, "&ngsim;"], [0, "&LessGreater;"], [0, "&gl;"], [0, "&NotLessGreater;"], [0, "&NotGreaterLess;"], [0, "&pr;"], [0, "&sc;"], [0, "&prcue;"], [0, "&sccue;"], [0, "&PrecedesTilde;"], [0, { v: "&scsim;", n: 824, o: "&NotSucceedsTilde;" }], [0, "&NotPrecedes;"], [0, "&NotSucceeds;"], [0, { v: "&sub;", n: 8402, o: "&NotSubset;" }], [0, { v: "&sup;", n: 8402, o: "&NotSuperset;" }], [0, "&nsub;"], [0, "&nsup;"], [0, "&sube;"], [0, "&supe;"], [0, "&NotSubsetEqual;"], [0, "&NotSupersetEqual;"], [0, { v: "&subne;", n: 65024, o: "&varsubsetneq;" }], [0, { v: "&supne;", n: 65024, o: "&varsupsetneq;" }], [1, "&cupdot;"], [0, "&UnionPlus;"], [0, { v: "&sqsub;", n: 824, o: "&NotSquareSubset;" }], [0, { v: "&sqsup;", n: 824, o: "&NotSquareSuperset;" }], [0, "&sqsube;"], [0, "&sqsupe;"], [0, { v: "&sqcap;", n: 65024, o: "&sqcaps;" }], [0, { v: "&sqcup;", n: 65024, o: "&sqcups;" }], [0, "&CirclePlus;"], [0, "&CircleMinus;"], [0, "&CircleTimes;"], [0, "&osol;"], [0, "&CircleDot;"], [0, "&circledcirc;"], [0, "&circledast;"], [1, "&circleddash;"], [0, "&boxplus;"], [0, "&boxminus;"], [0, "&boxtimes;"], [0, "&dotsquare;"], [0, "&RightTee;"], [0, "&dashv;"], [0, "&DownTee;"], [0, "&bot;"], [1, "&models;"], [0, "&DoubleRightTee;"], [0, "&Vdash;"], [0, "&Vvdash;"], [0, "&VDash;"], [0, "&nvdash;"], [0, "&nvDash;"], [0, "&nVdash;"], [0, "&nVDash;"], [0, "&prurel;"], [1, "&LeftTriangle;"], [0, "&RightTriangle;"], [0, { v: "&LeftTriangleEqual;", n: 8402, o: "&nvltrie;" }], [0, { v: "&RightTriangleEqual;", n: 8402, o: "&nvrtrie;" }], [0, "&origof;"], [0, "&imof;"], [0, "&multimap;"], [0, "&hercon;"], [0, "&intcal;"], [0, "&veebar;"], [1, "&barvee;"], [0, "&angrtvb;"], [0, "&lrtri;"], [0, "&bigwedge;"], [0, "&bigvee;"], [0, "&bigcap;"], [0, "&bigcup;"], [0, "&diam;"], [0, "&sdot;"], [0, "&sstarf;"], [0, "&divideontimes;"], [0, "&bowtie;"], [0, "&ltimes;"], [0, "&rtimes;"], [0, "&leftthreetimes;"], [0, "&rightthreetimes;"], [0, "&backsimeq;"], [0, "&curlyvee;"], [0, "&curlywedge;"], [0, "&Sub;"], [0, "&Sup;"], [0, "&Cap;"], [0, "&Cup;"], [0, "&fork;"], [0, "&epar;"], [0, "&lessdot;"], [0, "&gtdot;"], [0, { v: "&Ll;", n: 824, o: "&nLl;" }], [0, { v: "&Gg;", n: 824, o: "&nGg;" }], [0, { v: "&leg;", n: 65024, o: "&lesg;" }], [0, { v: "&gel;", n: 65024, o: "&gesl;" }], [2, "&cuepr;"], [0, "&cuesc;"], [0, "&NotPrecedesSlantEqual;"], [0, "&NotSucceedsSlantEqual;"], [0, "&NotSquareSubsetEqual;"], [0, "&NotSquareSupersetEqual;"], [2, "&lnsim;"], [0, "&gnsim;"], [0, "&precnsim;"], [0, "&scnsim;"], [0, "&nltri;"], [0, "&NotRightTriangle;"], [0, "&nltrie;"], [0, "&NotRightTriangleEqual;"], [0, "&vellip;"], [0, "&ctdot;"], [0, "&utdot;"], [0, "&dtdot;"], [0, "&disin;"], [0, "&isinsv;"], [0, "&isins;"], [0, { v: "&isindot;", n: 824, o: "&notindot;" }], [0, "&notinvc;"], [0, "&notinvb;"], [1, { v: "&isinE;", n: 824, o: "&notinE;" }], [0, "&nisd;"], [0, "&xnis;"], [0, "&nis;"], [0, "&notnivc;"], [0, "&notnivb;"], [6, "&barwed;"], [0, "&Barwed;"], [1, "&lceil;"], [0, "&rceil;"], [0, "&LeftFloor;"], [0, "&rfloor;"], [0, "&drcrop;"], [0, "&dlcrop;"], [0, "&urcrop;"], [0, "&ulcrop;"], [0, "&bnot;"], [1, "&profline;"], [0, "&profsurf;"], [1, "&telrec;"], [0, "&target;"], [5, "&ulcorn;"], [0, "&urcorn;"], [0, "&dlcorn;"], [0, "&drcorn;"], [2, "&frown;"], [0, "&smile;"], [9, "&cylcty;"], [0, "&profalar;"], [7, "&topbot;"], [6, "&ovbar;"], [1, "&solbar;"], [60, "&angzarr;"], [51, "&lmoustache;"], [0, "&rmoustache;"], [2, "&OverBracket;"], [0, "&bbrk;"], [0, "&bbrktbrk;"], [37, "&OverParenthesis;"], [0, "&UnderParenthesis;"], [0, "&OverBrace;"], [0, "&UnderBrace;"], [2, "&trpezium;"], [4, "&elinters;"], [59, "&blank;"], [164, "&circledS;"], [55, "&boxh;"], [1, "&boxv;"], [9, "&boxdr;"], [3, "&boxdl;"], [3, "&boxur;"], [3, "&boxul;"], [3, "&boxvr;"], [7, "&boxvl;"], [7, "&boxhd;"], [7, "&boxhu;"], [7, "&boxvh;"], [19, "&boxH;"], [0, "&boxV;"], [0, "&boxdR;"], [0, "&boxDr;"], [0, "&boxDR;"], [0, "&boxdL;"], [0, "&boxDl;"], [0, "&boxDL;"], [0, "&boxuR;"], [0, "&boxUr;"], [0, "&boxUR;"], [0, "&boxuL;"], [0, "&boxUl;"], [0, "&boxUL;"], [0, "&boxvR;"], [0, "&boxVr;"], [0, "&boxVR;"], [0, "&boxvL;"], [0, "&boxVl;"], [0, "&boxVL;"], [0, "&boxHd;"], [0, "&boxhD;"], [0, "&boxHD;"], [0, "&boxHu;"], [0, "&boxhU;"], [0, "&boxHU;"], [0, "&boxvH;"], [0, "&boxVh;"], [0, "&boxVH;"], [19, "&uhblk;"], [3, "&lhblk;"], [3, "&block;"], [8, "&blk14;"], [0, "&blk12;"], [0, "&blk34;"], [13, "&square;"], [8, "&blacksquare;"], [0, "&EmptyVerySmallSquare;"], [1, "&rect;"], [0, "&marker;"], [2, "&fltns;"], [1, "&bigtriangleup;"], [0, "&blacktriangle;"], [0, "&triangle;"], [2, "&blacktriangleright;"], [0, "&rtri;"], [3, "&bigtriangledown;"], [0, "&blacktriangledown;"], [0, "&dtri;"], [2, "&blacktriangleleft;"], [0, "&ltri;"], [6, "&loz;"], [0, "&cir;"], [32, "&tridot;"], [2, "&bigcirc;"], [8, "&ultri;"], [0, "&urtri;"], [0, "&lltri;"], [0, "&EmptySmallSquare;"], [0, "&FilledSmallSquare;"], [8, "&bigstar;"], [0, "&star;"], [7, "&phone;"], [49, "&female;"], [1, "&male;"], [29, "&spades;"], [2, "&clubs;"], [1, "&hearts;"], [0, "&diamondsuit;"], [3, "&sung;"], [2, "&flat;"], [0, "&natural;"], [0, "&sharp;"], [163, "&check;"], [3, "&cross;"], [8, "&malt;"], [21, "&sext;"], [33, "&VerticalSeparator;"], [25, "&lbbrk;"], [0, "&rbbrk;"], [84, "&bsolhsub;"], [0, "&suphsol;"], [28, "&LeftDoubleBracket;"], [0, "&RightDoubleBracket;"], [0, "&lang;"], [0, "&rang;"], [0, "&Lang;"], [0, "&Rang;"], [0, "&loang;"], [0, "&roang;"], [7, "&longleftarrow;"], [0, "&longrightarrow;"], [0, "&longleftrightarrow;"], [0, "&DoubleLongLeftArrow;"], [0, "&DoubleLongRightArrow;"], [0, "&DoubleLongLeftRightArrow;"], [1, "&longmapsto;"], [2, "&dzigrarr;"], [258, "&nvlArr;"], [0, "&nvrArr;"], [0, "&nvHarr;"], [0, "&Map;"], [6, "&lbarr;"], [0, "&bkarow;"], [0, "&lBarr;"], [0, "&dbkarow;"], [0, "&drbkarow;"], [0, "&DDotrahd;"], [0, "&UpArrowBar;"], [0, "&DownArrowBar;"], [2, "&Rarrtl;"], [2, "&latail;"], [0, "&ratail;"], [0, "&lAtail;"], [0, "&rAtail;"], [0, "&larrfs;"], [0, "&rarrfs;"], [0, "&larrbfs;"], [0, "&rarrbfs;"], [2, "&nwarhk;"], [0, "&nearhk;"], [0, "&hksearow;"], [0, "&hkswarow;"], [0, "&nwnear;"], [0, "&nesear;"], [0, "&seswar;"], [0, "&swnwar;"], [8, { v: "&rarrc;", n: 824, o: "&nrarrc;" }], [1, "&cudarrr;"], [0, "&ldca;"], [0, "&rdca;"], [0, "&cudarrl;"], [0, "&larrpl;"], [2, "&curarrm;"], [0, "&cularrp;"], [7, "&rarrpl;"], [2, "&harrcir;"], [0, "&Uarrocir;"], [0, "&lurdshar;"], [0, "&ldrushar;"], [2, "&LeftRightVector;"], [0, "&RightUpDownVector;"], [0, "&DownLeftRightVector;"], [0, "&LeftUpDownVector;"], [0, "&LeftVectorBar;"], [0, "&RightVectorBar;"], [0, "&RightUpVectorBar;"], [0, "&RightDownVectorBar;"], [0, "&DownLeftVectorBar;"], [0, "&DownRightVectorBar;"], [0, "&LeftUpVectorBar;"], [0, "&LeftDownVectorBar;"], [0, "&LeftTeeVector;"], [0, "&RightTeeVector;"], [0, "&RightUpTeeVector;"], [0, "&RightDownTeeVector;"], [0, "&DownLeftTeeVector;"], [0, "&DownRightTeeVector;"], [0, "&LeftUpTeeVector;"], [0, "&LeftDownTeeVector;"], [0, "&lHar;"], [0, "&uHar;"], [0, "&rHar;"], [0, "&dHar;"], [0, "&luruhar;"], [0, "&ldrdhar;"], [0, "&ruluhar;"], [0, "&rdldhar;"], [0, "&lharul;"], [0, "&llhard;"], [0, "&rharul;"], [0, "&lrhard;"], [0, "&udhar;"], [0, "&duhar;"], [0, "&RoundImplies;"], [0, "&erarr;"], [0, "&simrarr;"], [0, "&larrsim;"], [0, "&rarrsim;"], [0, "&rarrap;"], [0, "&ltlarr;"], [1, "&gtrarr;"], [0, "&subrarr;"], [1, "&suplarr;"], [0, "&lfisht;"], [0, "&rfisht;"], [0, "&ufisht;"], [0, "&dfisht;"], [5, "&lopar;"], [0, "&ropar;"], [4, "&lbrke;"], [0, "&rbrke;"], [0, "&lbrkslu;"], [0, "&rbrksld;"], [0, "&lbrksld;"], [0, "&rbrkslu;"], [0, "&langd;"], [0, "&rangd;"], [0, "&lparlt;"], [0, "&rpargt;"], [0, "&gtlPar;"], [0, "&ltrPar;"], [3, "&vzigzag;"], [1, "&vangrt;"], [0, "&angrtvbd;"], [6, "&ange;"], [0, "&range;"], [0, "&dwangle;"], [0, "&uwangle;"], [0, "&angmsdaa;"], [0, "&angmsdab;"], [0, "&angmsdac;"], [0, "&angmsdad;"], [0, "&angmsdae;"], [0, "&angmsdaf;"], [0, "&angmsdag;"], [0, "&angmsdah;"], [0, "&bemptyv;"], [0, "&demptyv;"], [0, "&cemptyv;"], [0, "&raemptyv;"], [0, "&laemptyv;"], [0, "&ohbar;"], [0, "&omid;"], [0, "&opar;"], [1, "&operp;"], [1, "&olcross;"], [0, "&odsold;"], [1, "&olcir;"], [0, "&ofcir;"], [0, "&olt;"], [0, "&ogt;"], [0, "&cirscir;"], [0, "&cirE;"], [0, "&solb;"], [0, "&bsolb;"], [3, "&boxbox;"], [3, "&trisb;"], [0, "&rtriltri;"], [0, { v: "&LeftTriangleBar;", n: 824, o: "&NotLeftTriangleBar;" }], [0, { v: "&RightTriangleBar;", n: 824, o: "&NotRightTriangleBar;" }], [11, "&iinfin;"], [0, "&infintie;"], [0, "&nvinfin;"], [4, "&eparsl;"], [0, "&smeparsl;"], [0, "&eqvparsl;"], [5, "&blacklozenge;"], [8, "&RuleDelayed;"], [1, "&dsol;"], [9, "&bigodot;"], [0, "&bigoplus;"], [0, "&bigotimes;"], [1, "&biguplus;"], [1, "&bigsqcup;"], [5, "&iiiint;"], [0, "&fpartint;"], [2, "&cirfnint;"], [0, "&awint;"], [0, "&rppolint;"], [0, "&scpolint;"], [0, "&npolint;"], [0, "&pointint;"], [0, "&quatint;"], [0, "&intlarhk;"], [10, "&pluscir;"], [0, "&plusacir;"], [0, "&simplus;"], [0, "&plusdu;"], [0, "&plussim;"], [0, "&plustwo;"], [1, "&mcomma;"], [0, "&minusdu;"], [2, "&loplus;"], [0, "&roplus;"], [0, "&Cross;"], [0, "&timesd;"], [0, "&timesbar;"], [1, "&smashp;"], [0, "&lotimes;"], [0, "&rotimes;"], [0, "&otimesas;"], [0, "&Otimes;"], [0, "&odiv;"], [0, "&triplus;"], [0, "&triminus;"], [0, "&tritime;"], [0, "&intprod;"], [2, "&amalg;"], [0, "&capdot;"], [1, "&ncup;"], [0, "&ncap;"], [0, "&capand;"], [0, "&cupor;"], [0, "&cupcap;"], [0, "&capcup;"], [0, "&cupbrcap;"], [0, "&capbrcup;"], [0, "&cupcup;"], [0, "&capcap;"], [0, "&ccups;"], [0, "&ccaps;"], [2, "&ccupssm;"], [2, "&And;"], [0, "&Or;"], [0, "&andand;"], [0, "&oror;"], [0, "&orslope;"], [0, "&andslope;"], [1, "&andv;"], [0, "&orv;"], [0, "&andd;"], [0, "&ord;"], [1, "&wedbar;"], [6, "&sdote;"], [3, "&simdot;"], [2, { v: "&congdot;", n: 824, o: "&ncongdot;" }], [0, "&easter;"], [0, "&apacir;"], [0, { v: "&apE;", n: 824, o: "&napE;" }], [0, "&eplus;"], [0, "&pluse;"], [0, "&Esim;"], [0, "&Colone;"], [0, "&Equal;"], [1, "&ddotseq;"], [0, "&equivDD;"], [0, "&ltcir;"], [0, "&gtcir;"], [0, "&ltquest;"], [0, "&gtquest;"], [0, { v: "&leqslant;", n: 824, o: "&nleqslant;" }], [0, { v: "&geqslant;", n: 824, o: "&ngeqslant;" }], [0, "&lesdot;"], [0, "&gesdot;"], [0, "&lesdoto;"], [0, "&gesdoto;"], [0, "&lesdotor;"], [0, "&gesdotol;"], [0, "&lap;"], [0, "&gap;"], [0, "&lne;"], [0, "&gne;"], [0, "&lnap;"], [0, "&gnap;"], [0, "&lEg;"], [0, "&gEl;"], [0, "&lsime;"], [0, "&gsime;"], [0, "&lsimg;"], [0, "&gsiml;"], [0, "&lgE;"], [0, "&glE;"], [0, "&lesges;"], [0, "&gesles;"], [0, "&els;"], [0, "&egs;"], [0, "&elsdot;"], [0, "&egsdot;"], [0, "&el;"], [0, "&eg;"], [2, "&siml;"], [0, "&simg;"], [0, "&simlE;"], [0, "&simgE;"], [0, { v: "&LessLess;", n: 824, o: "&NotNestedLessLess;" }], [0, { v: "&GreaterGreater;", n: 824, o: "&NotNestedGreaterGreater;" }], [1, "&glj;"], [0, "&gla;"], [0, "&ltcc;"], [0, "&gtcc;"], [0, "&lescc;"], [0, "&gescc;"], [0, "&smt;"], [0, "&lat;"], [0, { v: "&smte;", n: 65024, o: "&smtes;" }], [0, { v: "&late;", n: 65024, o: "&lates;" }], [0, "&bumpE;"], [0, { v: "&PrecedesEqual;", n: 824, o: "&NotPrecedesEqual;" }], [0, { v: "&sce;", n: 824, o: "&NotSucceedsEqual;" }], [2, "&prE;"], [0, "&scE;"], [0, "&precneqq;"], [0, "&scnE;"], [0, "&prap;"], [0, "&scap;"], [0, "&precnapprox;"], [0, "&scnap;"], [0, "&Pr;"], [0, "&Sc;"], [0, "&subdot;"], [0, "&supdot;"], [0, "&subplus;"], [0, "&supplus;"], [0, "&submult;"], [0, "&supmult;"], [0, "&subedot;"], [0, "&supedot;"], [0, { v: "&subE;", n: 824, o: "&nsubE;" }], [0, { v: "&supE;", n: 824, o: "&nsupE;" }], [0, "&subsim;"], [0, "&supsim;"], [2, { v: "&subnE;", n: 65024, o: "&varsubsetneqq;" }], [0, { v: "&supnE;", n: 65024, o: "&varsupsetneqq;" }], [2, "&csub;"], [0, "&csup;"], [0, "&csube;"], [0, "&csupe;"], [0, "&subsup;"], [0, "&supsub;"], [0, "&subsub;"], [0, "&supsup;"], [0, "&suphsub;"], [0, "&supdsub;"], [0, "&forkv;"], [0, "&topfork;"], [0, "&mlcp;"], [8, "&Dashv;"], [1, "&Vdashl;"], [0, "&Barv;"], [0, "&vBar;"], [0, "&vBarv;"], [1, "&Vbar;"], [0, "&Not;"], [0, "&bNot;"], [0, "&rnmid;"], [0, "&cirmid;"], [0, "&midcir;"], [0, "&topcir;"], [0, "&nhpar;"], [0, "&parsim;"], [9, { v: "&parsl;", n: 8421, o: "&nparsl;" }], [44343, { n: new Map(/* @__PURE__ */ restoreDiff([[56476, "&Ascr;"], [1, "&Cscr;"], [0, "&Dscr;"], [2, "&Gscr;"], [2, "&Jscr;"], [0, "&Kscr;"], [2, "&Nscr;"], [0, "&Oscr;"], [0, "&Pscr;"], [0, "&Qscr;"], [1, "&Sscr;"], [0, "&Tscr;"], [0, "&Uscr;"], [0, "&Vscr;"], [0, "&Wscr;"], [0, "&Xscr;"], [0, "&Yscr;"], [0, "&Zscr;"], [0, "&ascr;"], [0, "&bscr;"], [0, "&cscr;"], [0, "&dscr;"], [1, "&fscr;"], [1, "&hscr;"], [0, "&iscr;"], [0, "&jscr;"], [0, "&kscr;"], [0, "&lscr;"], [0, "&mscr;"], [0, "&nscr;"], [1, "&pscr;"], [0, "&qscr;"], [0, "&rscr;"], [0, "&sscr;"], [0, "&tscr;"], [0, "&uscr;"], [0, "&vscr;"], [0, "&wscr;"], [0, "&xscr;"], [0, "&yscr;"], [0, "&zscr;"], [52, "&Afr;"], [0, "&Bfr;"], [1, "&Dfr;"], [0, "&Efr;"], [0, "&Ffr;"], [0, "&Gfr;"], [2, "&Jfr;"], [0, "&Kfr;"], [0, "&Lfr;"], [0, "&Mfr;"], [0, "&Nfr;"], [0, "&Ofr;"], [0, "&Pfr;"], [0, "&Qfr;"], [1, "&Sfr;"], [0, "&Tfr;"], [0, "&Ufr;"], [0, "&Vfr;"], [0, "&Wfr;"], [0, "&Xfr;"], [0, "&Yfr;"], [1, "&afr;"], [0, "&bfr;"], [0, "&cfr;"], [0, "&dfr;"], [0, "&efr;"], [0, "&ffr;"], [0, "&gfr;"], [0, "&hfr;"], [0, "&ifr;"], [0, "&jfr;"], [0, "&kfr;"], [0, "&lfr;"], [0, "&mfr;"], [0, "&nfr;"], [0, "&ofr;"], [0, "&pfr;"], [0, "&qfr;"], [0, "&rfr;"], [0, "&sfr;"], [0, "&tfr;"], [0, "&ufr;"], [0, "&vfr;"], [0, "&wfr;"], [0, "&xfr;"], [0, "&yfr;"], [0, "&zfr;"], [0, "&Aopf;"], [0, "&Bopf;"], [1, "&Dopf;"], [0, "&Eopf;"], [0, "&Fopf;"], [0, "&Gopf;"], [1, "&Iopf;"], [0, "&Jopf;"], [0, "&Kopf;"], [0, "&Lopf;"], [0, "&Mopf;"], [1, "&Oopf;"], [3, "&Sopf;"], [0, "&Topf;"], [0, "&Uopf;"], [0, "&Vopf;"], [0, "&Wopf;"], [0, "&Xopf;"], [0, "&Yopf;"], [1, "&aopf;"], [0, "&bopf;"], [0, "&copf;"], [0, "&dopf;"], [0, "&eopf;"], [0, "&fopf;"], [0, "&gopf;"], [0, "&hopf;"], [0, "&iopf;"], [0, "&jopf;"], [0, "&kopf;"], [0, "&lopf;"], [0, "&mopf;"], [0, "&nopf;"], [0, "&oopf;"], [0, "&popf;"], [0, "&qopf;"], [0, "&ropf;"], [0, "&sopf;"], [0, "&topf;"], [0, "&uopf;"], [0, "&vopf;"], [0, "&wopf;"], [0, "&xopf;"], [0, "&yopf;"], [0, "&zopf;"]])) }], [8906, "&fflig;"], [0, "&filig;"], [0, "&fllig;"], [0, "&ffilig;"], [0, "&ffllig;"]]));
});

// ../../../../node_modules/.bun/entities@4.5.0/node_modules/entities/lib/escape.js
var require_escape = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.escapeText = exports.escapeAttribute = exports.escapeUTF8 = exports.escape = exports.encodeXML = exports.getCodePoint = exports.xmlReplacer = undefined;
  exports.xmlReplacer = /["&'<>$\x80-\uFFFF]/g;
  var xmlCodeMap = new Map([
    [34, "&quot;"],
    [38, "&amp;"],
    [39, "&apos;"],
    [60, "&lt;"],
    [62, "&gt;"]
  ]);
  exports.getCodePoint = String.prototype.codePointAt != null ? function(str, index) {
    return str.codePointAt(index);
  } : function(c, index) {
    return (c.charCodeAt(index) & 64512) === 55296 ? (c.charCodeAt(index) - 55296) * 1024 + c.charCodeAt(index + 1) - 56320 + 65536 : c.charCodeAt(index);
  };
  function encodeXML(str) {
    var ret = "";
    var lastIdx = 0;
    var match;
    while ((match = exports.xmlReplacer.exec(str)) !== null) {
      var i = match.index;
      var char = str.charCodeAt(i);
      var next = xmlCodeMap.get(char);
      if (next !== undefined) {
        ret += str.substring(lastIdx, i) + next;
        lastIdx = i + 1;
      } else {
        ret += "".concat(str.substring(lastIdx, i), "&#x").concat((0, exports.getCodePoint)(str, i).toString(16), ";");
        lastIdx = exports.xmlReplacer.lastIndex += Number((char & 64512) === 55296);
      }
    }
    return ret + str.substr(lastIdx);
  }
  exports.encodeXML = encodeXML;
  exports.escape = encodeXML;
  function getEscaper(regex, map) {
    return function escape(data) {
      var match;
      var lastIdx = 0;
      var result = "";
      while (match = regex.exec(data)) {
        if (lastIdx !== match.index) {
          result += data.substring(lastIdx, match.index);
        }
        result += map.get(match[0].charCodeAt(0));
        lastIdx = match.index + 1;
      }
      return result + data.substring(lastIdx);
    };
  }
  exports.escapeUTF8 = getEscaper(/[&<>'"]/g, xmlCodeMap);
  exports.escapeAttribute = getEscaper(/["&\u00A0]/g, new Map([
    [34, "&quot;"],
    [38, "&amp;"],
    [160, "&nbsp;"]
  ]));
  exports.escapeText = getEscaper(/[&<>\u00A0]/g, new Map([
    [38, "&amp;"],
    [60, "&lt;"],
    [62, "&gt;"],
    [160, "&nbsp;"]
  ]));
});

// ../../../../node_modules/.bun/entities@4.5.0/node_modules/entities/lib/encode.js
var require_encode = __commonJS((exports) => {
  var __importDefault = exports && exports.__importDefault || function(mod) {
    return mod && mod.__esModule ? mod : { default: mod };
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.encodeNonAsciiHTML = exports.encodeHTML = undefined;
  var encode_html_js_1 = __importDefault(require_encode_html());
  var escape_js_1 = require_escape();
  var htmlReplacer = /[\t\n!-,./:-@[-`\f{-}$\x80-\uFFFF]/g;
  function encodeHTML(data) {
    return encodeHTMLTrieRe(htmlReplacer, data);
  }
  exports.encodeHTML = encodeHTML;
  function encodeNonAsciiHTML(data) {
    return encodeHTMLTrieRe(escape_js_1.xmlReplacer, data);
  }
  exports.encodeNonAsciiHTML = encodeNonAsciiHTML;
  function encodeHTMLTrieRe(regExp, str) {
    var ret = "";
    var lastIdx = 0;
    var match;
    while ((match = regExp.exec(str)) !== null) {
      var i = match.index;
      ret += str.substring(lastIdx, i);
      var char = str.charCodeAt(i);
      var next = encode_html_js_1.default.get(char);
      if (typeof next === "object") {
        if (i + 1 < str.length) {
          var nextChar = str.charCodeAt(i + 1);
          var value = typeof next.n === "number" ? next.n === nextChar ? next.o : undefined : next.n.get(nextChar);
          if (value !== undefined) {
            ret += value;
            lastIdx = regExp.lastIndex += 1;
            continue;
          }
        }
        next = next.v;
      }
      if (next !== undefined) {
        ret += next;
        lastIdx = i + 1;
      } else {
        var cp = (0, escape_js_1.getCodePoint)(str, i);
        ret += "&#x".concat(cp.toString(16), ";");
        lastIdx = regExp.lastIndex += Number(cp !== char);
      }
    }
    return ret + str.substr(lastIdx);
  }
});

// ../../../../node_modules/.bun/entities@4.5.0/node_modules/entities/lib/index.js
var require_lib3 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.decodeXMLStrict = exports.decodeHTML5Strict = exports.decodeHTML4Strict = exports.decodeHTML5 = exports.decodeHTML4 = exports.decodeHTMLAttribute = exports.decodeHTMLStrict = exports.decodeHTML = exports.decodeXML = exports.DecodingMode = exports.EntityDecoder = exports.encodeHTML5 = exports.encodeHTML4 = exports.encodeNonAsciiHTML = exports.encodeHTML = exports.escapeText = exports.escapeAttribute = exports.escapeUTF8 = exports.escape = exports.encodeXML = exports.encode = exports.decodeStrict = exports.decode = exports.EncodingMode = exports.EntityLevel = undefined;
  var decode_js_1 = require_decode();
  var encode_js_1 = require_encode();
  var escape_js_1 = require_escape();
  var EntityLevel;
  (function(EntityLevel2) {
    EntityLevel2[EntityLevel2["XML"] = 0] = "XML";
    EntityLevel2[EntityLevel2["HTML"] = 1] = "HTML";
  })(EntityLevel = exports.EntityLevel || (exports.EntityLevel = {}));
  var EncodingMode;
  (function(EncodingMode2) {
    EncodingMode2[EncodingMode2["UTF8"] = 0] = "UTF8";
    EncodingMode2[EncodingMode2["ASCII"] = 1] = "ASCII";
    EncodingMode2[EncodingMode2["Extensive"] = 2] = "Extensive";
    EncodingMode2[EncodingMode2["Attribute"] = 3] = "Attribute";
    EncodingMode2[EncodingMode2["Text"] = 4] = "Text";
  })(EncodingMode = exports.EncodingMode || (exports.EncodingMode = {}));
  function decode(data, options) {
    if (options === undefined) {
      options = EntityLevel.XML;
    }
    var level = typeof options === "number" ? options : options.level;
    if (level === EntityLevel.HTML) {
      var mode = typeof options === "object" ? options.mode : undefined;
      return (0, decode_js_1.decodeHTML)(data, mode);
    }
    return (0, decode_js_1.decodeXML)(data);
  }
  exports.decode = decode;
  function decodeStrict(data, options) {
    var _a;
    if (options === undefined) {
      options = EntityLevel.XML;
    }
    var opts = typeof options === "number" ? { level: options } : options;
    (_a = opts.mode) !== null && _a !== undefined || (opts.mode = decode_js_1.DecodingMode.Strict);
    return decode(data, opts);
  }
  exports.decodeStrict = decodeStrict;
  function encode(data, options) {
    if (options === undefined) {
      options = EntityLevel.XML;
    }
    var opts = typeof options === "number" ? { level: options } : options;
    if (opts.mode === EncodingMode.UTF8)
      return (0, escape_js_1.escapeUTF8)(data);
    if (opts.mode === EncodingMode.Attribute)
      return (0, escape_js_1.escapeAttribute)(data);
    if (opts.mode === EncodingMode.Text)
      return (0, escape_js_1.escapeText)(data);
    if (opts.level === EntityLevel.HTML) {
      if (opts.mode === EncodingMode.ASCII) {
        return (0, encode_js_1.encodeNonAsciiHTML)(data);
      }
      return (0, encode_js_1.encodeHTML)(data);
    }
    return (0, escape_js_1.encodeXML)(data);
  }
  exports.encode = encode;
  var escape_js_2 = require_escape();
  Object.defineProperty(exports, "encodeXML", { enumerable: true, get: function() {
    return escape_js_2.encodeXML;
  } });
  Object.defineProperty(exports, "escape", { enumerable: true, get: function() {
    return escape_js_2.escape;
  } });
  Object.defineProperty(exports, "escapeUTF8", { enumerable: true, get: function() {
    return escape_js_2.escapeUTF8;
  } });
  Object.defineProperty(exports, "escapeAttribute", { enumerable: true, get: function() {
    return escape_js_2.escapeAttribute;
  } });
  Object.defineProperty(exports, "escapeText", { enumerable: true, get: function() {
    return escape_js_2.escapeText;
  } });
  var encode_js_2 = require_encode();
  Object.defineProperty(exports, "encodeHTML", { enumerable: true, get: function() {
    return encode_js_2.encodeHTML;
  } });
  Object.defineProperty(exports, "encodeNonAsciiHTML", { enumerable: true, get: function() {
    return encode_js_2.encodeNonAsciiHTML;
  } });
  Object.defineProperty(exports, "encodeHTML4", { enumerable: true, get: function() {
    return encode_js_2.encodeHTML;
  } });
  Object.defineProperty(exports, "encodeHTML5", { enumerable: true, get: function() {
    return encode_js_2.encodeHTML;
  } });
  var decode_js_2 = require_decode();
  Object.defineProperty(exports, "EntityDecoder", { enumerable: true, get: function() {
    return decode_js_2.EntityDecoder;
  } });
  Object.defineProperty(exports, "DecodingMode", { enumerable: true, get: function() {
    return decode_js_2.DecodingMode;
  } });
  Object.defineProperty(exports, "decodeXML", { enumerable: true, get: function() {
    return decode_js_2.decodeXML;
  } });
  Object.defineProperty(exports, "decodeHTML", { enumerable: true, get: function() {
    return decode_js_2.decodeHTML;
  } });
  Object.defineProperty(exports, "decodeHTMLStrict", { enumerable: true, get: function() {
    return decode_js_2.decodeHTMLStrict;
  } });
  Object.defineProperty(exports, "decodeHTMLAttribute", { enumerable: true, get: function() {
    return decode_js_2.decodeHTMLAttribute;
  } });
  Object.defineProperty(exports, "decodeHTML4", { enumerable: true, get: function() {
    return decode_js_2.decodeHTML;
  } });
  Object.defineProperty(exports, "decodeHTML5", { enumerable: true, get: function() {
    return decode_js_2.decodeHTML;
  } });
  Object.defineProperty(exports, "decodeHTML4Strict", { enumerable: true, get: function() {
    return decode_js_2.decodeHTMLStrict;
  } });
  Object.defineProperty(exports, "decodeHTML5Strict", { enumerable: true, get: function() {
    return decode_js_2.decodeHTMLStrict;
  } });
  Object.defineProperty(exports, "decodeXMLStrict", { enumerable: true, get: function() {
    return decode_js_2.decodeXML;
  } });
});

// ../../../../node_modules/.bun/dom-serializer@2.0.0/node_modules/dom-serializer/lib/foreignNames.js
var require_foreignNames = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.attributeNames = exports.elementNames = undefined;
  exports.elementNames = new Map([
    "altGlyph",
    "altGlyphDef",
    "altGlyphItem",
    "animateColor",
    "animateMotion",
    "animateTransform",
    "clipPath",
    "feBlend",
    "feColorMatrix",
    "feComponentTransfer",
    "feComposite",
    "feConvolveMatrix",
    "feDiffuseLighting",
    "feDisplacementMap",
    "feDistantLight",
    "feDropShadow",
    "feFlood",
    "feFuncA",
    "feFuncB",
    "feFuncG",
    "feFuncR",
    "feGaussianBlur",
    "feImage",
    "feMerge",
    "feMergeNode",
    "feMorphology",
    "feOffset",
    "fePointLight",
    "feSpecularLighting",
    "feSpotLight",
    "feTile",
    "feTurbulence",
    "foreignObject",
    "glyphRef",
    "linearGradient",
    "radialGradient",
    "textPath"
  ].map(function(val) {
    return [val.toLowerCase(), val];
  }));
  exports.attributeNames = new Map([
    "definitionURL",
    "attributeName",
    "attributeType",
    "baseFrequency",
    "baseProfile",
    "calcMode",
    "clipPathUnits",
    "diffuseConstant",
    "edgeMode",
    "filterUnits",
    "glyphRef",
    "gradientTransform",
    "gradientUnits",
    "kernelMatrix",
    "kernelUnitLength",
    "keyPoints",
    "keySplines",
    "keyTimes",
    "lengthAdjust",
    "limitingConeAngle",
    "markerHeight",
    "markerUnits",
    "markerWidth",
    "maskContentUnits",
    "maskUnits",
    "numOctaves",
    "pathLength",
    "patternContentUnits",
    "patternTransform",
    "patternUnits",
    "pointsAtX",
    "pointsAtY",
    "pointsAtZ",
    "preserveAlpha",
    "preserveAspectRatio",
    "primitiveUnits",
    "refX",
    "refY",
    "repeatCount",
    "repeatDur",
    "requiredExtensions",
    "requiredFeatures",
    "specularConstant",
    "specularExponent",
    "spreadMethod",
    "startOffset",
    "stdDeviation",
    "stitchTiles",
    "surfaceScale",
    "systemLanguage",
    "tableValues",
    "targetX",
    "targetY",
    "textLength",
    "viewBox",
    "viewTarget",
    "xChannelSelector",
    "yChannelSelector",
    "zoomAndPan"
  ].map(function(val) {
    return [val.toLowerCase(), val];
  }));
});

// ../../../../node_modules/.bun/dom-serializer@2.0.0/node_modules/dom-serializer/lib/index.js
var require_lib4 = __commonJS((exports) => {
  var __assign = exports && exports.__assign || function() {
    __assign = Object.assign || function(t) {
      for (var s, i = 1, n = arguments.length;i < n; i++) {
        s = arguments[i];
        for (var p in s)
          if (Object.prototype.hasOwnProperty.call(s, p))
            t[p] = s[p];
      }
      return t;
    };
    return __assign.apply(this, arguments);
  };
  var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() {
        return m[k];
      } };
    }
    Object.defineProperty(o, k2, desc);
  } : function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    o[k2] = m[k];
  });
  var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
  } : function(o, v) {
    o["default"] = v;
  });
  var __importStar = exports && exports.__importStar || function(mod) {
    if (mod && mod.__esModule)
      return mod;
    var result = {};
    if (mod != null) {
      for (var k in mod)
        if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
          __createBinding(result, mod, k);
    }
    __setModuleDefault(result, mod);
    return result;
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.render = undefined;
  var ElementType = __importStar(require_lib());
  var entities_1 = require_lib3();
  var foreignNames_js_1 = require_foreignNames();
  var unencodedElements = new Set([
    "style",
    "script",
    "xmp",
    "iframe",
    "noembed",
    "noframes",
    "plaintext",
    "noscript"
  ]);
  function replaceQuotes(value) {
    return value.replace(/"/g, "&quot;");
  }
  function formatAttributes(attributes, opts) {
    var _a;
    if (!attributes)
      return;
    var encode = ((_a = opts.encodeEntities) !== null && _a !== undefined ? _a : opts.decodeEntities) === false ? replaceQuotes : opts.xmlMode || opts.encodeEntities !== "utf8" ? entities_1.encodeXML : entities_1.escapeAttribute;
    return Object.keys(attributes).map(function(key) {
      var _a2, _b;
      var value = (_a2 = attributes[key]) !== null && _a2 !== undefined ? _a2 : "";
      if (opts.xmlMode === "foreign") {
        key = (_b = foreignNames_js_1.attributeNames.get(key)) !== null && _b !== undefined ? _b : key;
      }
      if (!opts.emptyAttrs && !opts.xmlMode && value === "") {
        return key;
      }
      return "".concat(key, '="').concat(encode(value), '"');
    }).join(" ");
  }
  var singleTag = new Set([
    "area",
    "base",
    "basefont",
    "br",
    "col",
    "command",
    "embed",
    "frame",
    "hr",
    "img",
    "input",
    "isindex",
    "keygen",
    "link",
    "meta",
    "param",
    "source",
    "track",
    "wbr"
  ]);
  function render(node, options) {
    if (options === undefined) {
      options = {};
    }
    var nodes = "length" in node ? node : [node];
    var output = "";
    for (var i = 0;i < nodes.length; i++) {
      output += renderNode(nodes[i], options);
    }
    return output;
  }
  exports.render = render;
  exports.default = render;
  function renderNode(node, options) {
    switch (node.type) {
      case ElementType.Root:
        return render(node.children, options);
      case ElementType.Doctype:
      case ElementType.Directive:
        return renderDirective(node);
      case ElementType.Comment:
        return renderComment(node);
      case ElementType.CDATA:
        return renderCdata(node);
      case ElementType.Script:
      case ElementType.Style:
      case ElementType.Tag:
        return renderTag(node, options);
      case ElementType.Text:
        return renderText(node, options);
    }
  }
  var foreignModeIntegrationPoints = new Set([
    "mi",
    "mo",
    "mn",
    "ms",
    "mtext",
    "annotation-xml",
    "foreignObject",
    "desc",
    "title"
  ]);
  var foreignElements = new Set(["svg", "math"]);
  function renderTag(elem, opts) {
    var _a;
    if (opts.xmlMode === "foreign") {
      elem.name = (_a = foreignNames_js_1.elementNames.get(elem.name)) !== null && _a !== undefined ? _a : elem.name;
      if (elem.parent && foreignModeIntegrationPoints.has(elem.parent.name)) {
        opts = __assign(__assign({}, opts), { xmlMode: false });
      }
    }
    if (!opts.xmlMode && foreignElements.has(elem.name)) {
      opts = __assign(__assign({}, opts), { xmlMode: "foreign" });
    }
    var tag = "<".concat(elem.name);
    var attribs = formatAttributes(elem.attribs, opts);
    if (attribs) {
      tag += " ".concat(attribs);
    }
    if (elem.children.length === 0 && (opts.xmlMode ? opts.selfClosingTags !== false : opts.selfClosingTags && singleTag.has(elem.name))) {
      if (!opts.xmlMode)
        tag += " ";
      tag += "/>";
    } else {
      tag += ">";
      if (elem.children.length > 0) {
        tag += render(elem.children, opts);
      }
      if (opts.xmlMode || !singleTag.has(elem.name)) {
        tag += "</".concat(elem.name, ">");
      }
    }
    return tag;
  }
  function renderDirective(elem) {
    return "<".concat(elem.data, ">");
  }
  function renderText(elem, opts) {
    var _a;
    var data = elem.data || "";
    if (((_a = opts.encodeEntities) !== null && _a !== undefined ? _a : opts.decodeEntities) !== false && !(!opts.xmlMode && elem.parent && unencodedElements.has(elem.parent.name))) {
      data = opts.xmlMode || opts.encodeEntities !== "utf8" ? (0, entities_1.encodeXML)(data) : (0, entities_1.escapeText)(data);
    }
    return data;
  }
  function renderCdata(elem) {
    return "<![CDATA[".concat(elem.children[0].data, "]]>");
  }
  function renderComment(elem) {
    return "<!--".concat(elem.data, "-->");
  }
});

// ../../../../node_modules/.bun/domutils@3.2.2/node_modules/domutils/lib/stringify.js
var require_stringify = __commonJS((exports) => {
  var __importDefault = exports && exports.__importDefault || function(mod) {
    return mod && mod.__esModule ? mod : { default: mod };
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.getOuterHTML = getOuterHTML;
  exports.getInnerHTML = getInnerHTML;
  exports.getText = getText;
  exports.textContent = textContent;
  exports.innerText = innerText;
  var domhandler_1 = require_lib2();
  var dom_serializer_1 = __importDefault(require_lib4());
  var domelementtype_1 = require_lib();
  function getOuterHTML(node, options) {
    return (0, dom_serializer_1.default)(node, options);
  }
  function getInnerHTML(node, options) {
    return (0, domhandler_1.hasChildren)(node) ? node.children.map(function(node2) {
      return getOuterHTML(node2, options);
    }).join("") : "";
  }
  function getText(node) {
    if (Array.isArray(node))
      return node.map(getText).join("");
    if ((0, domhandler_1.isTag)(node))
      return node.name === "br" ? `
` : getText(node.children);
    if ((0, domhandler_1.isCDATA)(node))
      return getText(node.children);
    if ((0, domhandler_1.isText)(node))
      return node.data;
    return "";
  }
  function textContent(node) {
    if (Array.isArray(node))
      return node.map(textContent).join("");
    if ((0, domhandler_1.hasChildren)(node) && !(0, domhandler_1.isComment)(node)) {
      return textContent(node.children);
    }
    if ((0, domhandler_1.isText)(node))
      return node.data;
    return "";
  }
  function innerText(node) {
    if (Array.isArray(node))
      return node.map(innerText).join("");
    if ((0, domhandler_1.hasChildren)(node) && (node.type === domelementtype_1.ElementType.Tag || (0, domhandler_1.isCDATA)(node))) {
      return innerText(node.children);
    }
    if ((0, domhandler_1.isText)(node))
      return node.data;
    return "";
  }
});

// ../../../../node_modules/.bun/domutils@3.2.2/node_modules/domutils/lib/traversal.js
var require_traversal = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.getChildren = getChildren;
  exports.getParent = getParent;
  exports.getSiblings = getSiblings;
  exports.getAttributeValue = getAttributeValue;
  exports.hasAttrib = hasAttrib;
  exports.getName = getName;
  exports.nextElementSibling = nextElementSibling;
  exports.prevElementSibling = prevElementSibling;
  var domhandler_1 = require_lib2();
  function getChildren(elem) {
    return (0, domhandler_1.hasChildren)(elem) ? elem.children : [];
  }
  function getParent(elem) {
    return elem.parent || null;
  }
  function getSiblings(elem) {
    var _a, _b;
    var parent = getParent(elem);
    if (parent != null)
      return getChildren(parent);
    var siblings = [elem];
    var { prev, next } = elem;
    while (prev != null) {
      siblings.unshift(prev);
      _a = prev, prev = _a.prev;
    }
    while (next != null) {
      siblings.push(next);
      _b = next, next = _b.next;
    }
    return siblings;
  }
  function getAttributeValue(elem, name) {
    var _a;
    return (_a = elem.attribs) === null || _a === undefined ? undefined : _a[name];
  }
  function hasAttrib(elem, name) {
    return elem.attribs != null && Object.prototype.hasOwnProperty.call(elem.attribs, name) && elem.attribs[name] != null;
  }
  function getName(elem) {
    return elem.name;
  }
  function nextElementSibling(elem) {
    var _a;
    var next = elem.next;
    while (next !== null && !(0, domhandler_1.isTag)(next))
      _a = next, next = _a.next;
    return next;
  }
  function prevElementSibling(elem) {
    var _a;
    var prev = elem.prev;
    while (prev !== null && !(0, domhandler_1.isTag)(prev))
      _a = prev, prev = _a.prev;
    return prev;
  }
});

// ../../../../node_modules/.bun/domutils@3.2.2/node_modules/domutils/lib/manipulation.js
var require_manipulation = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.removeElement = removeElement;
  exports.replaceElement = replaceElement;
  exports.appendChild = appendChild;
  exports.append = append;
  exports.prependChild = prependChild;
  exports.prepend = prepend;
  function removeElement(elem) {
    if (elem.prev)
      elem.prev.next = elem.next;
    if (elem.next)
      elem.next.prev = elem.prev;
    if (elem.parent) {
      var childs = elem.parent.children;
      var childsIndex = childs.lastIndexOf(elem);
      if (childsIndex >= 0) {
        childs.splice(childsIndex, 1);
      }
    }
    elem.next = null;
    elem.prev = null;
    elem.parent = null;
  }
  function replaceElement(elem, replacement) {
    var prev = replacement.prev = elem.prev;
    if (prev) {
      prev.next = replacement;
    }
    var next = replacement.next = elem.next;
    if (next) {
      next.prev = replacement;
    }
    var parent = replacement.parent = elem.parent;
    if (parent) {
      var childs = parent.children;
      childs[childs.lastIndexOf(elem)] = replacement;
      elem.parent = null;
    }
  }
  function appendChild(parent, child) {
    removeElement(child);
    child.next = null;
    child.parent = parent;
    if (parent.children.push(child) > 1) {
      var sibling = parent.children[parent.children.length - 2];
      sibling.next = child;
      child.prev = sibling;
    } else {
      child.prev = null;
    }
  }
  function append(elem, next) {
    removeElement(next);
    var parent = elem.parent;
    var currNext = elem.next;
    next.next = currNext;
    next.prev = elem;
    elem.next = next;
    next.parent = parent;
    if (currNext) {
      currNext.prev = next;
      if (parent) {
        var childs = parent.children;
        childs.splice(childs.lastIndexOf(currNext), 0, next);
      }
    } else if (parent) {
      parent.children.push(next);
    }
  }
  function prependChild(parent, child) {
    removeElement(child);
    child.parent = parent;
    child.prev = null;
    if (parent.children.unshift(child) !== 1) {
      var sibling = parent.children[1];
      sibling.prev = child;
      child.next = sibling;
    } else {
      child.next = null;
    }
  }
  function prepend(elem, prev) {
    removeElement(prev);
    var parent = elem.parent;
    if (parent) {
      var childs = parent.children;
      childs.splice(childs.indexOf(elem), 0, prev);
    }
    if (elem.prev) {
      elem.prev.next = prev;
    }
    prev.parent = parent;
    prev.prev = elem.prev;
    prev.next = elem;
    elem.prev = prev;
  }
});

// ../../../../node_modules/.bun/domutils@3.2.2/node_modules/domutils/lib/querying.js
var require_querying = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.filter = filter;
  exports.find = find;
  exports.findOneChild = findOneChild;
  exports.findOne = findOne;
  exports.existsOne = existsOne;
  exports.findAll = findAll;
  var domhandler_1 = require_lib2();
  function filter(test, node, recurse, limit) {
    if (recurse === undefined) {
      recurse = true;
    }
    if (limit === undefined) {
      limit = Infinity;
    }
    return find(test, Array.isArray(node) ? node : [node], recurse, limit);
  }
  function find(test, nodes, recurse, limit) {
    var result = [];
    var nodeStack = [Array.isArray(nodes) ? nodes : [nodes]];
    var indexStack = [0];
    for (;; ) {
      if (indexStack[0] >= nodeStack[0].length) {
        if (indexStack.length === 1) {
          return result;
        }
        nodeStack.shift();
        indexStack.shift();
        continue;
      }
      var elem = nodeStack[0][indexStack[0]++];
      if (test(elem)) {
        result.push(elem);
        if (--limit <= 0)
          return result;
      }
      if (recurse && (0, domhandler_1.hasChildren)(elem) && elem.children.length > 0) {
        indexStack.unshift(0);
        nodeStack.unshift(elem.children);
      }
    }
  }
  function findOneChild(test, nodes) {
    return nodes.find(test);
  }
  function findOne(test, nodes, recurse) {
    if (recurse === undefined) {
      recurse = true;
    }
    var searchedNodes = Array.isArray(nodes) ? nodes : [nodes];
    for (var i = 0;i < searchedNodes.length; i++) {
      var node = searchedNodes[i];
      if ((0, domhandler_1.isTag)(node) && test(node)) {
        return node;
      }
      if (recurse && (0, domhandler_1.hasChildren)(node) && node.children.length > 0) {
        var found = findOne(test, node.children, true);
        if (found)
          return found;
      }
    }
    return null;
  }
  function existsOne(test, nodes) {
    return (Array.isArray(nodes) ? nodes : [nodes]).some(function(node) {
      return (0, domhandler_1.isTag)(node) && test(node) || (0, domhandler_1.hasChildren)(node) && existsOne(test, node.children);
    });
  }
  function findAll(test, nodes) {
    var result = [];
    var nodeStack = [Array.isArray(nodes) ? nodes : [nodes]];
    var indexStack = [0];
    for (;; ) {
      if (indexStack[0] >= nodeStack[0].length) {
        if (nodeStack.length === 1) {
          return result;
        }
        nodeStack.shift();
        indexStack.shift();
        continue;
      }
      var elem = nodeStack[0][indexStack[0]++];
      if ((0, domhandler_1.isTag)(elem) && test(elem))
        result.push(elem);
      if ((0, domhandler_1.hasChildren)(elem) && elem.children.length > 0) {
        indexStack.unshift(0);
        nodeStack.unshift(elem.children);
      }
    }
  }
});

// ../../../../node_modules/.bun/domutils@3.2.2/node_modules/domutils/lib/legacy.js
var require_legacy = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.testElement = testElement;
  exports.getElements = getElements;
  exports.getElementById = getElementById;
  exports.getElementsByTagName = getElementsByTagName;
  exports.getElementsByClassName = getElementsByClassName;
  exports.getElementsByTagType = getElementsByTagType;
  var domhandler_1 = require_lib2();
  var querying_js_1 = require_querying();
  var Checks = {
    tag_name: function(name) {
      if (typeof name === "function") {
        return function(elem) {
          return (0, domhandler_1.isTag)(elem) && name(elem.name);
        };
      } else if (name === "*") {
        return domhandler_1.isTag;
      }
      return function(elem) {
        return (0, domhandler_1.isTag)(elem) && elem.name === name;
      };
    },
    tag_type: function(type) {
      if (typeof type === "function") {
        return function(elem) {
          return type(elem.type);
        };
      }
      return function(elem) {
        return elem.type === type;
      };
    },
    tag_contains: function(data) {
      if (typeof data === "function") {
        return function(elem) {
          return (0, domhandler_1.isText)(elem) && data(elem.data);
        };
      }
      return function(elem) {
        return (0, domhandler_1.isText)(elem) && elem.data === data;
      };
    }
  };
  function getAttribCheck(attrib, value) {
    if (typeof value === "function") {
      return function(elem) {
        return (0, domhandler_1.isTag)(elem) && value(elem.attribs[attrib]);
      };
    }
    return function(elem) {
      return (0, domhandler_1.isTag)(elem) && elem.attribs[attrib] === value;
    };
  }
  function combineFuncs(a, b) {
    return function(elem) {
      return a(elem) || b(elem);
    };
  }
  function compileTest(options) {
    var funcs = Object.keys(options).map(function(key) {
      var value = options[key];
      return Object.prototype.hasOwnProperty.call(Checks, key) ? Checks[key](value) : getAttribCheck(key, value);
    });
    return funcs.length === 0 ? null : funcs.reduce(combineFuncs);
  }
  function testElement(options, node) {
    var test = compileTest(options);
    return test ? test(node) : true;
  }
  function getElements(options, nodes, recurse, limit) {
    if (limit === undefined) {
      limit = Infinity;
    }
    var test = compileTest(options);
    return test ? (0, querying_js_1.filter)(test, nodes, recurse, limit) : [];
  }
  function getElementById(id, nodes, recurse) {
    if (recurse === undefined) {
      recurse = true;
    }
    if (!Array.isArray(nodes))
      nodes = [nodes];
    return (0, querying_js_1.findOne)(getAttribCheck("id", id), nodes, recurse);
  }
  function getElementsByTagName(tagName, nodes, recurse, limit) {
    if (recurse === undefined) {
      recurse = true;
    }
    if (limit === undefined) {
      limit = Infinity;
    }
    return (0, querying_js_1.filter)(Checks["tag_name"](tagName), nodes, recurse, limit);
  }
  function getElementsByClassName(className, nodes, recurse, limit) {
    if (recurse === undefined) {
      recurse = true;
    }
    if (limit === undefined) {
      limit = Infinity;
    }
    return (0, querying_js_1.filter)(getAttribCheck("class", className), nodes, recurse, limit);
  }
  function getElementsByTagType(type, nodes, recurse, limit) {
    if (recurse === undefined) {
      recurse = true;
    }
    if (limit === undefined) {
      limit = Infinity;
    }
    return (0, querying_js_1.filter)(Checks["tag_type"](type), nodes, recurse, limit);
  }
});

// ../../../../node_modules/.bun/domutils@3.2.2/node_modules/domutils/lib/helpers.js
var require_helpers = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.DocumentPosition = undefined;
  exports.removeSubsets = removeSubsets;
  exports.compareDocumentPosition = compareDocumentPosition;
  exports.uniqueSort = uniqueSort;
  var domhandler_1 = require_lib2();
  function removeSubsets(nodes) {
    var idx = nodes.length;
    while (--idx >= 0) {
      var node = nodes[idx];
      if (idx > 0 && nodes.lastIndexOf(node, idx - 1) >= 0) {
        nodes.splice(idx, 1);
        continue;
      }
      for (var ancestor = node.parent;ancestor; ancestor = ancestor.parent) {
        if (nodes.includes(ancestor)) {
          nodes.splice(idx, 1);
          break;
        }
      }
    }
    return nodes;
  }
  var DocumentPosition;
  (function(DocumentPosition2) {
    DocumentPosition2[DocumentPosition2["DISCONNECTED"] = 1] = "DISCONNECTED";
    DocumentPosition2[DocumentPosition2["PRECEDING"] = 2] = "PRECEDING";
    DocumentPosition2[DocumentPosition2["FOLLOWING"] = 4] = "FOLLOWING";
    DocumentPosition2[DocumentPosition2["CONTAINS"] = 8] = "CONTAINS";
    DocumentPosition2[DocumentPosition2["CONTAINED_BY"] = 16] = "CONTAINED_BY";
  })(DocumentPosition || (exports.DocumentPosition = DocumentPosition = {}));
  function compareDocumentPosition(nodeA, nodeB) {
    var aParents = [];
    var bParents = [];
    if (nodeA === nodeB) {
      return 0;
    }
    var current = (0, domhandler_1.hasChildren)(nodeA) ? nodeA : nodeA.parent;
    while (current) {
      aParents.unshift(current);
      current = current.parent;
    }
    current = (0, domhandler_1.hasChildren)(nodeB) ? nodeB : nodeB.parent;
    while (current) {
      bParents.unshift(current);
      current = current.parent;
    }
    var maxIdx = Math.min(aParents.length, bParents.length);
    var idx = 0;
    while (idx < maxIdx && aParents[idx] === bParents[idx]) {
      idx++;
    }
    if (idx === 0) {
      return DocumentPosition.DISCONNECTED;
    }
    var sharedParent = aParents[idx - 1];
    var siblings = sharedParent.children;
    var aSibling = aParents[idx];
    var bSibling = bParents[idx];
    if (siblings.indexOf(aSibling) > siblings.indexOf(bSibling)) {
      if (sharedParent === nodeB) {
        return DocumentPosition.FOLLOWING | DocumentPosition.CONTAINED_BY;
      }
      return DocumentPosition.FOLLOWING;
    }
    if (sharedParent === nodeA) {
      return DocumentPosition.PRECEDING | DocumentPosition.CONTAINS;
    }
    return DocumentPosition.PRECEDING;
  }
  function uniqueSort(nodes) {
    nodes = nodes.filter(function(node, i, arr) {
      return !arr.includes(node, i + 1);
    });
    nodes.sort(function(a, b) {
      var relative = compareDocumentPosition(a, b);
      if (relative & DocumentPosition.PRECEDING) {
        return -1;
      } else if (relative & DocumentPosition.FOLLOWING) {
        return 1;
      }
      return 0;
    });
    return nodes;
  }
});

// ../../../../node_modules/.bun/domutils@3.2.2/node_modules/domutils/lib/feeds.js
var require_feeds = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.getFeed = getFeed;
  var stringify_js_1 = require_stringify();
  var legacy_js_1 = require_legacy();
  function getFeed(doc) {
    var feedRoot = getOneElement(isValidFeed, doc);
    return !feedRoot ? null : feedRoot.name === "feed" ? getAtomFeed(feedRoot) : getRssFeed(feedRoot);
  }
  function getAtomFeed(feedRoot) {
    var _a;
    var childs = feedRoot.children;
    var feed = {
      type: "atom",
      items: (0, legacy_js_1.getElementsByTagName)("entry", childs).map(function(item) {
        var _a2;
        var children = item.children;
        var entry = { media: getMediaElements(children) };
        addConditionally(entry, "id", "id", children);
        addConditionally(entry, "title", "title", children);
        var href2 = (_a2 = getOneElement("link", children)) === null || _a2 === undefined ? undefined : _a2.attribs["href"];
        if (href2) {
          entry.link = href2;
        }
        var description = fetch("summary", children) || fetch("content", children);
        if (description) {
          entry.description = description;
        }
        var pubDate = fetch("updated", children);
        if (pubDate) {
          entry.pubDate = new Date(pubDate);
        }
        return entry;
      })
    };
    addConditionally(feed, "id", "id", childs);
    addConditionally(feed, "title", "title", childs);
    var href = (_a = getOneElement("link", childs)) === null || _a === undefined ? undefined : _a.attribs["href"];
    if (href) {
      feed.link = href;
    }
    addConditionally(feed, "description", "subtitle", childs);
    var updated = fetch("updated", childs);
    if (updated) {
      feed.updated = new Date(updated);
    }
    addConditionally(feed, "author", "email", childs, true);
    return feed;
  }
  function getRssFeed(feedRoot) {
    var _a, _b;
    var childs = (_b = (_a = getOneElement("channel", feedRoot.children)) === null || _a === undefined ? undefined : _a.children) !== null && _b !== undefined ? _b : [];
    var feed = {
      type: feedRoot.name.substr(0, 3),
      id: "",
      items: (0, legacy_js_1.getElementsByTagName)("item", feedRoot.children).map(function(item) {
        var children = item.children;
        var entry = { media: getMediaElements(children) };
        addConditionally(entry, "id", "guid", children);
        addConditionally(entry, "title", "title", children);
        addConditionally(entry, "link", "link", children);
        addConditionally(entry, "description", "description", children);
        var pubDate = fetch("pubDate", children) || fetch("dc:date", children);
        if (pubDate)
          entry.pubDate = new Date(pubDate);
        return entry;
      })
    };
    addConditionally(feed, "title", "title", childs);
    addConditionally(feed, "link", "link", childs);
    addConditionally(feed, "description", "description", childs);
    var updated = fetch("lastBuildDate", childs);
    if (updated) {
      feed.updated = new Date(updated);
    }
    addConditionally(feed, "author", "managingEditor", childs, true);
    return feed;
  }
  var MEDIA_KEYS_STRING = ["url", "type", "lang"];
  var MEDIA_KEYS_INT = [
    "fileSize",
    "bitrate",
    "framerate",
    "samplingrate",
    "channels",
    "duration",
    "height",
    "width"
  ];
  function getMediaElements(where) {
    return (0, legacy_js_1.getElementsByTagName)("media:content", where).map(function(elem) {
      var attribs = elem.attribs;
      var media = {
        medium: attribs["medium"],
        isDefault: !!attribs["isDefault"]
      };
      for (var _i = 0, MEDIA_KEYS_STRING_1 = MEDIA_KEYS_STRING;_i < MEDIA_KEYS_STRING_1.length; _i++) {
        var attrib = MEDIA_KEYS_STRING_1[_i];
        if (attribs[attrib]) {
          media[attrib] = attribs[attrib];
        }
      }
      for (var _a = 0, MEDIA_KEYS_INT_1 = MEDIA_KEYS_INT;_a < MEDIA_KEYS_INT_1.length; _a++) {
        var attrib = MEDIA_KEYS_INT_1[_a];
        if (attribs[attrib]) {
          media[attrib] = parseInt(attribs[attrib], 10);
        }
      }
      if (attribs["expression"]) {
        media.expression = attribs["expression"];
      }
      return media;
    });
  }
  function getOneElement(tagName, node) {
    return (0, legacy_js_1.getElementsByTagName)(tagName, node, true, 1)[0];
  }
  function fetch(tagName, where, recurse) {
    if (recurse === undefined) {
      recurse = false;
    }
    return (0, stringify_js_1.textContent)((0, legacy_js_1.getElementsByTagName)(tagName, where, recurse, 1)).trim();
  }
  function addConditionally(obj, prop, tagName, where, recurse) {
    if (recurse === undefined) {
      recurse = false;
    }
    var val = fetch(tagName, where, recurse);
    if (val)
      obj[prop] = val;
  }
  function isValidFeed(value) {
    return value === "rss" || value === "feed" || value === "rdf:RDF";
  }
});

// ../../../../node_modules/.bun/domutils@3.2.2/node_modules/domutils/lib/index.js
var require_lib5 = __commonJS((exports) => {
  var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() {
        return m[k];
      } };
    }
    Object.defineProperty(o, k2, desc);
  } : function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    o[k2] = m[k];
  });
  var __exportStar = exports && exports.__exportStar || function(m, exports2) {
    for (var p in m)
      if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p))
        __createBinding(exports2, m, p);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.hasChildren = exports.isDocument = exports.isComment = exports.isText = exports.isCDATA = exports.isTag = undefined;
  __exportStar(require_stringify(), exports);
  __exportStar(require_traversal(), exports);
  __exportStar(require_manipulation(), exports);
  __exportStar(require_querying(), exports);
  __exportStar(require_legacy(), exports);
  __exportStar(require_helpers(), exports);
  __exportStar(require_feeds(), exports);
  var domhandler_1 = require_lib2();
  Object.defineProperty(exports, "isTag", { enumerable: true, get: function() {
    return domhandler_1.isTag;
  } });
  Object.defineProperty(exports, "isCDATA", { enumerable: true, get: function() {
    return domhandler_1.isCDATA;
  } });
  Object.defineProperty(exports, "isText", { enumerable: true, get: function() {
    return domhandler_1.isText;
  } });
  Object.defineProperty(exports, "isComment", { enumerable: true, get: function() {
    return domhandler_1.isComment;
  } });
  Object.defineProperty(exports, "isDocument", { enumerable: true, get: function() {
    return domhandler_1.isDocument;
  } });
  Object.defineProperty(exports, "hasChildren", { enumerable: true, get: function() {
    return domhandler_1.hasChildren;
  } });
});

// ../../../../node_modules/.bun/boolbase@1.0.0/node_modules/boolbase/index.js
var require_boolbase = __commonJS((exports, module) => {
  module.exports = {
    trueFunc: function trueFunc() {
      return true;
    },
    falseFunc: function falseFunc() {
      return false;
    }
  };
});

// ../../../../node_modules/.bun/css-what@6.2.2/node_modules/css-what/lib/commonjs/types.js
var require_types = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.AttributeAction = exports.IgnoreCaseMode = exports.SelectorType = undefined;
  var SelectorType;
  (function(SelectorType2) {
    SelectorType2["Attribute"] = "attribute";
    SelectorType2["Pseudo"] = "pseudo";
    SelectorType2["PseudoElement"] = "pseudo-element";
    SelectorType2["Tag"] = "tag";
    SelectorType2["Universal"] = "universal";
    SelectorType2["Adjacent"] = "adjacent";
    SelectorType2["Child"] = "child";
    SelectorType2["Descendant"] = "descendant";
    SelectorType2["Parent"] = "parent";
    SelectorType2["Sibling"] = "sibling";
    SelectorType2["ColumnCombinator"] = "column-combinator";
  })(SelectorType = exports.SelectorType || (exports.SelectorType = {}));
  exports.IgnoreCaseMode = {
    Unknown: null,
    QuirksMode: "quirks",
    IgnoreCase: true,
    CaseSensitive: false
  };
  var AttributeAction;
  (function(AttributeAction2) {
    AttributeAction2["Any"] = "any";
    AttributeAction2["Element"] = "element";
    AttributeAction2["End"] = "end";
    AttributeAction2["Equals"] = "equals";
    AttributeAction2["Exists"] = "exists";
    AttributeAction2["Hyphen"] = "hyphen";
    AttributeAction2["Not"] = "not";
    AttributeAction2["Start"] = "start";
  })(AttributeAction = exports.AttributeAction || (exports.AttributeAction = {}));
});

// ../../../../node_modules/.bun/css-what@6.2.2/node_modules/css-what/lib/commonjs/parse.js
var require_parse = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.parse = exports.isTraversal = undefined;
  var types_1 = require_types();
  var reName = /^[^\\#]?(?:\\(?:[\da-f]{1,6}\s?|.)|[\w\-\u00b0-\uFFFF])+/;
  var reEscape = /\\([\da-f]{1,6}\s?|(\s)|.)/gi;
  var actionTypes = new Map([
    [126, types_1.AttributeAction.Element],
    [94, types_1.AttributeAction.Start],
    [36, types_1.AttributeAction.End],
    [42, types_1.AttributeAction.Any],
    [33, types_1.AttributeAction.Not],
    [124, types_1.AttributeAction.Hyphen]
  ]);
  var unpackPseudos = new Set([
    "has",
    "not",
    "matches",
    "is",
    "where",
    "host",
    "host-context"
  ]);
  function isTraversal(selector) {
    switch (selector.type) {
      case types_1.SelectorType.Adjacent:
      case types_1.SelectorType.Child:
      case types_1.SelectorType.Descendant:
      case types_1.SelectorType.Parent:
      case types_1.SelectorType.Sibling:
      case types_1.SelectorType.ColumnCombinator:
        return true;
      default:
        return false;
    }
  }
  exports.isTraversal = isTraversal;
  var stripQuotesFromPseudos = new Set(["contains", "icontains"]);
  function funescape(_, escaped, escapedWhitespace) {
    var high = parseInt(escaped, 16) - 65536;
    return high !== high || escapedWhitespace ? escaped : high < 0 ? String.fromCharCode(high + 65536) : String.fromCharCode(high >> 10 | 55296, high & 1023 | 56320);
  }
  function unescapeCSS(str) {
    return str.replace(reEscape, funescape);
  }
  function isQuote(c) {
    return c === 39 || c === 34;
  }
  function isWhitespace(c) {
    return c === 32 || c === 9 || c === 10 || c === 12 || c === 13;
  }
  function parse(selector) {
    var subselects = [];
    var endIndex = parseSelector(subselects, "".concat(selector), 0);
    if (endIndex < selector.length) {
      throw new Error("Unmatched selector: ".concat(selector.slice(endIndex)));
    }
    return subselects;
  }
  exports.parse = parse;
  function parseSelector(subselects, selector, selectorIndex) {
    var tokens = [];
    function getName(offset) {
      var match = selector.slice(selectorIndex + offset).match(reName);
      if (!match) {
        throw new Error("Expected name, found ".concat(selector.slice(selectorIndex)));
      }
      var name = match[0];
      selectorIndex += offset + name.length;
      return unescapeCSS(name);
    }
    function stripWhitespace(offset) {
      selectorIndex += offset;
      while (selectorIndex < selector.length && isWhitespace(selector.charCodeAt(selectorIndex))) {
        selectorIndex++;
      }
    }
    function readValueWithParenthesis() {
      selectorIndex += 1;
      var start = selectorIndex;
      var counter = 1;
      for (;counter > 0 && selectorIndex < selector.length; selectorIndex++) {
        if (selector.charCodeAt(selectorIndex) === 40 && !isEscaped(selectorIndex)) {
          counter++;
        } else if (selector.charCodeAt(selectorIndex) === 41 && !isEscaped(selectorIndex)) {
          counter--;
        }
      }
      if (counter) {
        throw new Error("Parenthesis not matched");
      }
      return unescapeCSS(selector.slice(start, selectorIndex - 1));
    }
    function isEscaped(pos) {
      var slashCount = 0;
      while (selector.charCodeAt(--pos) === 92)
        slashCount++;
      return (slashCount & 1) === 1;
    }
    function ensureNotTraversal() {
      if (tokens.length > 0 && isTraversal(tokens[tokens.length - 1])) {
        throw new Error("Did not expect successive traversals.");
      }
    }
    function addTraversal(type) {
      if (tokens.length > 0 && tokens[tokens.length - 1].type === types_1.SelectorType.Descendant) {
        tokens[tokens.length - 1].type = type;
        return;
      }
      ensureNotTraversal();
      tokens.push({ type });
    }
    function addSpecialAttribute(name, action2) {
      tokens.push({
        type: types_1.SelectorType.Attribute,
        name,
        action: action2,
        value: getName(1),
        namespace: null,
        ignoreCase: "quirks"
      });
    }
    function finalizeSubselector() {
      if (tokens.length && tokens[tokens.length - 1].type === types_1.SelectorType.Descendant) {
        tokens.pop();
      }
      if (tokens.length === 0) {
        throw new Error("Empty sub-selector");
      }
      subselects.push(tokens);
    }
    stripWhitespace(0);
    if (selector.length === selectorIndex) {
      return selectorIndex;
    }
    loop:
      while (selectorIndex < selector.length) {
        var firstChar = selector.charCodeAt(selectorIndex);
        switch (firstChar) {
          case 32:
          case 9:
          case 10:
          case 12:
          case 13: {
            if (tokens.length === 0 || tokens[0].type !== types_1.SelectorType.Descendant) {
              ensureNotTraversal();
              tokens.push({ type: types_1.SelectorType.Descendant });
            }
            stripWhitespace(1);
            break;
          }
          case 62: {
            addTraversal(types_1.SelectorType.Child);
            stripWhitespace(1);
            break;
          }
          case 60: {
            addTraversal(types_1.SelectorType.Parent);
            stripWhitespace(1);
            break;
          }
          case 126: {
            addTraversal(types_1.SelectorType.Sibling);
            stripWhitespace(1);
            break;
          }
          case 43: {
            addTraversal(types_1.SelectorType.Adjacent);
            stripWhitespace(1);
            break;
          }
          case 46: {
            addSpecialAttribute("class", types_1.AttributeAction.Element);
            break;
          }
          case 35: {
            addSpecialAttribute("id", types_1.AttributeAction.Equals);
            break;
          }
          case 91: {
            stripWhitespace(1);
            var name_1 = undefined;
            var namespace = null;
            if (selector.charCodeAt(selectorIndex) === 124) {
              name_1 = getName(1);
            } else if (selector.startsWith("*|", selectorIndex)) {
              namespace = "*";
              name_1 = getName(2);
            } else {
              name_1 = getName(0);
              if (selector.charCodeAt(selectorIndex) === 124 && selector.charCodeAt(selectorIndex + 1) !== 61) {
                namespace = name_1;
                name_1 = getName(1);
              }
            }
            stripWhitespace(0);
            var action = types_1.AttributeAction.Exists;
            var possibleAction = actionTypes.get(selector.charCodeAt(selectorIndex));
            if (possibleAction) {
              action = possibleAction;
              if (selector.charCodeAt(selectorIndex + 1) !== 61) {
                throw new Error("Expected `=`");
              }
              stripWhitespace(2);
            } else if (selector.charCodeAt(selectorIndex) === 61) {
              action = types_1.AttributeAction.Equals;
              stripWhitespace(1);
            }
            var value = "";
            var ignoreCase = null;
            if (action !== "exists") {
              if (isQuote(selector.charCodeAt(selectorIndex))) {
                var quote = selector.charCodeAt(selectorIndex);
                var sectionEnd = selectorIndex + 1;
                while (sectionEnd < selector.length && (selector.charCodeAt(sectionEnd) !== quote || isEscaped(sectionEnd))) {
                  sectionEnd += 1;
                }
                if (selector.charCodeAt(sectionEnd) !== quote) {
                  throw new Error("Attribute value didn't end");
                }
                value = unescapeCSS(selector.slice(selectorIndex + 1, sectionEnd));
                selectorIndex = sectionEnd + 1;
              } else {
                var valueStart = selectorIndex;
                while (selectorIndex < selector.length && (!isWhitespace(selector.charCodeAt(selectorIndex)) && selector.charCodeAt(selectorIndex) !== 93 || isEscaped(selectorIndex))) {
                  selectorIndex += 1;
                }
                value = unescapeCSS(selector.slice(valueStart, selectorIndex));
              }
              stripWhitespace(0);
              var forceIgnore = selector.charCodeAt(selectorIndex) | 32;
              if (forceIgnore === 115) {
                ignoreCase = false;
                stripWhitespace(1);
              } else if (forceIgnore === 105) {
                ignoreCase = true;
                stripWhitespace(1);
              }
            }
            if (selector.charCodeAt(selectorIndex) !== 93) {
              throw new Error("Attribute selector didn't terminate");
            }
            selectorIndex += 1;
            var attributeSelector = {
              type: types_1.SelectorType.Attribute,
              name: name_1,
              action,
              value,
              namespace,
              ignoreCase
            };
            tokens.push(attributeSelector);
            break;
          }
          case 58: {
            if (selector.charCodeAt(selectorIndex + 1) === 58) {
              tokens.push({
                type: types_1.SelectorType.PseudoElement,
                name: getName(2).toLowerCase(),
                data: selector.charCodeAt(selectorIndex) === 40 ? readValueWithParenthesis() : null
              });
              continue;
            }
            var name_2 = getName(1).toLowerCase();
            var data = null;
            if (selector.charCodeAt(selectorIndex) === 40) {
              if (unpackPseudos.has(name_2)) {
                if (isQuote(selector.charCodeAt(selectorIndex + 1))) {
                  throw new Error("Pseudo-selector ".concat(name_2, " cannot be quoted"));
                }
                data = [];
                selectorIndex = parseSelector(data, selector, selectorIndex + 1);
                if (selector.charCodeAt(selectorIndex) !== 41) {
                  throw new Error("Missing closing parenthesis in :".concat(name_2, " (").concat(selector, ")"));
                }
                selectorIndex += 1;
              } else {
                data = readValueWithParenthesis();
                if (stripQuotesFromPseudos.has(name_2)) {
                  var quot = data.charCodeAt(0);
                  if (quot === data.charCodeAt(data.length - 1) && isQuote(quot)) {
                    data = data.slice(1, -1);
                  }
                }
                data = unescapeCSS(data);
              }
            }
            tokens.push({ type: types_1.SelectorType.Pseudo, name: name_2, data });
            break;
          }
          case 44: {
            finalizeSubselector();
            tokens = [];
            stripWhitespace(1);
            break;
          }
          default: {
            if (selector.startsWith("/*", selectorIndex)) {
              var endIndex = selector.indexOf("*/", selectorIndex + 2);
              if (endIndex < 0) {
                throw new Error("Comment was not terminated");
              }
              selectorIndex = endIndex + 2;
              if (tokens.length === 0) {
                stripWhitespace(0);
              }
              break;
            }
            var namespace = null;
            var name_3 = undefined;
            if (firstChar === 42) {
              selectorIndex += 1;
              name_3 = "*";
            } else if (firstChar === 124) {
              name_3 = "";
              if (selector.charCodeAt(selectorIndex + 1) === 124) {
                addTraversal(types_1.SelectorType.ColumnCombinator);
                stripWhitespace(2);
                break;
              }
            } else if (reName.test(selector.slice(selectorIndex))) {
              name_3 = getName(0);
            } else {
              break loop;
            }
            if (selector.charCodeAt(selectorIndex) === 124 && selector.charCodeAt(selectorIndex + 1) !== 124) {
              namespace = name_3;
              if (selector.charCodeAt(selectorIndex + 1) === 42) {
                name_3 = "*";
                selectorIndex += 2;
              } else {
                name_3 = getName(1);
              }
            }
            tokens.push(name_3 === "*" ? { type: types_1.SelectorType.Universal, namespace } : { type: types_1.SelectorType.Tag, name: name_3, namespace });
          }
        }
      }
    finalizeSubselector();
    return selectorIndex;
  }
});

// ../../../../node_modules/.bun/css-what@6.2.2/node_modules/css-what/lib/commonjs/stringify.js
var require_stringify2 = __commonJS((exports) => {
  var __spreadArray = exports && exports.__spreadArray || function(to, from, pack) {
    if (pack || arguments.length === 2)
      for (var i = 0, l = from.length, ar;i < l; i++) {
        if (ar || !(i in from)) {
          if (!ar)
            ar = Array.prototype.slice.call(from, 0, i);
          ar[i] = from[i];
        }
      }
    return to.concat(ar || Array.prototype.slice.call(from));
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.stringify = undefined;
  var types_1 = require_types();
  var attribValChars = ["\\", '"'];
  var pseudoValChars = __spreadArray(__spreadArray([], attribValChars, true), ["(", ")"], false);
  var charsToEscapeInAttributeValue = new Set(attribValChars.map(function(c) {
    return c.charCodeAt(0);
  }));
  var charsToEscapeInPseudoValue = new Set(pseudoValChars.map(function(c) {
    return c.charCodeAt(0);
  }));
  var charsToEscapeInName = new Set(__spreadArray(__spreadArray([], pseudoValChars, true), [
    "~",
    "^",
    "$",
    "*",
    "+",
    "!",
    "|",
    ":",
    "[",
    "]",
    " ",
    "."
  ], false).map(function(c) {
    return c.charCodeAt(0);
  }));
  function stringify(selector) {
    return selector.map(function(token) {
      return token.map(stringifyToken).join("");
    }).join(", ");
  }
  exports.stringify = stringify;
  function stringifyToken(token, index, arr) {
    switch (token.type) {
      case types_1.SelectorType.Child:
        return index === 0 ? "> " : " > ";
      case types_1.SelectorType.Parent:
        return index === 0 ? "< " : " < ";
      case types_1.SelectorType.Sibling:
        return index === 0 ? "~ " : " ~ ";
      case types_1.SelectorType.Adjacent:
        return index === 0 ? "+ " : " + ";
      case types_1.SelectorType.Descendant:
        return " ";
      case types_1.SelectorType.ColumnCombinator:
        return index === 0 ? "|| " : " || ";
      case types_1.SelectorType.Universal:
        return token.namespace === "*" && index + 1 < arr.length && "name" in arr[index + 1] ? "" : "".concat(getNamespace(token.namespace), "*");
      case types_1.SelectorType.Tag:
        return getNamespacedName(token);
      case types_1.SelectorType.PseudoElement:
        return "::".concat(escapeName(token.name, charsToEscapeInName)).concat(token.data === null ? "" : "(".concat(escapeName(token.data, charsToEscapeInPseudoValue), ")"));
      case types_1.SelectorType.Pseudo:
        return ":".concat(escapeName(token.name, charsToEscapeInName)).concat(token.data === null ? "" : "(".concat(typeof token.data === "string" ? escapeName(token.data, charsToEscapeInPseudoValue) : stringify(token.data), ")"));
      case types_1.SelectorType.Attribute: {
        if (token.name === "id" && token.action === types_1.AttributeAction.Equals && token.ignoreCase === "quirks" && !token.namespace) {
          return "#".concat(escapeName(token.value, charsToEscapeInName));
        }
        if (token.name === "class" && token.action === types_1.AttributeAction.Element && token.ignoreCase === "quirks" && !token.namespace) {
          return ".".concat(escapeName(token.value, charsToEscapeInName));
        }
        var name_1 = getNamespacedName(token);
        if (token.action === types_1.AttributeAction.Exists) {
          return "[".concat(name_1, "]");
        }
        return "[".concat(name_1).concat(getActionValue(token.action), '="').concat(escapeName(token.value, charsToEscapeInAttributeValue), '"').concat(token.ignoreCase === null ? "" : token.ignoreCase ? " i" : " s", "]");
      }
    }
  }
  function getActionValue(action) {
    switch (action) {
      case types_1.AttributeAction.Equals:
        return "";
      case types_1.AttributeAction.Element:
        return "~";
      case types_1.AttributeAction.Start:
        return "^";
      case types_1.AttributeAction.End:
        return "$";
      case types_1.AttributeAction.Any:
        return "*";
      case types_1.AttributeAction.Not:
        return "!";
      case types_1.AttributeAction.Hyphen:
        return "|";
      case types_1.AttributeAction.Exists:
        throw new Error("Shouldn't be here");
    }
  }
  function getNamespacedName(token) {
    return "".concat(getNamespace(token.namespace)).concat(escapeName(token.name, charsToEscapeInName));
  }
  function getNamespace(namespace) {
    return namespace !== null ? "".concat(namespace === "*" ? "*" : escapeName(namespace, charsToEscapeInName), "|") : "";
  }
  function escapeName(str, charsToEscape) {
    var lastIdx = 0;
    var ret = "";
    for (var i = 0;i < str.length; i++) {
      if (charsToEscape.has(str.charCodeAt(i))) {
        ret += "".concat(str.slice(lastIdx, i), "\\").concat(str.charAt(i));
        lastIdx = i + 1;
      }
    }
    return ret.length > 0 ? ret + str.slice(lastIdx) : str;
  }
});

// ../../../../node_modules/.bun/css-what@6.2.2/node_modules/css-what/lib/commonjs/index.js
var require_commonjs = __commonJS((exports) => {
  var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() {
        return m[k];
      } };
    }
    Object.defineProperty(o, k2, desc);
  } : function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    o[k2] = m[k];
  });
  var __exportStar = exports && exports.__exportStar || function(m, exports2) {
    for (var p in m)
      if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p))
        __createBinding(exports2, m, p);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.stringify = exports.parse = exports.isTraversal = undefined;
  __exportStar(require_types(), exports);
  var parse_1 = require_parse();
  Object.defineProperty(exports, "isTraversal", { enumerable: true, get: function() {
    return parse_1.isTraversal;
  } });
  Object.defineProperty(exports, "parse", { enumerable: true, get: function() {
    return parse_1.parse;
  } });
  var stringify_1 = require_stringify2();
  Object.defineProperty(exports, "stringify", { enumerable: true, get: function() {
    return stringify_1.stringify;
  } });
});

// ../../../../node_modules/.bun/css-select@5.2.2/node_modules/css-select/lib/sort.js
var require_sort = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.isTraversal = undefined;
  var css_what_1 = require_commonjs();
  var procedure = new Map([
    [css_what_1.SelectorType.Universal, 50],
    [css_what_1.SelectorType.Tag, 30],
    [css_what_1.SelectorType.Attribute, 1],
    [css_what_1.SelectorType.Pseudo, 0]
  ]);
  function isTraversal(token) {
    return !procedure.has(token.type);
  }
  exports.isTraversal = isTraversal;
  var attributes = new Map([
    [css_what_1.AttributeAction.Exists, 10],
    [css_what_1.AttributeAction.Equals, 8],
    [css_what_1.AttributeAction.Not, 7],
    [css_what_1.AttributeAction.Start, 6],
    [css_what_1.AttributeAction.End, 6],
    [css_what_1.AttributeAction.Any, 5]
  ]);
  function sortByProcedure(arr) {
    var procs = arr.map(getProcedure);
    for (var i = 1;i < arr.length; i++) {
      var procNew = procs[i];
      if (procNew < 0)
        continue;
      for (var j = i - 1;j >= 0 && procNew < procs[j]; j--) {
        var token = arr[j + 1];
        arr[j + 1] = arr[j];
        arr[j] = token;
        procs[j + 1] = procs[j];
        procs[j] = procNew;
      }
    }
  }
  exports.default = sortByProcedure;
  function getProcedure(token) {
    var _a, _b;
    var proc = (_a = procedure.get(token.type)) !== null && _a !== undefined ? _a : -1;
    if (token.type === css_what_1.SelectorType.Attribute) {
      proc = (_b = attributes.get(token.action)) !== null && _b !== undefined ? _b : 4;
      if (token.action === css_what_1.AttributeAction.Equals && token.name === "id") {
        proc = 9;
      }
      if (token.ignoreCase) {
        proc >>= 1;
      }
    } else if (token.type === css_what_1.SelectorType.Pseudo) {
      if (!token.data) {
        proc = 3;
      } else if (token.name === "has" || token.name === "contains") {
        proc = 0;
      } else if (Array.isArray(token.data)) {
        proc = Math.min.apply(Math, token.data.map(function(d) {
          return Math.min.apply(Math, d.map(getProcedure));
        }));
        if (proc < 0) {
          proc = 0;
        }
      } else {
        proc = 2;
      }
    }
    return proc;
  }
});

// ../../../../node_modules/.bun/css-select@5.2.2/node_modules/css-select/lib/attributes.js
var require_attributes = __commonJS((exports) => {
  var __importDefault = exports && exports.__importDefault || function(mod) {
    return mod && mod.__esModule ? mod : { default: mod };
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.attributeRules = undefined;
  var boolbase_1 = __importDefault(require_boolbase());
  var reChars = /[-[\]{}()*+?.,\\^$|#\s]/g;
  function escapeRegex(value) {
    return value.replace(reChars, "\\$&");
  }
  var caseInsensitiveAttributes = new Set([
    "accept",
    "accept-charset",
    "align",
    "alink",
    "axis",
    "bgcolor",
    "charset",
    "checked",
    "clear",
    "codetype",
    "color",
    "compact",
    "declare",
    "defer",
    "dir",
    "direction",
    "disabled",
    "enctype",
    "face",
    "frame",
    "hreflang",
    "http-equiv",
    "lang",
    "language",
    "link",
    "media",
    "method",
    "multiple",
    "nohref",
    "noresize",
    "noshade",
    "nowrap",
    "readonly",
    "rel",
    "rev",
    "rules",
    "scope",
    "scrolling",
    "selected",
    "shape",
    "target",
    "text",
    "type",
    "valign",
    "valuetype",
    "vlink"
  ]);
  function shouldIgnoreCase(selector, options) {
    return typeof selector.ignoreCase === "boolean" ? selector.ignoreCase : selector.ignoreCase === "quirks" ? !!options.quirksMode : !options.xmlMode && caseInsensitiveAttributes.has(selector.name);
  }
  exports.attributeRules = {
    equals: function(next, data, options) {
      var adapter = options.adapter;
      var name = data.name;
      var value = data.value;
      if (shouldIgnoreCase(data, options)) {
        value = value.toLowerCase();
        return function(elem) {
          var attr = adapter.getAttributeValue(elem, name);
          return attr != null && attr.length === value.length && attr.toLowerCase() === value && next(elem);
        };
      }
      return function(elem) {
        return adapter.getAttributeValue(elem, name) === value && next(elem);
      };
    },
    hyphen: function(next, data, options) {
      var adapter = options.adapter;
      var name = data.name;
      var value = data.value;
      var len = value.length;
      if (shouldIgnoreCase(data, options)) {
        value = value.toLowerCase();
        return function hyphenIC(elem) {
          var attr = adapter.getAttributeValue(elem, name);
          return attr != null && (attr.length === len || attr.charAt(len) === "-") && attr.substr(0, len).toLowerCase() === value && next(elem);
        };
      }
      return function hyphen(elem) {
        var attr = adapter.getAttributeValue(elem, name);
        return attr != null && (attr.length === len || attr.charAt(len) === "-") && attr.substr(0, len) === value && next(elem);
      };
    },
    element: function(next, data, options) {
      var adapter = options.adapter;
      var { name, value } = data;
      if (/\s/.test(value)) {
        return boolbase_1.default.falseFunc;
      }
      var regex = new RegExp("(?:^|\\s)".concat(escapeRegex(value), "(?:$|\\s)"), shouldIgnoreCase(data, options) ? "i" : "");
      return function element(elem) {
        var attr = adapter.getAttributeValue(elem, name);
        return attr != null && attr.length >= value.length && regex.test(attr) && next(elem);
      };
    },
    exists: function(next, _a, _b) {
      var name = _a.name;
      var adapter = _b.adapter;
      return function(elem) {
        return adapter.hasAttrib(elem, name) && next(elem);
      };
    },
    start: function(next, data, options) {
      var adapter = options.adapter;
      var name = data.name;
      var value = data.value;
      var len = value.length;
      if (len === 0) {
        return boolbase_1.default.falseFunc;
      }
      if (shouldIgnoreCase(data, options)) {
        value = value.toLowerCase();
        return function(elem) {
          var attr = adapter.getAttributeValue(elem, name);
          return attr != null && attr.length >= len && attr.substr(0, len).toLowerCase() === value && next(elem);
        };
      }
      return function(elem) {
        var _a;
        return !!((_a = adapter.getAttributeValue(elem, name)) === null || _a === undefined ? undefined : _a.startsWith(value)) && next(elem);
      };
    },
    end: function(next, data, options) {
      var adapter = options.adapter;
      var name = data.name;
      var value = data.value;
      var len = -value.length;
      if (len === 0) {
        return boolbase_1.default.falseFunc;
      }
      if (shouldIgnoreCase(data, options)) {
        value = value.toLowerCase();
        return function(elem) {
          var _a;
          return ((_a = adapter.getAttributeValue(elem, name)) === null || _a === undefined ? undefined : _a.substr(len).toLowerCase()) === value && next(elem);
        };
      }
      return function(elem) {
        var _a;
        return !!((_a = adapter.getAttributeValue(elem, name)) === null || _a === undefined ? undefined : _a.endsWith(value)) && next(elem);
      };
    },
    any: function(next, data, options) {
      var adapter = options.adapter;
      var { name, value } = data;
      if (value === "") {
        return boolbase_1.default.falseFunc;
      }
      if (shouldIgnoreCase(data, options)) {
        var regex_1 = new RegExp(escapeRegex(value), "i");
        return function anyIC(elem) {
          var attr = adapter.getAttributeValue(elem, name);
          return attr != null && attr.length >= value.length && regex_1.test(attr) && next(elem);
        };
      }
      return function(elem) {
        var _a;
        return !!((_a = adapter.getAttributeValue(elem, name)) === null || _a === undefined ? undefined : _a.includes(value)) && next(elem);
      };
    },
    not: function(next, data, options) {
      var adapter = options.adapter;
      var name = data.name;
      var value = data.value;
      if (value === "") {
        return function(elem) {
          return !!adapter.getAttributeValue(elem, name) && next(elem);
        };
      } else if (shouldIgnoreCase(data, options)) {
        value = value.toLowerCase();
        return function(elem) {
          var attr = adapter.getAttributeValue(elem, name);
          return (attr == null || attr.length !== value.length || attr.toLowerCase() !== value) && next(elem);
        };
      }
      return function(elem) {
        return adapter.getAttributeValue(elem, name) !== value && next(elem);
      };
    }
  };
});

// ../../../../node_modules/.bun/nth-check@2.1.1/node_modules/nth-check/lib/parse.js
var require_parse2 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.parse = undefined;
  var whitespace = new Set([9, 10, 12, 13, 32]);
  var ZERO = 48;
  var NINE = 57;
  function parse(formula) {
    formula = formula.trim().toLowerCase();
    if (formula === "even") {
      return [2, 0];
    } else if (formula === "odd") {
      return [2, 1];
    }
    var idx = 0;
    var a = 0;
    var sign = readSign();
    var number = readNumber();
    if (idx < formula.length && formula.charAt(idx) === "n") {
      idx++;
      a = sign * (number !== null && number !== undefined ? number : 1);
      skipWhitespace();
      if (idx < formula.length) {
        sign = readSign();
        skipWhitespace();
        number = readNumber();
      } else {
        sign = number = 0;
      }
    }
    if (number === null || idx < formula.length) {
      throw new Error("n-th rule couldn't be parsed ('".concat(formula, "')"));
    }
    return [a, sign * number];
    function readSign() {
      if (formula.charAt(idx) === "-") {
        idx++;
        return -1;
      }
      if (formula.charAt(idx) === "+") {
        idx++;
      }
      return 1;
    }
    function readNumber() {
      var start = idx;
      var value = 0;
      while (idx < formula.length && formula.charCodeAt(idx) >= ZERO && formula.charCodeAt(idx) <= NINE) {
        value = value * 10 + (formula.charCodeAt(idx) - ZERO);
        idx++;
      }
      return idx === start ? null : value;
    }
    function skipWhitespace() {
      while (idx < formula.length && whitespace.has(formula.charCodeAt(idx))) {
        idx++;
      }
    }
  }
  exports.parse = parse;
});

// ../../../../node_modules/.bun/nth-check@2.1.1/node_modules/nth-check/lib/compile.js
var require_compile = __commonJS((exports) => {
  var __importDefault = exports && exports.__importDefault || function(mod) {
    return mod && mod.__esModule ? mod : { default: mod };
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.generate = exports.compile = undefined;
  var boolbase_1 = __importDefault(require_boolbase());
  function compile(parsed) {
    var a = parsed[0];
    var b = parsed[1] - 1;
    if (b < 0 && a <= 0)
      return boolbase_1.default.falseFunc;
    if (a === -1)
      return function(index) {
        return index <= b;
      };
    if (a === 0)
      return function(index) {
        return index === b;
      };
    if (a === 1)
      return b < 0 ? boolbase_1.default.trueFunc : function(index) {
        return index >= b;
      };
    var absA = Math.abs(a);
    var bMod = (b % absA + absA) % absA;
    return a > 1 ? function(index) {
      return index >= b && index % absA === bMod;
    } : function(index) {
      return index <= b && index % absA === bMod;
    };
  }
  exports.compile = compile;
  function generate(parsed) {
    var a = parsed[0];
    var b = parsed[1] - 1;
    var n = 0;
    if (a < 0) {
      var aPos_1 = -a;
      var minValue_1 = (b % aPos_1 + aPos_1) % aPos_1;
      return function() {
        var val = minValue_1 + aPos_1 * n++;
        return val > b ? null : val;
      };
    }
    if (a === 0)
      return b < 0 ? function() {
        return null;
      } : function() {
        return n++ === 0 ? b : null;
      };
    if (b < 0) {
      b += a * Math.ceil(-b / a);
    }
    return function() {
      return a * n++ + b;
    };
  }
  exports.generate = generate;
});

// ../../../../node_modules/.bun/nth-check@2.1.1/node_modules/nth-check/lib/index.js
var require_lib6 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.sequence = exports.generate = exports.compile = exports.parse = undefined;
  var parse_js_1 = require_parse2();
  Object.defineProperty(exports, "parse", { enumerable: true, get: function() {
    return parse_js_1.parse;
  } });
  var compile_js_1 = require_compile();
  Object.defineProperty(exports, "compile", { enumerable: true, get: function() {
    return compile_js_1.compile;
  } });
  Object.defineProperty(exports, "generate", { enumerable: true, get: function() {
    return compile_js_1.generate;
  } });
  function nthCheck(formula) {
    return (0, compile_js_1.compile)((0, parse_js_1.parse)(formula));
  }
  exports.default = nthCheck;
  function sequence(formula) {
    return (0, compile_js_1.generate)((0, parse_js_1.parse)(formula));
  }
  exports.sequence = sequence;
});

// ../../../../node_modules/.bun/css-select@5.2.2/node_modules/css-select/lib/pseudo-selectors/filters.js
var require_filters = __commonJS((exports) => {
  var __importDefault = exports && exports.__importDefault || function(mod) {
    return mod && mod.__esModule ? mod : { default: mod };
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.filters = undefined;
  var nth_check_1 = __importDefault(require_lib6());
  var boolbase_1 = __importDefault(require_boolbase());
  function getChildFunc(next, adapter) {
    return function(elem) {
      var parent = adapter.getParent(elem);
      return parent != null && adapter.isTag(parent) && next(elem);
    };
  }
  exports.filters = {
    contains: function(next, text, _a) {
      var adapter = _a.adapter;
      return function contains(elem) {
        return next(elem) && adapter.getText(elem).includes(text);
      };
    },
    icontains: function(next, text, _a) {
      var adapter = _a.adapter;
      var itext = text.toLowerCase();
      return function icontains(elem) {
        return next(elem) && adapter.getText(elem).toLowerCase().includes(itext);
      };
    },
    "nth-child": function(next, rule, _a) {
      var { adapter, equals } = _a;
      var func = (0, nth_check_1.default)(rule);
      if (func === boolbase_1.default.falseFunc)
        return boolbase_1.default.falseFunc;
      if (func === boolbase_1.default.trueFunc)
        return getChildFunc(next, adapter);
      return function nthChild(elem) {
        var siblings = adapter.getSiblings(elem);
        var pos = 0;
        for (var i = 0;i < siblings.length; i++) {
          if (equals(elem, siblings[i]))
            break;
          if (adapter.isTag(siblings[i])) {
            pos++;
          }
        }
        return func(pos) && next(elem);
      };
    },
    "nth-last-child": function(next, rule, _a) {
      var { adapter, equals } = _a;
      var func = (0, nth_check_1.default)(rule);
      if (func === boolbase_1.default.falseFunc)
        return boolbase_1.default.falseFunc;
      if (func === boolbase_1.default.trueFunc)
        return getChildFunc(next, adapter);
      return function nthLastChild(elem) {
        var siblings = adapter.getSiblings(elem);
        var pos = 0;
        for (var i = siblings.length - 1;i >= 0; i--) {
          if (equals(elem, siblings[i]))
            break;
          if (adapter.isTag(siblings[i])) {
            pos++;
          }
        }
        return func(pos) && next(elem);
      };
    },
    "nth-of-type": function(next, rule, _a) {
      var { adapter, equals } = _a;
      var func = (0, nth_check_1.default)(rule);
      if (func === boolbase_1.default.falseFunc)
        return boolbase_1.default.falseFunc;
      if (func === boolbase_1.default.trueFunc)
        return getChildFunc(next, adapter);
      return function nthOfType(elem) {
        var siblings = adapter.getSiblings(elem);
        var pos = 0;
        for (var i = 0;i < siblings.length; i++) {
          var currentSibling = siblings[i];
          if (equals(elem, currentSibling))
            break;
          if (adapter.isTag(currentSibling) && adapter.getName(currentSibling) === adapter.getName(elem)) {
            pos++;
          }
        }
        return func(pos) && next(elem);
      };
    },
    "nth-last-of-type": function(next, rule, _a) {
      var { adapter, equals } = _a;
      var func = (0, nth_check_1.default)(rule);
      if (func === boolbase_1.default.falseFunc)
        return boolbase_1.default.falseFunc;
      if (func === boolbase_1.default.trueFunc)
        return getChildFunc(next, adapter);
      return function nthLastOfType(elem) {
        var siblings = adapter.getSiblings(elem);
        var pos = 0;
        for (var i = siblings.length - 1;i >= 0; i--) {
          var currentSibling = siblings[i];
          if (equals(elem, currentSibling))
            break;
          if (adapter.isTag(currentSibling) && adapter.getName(currentSibling) === adapter.getName(elem)) {
            pos++;
          }
        }
        return func(pos) && next(elem);
      };
    },
    root: function(next, _rule, _a) {
      var adapter = _a.adapter;
      return function(elem) {
        var parent = adapter.getParent(elem);
        return (parent == null || !adapter.isTag(parent)) && next(elem);
      };
    },
    scope: function(next, rule, options, context) {
      var equals = options.equals;
      if (!context || context.length === 0) {
        return exports.filters["root"](next, rule, options);
      }
      if (context.length === 1) {
        return function(elem) {
          return equals(context[0], elem) && next(elem);
        };
      }
      return function(elem) {
        return context.includes(elem) && next(elem);
      };
    },
    hover: dynamicStatePseudo("isHovered"),
    visited: dynamicStatePseudo("isVisited"),
    active: dynamicStatePseudo("isActive")
  };
  function dynamicStatePseudo(name) {
    return function dynamicPseudo(next, _rule, _a) {
      var adapter = _a.adapter;
      var func = adapter[name];
      if (typeof func !== "function") {
        return boolbase_1.default.falseFunc;
      }
      return function active(elem) {
        return func(elem) && next(elem);
      };
    };
  }
});

// ../../../../node_modules/.bun/css-select@5.2.2/node_modules/css-select/lib/pseudo-selectors/pseudos.js
var require_pseudos = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.verifyPseudoArgs = exports.pseudos = undefined;
  exports.pseudos = {
    empty: function(elem, _a) {
      var adapter = _a.adapter;
      return !adapter.getChildren(elem).some(function(elem2) {
        return adapter.isTag(elem2) || adapter.getText(elem2) !== "";
      });
    },
    "first-child": function(elem, _a) {
      var { adapter, equals } = _a;
      if (adapter.prevElementSibling) {
        return adapter.prevElementSibling(elem) == null;
      }
      var firstChild = adapter.getSiblings(elem).find(function(elem2) {
        return adapter.isTag(elem2);
      });
      return firstChild != null && equals(elem, firstChild);
    },
    "last-child": function(elem, _a) {
      var { adapter, equals } = _a;
      var siblings = adapter.getSiblings(elem);
      for (var i = siblings.length - 1;i >= 0; i--) {
        if (equals(elem, siblings[i]))
          return true;
        if (adapter.isTag(siblings[i]))
          break;
      }
      return false;
    },
    "first-of-type": function(elem, _a) {
      var { adapter, equals } = _a;
      var siblings = adapter.getSiblings(elem);
      var elemName = adapter.getName(elem);
      for (var i = 0;i < siblings.length; i++) {
        var currentSibling = siblings[i];
        if (equals(elem, currentSibling))
          return true;
        if (adapter.isTag(currentSibling) && adapter.getName(currentSibling) === elemName) {
          break;
        }
      }
      return false;
    },
    "last-of-type": function(elem, _a) {
      var { adapter, equals } = _a;
      var siblings = adapter.getSiblings(elem);
      var elemName = adapter.getName(elem);
      for (var i = siblings.length - 1;i >= 0; i--) {
        var currentSibling = siblings[i];
        if (equals(elem, currentSibling))
          return true;
        if (adapter.isTag(currentSibling) && adapter.getName(currentSibling) === elemName) {
          break;
        }
      }
      return false;
    },
    "only-of-type": function(elem, _a) {
      var { adapter, equals } = _a;
      var elemName = adapter.getName(elem);
      return adapter.getSiblings(elem).every(function(sibling) {
        return equals(elem, sibling) || !adapter.isTag(sibling) || adapter.getName(sibling) !== elemName;
      });
    },
    "only-child": function(elem, _a) {
      var { adapter, equals } = _a;
      return adapter.getSiblings(elem).every(function(sibling) {
        return equals(elem, sibling) || !adapter.isTag(sibling);
      });
    }
  };
  function verifyPseudoArgs(func, name, subselect, argIndex) {
    if (subselect === null) {
      if (func.length > argIndex) {
        throw new Error("Pseudo-class :".concat(name, " requires an argument"));
      }
    } else if (func.length === argIndex) {
      throw new Error("Pseudo-class :".concat(name, " doesn't have any arguments"));
    }
  }
  exports.verifyPseudoArgs = verifyPseudoArgs;
});

// ../../../../node_modules/.bun/css-select@5.2.2/node_modules/css-select/lib/pseudo-selectors/aliases.js
var require_aliases = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.aliases = undefined;
  exports.aliases = {
    "any-link": ":is(a, area, link)[href]",
    link: ":any-link:not(:visited)",
    disabled: `:is(
        :is(button, input, select, textarea, optgroup, option)[disabled],
        optgroup[disabled] > option,
        fieldset[disabled]:not(fieldset[disabled] legend:first-of-type *)
    )`,
    enabled: ":not(:disabled)",
    checked: ":is(:is(input[type=radio], input[type=checkbox])[checked], option:selected)",
    required: ":is(input, select, textarea)[required]",
    optional: ":is(input, select, textarea):not([required])",
    selected: "option:is([selected], select:not([multiple]):not(:has(> option[selected])) > :first-of-type)",
    checkbox: "[type=checkbox]",
    file: "[type=file]",
    password: "[type=password]",
    radio: "[type=radio]",
    reset: "[type=reset]",
    image: "[type=image]",
    submit: "[type=submit]",
    parent: ":not(:empty)",
    header: ":is(h1, h2, h3, h4, h5, h6)",
    button: ":is(button, input[type=button])",
    input: ":is(input, textarea, select, button)",
    text: "input:is(:not([type!='']), [type=text])"
  };
});

// ../../../../node_modules/.bun/css-select@5.2.2/node_modules/css-select/lib/pseudo-selectors/subselects.js
var require_subselects = __commonJS((exports) => {
  var __spreadArray = exports && exports.__spreadArray || function(to, from, pack) {
    if (pack || arguments.length === 2)
      for (var i = 0, l = from.length, ar;i < l; i++) {
        if (ar || !(i in from)) {
          if (!ar)
            ar = Array.prototype.slice.call(from, 0, i);
          ar[i] = from[i];
        }
      }
    return to.concat(ar || Array.prototype.slice.call(from));
  };
  var __importDefault = exports && exports.__importDefault || function(mod) {
    return mod && mod.__esModule ? mod : { default: mod };
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.subselects = exports.getNextSiblings = exports.ensureIsTag = exports.PLACEHOLDER_ELEMENT = undefined;
  var boolbase_1 = __importDefault(require_boolbase());
  var sort_js_1 = require_sort();
  exports.PLACEHOLDER_ELEMENT = {};
  function ensureIsTag(next, adapter) {
    if (next === boolbase_1.default.falseFunc)
      return boolbase_1.default.falseFunc;
    return function(elem) {
      return adapter.isTag(elem) && next(elem);
    };
  }
  exports.ensureIsTag = ensureIsTag;
  function getNextSiblings(elem, adapter) {
    var siblings = adapter.getSiblings(elem);
    if (siblings.length <= 1)
      return [];
    var elemIndex = siblings.indexOf(elem);
    if (elemIndex < 0 || elemIndex === siblings.length - 1)
      return [];
    return siblings.slice(elemIndex + 1).filter(adapter.isTag);
  }
  exports.getNextSiblings = getNextSiblings;
  function copyOptions(options) {
    return {
      xmlMode: !!options.xmlMode,
      lowerCaseAttributeNames: !!options.lowerCaseAttributeNames,
      lowerCaseTags: !!options.lowerCaseTags,
      quirksMode: !!options.quirksMode,
      cacheResults: !!options.cacheResults,
      pseudos: options.pseudos,
      adapter: options.adapter,
      equals: options.equals
    };
  }
  var is = function(next, token, options, context, compileToken) {
    var func = compileToken(token, copyOptions(options), context);
    return func === boolbase_1.default.trueFunc ? next : func === boolbase_1.default.falseFunc ? boolbase_1.default.falseFunc : function(elem) {
      return func(elem) && next(elem);
    };
  };
  exports.subselects = {
    is,
    matches: is,
    where: is,
    not: function(next, token, options, context, compileToken) {
      var func = compileToken(token, copyOptions(options), context);
      return func === boolbase_1.default.falseFunc ? next : func === boolbase_1.default.trueFunc ? boolbase_1.default.falseFunc : function(elem) {
        return !func(elem) && next(elem);
      };
    },
    has: function(next, subselect, options, _context, compileToken) {
      var adapter = options.adapter;
      var opts = copyOptions(options);
      opts.relativeSelector = true;
      var context = subselect.some(function(s) {
        return s.some(sort_js_1.isTraversal);
      }) ? [exports.PLACEHOLDER_ELEMENT] : undefined;
      var compiled = compileToken(subselect, opts, context);
      if (compiled === boolbase_1.default.falseFunc)
        return boolbase_1.default.falseFunc;
      var hasElement = ensureIsTag(compiled, adapter);
      if (context && compiled !== boolbase_1.default.trueFunc) {
        var _a = compiled.shouldTestNextSiblings, shouldTestNextSiblings_1 = _a === undefined ? false : _a;
        return function(elem) {
          if (!next(elem))
            return false;
          context[0] = elem;
          var childs = adapter.getChildren(elem);
          var nextElements = shouldTestNextSiblings_1 ? __spreadArray(__spreadArray([], childs, true), getNextSiblings(elem, adapter), true) : childs;
          return adapter.existsOne(hasElement, nextElements);
        };
      }
      return function(elem) {
        return next(elem) && adapter.existsOne(hasElement, adapter.getChildren(elem));
      };
    }
  };
});

// ../../../../node_modules/.bun/css-select@5.2.2/node_modules/css-select/lib/pseudo-selectors/index.js
var require_pseudo_selectors = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.compilePseudoSelector = exports.aliases = exports.pseudos = exports.filters = undefined;
  var css_what_1 = require_commonjs();
  var filters_js_1 = require_filters();
  Object.defineProperty(exports, "filters", { enumerable: true, get: function() {
    return filters_js_1.filters;
  } });
  var pseudos_js_1 = require_pseudos();
  Object.defineProperty(exports, "pseudos", { enumerable: true, get: function() {
    return pseudos_js_1.pseudos;
  } });
  var aliases_js_1 = require_aliases();
  Object.defineProperty(exports, "aliases", { enumerable: true, get: function() {
    return aliases_js_1.aliases;
  } });
  var subselects_js_1 = require_subselects();
  function compilePseudoSelector(next, selector, options, context, compileToken) {
    var _a;
    var { name, data } = selector;
    if (Array.isArray(data)) {
      if (!(name in subselects_js_1.subselects)) {
        throw new Error("Unknown pseudo-class :".concat(name, "(").concat(data, ")"));
      }
      return subselects_js_1.subselects[name](next, data, options, context, compileToken);
    }
    var userPseudo = (_a = options.pseudos) === null || _a === undefined ? undefined : _a[name];
    var stringPseudo = typeof userPseudo === "string" ? userPseudo : aliases_js_1.aliases[name];
    if (typeof stringPseudo === "string") {
      if (data != null) {
        throw new Error("Pseudo ".concat(name, " doesn't have any arguments"));
      }
      var alias = (0, css_what_1.parse)(stringPseudo);
      return subselects_js_1.subselects["is"](next, alias, options, context, compileToken);
    }
    if (typeof userPseudo === "function") {
      (0, pseudos_js_1.verifyPseudoArgs)(userPseudo, name, data, 1);
      return function(elem) {
        return userPseudo(elem, data) && next(elem);
      };
    }
    if (name in filters_js_1.filters) {
      return filters_js_1.filters[name](next, data, options, context);
    }
    if (name in pseudos_js_1.pseudos) {
      var pseudo_1 = pseudos_js_1.pseudos[name];
      (0, pseudos_js_1.verifyPseudoArgs)(pseudo_1, name, data, 2);
      return function(elem) {
        return pseudo_1(elem, options, data) && next(elem);
      };
    }
    throw new Error("Unknown pseudo-class :".concat(name));
  }
  exports.compilePseudoSelector = compilePseudoSelector;
});

// ../../../../node_modules/.bun/css-select@5.2.2/node_modules/css-select/lib/general.js
var require_general = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.compileGeneralSelector = undefined;
  var attributes_js_1 = require_attributes();
  var index_js_1 = require_pseudo_selectors();
  var css_what_1 = require_commonjs();
  function getElementParent(node, adapter) {
    var parent = adapter.getParent(node);
    if (parent && adapter.isTag(parent)) {
      return parent;
    }
    return null;
  }
  function compileGeneralSelector(next, selector, options, context, compileToken) {
    var { adapter, equals } = options;
    switch (selector.type) {
      case css_what_1.SelectorType.PseudoElement: {
        throw new Error("Pseudo-elements are not supported by css-select");
      }
      case css_what_1.SelectorType.ColumnCombinator: {
        throw new Error("Column combinators are not yet supported by css-select");
      }
      case css_what_1.SelectorType.Attribute: {
        if (selector.namespace != null) {
          throw new Error("Namespaced attributes are not yet supported by css-select");
        }
        if (!options.xmlMode || options.lowerCaseAttributeNames) {
          selector.name = selector.name.toLowerCase();
        }
        return attributes_js_1.attributeRules[selector.action](next, selector, options);
      }
      case css_what_1.SelectorType.Pseudo: {
        return (0, index_js_1.compilePseudoSelector)(next, selector, options, context, compileToken);
      }
      case css_what_1.SelectorType.Tag: {
        if (selector.namespace != null) {
          throw new Error("Namespaced tag names are not yet supported by css-select");
        }
        var name_1 = selector.name;
        if (!options.xmlMode || options.lowerCaseTags) {
          name_1 = name_1.toLowerCase();
        }
        return function tag(elem) {
          return adapter.getName(elem) === name_1 && next(elem);
        };
      }
      case css_what_1.SelectorType.Descendant: {
        if (options.cacheResults === false || typeof WeakSet === "undefined") {
          return function descendant(elem) {
            var current = elem;
            while (current = getElementParent(current, adapter)) {
              if (next(current)) {
                return true;
              }
            }
            return false;
          };
        }
        var isFalseCache_1 = new WeakSet;
        return function cachedDescendant(elem) {
          var current = elem;
          while (current = getElementParent(current, adapter)) {
            if (!isFalseCache_1.has(current)) {
              if (adapter.isTag(current) && next(current)) {
                return true;
              }
              isFalseCache_1.add(current);
            }
          }
          return false;
        };
      }
      case "_flexibleDescendant": {
        return function flexibleDescendant(elem) {
          var current = elem;
          do {
            if (next(current))
              return true;
          } while (current = getElementParent(current, adapter));
          return false;
        };
      }
      case css_what_1.SelectorType.Parent: {
        return function parent(elem) {
          return adapter.getChildren(elem).some(function(elem2) {
            return adapter.isTag(elem2) && next(elem2);
          });
        };
      }
      case css_what_1.SelectorType.Child: {
        return function child(elem) {
          var parent = adapter.getParent(elem);
          return parent != null && adapter.isTag(parent) && next(parent);
        };
      }
      case css_what_1.SelectorType.Sibling: {
        return function sibling(elem) {
          var siblings = adapter.getSiblings(elem);
          for (var i = 0;i < siblings.length; i++) {
            var currentSibling = siblings[i];
            if (equals(elem, currentSibling))
              break;
            if (adapter.isTag(currentSibling) && next(currentSibling)) {
              return true;
            }
          }
          return false;
        };
      }
      case css_what_1.SelectorType.Adjacent: {
        if (adapter.prevElementSibling) {
          return function adjacent(elem) {
            var previous = adapter.prevElementSibling(elem);
            return previous != null && next(previous);
          };
        }
        return function adjacent(elem) {
          var siblings = adapter.getSiblings(elem);
          var lastElement;
          for (var i = 0;i < siblings.length; i++) {
            var currentSibling = siblings[i];
            if (equals(elem, currentSibling))
              break;
            if (adapter.isTag(currentSibling)) {
              lastElement = currentSibling;
            }
          }
          return !!lastElement && next(lastElement);
        };
      }
      case css_what_1.SelectorType.Universal: {
        if (selector.namespace != null && selector.namespace !== "*") {
          throw new Error("Namespaced universal selectors are not yet supported by css-select");
        }
        return next;
      }
    }
  }
  exports.compileGeneralSelector = compileGeneralSelector;
});

// ../../../../node_modules/.bun/css-select@5.2.2/node_modules/css-select/lib/compile.js
var require_compile2 = __commonJS((exports) => {
  var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() {
        return m[k];
      } };
    }
    Object.defineProperty(o, k2, desc);
  } : function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    o[k2] = m[k];
  });
  var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
  } : function(o, v) {
    o["default"] = v;
  });
  var __importStar = exports && exports.__importStar || function(mod) {
    if (mod && mod.__esModule)
      return mod;
    var result = {};
    if (mod != null) {
      for (var k in mod)
        if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
          __createBinding(result, mod, k);
    }
    __setModuleDefault(result, mod);
    return result;
  };
  var __importDefault = exports && exports.__importDefault || function(mod) {
    return mod && mod.__esModule ? mod : { default: mod };
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.compileToken = exports.compileUnsafe = exports.compile = undefined;
  var css_what_1 = require_commonjs();
  var boolbase_1 = __importDefault(require_boolbase());
  var sort_js_1 = __importStar(require_sort());
  var general_js_1 = require_general();
  var subselects_js_1 = require_subselects();
  function compile(selector, options, context) {
    var next = compileUnsafe(selector, options, context);
    return (0, subselects_js_1.ensureIsTag)(next, options.adapter);
  }
  exports.compile = compile;
  function compileUnsafe(selector, options, context) {
    var token = typeof selector === "string" ? (0, css_what_1.parse)(selector) : selector;
    return compileToken(token, options, context);
  }
  exports.compileUnsafe = compileUnsafe;
  function includesScopePseudo(t) {
    return t.type === css_what_1.SelectorType.Pseudo && (t.name === "scope" || Array.isArray(t.data) && t.data.some(function(data) {
      return data.some(includesScopePseudo);
    }));
  }
  var DESCENDANT_TOKEN = { type: css_what_1.SelectorType.Descendant };
  var FLEXIBLE_DESCENDANT_TOKEN = {
    type: "_flexibleDescendant"
  };
  var SCOPE_TOKEN = {
    type: css_what_1.SelectorType.Pseudo,
    name: "scope",
    data: null
  };
  function absolutize(token, _a, context) {
    var adapter = _a.adapter;
    var hasContext = !!(context === null || context === undefined ? undefined : context.every(function(e) {
      var parent = adapter.isTag(e) && adapter.getParent(e);
      return e === subselects_js_1.PLACEHOLDER_ELEMENT || parent && adapter.isTag(parent);
    }));
    for (var _i = 0, token_1 = token;_i < token_1.length; _i++) {
      var t = token_1[_i];
      if (t.length > 0 && (0, sort_js_1.isTraversal)(t[0]) && t[0].type !== css_what_1.SelectorType.Descendant) {} else if (hasContext && !t.some(includesScopePseudo)) {
        t.unshift(DESCENDANT_TOKEN);
      } else {
        continue;
      }
      t.unshift(SCOPE_TOKEN);
    }
  }
  function compileToken(token, options, context) {
    var _a;
    token.forEach(sort_js_1.default);
    context = (_a = options.context) !== null && _a !== undefined ? _a : context;
    var isArrayContext = Array.isArray(context);
    var finalContext = context && (Array.isArray(context) ? context : [context]);
    if (options.relativeSelector !== false) {
      absolutize(token, options, finalContext);
    } else if (token.some(function(t) {
      return t.length > 0 && (0, sort_js_1.isTraversal)(t[0]);
    })) {
      throw new Error("Relative selectors are not allowed when the `relativeSelector` option is disabled");
    }
    var shouldTestNextSiblings = false;
    var query = token.map(function(rules) {
      if (rules.length >= 2) {
        var first = rules[0], second = rules[1];
        if (first.type !== css_what_1.SelectorType.Pseudo || first.name !== "scope") {} else if (isArrayContext && second.type === css_what_1.SelectorType.Descendant) {
          rules[1] = FLEXIBLE_DESCENDANT_TOKEN;
        } else if (second.type === css_what_1.SelectorType.Adjacent || second.type === css_what_1.SelectorType.Sibling) {
          shouldTestNextSiblings = true;
        }
      }
      return compileRules(rules, options, finalContext);
    }).reduce(reduceRules, boolbase_1.default.falseFunc);
    query.shouldTestNextSiblings = shouldTestNextSiblings;
    return query;
  }
  exports.compileToken = compileToken;
  function compileRules(rules, options, context) {
    var _a;
    return rules.reduce(function(previous, rule) {
      return previous === boolbase_1.default.falseFunc ? boolbase_1.default.falseFunc : (0, general_js_1.compileGeneralSelector)(previous, rule, options, context, compileToken);
    }, (_a = options.rootFunc) !== null && _a !== undefined ? _a : boolbase_1.default.trueFunc);
  }
  function reduceRules(a, b) {
    if (b === boolbase_1.default.falseFunc || a === boolbase_1.default.trueFunc) {
      return a;
    }
    if (a === boolbase_1.default.falseFunc || b === boolbase_1.default.trueFunc) {
      return b;
    }
    return function combine(elem) {
      return a(elem) || b(elem);
    };
  }
});

// ../../../../node_modules/.bun/css-select@5.2.2/node_modules/css-select/lib/index.js
var require_lib7 = __commonJS((exports) => {
  var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() {
        return m[k];
      } };
    }
    Object.defineProperty(o, k2, desc);
  } : function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    o[k2] = m[k];
  });
  var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
  } : function(o, v) {
    o["default"] = v;
  });
  var __importStar = exports && exports.__importStar || function(mod) {
    if (mod && mod.__esModule)
      return mod;
    var result = {};
    if (mod != null) {
      for (var k in mod)
        if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
          __createBinding(result, mod, k);
    }
    __setModuleDefault(result, mod);
    return result;
  };
  var __importDefault = exports && exports.__importDefault || function(mod) {
    return mod && mod.__esModule ? mod : { default: mod };
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.aliases = exports.pseudos = exports.filters = exports.is = exports.selectOne = exports.selectAll = exports.prepareContext = exports._compileToken = exports._compileUnsafe = exports.compile = undefined;
  var DomUtils = __importStar(require_lib5());
  var boolbase_1 = __importDefault(require_boolbase());
  var compile_js_1 = require_compile2();
  var subselects_js_1 = require_subselects();
  var defaultEquals = function(a, b) {
    return a === b;
  };
  var defaultOptions = {
    adapter: DomUtils,
    equals: defaultEquals
  };
  function convertOptionFormats(options) {
    var _a, _b, _c, _d;
    var opts = options !== null && options !== undefined ? options : defaultOptions;
    (_a = opts.adapter) !== null && _a !== undefined || (opts.adapter = DomUtils);
    (_b = opts.equals) !== null && _b !== undefined || (opts.equals = (_d = (_c = opts.adapter) === null || _c === undefined ? undefined : _c.equals) !== null && _d !== undefined ? _d : defaultEquals);
    return opts;
  }
  function wrapCompile(func) {
    return function addAdapter(selector, options, context) {
      var opts = convertOptionFormats(options);
      return func(selector, opts, context);
    };
  }
  exports.compile = wrapCompile(compile_js_1.compile);
  exports._compileUnsafe = wrapCompile(compile_js_1.compileUnsafe);
  exports._compileToken = wrapCompile(compile_js_1.compileToken);
  function getSelectorFunc(searchFunc) {
    return function select(query, elements, options) {
      var opts = convertOptionFormats(options);
      if (typeof query !== "function") {
        query = (0, compile_js_1.compileUnsafe)(query, opts, elements);
      }
      var filteredElements = prepareContext(elements, opts.adapter, query.shouldTestNextSiblings);
      return searchFunc(query, filteredElements, opts);
    };
  }
  function prepareContext(elems, adapter, shouldTestNextSiblings) {
    if (shouldTestNextSiblings === undefined) {
      shouldTestNextSiblings = false;
    }
    if (shouldTestNextSiblings) {
      elems = appendNextSiblings(elems, adapter);
    }
    return Array.isArray(elems) ? adapter.removeSubsets(elems) : adapter.getChildren(elems);
  }
  exports.prepareContext = prepareContext;
  function appendNextSiblings(elem, adapter) {
    var elems = Array.isArray(elem) ? elem.slice(0) : [elem];
    var elemsLength = elems.length;
    for (var i = 0;i < elemsLength; i++) {
      var nextSiblings = (0, subselects_js_1.getNextSiblings)(elems[i], adapter);
      elems.push.apply(elems, nextSiblings);
    }
    return elems;
  }
  exports.selectAll = getSelectorFunc(function(query, elems, options) {
    return query === boolbase_1.default.falseFunc || !elems || elems.length === 0 ? [] : options.adapter.findAll(query, elems);
  });
  exports.selectOne = getSelectorFunc(function(query, elems, options) {
    return query === boolbase_1.default.falseFunc || !elems || elems.length === 0 ? null : options.adapter.findOne(query, elems);
  });
  function is(elem, query, options) {
    var opts = convertOptionFormats(options);
    return (typeof query === "function" ? query : (0, compile_js_1.compile)(query, opts))(elem);
  }
  exports.is = is;
  exports.default = exports.selectAll;
  var index_js_1 = require_pseudo_selectors();
  Object.defineProperty(exports, "filters", { enumerable: true, get: function() {
    return index_js_1.filters;
  } });
  Object.defineProperty(exports, "pseudos", { enumerable: true, get: function() {
    return index_js_1.pseudos;
  } });
  Object.defineProperty(exports, "aliases", { enumerable: true, get: function() {
    return index_js_1.aliases;
  } });
});

// ../../../../node_modules/.bun/svgo@3.3.2/node_modules/svgo/lib/svgo/css-select-adapter.js
var require_css_select_adapter = __commonJS((exports, module) => {
  var isTag = (node) => {
    return node.type === "element";
  };
  var existsOne = (test, elems) => {
    return elems.some((elem) => {
      if (isTag(elem)) {
        return test(elem) || existsOne(test, getChildren(elem));
      } else {
        return false;
      }
    });
  };
  var getAttributeValue = (elem, name) => {
    return elem.attributes[name];
  };
  var getChildren = (node) => {
    return node.children || [];
  };
  var getName = (elemAst) => {
    return elemAst.name;
  };
  var getParent = (node) => {
    return node.parentNode || null;
  };
  var getSiblings = (elem) => {
    var parent = getParent(elem);
    return parent ? getChildren(parent) : [];
  };
  var getText = (node) => {
    if (node.children[0].type === "text" && node.children[0].type === "cdata") {
      return node.children[0].value;
    }
    return "";
  };
  var hasAttrib = (elem, name) => {
    return elem.attributes[name] !== undefined;
  };
  var removeSubsets = (nodes) => {
    let idx = nodes.length;
    let node;
    let ancestor;
    let replace;
    while (--idx > -1) {
      node = ancestor = nodes[idx];
      nodes[idx] = null;
      replace = true;
      while (ancestor) {
        if (nodes.includes(ancestor)) {
          replace = false;
          nodes.splice(idx, 1);
          break;
        }
        ancestor = getParent(ancestor);
      }
      if (replace) {
        nodes[idx] = node;
      }
    }
    return nodes;
  };
  var findAll = (test, elems) => {
    const result = [];
    for (const elem of elems) {
      if (isTag(elem)) {
        if (test(elem)) {
          result.push(elem);
        }
        result.push(...findAll(test, getChildren(elem)));
      }
    }
    return result;
  };
  var findOne = (test, elems) => {
    for (const elem of elems) {
      if (isTag(elem)) {
        if (test(elem)) {
          return elem;
        }
        const result = findOne(test, getChildren(elem));
        if (result) {
          return result;
        }
      }
    }
    return null;
  };
  var svgoCssSelectAdapter = {
    isTag,
    existsOne,
    getAttributeValue,
    getChildren,
    getName,
    getParent,
    getSiblings,
    getText,
    hasAttrib,
    removeSubsets,
    findAll,
    findOne
  };
  module.exports = svgoCssSelectAdapter;
});

// ../../../../node_modules/.bun/svgo@3.3.2/node_modules/svgo/lib/xast.js
var require_xast = __commonJS((exports) => {
  var { selectAll, selectOne, is } = require_lib7();
  var xastAdaptor = require_css_select_adapter();
  var cssSelectOptions = {
    xmlMode: true,
    adapter: xastAdaptor
  };
  var querySelectorAll = (node, selector) => {
    return selectAll(selector, node, cssSelectOptions);
  };
  exports.querySelectorAll = querySelectorAll;
  var querySelector = (node, selector) => {
    return selectOne(selector, node, cssSelectOptions);
  };
  exports.querySelector = querySelector;
  var matches = (node, selector) => {
    return is(node, selector, cssSelectOptions);
  };
  exports.matches = matches;
  var visitSkip = Symbol();
  exports.visitSkip = visitSkip;
  var visit = (node, visitor, parentNode) => {
    const callbacks = visitor[node.type];
    if (callbacks && callbacks.enter) {
      const symbol = callbacks.enter(node, parentNode);
      if (symbol === visitSkip) {
        return;
      }
    }
    if (node.type === "root") {
      for (const child of node.children) {
        visit(child, visitor, node);
      }
    }
    if (node.type === "element") {
      if (parentNode.children.includes(node)) {
        for (const child of node.children) {
          visit(child, visitor, node);
        }
      }
    }
    if (callbacks && callbacks.exit) {
      callbacks.exit(node, parentNode);
    }
  };
  exports.visit = visit;
  var detachNodeFromParent = (node, parentNode) => {
    parentNode.children = parentNode.children.filter((child) => child !== node);
  };
  exports.detachNodeFromParent = detachNodeFromParent;
});

// ../../../../node_modules/.bun/svgo@3.3.2/node_modules/svgo/lib/svgo/plugins.js
var require_plugins = __commonJS((exports) => {
  var { visit } = require_xast();
  var invokePlugins = (ast, info, plugins, overrides, globalOverrides) => {
    for (const plugin of plugins) {
      const override = overrides?.[plugin.name];
      if (override === false) {
        continue;
      }
      const params = { ...plugin.params, ...globalOverrides, ...override };
      const visitor = plugin.fn(ast, params, info);
      if (visitor != null) {
        visit(ast, visitor);
      }
    }
  };
  exports.invokePlugins = invokePlugins;
  var createPreset = ({ name, plugins }) => {
    return {
      name,
      fn: (ast, params, info) => {
        const { floatPrecision, overrides } = params;
        const globalOverrides = {};
        if (floatPrecision != null) {
          globalOverrides.floatPrecision = floatPrecision;
        }
        if (overrides) {
          const pluginNames = plugins.map(({ name: name2 }) => name2);
          for (const pluginName of Object.keys(overrides)) {
            if (!pluginNames.includes(pluginName)) {
              console.warn(`You are trying to configure ${pluginName} which is not part of ${name}.
` + `Try to put it before or after, for example

` + `plugins: [
` + `  {
` + `    name: '${name}',
` + `  },
` + `  '${pluginName}'
` + `]
`);
            }
          }
        }
        invokePlugins(ast, info, plugins, overrides, globalOverrides);
      }
    };
  };
  exports.createPreset = createPreset;
});

// ../../../../node_modules/.bun/svgo@3.3.2/node_modules/svgo/plugins/removeDoctype.js
var require_removeDoctype = __commonJS((exports) => {
  var { detachNodeFromParent } = require_xast();
  exports.name = "removeDoctype";
  exports.description = "removes doctype declaration";
  exports.fn = () => {
    return {
      doctype: {
        enter: (node, parentNode) => {
          detachNodeFromParent(node, parentNode);
        }
      }
    };
  };
});

// ../../../../node_modules/.bun/svgo@3.3.2/node_modules/svgo/plugins/removeXMLProcInst.js
var require_removeXMLProcInst = __commonJS((exports) => {
  var { detachNodeFromParent } = require_xast();
  exports.name = "removeXMLProcInst";
  exports.description = "removes XML processing instructions";
  exports.fn = () => {
    return {
      instruction: {
        enter: (node, parentNode) => {
          if (node.name === "xml") {
            detachNodeFromParent(node, parentNode);
          }
        }
      }
    };
  };
});

// ../../../../node_modules/.bun/svgo@3.3.2/node_modules/svgo/plugins/removeComments.js
var require_removeComments = __commonJS((exports) => {
  var { detachNodeFromParent } = require_xast();
  exports.name = "removeComments";
  exports.description = "removes comments";
  var DEFAULT_PRESERVE_PATTERNS = [/^!/];
  exports.fn = (_root, params) => {
    const { preservePatterns = DEFAULT_PRESERVE_PATTERNS } = params;
    return {
      comment: {
        enter: (node, parentNode) => {
          if (preservePatterns) {
            if (!Array.isArray(preservePatterns)) {
              throw Error(`Expected array in removeComments preservePatterns parameter but received ${preservePatterns}`);
            }
            const matches = preservePatterns.some((pattern) => {
              return new RegExp(pattern).test(node.value);
            });
            if (matches) {
              return;
            }
          }
          detachNodeFromParent(node, parentNode);
        }
      }
    };
  };
});

// ../../../../node_modules/.bun/svgo@3.3.2/node_modules/svgo/plugins/removeMetadata.js
var require_removeMetadata = __commonJS((exports) => {
  var { detachNodeFromParent } = require_xast();
  exports.name = "removeMetadata";
  exports.description = "removes <metadata>";
  exports.fn = () => {
    return {
      element: {
        enter: (node, parentNode) => {
          if (node.name === "metadata") {
            detachNodeFromParent(node, parentNode);
          }
        }
      }
    };
  };
});

// ../../../../node_modules/.bun/svgo@3.3.2/node_modules/svgo/plugins/removeEditorsNSData.js
var require_removeEditorsNSData = __commonJS((exports) => {
  var { detachNodeFromParent } = require_xast();
  var { editorNamespaces } = require__collections();
  exports.name = "removeEditorsNSData";
  exports.description = "removes editors namespaces, elements and attributes";
  exports.fn = (_root, params) => {
    let namespaces = [...editorNamespaces];
    if (Array.isArray(params.additionalNamespaces)) {
      namespaces = [...editorNamespaces, ...params.additionalNamespaces];
    }
    const prefixes = [];
    return {
      element: {
        enter: (node, parentNode) => {
          if (node.name === "svg") {
            for (const [name, value] of Object.entries(node.attributes)) {
              if (name.startsWith("xmlns:") && namespaces.includes(value)) {
                prefixes.push(name.slice("xmlns:".length));
                delete node.attributes[name];
              }
            }
          }
          for (const name of Object.keys(node.attributes)) {
            if (name.includes(":")) {
              const [prefix] = name.split(":");
              if (prefixes.includes(prefix)) {
                delete node.attributes[name];
              }
            }
          }
          if (node.name.includes(":")) {
            const [prefix] = node.name.split(":");
            if (prefixes.includes(prefix)) {
              detachNodeFromParent(node, parentNode);
            }
          }
        }
      }
    };
  };
});

// ../../../../node_modules/.bun/svgo@3.3.2/node_modules/svgo/plugins/cleanupAttrs.js
var require_cleanupAttrs = __commonJS((exports) => {
  exports.name = "cleanupAttrs";
  exports.description = "cleanups attributes from newlines, trailing and repeating spaces";
  var regNewlinesNeedSpace = /(\S)\r?\n(\S)/g;
  var regNewlines = /\r?\n/g;
  var regSpaces = /\s{2,}/g;
  exports.fn = (root, params) => {
    const { newlines = true, trim = true, spaces = true } = params;
    return {
      element: {
        enter: (node) => {
          for (const name of Object.keys(node.attributes)) {
            if (newlines) {
              node.attributes[name] = node.attributes[name].replace(regNewlinesNeedSpace, (match, p1, p2) => p1 + " " + p2);
              node.attributes[name] = node.attributes[name].replace(regNewlines, "");
            }
            if (trim) {
              node.attributes[name] = node.attributes[name].trim();
            }
            if (spaces) {
              node.attributes[name] = node.attributes[name].replace(regSpaces, " ");
            }
          }
        }
      }
    };
  };
});

// ../../../../node_modules/.bun/svgo@3.3.2/node_modules/svgo/plugins/mergeStyles.js
var require_mergeStyles = __commonJS((exports) => {
  var { visitSkip, detachNodeFromParent } = require_xast();
  exports.name = "mergeStyles";
  exports.description = "merge multiple style elements into one";
  exports.fn = () => {
    let firstStyleElement = null;
    let collectedStyles = "";
    let styleContentType = "text";
    return {
      element: {
        enter: (node, parentNode) => {
          if (node.name === "foreignObject") {
            return visitSkip;
          }
          if (node.name !== "style") {
            return;
          }
          if (node.attributes.type != null && node.attributes.type !== "" && node.attributes.type !== "text/css") {
            return;
          }
          let css = "";
          for (const child of node.children) {
            if (child.type === "text") {
              css += child.value;
            }
            if (child.type === "cdata") {
              styleContentType = "cdata";
              css += child.value;
            }
          }
          if (css.trim().length === 0) {
            detachNodeFromParent(node, parentNode);
            return;
          }
          if (node.attributes.media == null) {
            collectedStyles += css;
          } else {
            collectedStyles += `@media ${node.attributes.media}{${css}}`;
            delete node.attributes.media;
          }
          if (firstStyleElement == null) {
            firstStyleElement = node;
          } else {
            detachNodeFromParent(node, parentNode);
            const child = { type: styleContentType, value: collectedStyles };
            Object.defineProperty(child, "parentNode", {
              writable: true,
              value: firstStyleElement
            });
            firstStyleElement.children = [child];
          }
        }
      }
    };
  };
});

// ../../../../node_modules/.bun/css-tree@2.3.1/node_modules/css-tree/cjs/tokenizer/types.cjs
var require_types2 = __commonJS((exports) => {
  var EOF = 0;
  var Ident = 1;
  var Function = 2;
  var AtKeyword = 3;
  var Hash = 4;
  var String2 = 5;
  var BadString = 6;
  var Url = 7;
  var BadUrl = 8;
  var Delim = 9;
  var Number2 = 10;
  var Percentage = 11;
  var Dimension = 12;
  var WhiteSpace = 13;
  var CDO = 14;
  var CDC = 15;
  var Colon = 16;
  var Semicolon = 17;
  var Comma = 18;
  var LeftSquareBracket = 19;
  var RightSquareBracket = 20;
  var LeftParenthesis = 21;
  var RightParenthesis = 22;
  var LeftCurlyBracket = 23;
  var RightCurlyBracket = 24;
  var Comment = 25;
  exports.AtKeyword = AtKeyword;
  exports.BadString = BadString;
  exports.BadUrl = BadUrl;
  exports.CDC = CDC;
  exports.CDO = CDO;
  exports.Colon = Colon;
  exports.Comma = Comma;
  exports.Comment = Comment;
  exports.Delim = Delim;
  exports.Dimension = Dimension;
  exports.EOF = EOF;
  exports.Function = Function;
  exports.Hash = Hash;
  exports.Ident = Ident;
  exports.LeftCurlyBracket = LeftCurlyBracket;
  exports.LeftParenthesis = LeftParenthesis;
  exports.LeftSquareBracket = LeftSquareBracket;
  exports.Number = Number2;
  exports.Percentage = Percentage;
  exports.RightCurlyBracket = RightCurlyBracket;
  exports.RightParenthesis = RightParenthesis;
  exports.RightSquareBracket = RightSquareBracket;
  exports.Semicolon = Semicolon;
  exports.String = String2;
  exports.Url = Url;
  exports.WhiteSpace = WhiteSpace;
});

// ../../../../node_modules/.bun/css-tree@2.3.1/node_modules/css-tree/cjs/tokenizer/char-code-definitions.cjs
var require_char_code_definitions = __commonJS((exports) => {
  var EOF = 0;
  function isDigit(code) {
    return code >= 48 && code <= 57;
  }
  function isHexDigit(code) {
    return isDigit(code) || code >= 65 && code <= 70 || code >= 97 && code <= 102;
  }
  function isUppercaseLetter(code) {
    return code >= 65 && code <= 90;
  }
  function isLowercaseLetter(code) {
    return code >= 97 && code <= 122;
  }
  function isLetter(code) {
    return isUppercaseLetter(code) || isLowercaseLetter(code);
  }
  function isNonAscii(code) {
    return code >= 128;
  }
  function isNameStart(code) {
    return isLetter(code) || isNonAscii(code) || code === 95;
  }
  function isName(code) {
    return isNameStart(code) || isDigit(code) || code === 45;
  }
  function isNonPrintable(code) {
    return code >= 0 && code <= 8 || code === 11 || code >= 14 && code <= 31 || code === 127;
  }
  function isNewline(code) {
    return code === 10 || code === 13 || code === 12;
  }
  function isWhiteSpace(code) {
    return isNewline(code) || code === 32 || code === 9;
  }
  function isValidEscape(first, second) {
    if (first !== 92) {
      return false;
    }
    if (isNewline(second) || second === EOF) {
      return false;
    }
    return true;
  }
  function isIdentifierStart(first, second, third) {
    if (first === 45) {
      return isNameStart(second) || second === 45 || isValidEscape(second, third);
    }
    if (isNameStart(first)) {
      return true;
    }
    if (first === 92) {
      return isValidEscape(first, second);
    }
    return false;
  }
  function isNumberStart(first, second, third) {
    if (first === 43 || first === 45) {
      if (isDigit(second)) {
        return 2;
      }
      return second === 46 && isDigit(third) ? 3 : 0;
    }
    if (first === 46) {
      return isDigit(second) ? 2 : 0;
    }
    if (isDigit(first)) {
      return 1;
    }
    return 0;
  }
  function isBOM(code) {
    if (code === 65279) {
      return 1;
    }
    if (code === 65534) {
      return 1;
    }
    return 0;
  }
  var CATEGORY = new Array(128);
  var EofCategory = 128;
  var WhiteSpaceCategory = 130;
  var DigitCategory = 131;
  var NameStartCategory = 132;
  var NonPrintableCategory = 133;
  for (let i = 0;i < CATEGORY.length; i++) {
    CATEGORY[i] = isWhiteSpace(i) && WhiteSpaceCategory || isDigit(i) && DigitCategory || isNameStart(i) && NameStartCategory || isNonPrintable(i) && NonPrintableCategory || i || EofCategory;
  }
  function charCodeCategory(code) {
    return code < 128 ? CATEGORY[code] : NameStartCategory;
  }
  exports.DigitCategory = DigitCategory;
  exports.EofCategory = EofCategory;
  exports.NameStartCategory = NameStartCategory;
  exports.NonPrintableCategory = NonPrintableCategory;
  exports.WhiteSpaceCategory = WhiteSpaceCategory;
  exports.charCodeCategory = charCodeCategory;
  exports.isBOM = isBOM;
  exports.isDigit = isDigit;
  exports.isHexDigit = isHexDigit;
  exports.isIdentifierStart = isIdentifierStart;
  exports.isLetter = isLetter;
  exports.isLowercaseLetter = isLowercaseLetter;
  exports.isName = isName;
  exports.isNameStart = isNameStart;
  exports.isNewline = isNewline;
  exports.isNonAscii = isNonAscii;
  exports.isNonPrintable = isNonPrintable;
  exports.isNumberStart = isNumberStart;
  exports.isUppercaseLetter = isUppercaseLetter;
  exports.isValidEscape = isValidEscape;
  exports.isWhiteSpace = isWhiteSpace;
});

// ../../../../node_modules/.bun/css-tree@2.3.1/node_modules/css-tree/cjs/tokenizer/utils.cjs
var require_utils = __commonJS((exports) => {
  var charCodeDefinitions = require_char_code_definitions();
  function getCharCode(source, offset) {
    return offset < source.length ? source.charCodeAt(offset) : 0;
  }
  function getNewlineLength(source, offset, code) {
    if (code === 13 && getCharCode(source, offset + 1) === 10) {
      return 2;
    }
    return 1;
  }
  function cmpChar(testStr, offset, referenceCode) {
    let code = testStr.charCodeAt(offset);
    if (charCodeDefinitions.isUppercaseLetter(code)) {
      code = code | 32;
    }
    return code === referenceCode;
  }
  function cmpStr(testStr, start, end, referenceStr) {
    if (end - start !== referenceStr.length) {
      return false;
    }
    if (start < 0 || end > testStr.length) {
      return false;
    }
    for (let i = start;i < end; i++) {
      const referenceCode = referenceStr.charCodeAt(i - start);
      let testCode = testStr.charCodeAt(i);
      if (charCodeDefinitions.isUppercaseLetter(testCode)) {
        testCode = testCode | 32;
      }
      if (testCode !== referenceCode) {
        return false;
      }
    }
    return true;
  }
  function findWhiteSpaceStart(source, offset) {
    for (;offset >= 0; offset--) {
      if (!charCodeDefinitions.isWhiteSpace(source.charCodeAt(offset))) {
        break;
      }
    }
    return offset + 1;
  }
  function findWhiteSpaceEnd(source, offset) {
    for (;offset < source.length; offset++) {
      if (!charCodeDefinitions.isWhiteSpace(source.charCodeAt(offset))) {
        break;
      }
    }
    return offset;
  }
  function findDecimalNumberEnd(source, offset) {
    for (;offset < source.length; offset++) {
      if (!charCodeDefinitions.isDigit(source.charCodeAt(offset))) {
        break;
      }
    }
    return offset;
  }
  function consumeEscaped(source, offset) {
    offset += 2;
    if (charCodeDefinitions.isHexDigit(getCharCode(source, offset - 1))) {
      for (const maxOffset = Math.min(source.length, offset + 5);offset < maxOffset; offset++) {
        if (!charCodeDefinitions.isHexDigit(getCharCode(source, offset))) {
          break;
        }
      }
      const code = getCharCode(source, offset);
      if (charCodeDefinitions.isWhiteSpace(code)) {
        offset += getNewlineLength(source, offset, code);
      }
    }
    return offset;
  }
  function consumeName(source, offset) {
    for (;offset < source.length; offset++) {
      const code = source.charCodeAt(offset);
      if (charCodeDefinitions.isName(code)) {
        continue;
      }
      if (charCodeDefinitions.isValidEscape(code, getCharCode(source, offset + 1))) {
        offset = consumeEscaped(source, offset) - 1;
        continue;
      }
      break;
    }
    return offset;
  }
  function consumeNumber(source, offset) {
    let code = source.charCodeAt(offset);
    if (code === 43 || code === 45) {
      code = source.charCodeAt(offset += 1);
    }
    if (charCodeDefinitions.isDigit(code)) {
      offset = findDecimalNumberEnd(source, offset + 1);
      code = source.charCodeAt(offset);
    }
    if (code === 46 && charCodeDefinitions.isDigit(source.charCodeAt(offset + 1))) {
      offset += 2;
      offset = findDecimalNumberEnd(source, offset);
    }
    if (cmpChar(source, offset, 101)) {
      let sign = 0;
      code = source.charCodeAt(offset + 1);
      if (code === 45 || code === 43) {
        sign = 1;
        code = source.charCodeAt(offset + 2);
      }
      if (charCodeDefinitions.isDigit(code)) {
        offset = findDecimalNumberEnd(source, offset + 1 + sign + 1);
      }
    }
    return offset;
  }
  function consumeBadUrlRemnants(source, offset) {
    for (;offset < source.length; offset++) {
      const code = source.charCodeAt(offset);
      if (code === 41) {
        offset++;
        break;
      }
      if (charCodeDefinitions.isValidEscape(code, getCharCode(source, offset + 1))) {
        offset = consumeEscaped(source, offset);
      }
    }
    return offset;
  }
  function decodeEscaped(escaped) {
    if (escaped.length === 1 && !charCodeDefinitions.isHexDigit(escaped.charCodeAt(0))) {
      return escaped[0];
    }
    let code = parseInt(escaped, 16);
    if (code === 0 || code >= 55296 && code <= 57343 || code > 1114111) {
      code = 65533;
    }
    return String.fromCodePoint(code);
  }
  exports.cmpChar = cmpChar;
  exports.cmpStr = cmpStr;
  exports.consumeBadUrlRemnants = consumeBadUrlRemnants;
  exports.consumeEscaped = consumeEscaped;
  exports.consumeName = consumeName;
  exports.consumeNumber = consumeNumber;
  exports.decodeEscaped = decodeEscaped;
  exports.findDecimalNumberEnd = findDecimalNumberEnd;
  exports.findWhiteSpaceEnd = findWhiteSpaceEnd;
  exports.findWhiteSpaceStart = findWhiteSpaceStart;
  exports.getNewlineLength = getNewlineLength;
});

// ../../../../node_modules/.bun/css-tree@2.3.1/node_modules/css-tree/cjs/tokenizer/names.cjs
var require_names = __commonJS((exports, module) => {
  var tokenNames = [
    "EOF-token",
    "ident-token",
    "function-token",
    "at-keyword-token",
    "hash-token",
    "string-token",
    "bad-string-token",
    "url-token",
    "bad-url-token",
    "delim-token",
    "number-token",
    "percentage-token",
    "dimension-token",
    "whitespace-token",
    "CDO-token",
    "CDC-token",
    "colon-token",
    "semicolon-token",
    "comma-token",
    "[-token",
    "]-token",
    "(-token",
    ")-token",
    "{-token",
    "}-token"
  ];
  module.exports = tokenNames;
});

// ../../../../node_modules/.bun/css-tree@2.3.1/node_modules/css-tree/cjs/tokenizer/adopt-buffer.cjs
var require_adopt_buffer = __commonJS((exports) => {
  var MIN_SIZE = 16 * 1024;
  function adoptBuffer(buffer = null, size) {
    if (buffer === null || buffer.length < size) {
      return new Uint32Array(Math.max(size + 1024, MIN_SIZE));
    }
    return buffer;
  }
  exports.adoptBuffer = adoptBuffer;
});

// ../../../../node_modules/.bun/css-tree@2.3.1/node_modules/css-tree/cjs/tokenizer/OffsetToLocation.cjs
var require_OffsetToLocation = __commonJS((exports) => {
  var adoptBuffer = require_adopt_buffer();
  var charCodeDefinitions = require_char_code_definitions();
  var N = 10;
  var F = 12;
  var R = 13;
  function computeLinesAndColumns(host) {
    const source = host.source;
    const sourceLength = source.length;
    const startOffset = source.length > 0 ? charCodeDefinitions.isBOM(source.charCodeAt(0)) : 0;
    const lines = adoptBuffer.adoptBuffer(host.lines, sourceLength);
    const columns = adoptBuffer.adoptBuffer(host.columns, sourceLength);
    let line = host.startLine;
    let column = host.startColumn;
    for (let i = startOffset;i < sourceLength; i++) {
      const code = source.charCodeAt(i);
      lines[i] = line;
      columns[i] = column++;
      if (code === N || code === R || code === F) {
        if (code === R && i + 1 < sourceLength && source.charCodeAt(i + 1) === N) {
          i++;
          lines[i] = line;
          columns[i] = column;
        }
        line++;
        column = 1;
      }
    }
    lines[sourceLength] = line;
    columns[sourceLength] = column;
    host.lines = lines;
    host.columns = columns;
    host.computed = true;
  }

  class OffsetToLocation {
    constructor() {
      this.lines = null;
      this.columns = null;
      this.computed = false;
    }
    setSource(source, startOffset = 0, startLine = 1, startColumn = 1) {
      this.source = source;
      this.startOffset = startOffset;
      this.startLine = startLine;
      this.startColumn = startColumn;
      this.computed = false;
    }
    getLocation(offset, filename) {
      if (!this.computed) {
        computeLinesAndColumns(this);
      }
      return {
        source: filename,
        offset: this.startOffset + offset,
        line: this.lines[offset],
        column: this.columns[offset]
      };
    }
    getLocationRange(start, end, filename) {
      if (!this.computed) {
        computeLinesAndColumns(this);
      }
      return {
        source: filename,
        start: {
          offset: this.startOffset + start,
          line: this.lines[start],
          column: this.columns[start]
        },
        end: {
          offset: this.startOffset + end,
          line: this.lines[end],
          column: this.columns[end]
        }
      };
    }
  }
  exports.OffsetToLocation = OffsetToLocation;
});

// ../../../../node_modules/.bun/css-tree@2.3.1/node_modules/css-tree/cjs/tokenizer/TokenStream.cjs
var require_TokenStream = __commonJS((exports) => {
  var adoptBuffer = require_adopt_buffer();
  var utils = require_utils();
  var names = require_names();
  var types = require_types2();
  var OFFSET_MASK = 16777215;
  var TYPE_SHIFT = 24;
  var balancePair = new Map([
    [types.Function, types.RightParenthesis],
    [types.LeftParenthesis, types.RightParenthesis],
    [types.LeftSquareBracket, types.RightSquareBracket],
    [types.LeftCurlyBracket, types.RightCurlyBracket]
  ]);

  class TokenStream {
    constructor(source, tokenize) {
      this.setSource(source, tokenize);
    }
    reset() {
      this.eof = false;
      this.tokenIndex = -1;
      this.tokenType = 0;
      this.tokenStart = this.firstCharOffset;
      this.tokenEnd = this.firstCharOffset;
    }
    setSource(source = "", tokenize = () => {}) {
      source = String(source || "");
      const sourceLength = source.length;
      const offsetAndType = adoptBuffer.adoptBuffer(this.offsetAndType, source.length + 1);
      const balance = adoptBuffer.adoptBuffer(this.balance, source.length + 1);
      let tokenCount = 0;
      let balanceCloseType = 0;
      let balanceStart = 0;
      let firstCharOffset = -1;
      this.offsetAndType = null;
      this.balance = null;
      tokenize(source, (type, start, end) => {
        switch (type) {
          default:
            balance[tokenCount] = sourceLength;
            break;
          case balanceCloseType: {
            let balancePrev = balanceStart & OFFSET_MASK;
            balanceStart = balance[balancePrev];
            balanceCloseType = balanceStart >> TYPE_SHIFT;
            balance[tokenCount] = balancePrev;
            balance[balancePrev++] = tokenCount;
            for (;balancePrev < tokenCount; balancePrev++) {
              if (balance[balancePrev] === sourceLength) {
                balance[balancePrev] = tokenCount;
              }
            }
            break;
          }
          case types.LeftParenthesis:
          case types.Function:
          case types.LeftSquareBracket:
          case types.LeftCurlyBracket:
            balance[tokenCount] = balanceStart;
            balanceCloseType = balancePair.get(type);
            balanceStart = balanceCloseType << TYPE_SHIFT | tokenCount;
            break;
        }
        offsetAndType[tokenCount++] = type << TYPE_SHIFT | end;
        if (firstCharOffset === -1) {
          firstCharOffset = start;
        }
      });
      offsetAndType[tokenCount] = types.EOF << TYPE_SHIFT | sourceLength;
      balance[tokenCount] = sourceLength;
      balance[sourceLength] = sourceLength;
      while (balanceStart !== 0) {
        const balancePrev = balanceStart & OFFSET_MASK;
        balanceStart = balance[balancePrev];
        balance[balancePrev] = sourceLength;
      }
      this.source = source;
      this.firstCharOffset = firstCharOffset === -1 ? 0 : firstCharOffset;
      this.tokenCount = tokenCount;
      this.offsetAndType = offsetAndType;
      this.balance = balance;
      this.reset();
      this.next();
    }
    lookupType(offset) {
      offset += this.tokenIndex;
      if (offset < this.tokenCount) {
        return this.offsetAndType[offset] >> TYPE_SHIFT;
      }
      return types.EOF;
    }
    lookupOffset(offset) {
      offset += this.tokenIndex;
      if (offset < this.tokenCount) {
        return this.offsetAndType[offset - 1] & OFFSET_MASK;
      }
      return this.source.length;
    }
    lookupValue(offset, referenceStr) {
      offset += this.tokenIndex;
      if (offset < this.tokenCount) {
        return utils.cmpStr(this.source, this.offsetAndType[offset - 1] & OFFSET_MASK, this.offsetAndType[offset] & OFFSET_MASK, referenceStr);
      }
      return false;
    }
    getTokenStart(tokenIndex) {
      if (tokenIndex === this.tokenIndex) {
        return this.tokenStart;
      }
      if (tokenIndex > 0) {
        return tokenIndex < this.tokenCount ? this.offsetAndType[tokenIndex - 1] & OFFSET_MASK : this.offsetAndType[this.tokenCount] & OFFSET_MASK;
      }
      return this.firstCharOffset;
    }
    substrToCursor(start) {
      return this.source.substring(start, this.tokenStart);
    }
    isBalanceEdge(pos) {
      return this.balance[this.tokenIndex] < pos;
    }
    isDelim(code, offset) {
      if (offset) {
        return this.lookupType(offset) === types.Delim && this.source.charCodeAt(this.lookupOffset(offset)) === code;
      }
      return this.tokenType === types.Delim && this.source.charCodeAt(this.tokenStart) === code;
    }
    skip(tokenCount) {
      let next = this.tokenIndex + tokenCount;
      if (next < this.tokenCount) {
        this.tokenIndex = next;
        this.tokenStart = this.offsetAndType[next - 1] & OFFSET_MASK;
        next = this.offsetAndType[next];
        this.tokenType = next >> TYPE_SHIFT;
        this.tokenEnd = next & OFFSET_MASK;
      } else {
        this.tokenIndex = this.tokenCount;
        this.next();
      }
    }
    next() {
      let next = this.tokenIndex + 1;
      if (next < this.tokenCount) {
        this.tokenIndex = next;
        this.tokenStart = this.tokenEnd;
        next = this.offsetAndType[next];
        this.tokenType = next >> TYPE_SHIFT;
        this.tokenEnd = next & OFFSET_MASK;
      } else {
        this.eof = true;
        this.tokenIndex = this.tokenCount;
        this.tokenType = types.EOF;
        this.tokenStart = this.tokenEnd = this.source.length;
      }
    }
    skipSC() {
      while (this.tokenType === types.WhiteSpace || this.tokenType === types.Comment) {
        this.next();
      }
    }
    skipUntilBalanced(startToken, stopConsume) {
      let cursor = startToken;
      let balanceEnd;
      let offset;
      loop:
        for (;cursor < this.tokenCount; cursor++) {
          balanceEnd = this.balance[cursor];
          if (balanceEnd < startToken) {
            break loop;
          }
          offset = cursor > 0 ? this.offsetAndType[cursor - 1] & OFFSET_MASK : this.firstCharOffset;
          switch (stopConsume(this.source.charCodeAt(offset))) {
            case 1:
              break loop;
            case 2:
              cursor++;
              break loop;
            default:
              if (this.balance[balanceEnd] === cursor) {
                cursor = balanceEnd;
              }
          }
        }
      this.skip(cursor - this.tokenIndex);
    }
    forEachToken(fn) {
      for (let i = 0, offset = this.firstCharOffset;i < this.tokenCount; i++) {
        const start = offset;
        const item = this.offsetAndType[i];
        const end = item & OFFSET_MASK;
        const type = item >> TYPE_SHIFT;
        offset = end;
        fn(type, start, end, i);
      }
    }
    dump() {
      const tokens = new Array(this.tokenCount);
      this.forEachToken((type, start, end, index) => {
        tokens[index] = {
          idx: index,
          type: names[type],
          chunk: this.source.substring(start, end),
          balance: this.balance[index]
        };
      });
      return tokens;
    }
  }
  exports.TokenStream = TokenStream;
});

// ../../../../node_modules/.bun/css-tree@2.3.1/node_modules/css-tree/cjs/tokenizer/index.cjs
var require_tokenizer = __commonJS((exports) => {
  var types = require_types2();
  var charCodeDefinitions = require_char_code_definitions();
  var utils = require_utils();
  var names = require_names();
  var OffsetToLocation = require_OffsetToLocation();
  var TokenStream = require_TokenStream();
  function tokenize(source, onToken) {
    function getCharCode(offset2) {
      return offset2 < sourceLength ? source.charCodeAt(offset2) : 0;
    }
    function consumeNumericToken() {
      offset = utils.consumeNumber(source, offset);
      if (charCodeDefinitions.isIdentifierStart(getCharCode(offset), getCharCode(offset + 1), getCharCode(offset + 2))) {
        type = types.Dimension;
        offset = utils.consumeName(source, offset);
        return;
      }
      if (getCharCode(offset) === 37) {
        type = types.Percentage;
        offset++;
        return;
      }
      type = types.Number;
    }
    function consumeIdentLikeToken() {
      const nameStartOffset = offset;
      offset = utils.consumeName(source, offset);
      if (utils.cmpStr(source, nameStartOffset, offset, "url") && getCharCode(offset) === 40) {
        offset = utils.findWhiteSpaceEnd(source, offset + 1);
        if (getCharCode(offset) === 34 || getCharCode(offset) === 39) {
          type = types.Function;
          offset = nameStartOffset + 4;
          return;
        }
        consumeUrlToken();
        return;
      }
      if (getCharCode(offset) === 40) {
        type = types.Function;
        offset++;
        return;
      }
      type = types.Ident;
    }
    function consumeStringToken(endingCodePoint) {
      if (!endingCodePoint) {
        endingCodePoint = getCharCode(offset++);
      }
      type = types.String;
      for (;offset < source.length; offset++) {
        const code = source.charCodeAt(offset);
        switch (charCodeDefinitions.charCodeCategory(code)) {
          case endingCodePoint:
            offset++;
            return;
          case charCodeDefinitions.WhiteSpaceCategory:
            if (charCodeDefinitions.isNewline(code)) {
              offset += utils.getNewlineLength(source, offset, code);
              type = types.BadString;
              return;
            }
            break;
          case 92:
            if (offset === source.length - 1) {
              break;
            }
            const nextCode = getCharCode(offset + 1);
            if (charCodeDefinitions.isNewline(nextCode)) {
              offset += utils.getNewlineLength(source, offset + 1, nextCode);
            } else if (charCodeDefinitions.isValidEscape(code, nextCode)) {
              offset = utils.consumeEscaped(source, offset) - 1;
            }
            break;
        }
      }
    }
    function consumeUrlToken() {
      type = types.Url;
      offset = utils.findWhiteSpaceEnd(source, offset);
      for (;offset < source.length; offset++) {
        const code = source.charCodeAt(offset);
        switch (charCodeDefinitions.charCodeCategory(code)) {
          case 41:
            offset++;
            return;
          case charCodeDefinitions.WhiteSpaceCategory:
            offset = utils.findWhiteSpaceEnd(source, offset);
            if (getCharCode(offset) === 41 || offset >= source.length) {
              if (offset < source.length) {
                offset++;
              }
              return;
            }
            offset = utils.consumeBadUrlRemnants(source, offset);
            type = types.BadUrl;
            return;
          case 34:
          case 39:
          case 40:
          case charCodeDefinitions.NonPrintableCategory:
            offset = utils.consumeBadUrlRemnants(source, offset);
            type = types.BadUrl;
            return;
          case 92:
            if (charCodeDefinitions.isValidEscape(code, getCharCode(offset + 1))) {
              offset = utils.consumeEscaped(source, offset) - 1;
              break;
            }
            offset = utils.consumeBadUrlRemnants(source, offset);
            type = types.BadUrl;
            return;
        }
      }
    }
    source = String(source || "");
    const sourceLength = source.length;
    let start = charCodeDefinitions.isBOM(getCharCode(0));
    let offset = start;
    let type;
    while (offset < sourceLength) {
      const code = source.charCodeAt(offset);
      switch (charCodeDefinitions.charCodeCategory(code)) {
        case charCodeDefinitions.WhiteSpaceCategory:
          type = types.WhiteSpace;
          offset = utils.findWhiteSpaceEnd(source, offset + 1);
          break;
        case 34:
          consumeStringToken();
          break;
        case 35:
          if (charCodeDefinitions.isName(getCharCode(offset + 1)) || charCodeDefinitions.isValidEscape(getCharCode(offset + 1), getCharCode(offset + 2))) {
            type = types.Hash;
            offset = utils.consumeName(source, offset + 1);
          } else {
            type = types.Delim;
            offset++;
          }
          break;
        case 39:
          consumeStringToken();
          break;
        case 40:
          type = types.LeftParenthesis;
          offset++;
          break;
        case 41:
          type = types.RightParenthesis;
          offset++;
          break;
        case 43:
          if (charCodeDefinitions.isNumberStart(code, getCharCode(offset + 1), getCharCode(offset + 2))) {
            consumeNumericToken();
          } else {
            type = types.Delim;
            offset++;
          }
          break;
        case 44:
          type = types.Comma;
          offset++;
          break;
        case 45:
          if (charCodeDefinitions.isNumberStart(code, getCharCode(offset + 1), getCharCode(offset + 2))) {
            consumeNumericToken();
          } else {
            if (getCharCode(offset + 1) === 45 && getCharCode(offset + 2) === 62) {
              type = types.CDC;
              offset = offset + 3;
            } else {
              if (charCodeDefinitions.isIdentifierStart(code, getCharCode(offset + 1), getCharCode(offset + 2))) {
                consumeIdentLikeToken();
              } else {
                type = types.Delim;
                offset++;
              }
            }
          }
          break;
        case 46:
          if (charCodeDefinitions.isNumberStart(code, getCharCode(offset + 1), getCharCode(offset + 2))) {
            consumeNumericToken();
          } else {
            type = types.Delim;
            offset++;
          }
          break;
        case 47:
          if (getCharCode(offset + 1) === 42) {
            type = types.Comment;
            offset = source.indexOf("*/", offset + 2);
            offset = offset === -1 ? source.length : offset + 2;
          } else {
            type = types.Delim;
            offset++;
          }
          break;
        case 58:
          type = types.Colon;
          offset++;
          break;
        case 59:
          type = types.Semicolon;
          offset++;
          break;
        case 60:
          if (getCharCode(offset + 1) === 33 && getCharCode(offset + 2) === 45 && getCharCode(offset + 3) === 45) {
            type = types.CDO;
            offset = offset + 4;
          } else {
            type = types.Delim;
            offset++;
          }
          break;
        case 64:
          if (charCodeDefinitions.isIdentifierStart(getCharCode(offset + 1), getCharCode(offset + 2), getCharCode(offset + 3))) {
            type = types.AtKeyword;
            offset = utils.consumeName(source, offset + 1);
          } else {
            type = types.Delim;
            offset++;
          }
          break;
        case 91:
          type = types.LeftSquareBracket;
          offset++;
          break;
        case 92:
          if (charCodeDefinitions.isValidEscape(code, getCharCode(offset + 1))) {
            consumeIdentLikeToken();
          } else {
            type = types.Delim;
            offset++;
          }
          break;
        case 93:
          type = types.RightSquareBracket;
          offset++;
          break;
        case 123:
          type = types.LeftCurlyBracket;
          offset++;
          break;
        case 125:
          type = types.RightCurlyBracket;
          offset++;
          break;
        case charCodeDefinitions.DigitCategory:
          consumeNumericToken();
          break;
        case charCodeDefinitions.NameStartCategory:
          consumeIdentLikeToken();
          break;
        default:
          type = types.Delim;
          offset++;
      }
      onToken(type, start, start = offset);
    }
  }
  exports.AtKeyword = types.AtKeyword;
  exports.BadString = types.BadString;
  exports.BadUrl = types.BadUrl;
  exports.CDC = types.CDC;
  exports.CDO = types.CDO;
  exports.Colon = types.Colon;
  exports.Comma = types.Comma;
  exports.Comment = types.Comment;
  exports.Delim = types.Delim;
  exports.Dimension = types.Dimension;
  exports.EOF = types.EOF;
  exports.Function = types.Function;
  exports.Hash = types.Hash;
  exports.Ident = types.Ident;
  exports.LeftCurlyBracket = types.LeftCurlyBracket;
  exports.LeftParenthesis = types.LeftParenthesis;
  exports.LeftSquareBracket = types.LeftSquareBracket;
  exports.Number = types.Number;
  exports.Percentage = types.Percentage;
  exports.RightCurlyBracket = types.RightCurlyBracket;
  exports.RightParenthesis = types.RightParenthesis;
  exports.RightSquareBracket = types.RightSquareBracket;
  exports.Semicolon = types.Semicolon;
  exports.String = types.String;
  exports.Url = types.Url;
  exports.WhiteSpace = types.WhiteSpace;
  exports.tokenTypes = types;
  exports.DigitCategory = charCodeDefinitions.DigitCategory;
  exports.EofCategory = charCodeDefinitions.EofCategory;
  exports.NameStartCategory = charCodeDefinitions.NameStartCategory;
  exports.NonPrintableCategory = charCodeDefinitions.NonPrintableCategory;
  exports.WhiteSpaceCategory = charCodeDefinitions.WhiteSpaceCategory;
  exports.charCodeCategory = charCodeDefinitions.charCodeCategory;
  exports.isBOM = charCodeDefinitions.isBOM;
  exports.isDigit = charCodeDefinitions.isDigit;
  exports.isHexDigit = charCodeDefinitions.isHexDigit;
  exports.isIdentifierStart = charCodeDefinitions.isIdentifierStart;
  exports.isLetter = charCodeDefinitions.isLetter;
  exports.isLowercaseLetter = charCodeDefinitions.isLowercaseLetter;
  exports.isName = charCodeDefinitions.isName;
  exports.isNameStart = charCodeDefinitions.isNameStart;
  exports.isNewline = charCodeDefinitions.isNewline;
  exports.isNonAscii = charCodeDefinitions.isNonAscii;
  exports.isNonPrintable = charCodeDefinitions.isNonPrintable;
  exports.isNumberStart = charCodeDefinitions.isNumberStart;
  exports.isUppercaseLetter = charCodeDefinitions.isUppercaseLetter;
  exports.isValidEscape = charCodeDefinitions.isValidEscape;
  exports.isWhiteSpace = charCodeDefinitions.isWhiteSpace;
  exports.cmpChar = utils.cmpChar;
  exports.cmpStr = utils.cmpStr;
  exports.consumeBadUrlRemnants = utils.consumeBadUrlRemnants;
  exports.consumeEscaped = utils.consumeEscaped;
  exports.consumeName = utils.consumeName;
  exports.consumeNumber = utils.consumeNumber;
  exports.decodeEscaped = utils.decodeEscaped;
  exports.findDecimalNumberEnd = utils.findDecimalNumberEnd;
  exports.findWhiteSpaceEnd = utils.findWhiteSpaceEnd;
  exports.findWhiteSpaceStart = utils.findWhiteSpaceStart;
  exports.getNewlineLength = utils.getNewlineLength;
  exports.tokenNames = names;
  exports.OffsetToLocation = OffsetToLocation.OffsetToLocation;
  exports.TokenStream = TokenStream.TokenStream;
  exports.tokenize = tokenize;
});

// ../../../../node_modules/.bun/css-tree@2.3.1/node_modules/css-tree/cjs/utils/List.cjs
var require_List = __commonJS((exports) => {
  var releasedCursors = null;

  class List {
    static createItem(data) {
      return {
        prev: null,
        next: null,
        data
      };
    }
    constructor() {
      this.head = null;
      this.tail = null;
      this.cursor = null;
    }
    createItem(data) {
      return List.createItem(data);
    }
    allocateCursor(prev, next) {
      let cursor;
      if (releasedCursors !== null) {
        cursor = releasedCursors;
        releasedCursors = releasedCursors.cursor;
        cursor.prev = prev;
        cursor.next = next;
        cursor.cursor = this.cursor;
      } else {
        cursor = {
          prev,
          next,
          cursor: this.cursor
        };
      }
      this.cursor = cursor;
      return cursor;
    }
    releaseCursor() {
      const { cursor } = this;
      this.cursor = cursor.cursor;
      cursor.prev = null;
      cursor.next = null;
      cursor.cursor = releasedCursors;
      releasedCursors = cursor;
    }
    updateCursors(prevOld, prevNew, nextOld, nextNew) {
      let { cursor } = this;
      while (cursor !== null) {
        if (cursor.prev === prevOld) {
          cursor.prev = prevNew;
        }
        if (cursor.next === nextOld) {
          cursor.next = nextNew;
        }
        cursor = cursor.cursor;
      }
    }
    *[Symbol.iterator]() {
      for (let cursor = this.head;cursor !== null; cursor = cursor.next) {
        yield cursor.data;
      }
    }
    get size() {
      let size = 0;
      for (let cursor = this.head;cursor !== null; cursor = cursor.next) {
        size++;
      }
      return size;
    }
    get isEmpty() {
      return this.head === null;
    }
    get first() {
      return this.head && this.head.data;
    }
    get last() {
      return this.tail && this.tail.data;
    }
    fromArray(array) {
      let cursor = null;
      this.head = null;
      for (let data of array) {
        const item = List.createItem(data);
        if (cursor !== null) {
          cursor.next = item;
        } else {
          this.head = item;
        }
        item.prev = cursor;
        cursor = item;
      }
      this.tail = cursor;
      return this;
    }
    toArray() {
      return [...this];
    }
    toJSON() {
      return [...this];
    }
    forEach(fn, thisArg = this) {
      const cursor = this.allocateCursor(null, this.head);
      while (cursor.next !== null) {
        const item = cursor.next;
        cursor.next = item.next;
        fn.call(thisArg, item.data, item, this);
      }
      this.releaseCursor();
    }
    forEachRight(fn, thisArg = this) {
      const cursor = this.allocateCursor(this.tail, null);
      while (cursor.prev !== null) {
        const item = cursor.prev;
        cursor.prev = item.prev;
        fn.call(thisArg, item.data, item, this);
      }
      this.releaseCursor();
    }
    reduce(fn, initialValue, thisArg = this) {
      let cursor = this.allocateCursor(null, this.head);
      let acc = initialValue;
      let item;
      while (cursor.next !== null) {
        item = cursor.next;
        cursor.next = item.next;
        acc = fn.call(thisArg, acc, item.data, item, this);
      }
      this.releaseCursor();
      return acc;
    }
    reduceRight(fn, initialValue, thisArg = this) {
      let cursor = this.allocateCursor(this.tail, null);
      let acc = initialValue;
      let item;
      while (cursor.prev !== null) {
        item = cursor.prev;
        cursor.prev = item.prev;
        acc = fn.call(thisArg, acc, item.data, item, this);
      }
      this.releaseCursor();
      return acc;
    }
    some(fn, thisArg = this) {
      for (let cursor = this.head;cursor !== null; cursor = cursor.next) {
        if (fn.call(thisArg, cursor.data, cursor, this)) {
          return true;
        }
      }
      return false;
    }
    map(fn, thisArg = this) {
      const result = new List;
      for (let cursor = this.head;cursor !== null; cursor = cursor.next) {
        result.appendData(fn.call(thisArg, cursor.data, cursor, this));
      }
      return result;
    }
    filter(fn, thisArg = this) {
      const result = new List;
      for (let cursor = this.head;cursor !== null; cursor = cursor.next) {
        if (fn.call(thisArg, cursor.data, cursor, this)) {
          result.appendData(cursor.data);
        }
      }
      return result;
    }
    nextUntil(start, fn, thisArg = this) {
      if (start === null) {
        return;
      }
      const cursor = this.allocateCursor(null, start);
      while (cursor.next !== null) {
        const item = cursor.next;
        cursor.next = item.next;
        if (fn.call(thisArg, item.data, item, this)) {
          break;
        }
      }
      this.releaseCursor();
    }
    prevUntil(start, fn, thisArg = this) {
      if (start === null) {
        return;
      }
      const cursor = this.allocateCursor(start, null);
      while (cursor.prev !== null) {
        const item = cursor.prev;
        cursor.prev = item.prev;
        if (fn.call(thisArg, item.data, item, this)) {
          break;
        }
      }
      this.releaseCursor();
    }
    clear() {
      this.head = null;
      this.tail = null;
    }
    copy() {
      const result = new List;
      for (let data of this) {
        result.appendData(data);
      }
      return result;
    }
    prepend(item) {
      this.updateCursors(null, item, this.head, item);
      if (this.head !== null) {
        this.head.prev = item;
        item.next = this.head;
      } else {
        this.tail = item;
      }
      this.head = item;
      return this;
    }
    prependData(data) {
      return this.prepend(List.createItem(data));
    }
    append(item) {
      return this.insert(item);
    }
    appendData(data) {
      return this.insert(List.createItem(data));
    }
    insert(item, before = null) {
      if (before !== null) {
        this.updateCursors(before.prev, item, before, item);
        if (before.prev === null) {
          if (this.head !== before) {
            throw new Error("before doesn't belong to list");
          }
          this.head = item;
          before.prev = item;
          item.next = before;
          this.updateCursors(null, item);
        } else {
          before.prev.next = item;
          item.prev = before.prev;
          before.prev = item;
          item.next = before;
        }
      } else {
        this.updateCursors(this.tail, item, null, item);
        if (this.tail !== null) {
          this.tail.next = item;
          item.prev = this.tail;
        } else {
          this.head = item;
        }
        this.tail = item;
      }
      return this;
    }
    insertData(data, before) {
      return this.insert(List.createItem(data), before);
    }
    remove(item) {
      this.updateCursors(item, item.prev, item, item.next);
      if (item.prev !== null) {
        item.prev.next = item.next;
      } else {
        if (this.head !== item) {
          throw new Error("item doesn't belong to list");
        }
        this.head = item.next;
      }
      if (item.next !== null) {
        item.next.prev = item.prev;
      } else {
        if (this.tail !== item) {
          throw new Error("item doesn't belong to list");
        }
        this.tail = item.prev;
      }
      item.prev = null;
      item.next = null;
      return item;
    }
    push(data) {
      this.insert(List.createItem(data));
    }
    pop() {
      return this.tail !== null ? this.remove(this.tail) : null;
    }
    unshift(data) {
      this.prepend(List.createItem(data));
    }
    shift() {
      return this.head !== null ? this.remove(this.head) : null;
    }
    prependList(list) {
      return this.insertList(list, this.head);
    }
    appendList(list) {
      return this.insertList(list);
    }
    insertList(list, before) {
      if (list.head === null) {
        return this;
      }
      if (before !== undefined && before !== null) {
        this.updateCursors(before.prev, list.tail, before, list.head);
        if (before.prev !== null) {
          before.prev.next = list.head;
          list.head.prev = before.prev;
        } else {
          this.head = list.head;
        }
        before.prev = list.tail;
        list.tail.next = before;
      } else {
        this.updateCursors(this.tail, list.tail, null, list.head);
        if (this.tail !== null) {
          this.tail.next = list.head;
          list.head.prev = this.tail;
        } else {
          this.head = list.head;
        }
        this.tail = list.tail;
      }
      list.head = null;
      list.tail = null;
      return this;
    }
    replace(oldItem, newItemOrList) {
      if ("head" in newItemOrList) {
        this.insertList(newItemOrList, oldItem);
      } else {
        this.insert(newItemOrList, oldItem);
      }
      this.remove(oldItem);
    }
  }
  exports.List = List;
});

// ../../../../node_modules/.bun/css-tree@2.3.1/node_modules/css-tree/cjs/utils/create-custom-error.cjs
var require_create_custom_error = __commonJS((exports) => {
  function createCustomError(name, message) {
    const error = Object.create(SyntaxError.prototype);
    const errorStack = new Error;
    return Object.assign(error, {
      name,
      message,
      get stack() {
        return (errorStack.stack || "").replace(/^(.+\n){1,3}/, `${name}: ${message}
`);
      }
    });
  }
  exports.createCustomError = createCustomError;
});

// ../../../../node_modules/.bun/css-tree@2.3.1/node_modules/css-tree/cjs/parser/SyntaxError.cjs
var require_SyntaxError = __commonJS((exports) => {
  var createCustomError = require_create_custom_error();
  var MAX_LINE_LENGTH = 100;
  var OFFSET_CORRECTION = 60;
  var TAB_REPLACEMENT = "    ";
  function sourceFragment({ source, line, column }, extraLines) {
    function processLines(start, end) {
      return lines.slice(start, end).map((line2, idx) => String(start + idx + 1).padStart(maxNumLength) + " |" + line2).join(`
`);
    }
    const lines = source.split(/\r\n?|\n|\f/);
    const startLine = Math.max(1, line - extraLines) - 1;
    const endLine = Math.min(line + extraLines, lines.length + 1);
    const maxNumLength = Math.max(4, String(endLine).length) + 1;
    let cutLeft = 0;
    column += (TAB_REPLACEMENT.length - 1) * (lines[line - 1].substr(0, column - 1).match(/\t/g) || []).length;
    if (column > MAX_LINE_LENGTH) {
      cutLeft = column - OFFSET_CORRECTION + 3;
      column = OFFSET_CORRECTION - 2;
    }
    for (let i = startLine;i <= endLine; i++) {
      if (i >= 0 && i < lines.length) {
        lines[i] = lines[i].replace(/\t/g, TAB_REPLACEMENT);
        lines[i] = (cutLeft > 0 && lines[i].length > cutLeft ? "" : "") + lines[i].substr(cutLeft, MAX_LINE_LENGTH - 2) + (lines[i].length > cutLeft + MAX_LINE_LENGTH - 1 ? "" : "");
      }
    }
    return [
      processLines(startLine, line),
      new Array(column + maxNumLength + 2).join("-") + "^",
      processLines(line, endLine)
    ].filter(Boolean).join(`
`);
  }
  function SyntaxError2(message, source, offset, line, column) {
    const error = Object.assign(createCustomError.createCustomError("SyntaxError", message), {
      source,
      offset,
      line,
      column,
      sourceFragment(extraLines) {
        return sourceFragment({ source, line, column }, isNaN(extraLines) ? 0 : extraLines);
      },
      get formattedMessage() {
        return `Parse error: ${message}
` + sourceFragment({ source, line, column }, 2);
      }
    });
    return error;
  }
  exports.SyntaxError = SyntaxError2;
});

// ../../../../node_modules/.bun/css-tree@2.3.1/node_modules/css-tree/cjs/parser/sequence.cjs
var require_sequence = __commonJS((exports) => {
  var types = require_types2();
  function readSequence(recognizer) {
    const children = this.createList();
    let space = false;
    const context = {
      recognizer
    };
    while (!this.eof) {
      switch (this.tokenType) {
        case types.Comment:
          this.next();
          continue;
        case types.WhiteSpace:
          space = true;
          this.next();
          continue;
      }
      let child = recognizer.getNode.call(this, context);
      if (child === undefined) {
        break;
      }
      if (space) {
        if (recognizer.onWhiteSpace) {
          recognizer.onWhiteSpace.call(this, child, children, context);
        }
        space = false;
      }
      children.push(child);
    }
    if (space && recognizer.onWhiteSpace) {
      recognizer.onWhiteSpace.call(this, null, children, context);
    }
    return children;
  }
  exports.readSequence = readSequence;
});

// ../../../../node_modules/.bun/css-tree@2.3.1/node_modules/css-tree/cjs/parser/create.cjs
var require_create = __commonJS((exports) => {
  var List = require_List();
  var SyntaxError2 = require_SyntaxError();
  var index = require_tokenizer();
  var sequence = require_sequence();
  var OffsetToLocation = require_OffsetToLocation();
  var TokenStream = require_TokenStream();
  var utils = require_utils();
  var types = require_types2();
  var names = require_names();
  var NOOP = () => {};
  var EXCLAMATIONMARK = 33;
  var NUMBERSIGN = 35;
  var SEMICOLON = 59;
  var LEFTCURLYBRACKET = 123;
  var NULL = 0;
  function createParseContext(name) {
    return function() {
      return this[name]();
    };
  }
  function fetchParseValues(dict) {
    const result = Object.create(null);
    for (const name in dict) {
      const item = dict[name];
      const fn = item.parse || item;
      if (fn) {
        result[name] = fn;
      }
    }
    return result;
  }
  function processConfig(config) {
    const parseConfig = {
      context: Object.create(null),
      scope: Object.assign(Object.create(null), config.scope),
      atrule: fetchParseValues(config.atrule),
      pseudo: fetchParseValues(config.pseudo),
      node: fetchParseValues(config.node)
    };
    for (const name in config.parseContext) {
      switch (typeof config.parseContext[name]) {
        case "function":
          parseConfig.context[name] = config.parseContext[name];
          break;
        case "string":
          parseConfig.context[name] = createParseContext(config.parseContext[name]);
          break;
      }
    }
    return {
      config: parseConfig,
      ...parseConfig,
      ...parseConfig.node
    };
  }
  function createParser(config) {
    let source = "";
    let filename = "<unknown>";
    let needPositions = false;
    let onParseError = NOOP;
    let onParseErrorThrow = false;
    const locationMap = new OffsetToLocation.OffsetToLocation;
    const parser = Object.assign(new TokenStream.TokenStream, processConfig(config || {}), {
      parseAtrulePrelude: true,
      parseRulePrelude: true,
      parseValue: true,
      parseCustomProperty: false,
      readSequence: sequence.readSequence,
      consumeUntilBalanceEnd: () => 0,
      consumeUntilLeftCurlyBracket(code) {
        return code === LEFTCURLYBRACKET ? 1 : 0;
      },
      consumeUntilLeftCurlyBracketOrSemicolon(code) {
        return code === LEFTCURLYBRACKET || code === SEMICOLON ? 1 : 0;
      },
      consumeUntilExclamationMarkOrSemicolon(code) {
        return code === EXCLAMATIONMARK || code === SEMICOLON ? 1 : 0;
      },
      consumeUntilSemicolonIncluded(code) {
        return code === SEMICOLON ? 2 : 0;
      },
      createList() {
        return new List.List;
      },
      createSingleNodeList(node) {
        return new List.List().appendData(node);
      },
      getFirstListNode(list) {
        return list && list.first;
      },
      getLastListNode(list) {
        return list && list.last;
      },
      parseWithFallback(consumer, fallback) {
        const startToken = this.tokenIndex;
        try {
          return consumer.call(this);
        } catch (e) {
          if (onParseErrorThrow) {
            throw e;
          }
          const fallbackNode = fallback.call(this, startToken);
          onParseErrorThrow = true;
          onParseError(e, fallbackNode);
          onParseErrorThrow = false;
          return fallbackNode;
        }
      },
      lookupNonWSType(offset) {
        let type;
        do {
          type = this.lookupType(offset++);
          if (type !== types.WhiteSpace) {
            return type;
          }
        } while (type !== NULL);
        return NULL;
      },
      charCodeAt(offset) {
        return offset >= 0 && offset < source.length ? source.charCodeAt(offset) : 0;
      },
      substring(offsetStart, offsetEnd) {
        return source.substring(offsetStart, offsetEnd);
      },
      substrToCursor(start) {
        return this.source.substring(start, this.tokenStart);
      },
      cmpChar(offset, charCode) {
        return utils.cmpChar(source, offset, charCode);
      },
      cmpStr(offsetStart, offsetEnd, str) {
        return utils.cmpStr(source, offsetStart, offsetEnd, str);
      },
      consume(tokenType) {
        const start = this.tokenStart;
        this.eat(tokenType);
        return this.substrToCursor(start);
      },
      consumeFunctionName() {
        const name = source.substring(this.tokenStart, this.tokenEnd - 1);
        this.eat(types.Function);
        return name;
      },
      consumeNumber(type) {
        const number = source.substring(this.tokenStart, utils.consumeNumber(source, this.tokenStart));
        this.eat(type);
        return number;
      },
      eat(tokenType) {
        if (this.tokenType !== tokenType) {
          const tokenName = names[tokenType].slice(0, -6).replace(/-/g, " ").replace(/^./, (m) => m.toUpperCase());
          let message = `${/[[\](){}]/.test(tokenName) ? `"${tokenName}"` : tokenName} is expected`;
          let offset = this.tokenStart;
          switch (tokenType) {
            case types.Ident:
              if (this.tokenType === types.Function || this.tokenType === types.Url) {
                offset = this.tokenEnd - 1;
                message = "Identifier is expected but function found";
              } else {
                message = "Identifier is expected";
              }
              break;
            case types.Hash:
              if (this.isDelim(NUMBERSIGN)) {
                this.next();
                offset++;
                message = "Name is expected";
              }
              break;
            case types.Percentage:
              if (this.tokenType === types.Number) {
                offset = this.tokenEnd;
                message = "Percent sign is expected";
              }
              break;
          }
          this.error(message, offset);
        }
        this.next();
      },
      eatIdent(name) {
        if (this.tokenType !== types.Ident || this.lookupValue(0, name) === false) {
          this.error(`Identifier "${name}" is expected`);
        }
        this.next();
      },
      eatDelim(code) {
        if (!this.isDelim(code)) {
          this.error(`Delim "${String.fromCharCode(code)}" is expected`);
        }
        this.next();
      },
      getLocation(start, end) {
        if (needPositions) {
          return locationMap.getLocationRange(start, end, filename);
        }
        return null;
      },
      getLocationFromList(list) {
        if (needPositions) {
          const head = this.getFirstListNode(list);
          const tail = this.getLastListNode(list);
          return locationMap.getLocationRange(head !== null ? head.loc.start.offset - locationMap.startOffset : this.tokenStart, tail !== null ? tail.loc.end.offset - locationMap.startOffset : this.tokenStart, filename);
        }
        return null;
      },
      error(message, offset) {
        const location = typeof offset !== "undefined" && offset < source.length ? locationMap.getLocation(offset) : this.eof ? locationMap.getLocation(utils.findWhiteSpaceStart(source, source.length - 1)) : locationMap.getLocation(this.tokenStart);
        throw new SyntaxError2.SyntaxError(message || "Unexpected input", source, location.offset, location.line, location.column);
      }
    });
    const parse = function(source_, options) {
      source = source_;
      options = options || {};
      parser.setSource(source, index.tokenize);
      locationMap.setSource(source, options.offset, options.line, options.column);
      filename = options.filename || "<unknown>";
      needPositions = Boolean(options.positions);
      onParseError = typeof options.onParseError === "function" ? options.onParseError : NOOP;
      onParseErrorThrow = false;
      parser.parseAtrulePrelude = "parseAtrulePrelude" in options ? Boolean(options.parseAtrulePrelude) : true;
      parser.parseRulePrelude = "parseRulePrelude" in options ? Boolean(options.parseRulePrelude) : true;
      parser.parseValue = "parseValue" in options ? Boolean(options.parseValue) : true;
      parser.parseCustomProperty = "parseCustomProperty" in options ? Boolean(options.parseCustomProperty) : false;
      const { context = "default", onComment } = options;
      if (context in parser.context === false) {
        throw new Error("Unknown context `" + context + "`");
      }
      if (typeof onComment === "function") {
        parser.forEachToken((type, start, end) => {
          if (type === types.Comment) {
            const loc = parser.getLocation(start, end);
            const value = utils.cmpStr(source, end - 2, end, "*/") ? source.slice(start + 2, end - 2) : source.slice(start + 2, end);
            onComment(value, loc);
          }
        });
      }
      const ast = parser.context[context].call(parser, options);
      if (!parser.eof) {
        parser.error();
      }
      return ast;
    };
    return Object.assign(parse, {
      SyntaxError: SyntaxError2.SyntaxError,
      config: parser.config
    });
  }
  exports.createParser = createParser;
});

// ../../../../node_modules/.bun/source-map-js@1.2.1/node_modules/source-map-js/lib/base64.js
var require_base64 = __commonJS((exports) => {
  var intToCharMap = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/".split("");
  exports.encode = function(number) {
    if (0 <= number && number < intToCharMap.length) {
      return intToCharMap[number];
    }
    throw new TypeError("Must be between 0 and 63: " + number);
  };
  exports.decode = function(charCode) {
    var bigA = 65;
    var bigZ = 90;
    var littleA = 97;
    var littleZ = 122;
    var zero = 48;
    var nine = 57;
    var plus = 43;
    var slash = 47;
    var littleOffset = 26;
    var numberOffset = 52;
    if (bigA <= charCode && charCode <= bigZ) {
      return charCode - bigA;
    }
    if (littleA <= charCode && charCode <= littleZ) {
      return charCode - littleA + littleOffset;
    }
    if (zero <= charCode && charCode <= nine) {
      return charCode - zero + numberOffset;
    }
    if (charCode == plus) {
      return 62;
    }
    if (charCode == slash) {
      return 63;
    }
    return -1;
  };
});

// ../../../../node_modules/.bun/source-map-js@1.2.1/node_modules/source-map-js/lib/base64-vlq.js
var require_base64_vlq = __commonJS((exports) => {
  var base64 = require_base64();
  var VLQ_BASE_SHIFT = 5;
  var VLQ_BASE = 1 << VLQ_BASE_SHIFT;
  var VLQ_BASE_MASK = VLQ_BASE - 1;
  var VLQ_CONTINUATION_BIT = VLQ_BASE;
  function toVLQSigned(aValue) {
    return aValue < 0 ? (-aValue << 1) + 1 : (aValue << 1) + 0;
  }
  function fromVLQSigned(aValue) {
    var isNegative = (aValue & 1) === 1;
    var shifted = aValue >> 1;
    return isNegative ? -shifted : shifted;
  }
  exports.encode = function base64VLQ_encode(aValue) {
    var encoded = "";
    var digit;
    var vlq = toVLQSigned(aValue);
    do {
      digit = vlq & VLQ_BASE_MASK;
      vlq >>>= VLQ_BASE_SHIFT;
      if (vlq > 0) {
        digit |= VLQ_CONTINUATION_BIT;
      }
      encoded += base64.encode(digit);
    } while (vlq > 0);
    return encoded;
  };
  exports.decode = function base64VLQ_decode(aStr, aIndex, aOutParam) {
    var strLen = aStr.length;
    var result = 0;
    var shift = 0;
    var continuation, digit;
    do {
      if (aIndex >= strLen) {
        throw new Error("Expected more digits in base 64 VLQ value.");
      }
      digit = base64.decode(aStr.charCodeAt(aIndex++));
      if (digit === -1) {
        throw new Error("Invalid base64 digit: " + aStr.charAt(aIndex - 1));
      }
      continuation = !!(digit & VLQ_CONTINUATION_BIT);
      digit &= VLQ_BASE_MASK;
      result = result + (digit << shift);
      shift += VLQ_BASE_SHIFT;
    } while (continuation);
    aOutParam.value = fromVLQSigned(result);
    aOutParam.rest = aIndex;
  };
});

// ../../../../node_modules/.bun/source-map-js@1.2.1/node_modules/source-map-js/lib/util.js
var require_util = __commonJS((exports) => {
  function getArg(aArgs, aName, aDefaultValue) {
    if (aName in aArgs) {
      return aArgs[aName];
    } else if (arguments.length === 3) {
      return aDefaultValue;
    } else {
      throw new Error('"' + aName + '" is a required argument.');
    }
  }
  exports.getArg = getArg;
  var urlRegexp = /^(?:([\w+\-.]+):)?\/\/(?:(\w+:\w+)@)?([\w.-]*)(?::(\d+))?(.*)$/;
  var dataUrlRegexp = /^data:.+\,.+$/;
  function urlParse(aUrl) {
    var match = aUrl.match(urlRegexp);
    if (!match) {
      return null;
    }
    return {
      scheme: match[1],
      auth: match[2],
      host: match[3],
      port: match[4],
      path: match[5]
    };
  }
  exports.urlParse = urlParse;
  function urlGenerate(aParsedUrl) {
    var url = "";
    if (aParsedUrl.scheme) {
      url += aParsedUrl.scheme + ":";
    }
    url += "//";
    if (aParsedUrl.auth) {
      url += aParsedUrl.auth + "@";
    }
    if (aParsedUrl.host) {
      url += aParsedUrl.host;
    }
    if (aParsedUrl.port) {
      url += ":" + aParsedUrl.port;
    }
    if (aParsedUrl.path) {
      url += aParsedUrl.path;
    }
    return url;
  }
  exports.urlGenerate = urlGenerate;
  var MAX_CACHED_INPUTS = 32;
  function lruMemoize(f) {
    var cache = [];
    return function(input) {
      for (var i = 0;i < cache.length; i++) {
        if (cache[i].input === input) {
          var temp = cache[0];
          cache[0] = cache[i];
          cache[i] = temp;
          return cache[0].result;
        }
      }
      var result = f(input);
      cache.unshift({
        input,
        result
      });
      if (cache.length > MAX_CACHED_INPUTS) {
        cache.pop();
      }
      return result;
    };
  }
  var normalize = lruMemoize(function normalize2(aPath) {
    var path = aPath;
    var url = urlParse(aPath);
    if (url) {
      if (!url.path) {
        return aPath;
      }
      path = url.path;
    }
    var isAbsolute = exports.isAbsolute(path);
    var parts = [];
    var start = 0;
    var i = 0;
    while (true) {
      start = i;
      i = path.indexOf("/", start);
      if (i === -1) {
        parts.push(path.slice(start));
        break;
      } else {
        parts.push(path.slice(start, i));
        while (i < path.length && path[i] === "/") {
          i++;
        }
      }
    }
    for (var part, up = 0, i = parts.length - 1;i >= 0; i--) {
      part = parts[i];
      if (part === ".") {
        parts.splice(i, 1);
      } else if (part === "..") {
        up++;
      } else if (up > 0) {
        if (part === "") {
          parts.splice(i + 1, up);
          up = 0;
        } else {
          parts.splice(i, 2);
          up--;
        }
      }
    }
    path = parts.join("/");
    if (path === "") {
      path = isAbsolute ? "/" : ".";
    }
    if (url) {
      url.path = path;
      return urlGenerate(url);
    }
    return path;
  });
  exports.normalize = normalize;
  function join(aRoot, aPath) {
    if (aRoot === "") {
      aRoot = ".";
    }
    if (aPath === "") {
      aPath = ".";
    }
    var aPathUrl = urlParse(aPath);
    var aRootUrl = urlParse(aRoot);
    if (aRootUrl) {
      aRoot = aRootUrl.path || "/";
    }
    if (aPathUrl && !aPathUrl.scheme) {
      if (aRootUrl) {
        aPathUrl.scheme = aRootUrl.scheme;
      }
      return urlGenerate(aPathUrl);
    }
    if (aPathUrl || aPath.match(dataUrlRegexp)) {
      return aPath;
    }
    if (aRootUrl && !aRootUrl.host && !aRootUrl.path) {
      aRootUrl.host = aPath;
      return urlGenerate(aRootUrl);
    }
    var joined = aPath.charAt(0) === "/" ? aPath : normalize(aRoot.replace(/\/+$/, "") + "/" + aPath);
    if (aRootUrl) {
      aRootUrl.path = joined;
      return urlGenerate(aRootUrl);
    }
    return joined;
  }
  exports.join = join;
  exports.isAbsolute = function(aPath) {
    return aPath.charAt(0) === "/" || urlRegexp.test(aPath);
  };
  function relative(aRoot, aPath) {
    if (aRoot === "") {
      aRoot = ".";
    }
    aRoot = aRoot.replace(/\/$/, "");
    var level = 0;
    while (aPath.indexOf(aRoot + "/") !== 0) {
      var index = aRoot.lastIndexOf("/");
      if (index < 0) {
        return aPath;
      }
      aRoot = aRoot.slice(0, index);
      if (aRoot.match(/^([^\/]+:\/)?\/*$/)) {
        return aPath;
      }
      ++level;
    }
    return Array(level + 1).join("../") + aPath.substr(aRoot.length + 1);
  }
  exports.relative = relative;
  var supportsNullProto = function() {
    var obj = Object.create(null);
    return !("__proto__" in obj);
  }();
  function identity(s) {
    return s;
  }
  function toSetString(aStr) {
    if (isProtoString(aStr)) {
      return "$" + aStr;
    }
    return aStr;
  }
  exports.toSetString = supportsNullProto ? identity : toSetString;
  function fromSetString(aStr) {
    if (isProtoString(aStr)) {
      return aStr.slice(1);
    }
    return aStr;
  }
  exports.fromSetString = supportsNullProto ? identity : fromSetString;
  function isProtoString(s) {
    if (!s) {
      return false;
    }
    var length = s.length;
    if (length < 9) {
      return false;
    }
    if (s.charCodeAt(length - 1) !== 95 || s.charCodeAt(length - 2) !== 95 || s.charCodeAt(length - 3) !== 111 || s.charCodeAt(length - 4) !== 116 || s.charCodeAt(length - 5) !== 111 || s.charCodeAt(length - 6) !== 114 || s.charCodeAt(length - 7) !== 112 || s.charCodeAt(length - 8) !== 95 || s.charCodeAt(length - 9) !== 95) {
      return false;
    }
    for (var i = length - 10;i >= 0; i--) {
      if (s.charCodeAt(i) !== 36) {
        return false;
      }
    }
    return true;
  }
  function compareByOriginalPositions(mappingA, mappingB, onlyCompareOriginal) {
    var cmp = strcmp(mappingA.source, mappingB.source);
    if (cmp !== 0) {
      return cmp;
    }
    cmp = mappingA.originalLine - mappingB.originalLine;
    if (cmp !== 0) {
      return cmp;
    }
    cmp = mappingA.originalColumn - mappingB.originalColumn;
    if (cmp !== 0 || onlyCompareOriginal) {
      return cmp;
    }
    cmp = mappingA.generatedColumn - mappingB.generatedColumn;
    if (cmp !== 0) {
      return cmp;
    }
    cmp = mappingA.generatedLine - mappingB.generatedLine;
    if (cmp !== 0) {
      return cmp;
    }
    return strcmp(mappingA.name, mappingB.name);
  }
  exports.compareByOriginalPositions = compareByOriginalPositions;
  function compareByOriginalPositionsNoSource(mappingA, mappingB, onlyCompareOriginal) {
    var cmp;
    cmp = mappingA.originalLine - mappingB.originalLine;
    if (cmp !== 0) {
      return cmp;
    }
    cmp = mappingA.originalColumn - mappingB.originalColumn;
    if (cmp !== 0 || onlyCompareOriginal) {
      return cmp;
    }
    cmp = mappingA.generatedColumn - mappingB.generatedColumn;
    if (cmp !== 0) {
      return cmp;
    }
    cmp = mappingA.generatedLine - mappingB.generatedLine;
    if (cmp !== 0) {
      return cmp;
    }
    return strcmp(mappingA.name, mappingB.name);
  }
  exports.compareByOriginalPositionsNoSource = compareByOriginalPositionsNoSource;
  function compareByGeneratedPositionsDeflated(mappingA, mappingB, onlyCompareGenerated) {
    var cmp = mappingA.generatedLine - mappingB.generatedLine;
    if (cmp !== 0) {
      return cmp;
    }
    cmp = mappingA.generatedColumn - mappingB.generatedColumn;
    if (cmp !== 0 || onlyCompareGenerated) {
      return cmp;
    }
    cmp = strcmp(mappingA.source, mappingB.source);
    if (cmp !== 0) {
      return cmp;
    }
    cmp = mappingA.originalLine - mappingB.originalLine;
    if (cmp !== 0) {
      return cmp;
    }
    cmp = mappingA.originalColumn - mappingB.originalColumn;
    if (cmp !== 0) {
      return cmp;
    }
    return strcmp(mappingA.name, mappingB.name);
  }
  exports.compareByGeneratedPositionsDeflated = compareByGeneratedPositionsDeflated;
  function compareByGeneratedPositionsDeflatedNoLine(mappingA, mappingB, onlyCompareGenerated) {
    var cmp = mappingA.generatedColumn - mappingB.generatedColumn;
    if (cmp !== 0 || onlyCompareGenerated) {
      return cmp;
    }
    cmp = strcmp(mappingA.source, mappingB.source);
    if (cmp !== 0) {
      return cmp;
    }
    cmp = mappingA.originalLine - mappingB.originalLine;
    if (cmp !== 0) {
      return cmp;
    }
    cmp = mappingA.originalColumn - mappingB.originalColumn;
    if (cmp !== 0) {
      return cmp;
    }
    return strcmp(mappingA.name, mappingB.name);
  }
  exports.compareByGeneratedPositionsDeflatedNoLine = compareByGeneratedPositionsDeflatedNoLine;
  function strcmp(aStr1, aStr2) {
    if (aStr1 === aStr2) {
      return 0;
    }
    if (aStr1 === null) {
      return 1;
    }
    if (aStr2 === null) {
      return -1;
    }
    if (aStr1 > aStr2) {
      return 1;
    }
    return -1;
  }
  function compareByGeneratedPositionsInflated(mappingA, mappingB) {
    var cmp = mappingA.generatedLine - mappingB.generatedLine;
    if (cmp !== 0) {
      return cmp;
    }
    cmp = mappingA.generatedColumn - mappingB.generatedColumn;
    if (cmp !== 0) {
      return cmp;
    }
    cmp = strcmp(mappingA.source, mappingB.source);
    if (cmp !== 0) {
      return cmp;
    }
    cmp = mappingA.originalLine - mappingB.originalLine;
    if (cmp !== 0) {
      return cmp;
    }
    cmp = mappingA.originalColumn - mappingB.originalColumn;
    if (cmp !== 0) {
      return cmp;
    }
    return strcmp(mappingA.name, mappingB.name);
  }
  exports.compareByGeneratedPositionsInflated = compareByGeneratedPositionsInflated;
  function parseSourceMapInput(str) {
    return JSON.parse(str.replace(/^\)]}'[^\n]*\n/, ""));
  }
  exports.parseSourceMapInput = parseSourceMapInput;
  function computeSourceURL(sourceRoot, sourceURL, sourceMapURL) {
    sourceURL = sourceURL || "";
    if (sourceRoot) {
      if (sourceRoot[sourceRoot.length - 1] !== "/" && sourceURL[0] !== "/") {
        sourceRoot += "/";
      }
      sourceURL = sourceRoot + sourceURL;
    }
    if (sourceMapURL) {
      var parsed = urlParse(sourceMapURL);
      if (!parsed) {
        throw new Error("sourceMapURL could not be parsed");
      }
      if (parsed.path) {
        var index = parsed.path.lastIndexOf("/");
        if (index >= 0) {
          parsed.path = parsed.path.substring(0, index + 1);
        }
      }
      sourceURL = join(urlGenerate(parsed), sourceURL);
    }
    return normalize(sourceURL);
  }
  exports.computeSourceURL = computeSourceURL;
});

// ../../../../node_modules/.bun/source-map-js@1.2.1/node_modules/source-map-js/lib/array-set.js
var require_array_set = __commonJS((exports) => {
  var util = require_util();
  var has = Object.prototype.hasOwnProperty;
  var hasNativeMap = typeof Map !== "undefined";
  function ArraySet() {
    this._array = [];
    this._set = hasNativeMap ? new Map : Object.create(null);
  }
  ArraySet.fromArray = function ArraySet_fromArray(aArray, aAllowDuplicates) {
    var set = new ArraySet;
    for (var i = 0, len = aArray.length;i < len; i++) {
      set.add(aArray[i], aAllowDuplicates);
    }
    return set;
  };
  ArraySet.prototype.size = function ArraySet_size() {
    return hasNativeMap ? this._set.size : Object.getOwnPropertyNames(this._set).length;
  };
  ArraySet.prototype.add = function ArraySet_add(aStr, aAllowDuplicates) {
    var sStr = hasNativeMap ? aStr : util.toSetString(aStr);
    var isDuplicate = hasNativeMap ? this.has(aStr) : has.call(this._set, sStr);
    var idx = this._array.length;
    if (!isDuplicate || aAllowDuplicates) {
      this._array.push(aStr);
    }
    if (!isDuplicate) {
      if (hasNativeMap) {
        this._set.set(aStr, idx);
      } else {
        this._set[sStr] = idx;
      }
    }
  };
  ArraySet.prototype.has = function ArraySet_has(aStr) {
    if (hasNativeMap) {
      return this._set.has(aStr);
    } else {
      var sStr = util.toSetString(aStr);
      return has.call(this._set, sStr);
    }
  };
  ArraySet.prototype.indexOf = function ArraySet_indexOf(aStr) {
    if (hasNativeMap) {
      var idx = this._set.get(aStr);
      if (idx >= 0) {
        return idx;
      }
    } else {
      var sStr = util.toSetString(aStr);
      if (has.call(this._set, sStr)) {
        return this._set[sStr];
      }
    }
    throw new Error('"' + aStr + '" is not in the set.');
  };
  ArraySet.prototype.at = function ArraySet_at(aIdx) {
    if (aIdx >= 0 && aIdx < this._array.length) {
      return this._array[aIdx];
    }
    throw new Error("No element indexed by " + aIdx);
  };
  ArraySet.prototype.toArray = function ArraySet_toArray() {
    return this._array.slice();
  };
  exports.ArraySet = ArraySet;
});

// ../../../../node_modules/.bun/source-map-js@1.2.1/node_modules/source-map-js/lib/mapping-list.js
var require_mapping_list = __commonJS((exports) => {
  var util = require_util();
  function generatedPositionAfter(mappingA, mappingB) {
    var lineA = mappingA.generatedLine;
    var lineB = mappingB.generatedLine;
    var columnA = mappingA.generatedColumn;
    var columnB = mappingB.generatedColumn;
    return lineB > lineA || lineB == lineA && columnB >= columnA || util.compareByGeneratedPositionsInflated(mappingA, mappingB) <= 0;
  }
  function MappingList() {
    this._array = [];
    this._sorted = true;
    this._last = { generatedLine: -1, generatedColumn: 0 };
  }
  MappingList.prototype.unsortedForEach = function MappingList_forEach(aCallback, aThisArg) {
    this._array.forEach(aCallback, aThisArg);
  };
  MappingList.prototype.add = function MappingList_add(aMapping) {
    if (generatedPositionAfter(this._last, aMapping)) {
      this._last = aMapping;
      this._array.push(aMapping);
    } else {
      this._sorted = false;
      this._array.push(aMapping);
    }
  };
  MappingList.prototype.toArray = function MappingList_toArray() {
    if (!this._sorted) {
      this._array.sort(util.compareByGeneratedPositionsInflated);
      this._sorted = true;
    }
    return this._array;
  };
  exports.MappingList = MappingList;
});

// ../../../../node_modules/.bun/source-map-js@1.2.1/node_modules/source-map-js/lib/source-map-generator.js
var require_source_map_generator = __commonJS((exports) => {
  var base64VLQ = require_base64_vlq();
  var util = require_util();
  var ArraySet = require_array_set().ArraySet;
  var MappingList = require_mapping_list().MappingList;
  function SourceMapGenerator(aArgs) {
    if (!aArgs) {
      aArgs = {};
    }
    this._file = util.getArg(aArgs, "file", null);
    this._sourceRoot = util.getArg(aArgs, "sourceRoot", null);
    this._skipValidation = util.getArg(aArgs, "skipValidation", false);
    this._ignoreInvalidMapping = util.getArg(aArgs, "ignoreInvalidMapping", false);
    this._sources = new ArraySet;
    this._names = new ArraySet;
    this._mappings = new MappingList;
    this._sourcesContents = null;
  }
  SourceMapGenerator.prototype._version = 3;
  SourceMapGenerator.fromSourceMap = function SourceMapGenerator_fromSourceMap(aSourceMapConsumer, generatorOps) {
    var sourceRoot = aSourceMapConsumer.sourceRoot;
    var generator = new SourceMapGenerator(Object.assign(generatorOps || {}, {
      file: aSourceMapConsumer.file,
      sourceRoot
    }));
    aSourceMapConsumer.eachMapping(function(mapping) {
      var newMapping = {
        generated: {
          line: mapping.generatedLine,
          column: mapping.generatedColumn
        }
      };
      if (mapping.source != null) {
        newMapping.source = mapping.source;
        if (sourceRoot != null) {
          newMapping.source = util.relative(sourceRoot, newMapping.source);
        }
        newMapping.original = {
          line: mapping.originalLine,
          column: mapping.originalColumn
        };
        if (mapping.name != null) {
          newMapping.name = mapping.name;
        }
      }
      generator.addMapping(newMapping);
    });
    aSourceMapConsumer.sources.forEach(function(sourceFile) {
      var sourceRelative = sourceFile;
      if (sourceRoot !== null) {
        sourceRelative = util.relative(sourceRoot, sourceFile);
      }
      if (!generator._sources.has(sourceRelative)) {
        generator._sources.add(sourceRelative);
      }
      var content = aSourceMapConsumer.sourceContentFor(sourceFile);
      if (content != null) {
        generator.setSourceContent(sourceFile, content);
      }
    });
    return generator;
  };
  SourceMapGenerator.prototype.addMapping = function SourceMapGenerator_addMapping(aArgs) {
    var generated = util.getArg(aArgs, "generated");
    var original = util.getArg(aArgs, "original", null);
    var source = util.getArg(aArgs, "source", null);
    var name = util.getArg(aArgs, "name", null);
    if (!this._skipValidation) {
      if (this._validateMapping(generated, original, source, name) === false) {
        return;
      }
    }
    if (source != null) {
      source = String(source);
      if (!this._sources.has(source)) {
        this._sources.add(source);
      }
    }
    if (name != null) {
      name = String(name);
      if (!this._names.has(name)) {
        this._names.add(name);
      }
    }
    this._mappings.add({
      generatedLine: generated.line,
      generatedColumn: generated.column,
      originalLine: original != null && original.line,
      originalColumn: original != null && original.column,
      source,
      name
    });
  };
  SourceMapGenerator.prototype.setSourceContent = function SourceMapGenerator_setSourceContent(aSourceFile, aSourceContent) {
    var source = aSourceFile;
    if (this._sourceRoot != null) {
      source = util.relative(this._sourceRoot, source);
    }
    if (aSourceContent != null) {
      if (!this._sourcesContents) {
        this._sourcesContents = Object.create(null);
      }
      this._sourcesContents[util.toSetString(source)] = aSourceContent;
    } else if (this._sourcesContents) {
      delete this._sourcesContents[util.toSetString(source)];
      if (Object.keys(this._sourcesContents).length === 0) {
        this._sourcesContents = null;
      }
    }
  };
  SourceMapGenerator.prototype.applySourceMap = function SourceMapGenerator_applySourceMap(aSourceMapConsumer, aSourceFile, aSourceMapPath) {
    var sourceFile = aSourceFile;
    if (aSourceFile == null) {
      if (aSourceMapConsumer.file == null) {
        throw new Error("SourceMapGenerator.prototype.applySourceMap requires either an explicit source file, " + `or the source map's "file" property. Both were omitted.`);
      }
      sourceFile = aSourceMapConsumer.file;
    }
    var sourceRoot = this._sourceRoot;
    if (sourceRoot != null) {
      sourceFile = util.relative(sourceRoot, sourceFile);
    }
    var newSources = new ArraySet;
    var newNames = new ArraySet;
    this._mappings.unsortedForEach(function(mapping) {
      if (mapping.source === sourceFile && mapping.originalLine != null) {
        var original = aSourceMapConsumer.originalPositionFor({
          line: mapping.originalLine,
          column: mapping.originalColumn
        });
        if (original.source != null) {
          mapping.source = original.source;
          if (aSourceMapPath != null) {
            mapping.source = util.join(aSourceMapPath, mapping.source);
          }
          if (sourceRoot != null) {
            mapping.source = util.relative(sourceRoot, mapping.source);
          }
          mapping.originalLine = original.line;
          mapping.originalColumn = original.column;
          if (original.name != null) {
            mapping.name = original.name;
          }
        }
      }
      var source = mapping.source;
      if (source != null && !newSources.has(source)) {
        newSources.add(source);
      }
      var name = mapping.name;
      if (name != null && !newNames.has(name)) {
        newNames.add(name);
      }
    }, this);
    this._sources = newSources;
    this._names = newNames;
    aSourceMapConsumer.sources.forEach(function(sourceFile2) {
      var content = aSourceMapConsumer.sourceContentFor(sourceFile2);
      if (content != null) {
        if (aSourceMapPath != null) {
          sourceFile2 = util.join(aSourceMapPath, sourceFile2);
        }
        if (sourceRoot != null) {
          sourceFile2 = util.relative(sourceRoot, sourceFile2);
        }
        this.setSourceContent(sourceFile2, content);
      }
    }, this);
  };
  SourceMapGenerator.prototype._validateMapping = function SourceMapGenerator_validateMapping(aGenerated, aOriginal, aSource, aName) {
    if (aOriginal && typeof aOriginal.line !== "number" && typeof aOriginal.column !== "number") {
      var message = "original.line and original.column are not numbers -- you probably meant to omit " + "the original mapping entirely and only map the generated position. If so, pass " + "null for the original mapping instead of an object with empty or null values.";
      if (this._ignoreInvalidMapping) {
        if (typeof console !== "undefined" && console.warn) {
          console.warn(message);
        }
        return false;
      } else {
        throw new Error(message);
      }
    }
    if (aGenerated && "line" in aGenerated && "column" in aGenerated && aGenerated.line > 0 && aGenerated.column >= 0 && !aOriginal && !aSource && !aName) {
      return;
    } else if (aGenerated && "line" in aGenerated && "column" in aGenerated && aOriginal && "line" in aOriginal && "column" in aOriginal && aGenerated.line > 0 && aGenerated.column >= 0 && aOriginal.line > 0 && aOriginal.column >= 0 && aSource) {
      return;
    } else {
      var message = "Invalid mapping: " + JSON.stringify({
        generated: aGenerated,
        source: aSource,
        original: aOriginal,
        name: aName
      });
      if (this._ignoreInvalidMapping) {
        if (typeof console !== "undefined" && console.warn) {
          console.warn(message);
        }
        return false;
      } else {
        throw new Error(message);
      }
    }
  };
  SourceMapGenerator.prototype._serializeMappings = function SourceMapGenerator_serializeMappings() {
    var previousGeneratedColumn = 0;
    var previousGeneratedLine = 1;
    var previousOriginalColumn = 0;
    var previousOriginalLine = 0;
    var previousName = 0;
    var previousSource = 0;
    var result = "";
    var next;
    var mapping;
    var nameIdx;
    var sourceIdx;
    var mappings = this._mappings.toArray();
    for (var i = 0, len = mappings.length;i < len; i++) {
      mapping = mappings[i];
      next = "";
      if (mapping.generatedLine !== previousGeneratedLine) {
        previousGeneratedColumn = 0;
        while (mapping.generatedLine !== previousGeneratedLine) {
          next += ";";
          previousGeneratedLine++;
        }
      } else {
        if (i > 0) {
          if (!util.compareByGeneratedPositionsInflated(mapping, mappings[i - 1])) {
            continue;
          }
          next += ",";
        }
      }
      next += base64VLQ.encode(mapping.generatedColumn - previousGeneratedColumn);
      previousGeneratedColumn = mapping.generatedColumn;
      if (mapping.source != null) {
        sourceIdx = this._sources.indexOf(mapping.source);
        next += base64VLQ.encode(sourceIdx - previousSource);
        previousSource = sourceIdx;
        next += base64VLQ.encode(mapping.originalLine - 1 - previousOriginalLine);
        previousOriginalLine = mapping.originalLine - 1;
        next += base64VLQ.encode(mapping.originalColumn - previousOriginalColumn);
        previousOriginalColumn = mapping.originalColumn;
        if (mapping.name != null) {
          nameIdx = this._names.indexOf(mapping.name);
          next += base64VLQ.encode(nameIdx - previousName);
          previousName = nameIdx;
        }
      }
      result += next;
    }
    return result;
  };
  SourceMapGenerator.prototype._generateSourcesContent = function SourceMapGenerator_generateSourcesContent(aSources, aSourceRoot) {
    return aSources.map(function(source) {
      if (!this._sourcesContents) {
        return null;
      }
      if (aSourceRoot != null) {
        source = util.relative(aSourceRoot, source);
      }
      var key = util.toSetString(source);
      return Object.prototype.hasOwnProperty.call(this._sourcesContents, key) ? this._sourcesContents[key] : null;
    }, this);
  };
  SourceMapGenerator.prototype.toJSON = function SourceMapGenerator_toJSON() {
    var map = {
      version: this._version,
      sources: this._sources.toArray(),
      names: this._names.toArray(),
      mappings: this._serializeMappings()
    };
    if (this._file != null) {
      map.file = this._file;
    }
    if (this._sourceRoot != null) {
      map.sourceRoot = this._sourceRoot;
    }
    if (this._sourcesContents) {
      map.sourcesContent = this._generateSourcesContent(map.sources, map.sourceRoot);
    }
    return map;
  };
  SourceMapGenerator.prototype.toString = function SourceMapGenerator_toString() {
    return JSON.stringify(this.toJSON());
  };
  exports.SourceMapGenerator = SourceMapGenerator;
});

// ../../../../node_modules/.bun/css-tree@2.3.1/node_modules/css-tree/cjs/generator/sourceMap.cjs
var require_sourceMap = __commonJS((exports) => {
  var sourceMapGenerator_js = require_source_map_generator();
  var trackNodes = new Set(["Atrule", "Selector", "Declaration"]);
  function generateSourceMap(handlers) {
    const map = new sourceMapGenerator_js.SourceMapGenerator;
    const generated = {
      line: 1,
      column: 0
    };
    const original = {
      line: 0,
      column: 0
    };
    const activatedGenerated = {
      line: 1,
      column: 0
    };
    const activatedMapping = {
      generated: activatedGenerated
    };
    let line = 1;
    let column = 0;
    let sourceMappingActive = false;
    const origHandlersNode = handlers.node;
    handlers.node = function(node) {
      if (node.loc && node.loc.start && trackNodes.has(node.type)) {
        const nodeLine = node.loc.start.line;
        const nodeColumn = node.loc.start.column - 1;
        if (original.line !== nodeLine || original.column !== nodeColumn) {
          original.line = nodeLine;
          original.column = nodeColumn;
          generated.line = line;
          generated.column = column;
          if (sourceMappingActive) {
            sourceMappingActive = false;
            if (generated.line !== activatedGenerated.line || generated.column !== activatedGenerated.column) {
              map.addMapping(activatedMapping);
            }
          }
          sourceMappingActive = true;
          map.addMapping({
            source: node.loc.source,
            original,
            generated
          });
        }
      }
      origHandlersNode.call(this, node);
      if (sourceMappingActive && trackNodes.has(node.type)) {
        activatedGenerated.line = line;
        activatedGenerated.column = column;
      }
    };
    const origHandlersEmit = handlers.emit;
    handlers.emit = function(value, type, auto) {
      for (let i = 0;i < value.length; i++) {
        if (value.charCodeAt(i) === 10) {
          line++;
          column = 0;
        } else {
          column++;
        }
      }
      origHandlersEmit(value, type, auto);
    };
    const origHandlersResult = handlers.result;
    handlers.result = function() {
      if (sourceMappingActive) {
        map.addMapping(activatedMapping);
      }
      return {
        css: origHandlersResult(),
        map
      };
    };
    return handlers;
  }
  exports.generateSourceMap = generateSourceMap;
});

// ../../../../node_modules/.bun/css-tree@2.3.1/node_modules/css-tree/cjs/generator/token-before.cjs
var require_token_before = __commonJS((exports) => {
  var types = require_types2();
  var PLUSSIGN = 43;
  var HYPHENMINUS = 45;
  var code = (type, value) => {
    if (type === types.Delim) {
      type = value;
    }
    if (typeof type === "string") {
      const charCode = type.charCodeAt(0);
      return charCode > 127 ? 32768 : charCode << 8;
    }
    return type;
  };
  var specPairs = [
    [types.Ident, types.Ident],
    [types.Ident, types.Function],
    [types.Ident, types.Url],
    [types.Ident, types.BadUrl],
    [types.Ident, "-"],
    [types.Ident, types.Number],
    [types.Ident, types.Percentage],
    [types.Ident, types.Dimension],
    [types.Ident, types.CDC],
    [types.Ident, types.LeftParenthesis],
    [types.AtKeyword, types.Ident],
    [types.AtKeyword, types.Function],
    [types.AtKeyword, types.Url],
    [types.AtKeyword, types.BadUrl],
    [types.AtKeyword, "-"],
    [types.AtKeyword, types.Number],
    [types.AtKeyword, types.Percentage],
    [types.AtKeyword, types.Dimension],
    [types.AtKeyword, types.CDC],
    [types.Hash, types.Ident],
    [types.Hash, types.Function],
    [types.Hash, types.Url],
    [types.Hash, types.BadUrl],
    [types.Hash, "-"],
    [types.Hash, types.Number],
    [types.Hash, types.Percentage],
    [types.Hash, types.Dimension],
    [types.Hash, types.CDC],
    [types.Dimension, types.Ident],
    [types.Dimension, types.Function],
    [types.Dimension, types.Url],
    [types.Dimension, types.BadUrl],
    [types.Dimension, "-"],
    [types.Dimension, types.Number],
    [types.Dimension, types.Percentage],
    [types.Dimension, types.Dimension],
    [types.Dimension, types.CDC],
    ["#", types.Ident],
    ["#", types.Function],
    ["#", types.Url],
    ["#", types.BadUrl],
    ["#", "-"],
    ["#", types.Number],
    ["#", types.Percentage],
    ["#", types.Dimension],
    ["#", types.CDC],
    ["-", types.Ident],
    ["-", types.Function],
    ["-", types.Url],
    ["-", types.BadUrl],
    ["-", "-"],
    ["-", types.Number],
    ["-", types.Percentage],
    ["-", types.Dimension],
    ["-", types.CDC],
    [types.Number, types.Ident],
    [types.Number, types.Function],
    [types.Number, types.Url],
    [types.Number, types.BadUrl],
    [types.Number, types.Number],
    [types.Number, types.Percentage],
    [types.Number, types.Dimension],
    [types.Number, "%"],
    [types.Number, types.CDC],
    ["@", types.Ident],
    ["@", types.Function],
    ["@", types.Url],
    ["@", types.BadUrl],
    ["@", "-"],
    ["@", types.CDC],
    [".", types.Number],
    [".", types.Percentage],
    [".", types.Dimension],
    ["+", types.Number],
    ["+", types.Percentage],
    ["+", types.Dimension],
    ["/", "*"]
  ];
  var safePairs = specPairs.concat([
    [types.Ident, types.Hash],
    [types.Dimension, types.Hash],
    [types.Hash, types.Hash],
    [types.AtKeyword, types.LeftParenthesis],
    [types.AtKeyword, types.String],
    [types.AtKeyword, types.Colon],
    [types.Percentage, types.Percentage],
    [types.Percentage, types.Dimension],
    [types.Percentage, types.Function],
    [types.Percentage, "-"],
    [types.RightParenthesis, types.Ident],
    [types.RightParenthesis, types.Function],
    [types.RightParenthesis, types.Percentage],
    [types.RightParenthesis, types.Dimension],
    [types.RightParenthesis, types.Hash],
    [types.RightParenthesis, "-"]
  ]);
  function createMap(pairs) {
    const isWhiteSpaceRequired = new Set(pairs.map(([prev, next]) => code(prev) << 16 | code(next)));
    return function(prevCode, type, value) {
      const nextCode = code(type, value);
      const nextCharCode = value.charCodeAt(0);
      const emitWs = nextCharCode === HYPHENMINUS && type !== types.Ident && type !== types.Function && type !== types.CDC || nextCharCode === PLUSSIGN ? isWhiteSpaceRequired.has(prevCode << 16 | nextCharCode << 8) : isWhiteSpaceRequired.has(prevCode << 16 | nextCode);
      if (emitWs) {
        this.emit(" ", types.WhiteSpace, true);
      }
      return nextCode;
    };
  }
  var spec = createMap(specPairs);
  var safe = createMap(safePairs);
  exports.safe = safe;
  exports.spec = spec;
});

// ../../../../node_modules/.bun/css-tree@2.3.1/node_modules/css-tree/cjs/generator/create.cjs
var require_create2 = __commonJS((exports) => {
  var index = require_tokenizer();
  var sourceMap = require_sourceMap();
  var tokenBefore = require_token_before();
  var types = require_types2();
  var REVERSESOLIDUS = 92;
  function processChildren(node, delimeter) {
    if (typeof delimeter === "function") {
      let prev = null;
      node.children.forEach((node2) => {
        if (prev !== null) {
          delimeter.call(this, prev);
        }
        this.node(node2);
        prev = node2;
      });
      return;
    }
    node.children.forEach(this.node, this);
  }
  function processChunk(chunk) {
    index.tokenize(chunk, (type, start, end) => {
      this.token(type, chunk.slice(start, end));
    });
  }
  function createGenerator(config) {
    const types$1 = new Map;
    for (let name in config.node) {
      const item = config.node[name];
      const fn = item.generate || item;
      if (typeof fn === "function") {
        types$1.set(name, item.generate || item);
      }
    }
    return function(node, options) {
      let buffer = "";
      let prevCode = 0;
      let handlers = {
        node(node2) {
          if (types$1.has(node2.type)) {
            types$1.get(node2.type).call(publicApi, node2);
          } else {
            throw new Error("Unknown node type: " + node2.type);
          }
        },
        tokenBefore: tokenBefore.safe,
        token(type, value) {
          prevCode = this.tokenBefore(prevCode, type, value);
          this.emit(value, type, false);
          if (type === types.Delim && value.charCodeAt(0) === REVERSESOLIDUS) {
            this.emit(`
`, types.WhiteSpace, true);
          }
        },
        emit(value) {
          buffer += value;
        },
        result() {
          return buffer;
        }
      };
      if (options) {
        if (typeof options.decorator === "function") {
          handlers = options.decorator(handlers);
        }
        if (options.sourceMap) {
          handlers = sourceMap.generateSourceMap(handlers);
        }
        if (options.mode in tokenBefore) {
          handlers.tokenBefore = tokenBefore[options.mode];
        }
      }
      const publicApi = {
        node: (node2) => handlers.node(node2),
        children: processChildren,
        token: (type, value) => handlers.token(type, value),
        tokenize: processChunk
      };
      handlers.node(node);
      return handlers.result();
    };
  }
  exports.createGenerator = createGenerator;
});

// ../../../../node_modules/.bun/css-tree@2.3.1/node_modules/css-tree/cjs/convertor/create.cjs
var require_create3 = __commonJS((exports) => {
  var List = require_List();
  function createConvertor(walk) {
    return {
      fromPlainObject(ast) {
        walk(ast, {
          enter(node) {
            if (node.children && node.children instanceof List.List === false) {
              node.children = new List.List().fromArray(node.children);
            }
          }
        });
        return ast;
      },
      toPlainObject(ast) {
        walk(ast, {
          leave(node) {
            if (node.children && node.children instanceof List.List) {
              node.children = node.children.toArray();
            }
          }
        });
        return ast;
      }
    };
  }
  exports.createConvertor = createConvertor;
});

// ../../../../node_modules/.bun/css-tree@2.3.1/node_modules/css-tree/cjs/walker/create.cjs
var require_create4 = __commonJS((exports) => {
  var { hasOwnProperty: hasOwnProperty2 } = Object.prototype;
  var noop = function() {};
  function ensureFunction(value) {
    return typeof value === "function" ? value : noop;
  }
  function invokeForType(fn, type) {
    return function(node, item, list) {
      if (node.type === type) {
        fn.call(this, node, item, list);
      }
    };
  }
  function getWalkersFromStructure(name, nodeType) {
    const structure = nodeType.structure;
    const walkers = [];
    for (const key in structure) {
      if (hasOwnProperty2.call(structure, key) === false) {
        continue;
      }
      let fieldTypes = structure[key];
      const walker = {
        name: key,
        type: false,
        nullable: false
      };
      if (!Array.isArray(fieldTypes)) {
        fieldTypes = [fieldTypes];
      }
      for (const fieldType of fieldTypes) {
        if (fieldType === null) {
          walker.nullable = true;
        } else if (typeof fieldType === "string") {
          walker.type = "node";
        } else if (Array.isArray(fieldType)) {
          walker.type = "list";
        }
      }
      if (walker.type) {
        walkers.push(walker);
      }
    }
    if (walkers.length) {
      return {
        context: nodeType.walkContext,
        fields: walkers
      };
    }
    return null;
  }
  function getTypesFromConfig(config) {
    const types = {};
    for (const name in config.node) {
      if (hasOwnProperty2.call(config.node, name)) {
        const nodeType = config.node[name];
        if (!nodeType.structure) {
          throw new Error("Missed `structure` field in `" + name + "` node type definition");
        }
        types[name] = getWalkersFromStructure(name, nodeType);
      }
    }
    return types;
  }
  function createTypeIterator(config, reverse) {
    const fields = config.fields.slice();
    const contextName = config.context;
    const useContext = typeof contextName === "string";
    if (reverse) {
      fields.reverse();
    }
    return function(node, context, walk, walkReducer) {
      let prevContextValue;
      if (useContext) {
        prevContextValue = context[contextName];
        context[contextName] = node;
      }
      for (const field of fields) {
        const ref = node[field.name];
        if (!field.nullable || ref) {
          if (field.type === "list") {
            const breakWalk = reverse ? ref.reduceRight(walkReducer, false) : ref.reduce(walkReducer, false);
            if (breakWalk) {
              return true;
            }
          } else if (walk(ref)) {
            return true;
          }
        }
      }
      if (useContext) {
        context[contextName] = prevContextValue;
      }
    };
  }
  function createFastTraveralMap({
    StyleSheet,
    Atrule,
    Rule,
    Block,
    DeclarationList
  }) {
    return {
      Atrule: {
        StyleSheet,
        Atrule,
        Rule,
        Block
      },
      Rule: {
        StyleSheet,
        Atrule,
        Rule,
        Block
      },
      Declaration: {
        StyleSheet,
        Atrule,
        Rule,
        Block,
        DeclarationList
      }
    };
  }
  function createWalker(config) {
    const types = getTypesFromConfig(config);
    const iteratorsNatural = {};
    const iteratorsReverse = {};
    const breakWalk = Symbol("break-walk");
    const skipNode = Symbol("skip-node");
    for (const name in types) {
      if (hasOwnProperty2.call(types, name) && types[name] !== null) {
        iteratorsNatural[name] = createTypeIterator(types[name], false);
        iteratorsReverse[name] = createTypeIterator(types[name], true);
      }
    }
    const fastTraversalIteratorsNatural = createFastTraveralMap(iteratorsNatural);
    const fastTraversalIteratorsReverse = createFastTraveralMap(iteratorsReverse);
    const walk = function(root, options) {
      function walkNode(node, item, list) {
        const enterRet = enter.call(context, node, item, list);
        if (enterRet === breakWalk) {
          return true;
        }
        if (enterRet === skipNode) {
          return false;
        }
        if (iterators.hasOwnProperty(node.type)) {
          if (iterators[node.type](node, context, walkNode, walkReducer)) {
            return true;
          }
        }
        if (leave.call(context, node, item, list) === breakWalk) {
          return true;
        }
        return false;
      }
      let enter = noop;
      let leave = noop;
      let iterators = iteratorsNatural;
      let walkReducer = (ret, data, item, list) => ret || walkNode(data, item, list);
      const context = {
        break: breakWalk,
        skip: skipNode,
        root,
        stylesheet: null,
        atrule: null,
        atrulePrelude: null,
        rule: null,
        selector: null,
        block: null,
        declaration: null,
        function: null
      };
      if (typeof options === "function") {
        enter = options;
      } else if (options) {
        enter = ensureFunction(options.enter);
        leave = ensureFunction(options.leave);
        if (options.reverse) {
          iterators = iteratorsReverse;
        }
        if (options.visit) {
          if (fastTraversalIteratorsNatural.hasOwnProperty(options.visit)) {
            iterators = options.reverse ? fastTraversalIteratorsReverse[options.visit] : fastTraversalIteratorsNatural[options.visit];
          } else if (!types.hasOwnProperty(options.visit)) {
            throw new Error("Bad value `" + options.visit + "` for `visit` option (should be: " + Object.keys(types).sort().join(", ") + ")");
          }
          enter = invokeForType(enter, options.visit);
          leave = invokeForType(leave, options.visit);
        }
      }
      if (enter === noop && leave === noop) {
        throw new Error("Neither `enter` nor `leave` walker handler is set or both aren't a function");
      }
      walkNode(root);
    };
    walk.break = breakWalk;
    walk.skip = skipNode;
    walk.find = function(ast, fn) {
      let found = null;
      walk(ast, function(node, item, list) {
        if (fn.call(this, node, item, list)) {
          found = node;
          return breakWalk;
        }
      });
      return found;
    };
    walk.findLast = function(ast, fn) {
      let found = null;
      walk(ast, {
        reverse: true,
        enter(node, item, list) {
          if (fn.call(this, node, item, list)) {
            found = node;
            return breakWalk;
          }
        }
      });
      return found;
    };
    walk.findAll = function(ast, fn) {
      const found = [];
      walk(ast, function(node, item, list) {
        if (fn.call(this, node, item, list)) {
          found.push(node);
        }
      });
      return found;
    };
    return walk;
  }
  exports.createWalker = createWalker;
});

// ../../../../node_modules/.bun/css-tree@2.3.1/node_modules/css-tree/cjs/definition-syntax/generate.cjs
var require_generate = __commonJS((exports) => {
  function noop(value) {
    return value;
  }
  function generateMultiplier(multiplier) {
    const { min, max, comma } = multiplier;
    if (min === 0 && max === 0) {
      return comma ? "#?" : "*";
    }
    if (min === 0 && max === 1) {
      return "?";
    }
    if (min === 1 && max === 0) {
      return comma ? "#" : "+";
    }
    if (min === 1 && max === 1) {
      return "";
    }
    return (comma ? "#" : "") + (min === max ? "{" + min + "}" : "{" + min + "," + (max !== 0 ? max : "") + "}");
  }
  function generateTypeOpts(node) {
    switch (node.type) {
      case "Range":
        return " [" + (node.min === null ? "-" : node.min) + "," + (node.max === null ? "" : node.max) + "]";
      default:
        throw new Error("Unknown node type `" + node.type + "`");
    }
  }
  function generateSequence(node, decorate, forceBraces, compact) {
    const combinator = node.combinator === " " || compact ? node.combinator : " " + node.combinator + " ";
    const result = node.terms.map((term) => internalGenerate(term, decorate, forceBraces, compact)).join(combinator);
    if (node.explicit || forceBraces) {
      return (compact || result[0] === "," ? "[" : "[ ") + result + (compact ? "]" : " ]");
    }
    return result;
  }
  function internalGenerate(node, decorate, forceBraces, compact) {
    let result;
    switch (node.type) {
      case "Group":
        result = generateSequence(node, decorate, forceBraces, compact) + (node.disallowEmpty ? "!" : "");
        break;
      case "Multiplier":
        return internalGenerate(node.term, decorate, forceBraces, compact) + decorate(generateMultiplier(node), node);
      case "Type":
        result = "<" + node.name + (node.opts ? decorate(generateTypeOpts(node.opts), node.opts) : "") + ">";
        break;
      case "Property":
        result = "<'" + node.name + "'>";
        break;
      case "Keyword":
        result = node.name;
        break;
      case "AtKeyword":
        result = "@" + node.name;
        break;
      case "Function":
        result = node.name + "(";
        break;
      case "String":
      case "Token":
        result = node.value;
        break;
      case "Comma":
        result = ",";
        break;
      default:
        throw new Error("Unknown node type `" + node.type + "`");
    }
    return decorate(result, node);
  }
  function generate(node, options) {
    let decorate = noop;
    let forceBraces = false;
    let compact = false;
    if (typeof options === "function") {
      decorate = options;
    } else if (options) {
      forceBraces = Boolean(options.forceBraces);
      compact = Boolean(options.compact);
      if (typeof options.decorate === "function") {
        decorate = options.decorate;
      }
    }
    return internalGenerate(node, decorate, forceBraces, compact);
  }
  exports.generate = generate;
});

// ../../../../node_modules/.bun/css-tree@2.3.1/node_modules/css-tree/cjs/lexer/error.cjs
var require_error = __commonJS((exports) => {
  var createCustomError = require_create_custom_error();
  var generate = require_generate();
  var defaultLoc = { offset: 0, line: 1, column: 1 };
  function locateMismatch(matchResult, node) {
    const tokens = matchResult.tokens;
    const longestMatch = matchResult.longestMatch;
    const mismatchNode = longestMatch < tokens.length ? tokens[longestMatch].node || null : null;
    const badNode = mismatchNode !== node ? mismatchNode : null;
    let mismatchOffset = 0;
    let mismatchLength = 0;
    let entries = 0;
    let css = "";
    let start;
    let end;
    for (let i = 0;i < tokens.length; i++) {
      const token = tokens[i].value;
      if (i === longestMatch) {
        mismatchLength = token.length;
        mismatchOffset = css.length;
      }
      if (badNode !== null && tokens[i].node === badNode) {
        if (i <= longestMatch) {
          entries++;
        } else {
          entries = 0;
        }
      }
      css += token;
    }
    if (longestMatch === tokens.length || entries > 1) {
      start = fromLoc(badNode || node, "end") || buildLoc(defaultLoc, css);
      end = buildLoc(start);
    } else {
      start = fromLoc(badNode, "start") || buildLoc(fromLoc(node, "start") || defaultLoc, css.slice(0, mismatchOffset));
      end = fromLoc(badNode, "end") || buildLoc(start, css.substr(mismatchOffset, mismatchLength));
    }
    return {
      css,
      mismatchOffset,
      mismatchLength,
      start,
      end
    };
  }
  function fromLoc(node, point) {
    const value = node && node.loc && node.loc[point];
    if (value) {
      return "line" in value ? buildLoc(value) : value;
    }
    return null;
  }
  function buildLoc({ offset, line, column }, extra) {
    const loc = {
      offset,
      line,
      column
    };
    if (extra) {
      const lines = extra.split(/\n|\r\n?|\f/);
      loc.offset += extra.length;
      loc.line += lines.length - 1;
      loc.column = lines.length === 1 ? loc.column + extra.length : lines.pop().length + 1;
    }
    return loc;
  }
  var SyntaxReferenceError = function(type, referenceName) {
    const error = createCustomError.createCustomError("SyntaxReferenceError", type + (referenceName ? " `" + referenceName + "`" : ""));
    error.reference = referenceName;
    return error;
  };
  var SyntaxMatchError = function(message, syntax, node, matchResult) {
    const error = createCustomError.createCustomError("SyntaxMatchError", message);
    const {
      css,
      mismatchOffset,
      mismatchLength,
      start,
      end
    } = locateMismatch(matchResult, node);
    error.rawMessage = message;
    error.syntax = syntax ? generate.generate(syntax) : "<generic>";
    error.css = css;
    error.mismatchOffset = mismatchOffset;
    error.mismatchLength = mismatchLength;
    error.message = message + `
` + "  syntax: " + error.syntax + `
` + "   value: " + (css || "<empty string>") + `
` + "  --------" + new Array(error.mismatchOffset + 1).join("-") + "^";
    Object.assign(error, start);
    error.loc = {
      source: node && node.loc && node.loc.source || "<unknown>",
      start,
      end
    };
    return error;
  };
  exports.SyntaxMatchError = SyntaxMatchError;
  exports.SyntaxReferenceError = SyntaxReferenceError;
});

// ../../../../node_modules/.bun/css-tree@2.3.1/node_modules/css-tree/cjs/utils/names.cjs
var require_names2 = __commonJS((exports) => {
  var keywords = new Map;
  var properties = new Map;
  var HYPHENMINUS = 45;
  var keyword = getKeywordDescriptor;
  var property = getPropertyDescriptor;
  var vendorPrefix = getVendorPrefix;
  function isCustomProperty(str, offset) {
    offset = offset || 0;
    return str.length - offset >= 2 && str.charCodeAt(offset) === HYPHENMINUS && str.charCodeAt(offset + 1) === HYPHENMINUS;
  }
  function getVendorPrefix(str, offset) {
    offset = offset || 0;
    if (str.length - offset >= 3) {
      if (str.charCodeAt(offset) === HYPHENMINUS && str.charCodeAt(offset + 1) !== HYPHENMINUS) {
        const secondDashIndex = str.indexOf("-", offset + 2);
        if (secondDashIndex !== -1) {
          return str.substring(offset, secondDashIndex + 1);
        }
      }
    }
    return "";
  }
  function getKeywordDescriptor(keyword2) {
    if (keywords.has(keyword2)) {
      return keywords.get(keyword2);
    }
    const name = keyword2.toLowerCase();
    let descriptor = keywords.get(name);
    if (descriptor === undefined) {
      const custom = isCustomProperty(name, 0);
      const vendor = !custom ? getVendorPrefix(name, 0) : "";
      descriptor = Object.freeze({
        basename: name.substr(vendor.length),
        name,
        prefix: vendor,
        vendor,
        custom
      });
    }
    keywords.set(keyword2, descriptor);
    return descriptor;
  }
  function getPropertyDescriptor(property2) {
    if (properties.has(property2)) {
      return properties.get(property2);
    }
    let name = property2;
    let hack = property2[0];
    if (hack === "/") {
      hack = property2[1] === "/" ? "//" : "/";
    } else if (hack !== "_" && hack !== "*" && hack !== "$" && hack !== "#" && hack !== "+" && hack !== "&") {
      hack = "";
    }
    const custom = isCustomProperty(name, hack.length);
    if (!custom) {
      name = name.toLowerCase();
      if (properties.has(name)) {
        const descriptor2 = properties.get(name);
        properties.set(property2, descriptor2);
        return descriptor2;
      }
    }
    const vendor = !custom ? getVendorPrefix(name, hack.length) : "";
    const prefix = name.substr(0, hack.length + vendor.length);
    const descriptor = Object.freeze({
      basename: name.substr(prefix.length),
      name: name.substr(hack.length),
      hack,
      vendor,
      prefix,
      custom
    });
    properties.set(property2, descriptor);
    return descriptor;
  }
  exports.isCustomProperty = isCustomProperty;
  exports.keyword = keyword;
  exports.property = property;
  exports.vendorPrefix = vendorPrefix;
});

// ../../../../node_modules/.bun/css-tree@2.3.1/node_modules/css-tree/cjs/lexer/generic-const.cjs
var require_generic_const = __commonJS((exports) => {
  var cssWideKeywords = [
    "initial",
    "inherit",
    "unset",
    "revert",
    "revert-layer"
  ];
  exports.cssWideKeywords = cssWideKeywords;
});

// ../../../../node_modules/.bun/css-tree@2.3.1/node_modules/css-tree/cjs/lexer/generic-an-plus-b.cjs
var require_generic_an_plus_b = __commonJS((exports, module) => {
  var charCodeDefinitions = require_char_code_definitions();
  var types = require_types2();
  var utils = require_utils();
  var PLUSSIGN = 43;
  var HYPHENMINUS = 45;
  var N = 110;
  var DISALLOW_SIGN = true;
  var ALLOW_SIGN = false;
  function isDelim(token, code) {
    return token !== null && token.type === types.Delim && token.value.charCodeAt(0) === code;
  }
  function skipSC(token, offset, getNextToken) {
    while (token !== null && (token.type === types.WhiteSpace || token.type === types.Comment)) {
      token = getNextToken(++offset);
    }
    return offset;
  }
  function checkInteger(token, valueOffset, disallowSign, offset) {
    if (!token) {
      return 0;
    }
    const code = token.value.charCodeAt(valueOffset);
    if (code === PLUSSIGN || code === HYPHENMINUS) {
      if (disallowSign) {
        return 0;
      }
      valueOffset++;
    }
    for (;valueOffset < token.value.length; valueOffset++) {
      if (!charCodeDefinitions.isDigit(token.value.charCodeAt(valueOffset))) {
        return 0;
      }
    }
    return offset + 1;
  }
  function consumeB(token, offset_, getNextToken) {
    let sign = false;
    let offset = skipSC(token, offset_, getNextToken);
    token = getNextToken(offset);
    if (token === null) {
      return offset_;
    }
    if (token.type !== types.Number) {
      if (isDelim(token, PLUSSIGN) || isDelim(token, HYPHENMINUS)) {
        sign = true;
        offset = skipSC(getNextToken(++offset), offset, getNextToken);
        token = getNextToken(offset);
        if (token === null || token.type !== types.Number) {
          return 0;
        }
      } else {
        return offset_;
      }
    }
    if (!sign) {
      const code = token.value.charCodeAt(0);
      if (code !== PLUSSIGN && code !== HYPHENMINUS) {
        return 0;
      }
    }
    return checkInteger(token, sign ? 0 : 1, sign, offset);
  }
  function anPlusB(token, getNextToken) {
    let offset = 0;
    if (!token) {
      return 0;
    }
    if (token.type === types.Number) {
      return checkInteger(token, 0, ALLOW_SIGN, offset);
    } else if (token.type === types.Ident && token.value.charCodeAt(0) === HYPHENMINUS) {
      if (!utils.cmpChar(token.value, 1, N)) {
        return 0;
      }
      switch (token.value.length) {
        case 2:
          return consumeB(getNextToken(++offset), offset, getNextToken);
        case 3:
          if (token.value.charCodeAt(2) !== HYPHENMINUS) {
            return 0;
          }
          offset = skipSC(getNextToken(++offset), offset, getNextToken);
          token = getNextToken(offset);
          return checkInteger(token, 0, DISALLOW_SIGN, offset);
        default:
          if (token.value.charCodeAt(2) !== HYPHENMINUS) {
            return 0;
          }
          return checkInteger(token, 3, DISALLOW_SIGN, offset);
      }
    } else if (token.type === types.Ident || isDelim(token, PLUSSIGN) && getNextToken(offset + 1).type === types.Ident) {
      if (token.type !== types.Ident) {
        token = getNextToken(++offset);
      }
      if (token === null || !utils.cmpChar(token.value, 0, N)) {
        return 0;
      }
      switch (token.value.length) {
        case 1:
          return consumeB(getNextToken(++offset), offset, getNextToken);
        case 2:
          if (token.value.charCodeAt(1) !== HYPHENMINUS) {
            return 0;
          }
          offset = skipSC(getNextToken(++offset), offset, getNextToken);
          token = getNextToken(offset);
          return checkInteger(token, 0, DISALLOW_SIGN, offset);
        default:
          if (token.value.charCodeAt(1) !== HYPHENMINUS) {
            return 0;
          }
          return checkInteger(token, 2, DISALLOW_SIGN, offset);
      }
    } else if (token.type === types.Dimension) {
      let code = token.value.charCodeAt(0);
      let sign = code === PLUSSIGN || code === HYPHENMINUS ? 1 : 0;
      let i = sign;
      for (;i < token.value.length; i++) {
        if (!charCodeDefinitions.isDigit(token.value.charCodeAt(i))) {
          break;
        }
      }
      if (i === sign) {
        return 0;
      }
      if (!utils.cmpChar(token.value, i, N)) {
        return 0;
      }
      if (i + 1 === token.value.length) {
        return consumeB(getNextToken(++offset), offset, getNextToken);
      } else {
        if (token.value.charCodeAt(i + 1) !== HYPHENMINUS) {
          return 0;
        }
        if (i + 2 === token.value.length) {
          offset = skipSC(getNextToken(++offset), offset, getNextToken);
          token = getNextToken(offset);
          return checkInteger(token, 0, DISALLOW_SIGN, offset);
        } else {
          return checkInteger(token, i + 2, DISALLOW_SIGN, offset);
        }
      }
    }
    return 0;
  }
  module.exports = anPlusB;
});

// ../../../../node_modules/.bun/css-tree@2.3.1/node_modules/css-tree/cjs/lexer/generic-urange.cjs
var require_generic_urange = __commonJS((exports, module) => {
  var charCodeDefinitions = require_char_code_definitions();
  var types = require_types2();
  var utils = require_utils();
  var PLUSSIGN = 43;
  var HYPHENMINUS = 45;
  var QUESTIONMARK = 63;
  var U = 117;
  function isDelim(token, code) {
    return token !== null && token.type === types.Delim && token.value.charCodeAt(0) === code;
  }
  function startsWith(token, code) {
    return token.value.charCodeAt(0) === code;
  }
  function hexSequence(token, offset, allowDash) {
    let hexlen = 0;
    for (let pos = offset;pos < token.value.length; pos++) {
      const code = token.value.charCodeAt(pos);
      if (code === HYPHENMINUS && allowDash && hexlen !== 0) {
        hexSequence(token, offset + hexlen + 1, false);
        return 6;
      }
      if (!charCodeDefinitions.isHexDigit(code)) {
        return 0;
      }
      if (++hexlen > 6) {
        return 0;
      }
    }
    return hexlen;
  }
  function withQuestionMarkSequence(consumed, length, getNextToken) {
    if (!consumed) {
      return 0;
    }
    while (isDelim(getNextToken(length), QUESTIONMARK)) {
      if (++consumed > 6) {
        return 0;
      }
      length++;
    }
    return length;
  }
  function urange(token, getNextToken) {
    let length = 0;
    if (token === null || token.type !== types.Ident || !utils.cmpChar(token.value, 0, U)) {
      return 0;
    }
    token = getNextToken(++length);
    if (token === null) {
      return 0;
    }
    if (isDelim(token, PLUSSIGN)) {
      token = getNextToken(++length);
      if (token === null) {
        return 0;
      }
      if (token.type === types.Ident) {
        return withQuestionMarkSequence(hexSequence(token, 0, true), ++length, getNextToken);
      }
      if (isDelim(token, QUESTIONMARK)) {
        return withQuestionMarkSequence(1, ++length, getNextToken);
      }
      return 0;
    }
    if (token.type === types.Number) {
      const consumedHexLength = hexSequence(token, 1, true);
      if (consumedHexLength === 0) {
        return 0;
      }
      token = getNextToken(++length);
      if (token === null) {
        return length;
      }
      if (token.type === types.Dimension || token.type === types.Number) {
        if (!startsWith(token, HYPHENMINUS) || !hexSequence(token, 1, false)) {
          return 0;
        }
        return length + 1;
      }
      return withQuestionMarkSequence(consumedHexLength, length, getNextToken);
    }
    if (token.type === types.Dimension) {
      return withQuestionMarkSequence(hexSequence(token, 1, true), ++length, getNextToken);
    }
    return 0;
  }
  module.exports = urange;
});

// ../../../../node_modules/.bun/css-tree@2.3.1/node_modules/css-tree/cjs/lexer/generic.cjs
var require_generic = __commonJS((exports) => {
  var genericConst = require_generic_const();
  var genericAnPlusB = require_generic_an_plus_b();
  var genericUrange = require_generic_urange();
  var types = require_types2();
  var charCodeDefinitions = require_char_code_definitions();
  var utils = require_utils();
  var calcFunctionNames = ["calc(", "-moz-calc(", "-webkit-calc("];
  var balancePair = new Map([
    [types.Function, types.RightParenthesis],
    [types.LeftParenthesis, types.RightParenthesis],
    [types.LeftSquareBracket, types.RightSquareBracket],
    [types.LeftCurlyBracket, types.RightCurlyBracket]
  ]);
  function charCodeAt(str, index) {
    return index < str.length ? str.charCodeAt(index) : 0;
  }
  function eqStr(actual, expected) {
    return utils.cmpStr(actual, 0, actual.length, expected);
  }
  function eqStrAny(actual, expected) {
    for (let i = 0;i < expected.length; i++) {
      if (eqStr(actual, expected[i])) {
        return true;
      }
    }
    return false;
  }
  function isPostfixIeHack(str, offset) {
    if (offset !== str.length - 2) {
      return false;
    }
    return charCodeAt(str, offset) === 92 && charCodeDefinitions.isDigit(charCodeAt(str, offset + 1));
  }
  function outOfRange(opts, value, numEnd) {
    if (opts && opts.type === "Range") {
      const num = Number(numEnd !== undefined && numEnd !== value.length ? value.substr(0, numEnd) : value);
      if (isNaN(num)) {
        return true;
      }
      if (opts.min !== null && num < opts.min && typeof opts.min !== "string") {
        return true;
      }
      if (opts.max !== null && num > opts.max && typeof opts.max !== "string") {
        return true;
      }
    }
    return false;
  }
  function consumeFunction(token, getNextToken) {
    let balanceCloseType = 0;
    let balanceStash = [];
    let length = 0;
    scan:
      do {
        switch (token.type) {
          case types.RightCurlyBracket:
          case types.RightParenthesis:
          case types.RightSquareBracket:
            if (token.type !== balanceCloseType) {
              break scan;
            }
            balanceCloseType = balanceStash.pop();
            if (balanceStash.length === 0) {
              length++;
              break scan;
            }
            break;
          case types.Function:
          case types.LeftParenthesis:
          case types.LeftSquareBracket:
          case types.LeftCurlyBracket:
            balanceStash.push(balanceCloseType);
            balanceCloseType = balancePair.get(token.type);
            break;
        }
        length++;
      } while (token = getNextToken(length));
    return length;
  }
  function calc(next) {
    return function(token, getNextToken, opts) {
      if (token === null) {
        return 0;
      }
      if (token.type === types.Function && eqStrAny(token.value, calcFunctionNames)) {
        return consumeFunction(token, getNextToken);
      }
      return next(token, getNextToken, opts);
    };
  }
  function tokenType(expectedTokenType) {
    return function(token) {
      if (token === null || token.type !== expectedTokenType) {
        return 0;
      }
      return 1;
    };
  }
  function customIdent(token) {
    if (token === null || token.type !== types.Ident) {
      return 0;
    }
    const name = token.value.toLowerCase();
    if (eqStrAny(name, genericConst.cssWideKeywords)) {
      return 0;
    }
    if (eqStr(name, "default")) {
      return 0;
    }
    return 1;
  }
  function customPropertyName(token) {
    if (token === null || token.type !== types.Ident) {
      return 0;
    }
    if (charCodeAt(token.value, 0) !== 45 || charCodeAt(token.value, 1) !== 45) {
      return 0;
    }
    return 1;
  }
  function hexColor(token) {
    if (token === null || token.type !== types.Hash) {
      return 0;
    }
    const length = token.value.length;
    if (length !== 4 && length !== 5 && length !== 7 && length !== 9) {
      return 0;
    }
    for (let i = 1;i < length; i++) {
      if (!charCodeDefinitions.isHexDigit(charCodeAt(token.value, i))) {
        return 0;
      }
    }
    return 1;
  }
  function idSelector(token) {
    if (token === null || token.type !== types.Hash) {
      return 0;
    }
    if (!charCodeDefinitions.isIdentifierStart(charCodeAt(token.value, 1), charCodeAt(token.value, 2), charCodeAt(token.value, 3))) {
      return 0;
    }
    return 1;
  }
  function declarationValue(token, getNextToken) {
    if (!token) {
      return 0;
    }
    let balanceCloseType = 0;
    let balanceStash = [];
    let length = 0;
    scan:
      do {
        switch (token.type) {
          case types.BadString:
          case types.BadUrl:
            break scan;
          case types.RightCurlyBracket:
          case types.RightParenthesis:
          case types.RightSquareBracket:
            if (token.type !== balanceCloseType) {
              break scan;
            }
            balanceCloseType = balanceStash.pop();
            break;
          case types.Semicolon:
            if (balanceCloseType === 0) {
              break scan;
            }
            break;
          case types.Delim:
            if (balanceCloseType === 0 && token.value === "!") {
              break scan;
            }
            break;
          case types.Function:
          case types.LeftParenthesis:
          case types.LeftSquareBracket:
          case types.LeftCurlyBracket:
            balanceStash.push(balanceCloseType);
            balanceCloseType = balancePair.get(token.type);
            break;
        }
        length++;
      } while (token = getNextToken(length));
    return length;
  }
  function anyValue(token, getNextToken) {
    if (!token) {
      return 0;
    }
    let balanceCloseType = 0;
    let balanceStash = [];
    let length = 0;
    scan:
      do {
        switch (token.type) {
          case types.BadString:
          case types.BadUrl:
            break scan;
          case types.RightCurlyBracket:
          case types.RightParenthesis:
          case types.RightSquareBracket:
            if (token.type !== balanceCloseType) {
              break scan;
            }
            balanceCloseType = balanceStash.pop();
            break;
          case types.Function:
          case types.LeftParenthesis:
          case types.LeftSquareBracket:
          case types.LeftCurlyBracket:
            balanceStash.push(balanceCloseType);
            balanceCloseType = balancePair.get(token.type);
            break;
        }
        length++;
      } while (token = getNextToken(length));
    return length;
  }
  function dimension(type) {
    if (type) {
      type = new Set(type);
    }
    return function(token, getNextToken, opts) {
      if (token === null || token.type !== types.Dimension) {
        return 0;
      }
      const numberEnd = utils.consumeNumber(token.value, 0);
      if (type !== null) {
        const reverseSolidusOffset = token.value.indexOf("\\", numberEnd);
        const unit = reverseSolidusOffset === -1 || !isPostfixIeHack(token.value, reverseSolidusOffset) ? token.value.substr(numberEnd) : token.value.substring(numberEnd, reverseSolidusOffset);
        if (type.has(unit.toLowerCase()) === false) {
          return 0;
        }
      }
      if (outOfRange(opts, token.value, numberEnd)) {
        return 0;
      }
      return 1;
    };
  }
  function percentage(token, getNextToken, opts) {
    if (token === null || token.type !== types.Percentage) {
      return 0;
    }
    if (outOfRange(opts, token.value, token.value.length - 1)) {
      return 0;
    }
    return 1;
  }
  function zero(next) {
    if (typeof next !== "function") {
      next = function() {
        return 0;
      };
    }
    return function(token, getNextToken, opts) {
      if (token !== null && token.type === types.Number) {
        if (Number(token.value) === 0) {
          return 1;
        }
      }
      return next(token, getNextToken, opts);
    };
  }
  function number(token, getNextToken, opts) {
    if (token === null) {
      return 0;
    }
    const numberEnd = utils.consumeNumber(token.value, 0);
    const isNumber = numberEnd === token.value.length;
    if (!isNumber && !isPostfixIeHack(token.value, numberEnd)) {
      return 0;
    }
    if (outOfRange(opts, token.value, numberEnd)) {
      return 0;
    }
    return 1;
  }
  function integer(token, getNextToken, opts) {
    if (token === null || token.type !== types.Number) {
      return 0;
    }
    let i = charCodeAt(token.value, 0) === 43 || charCodeAt(token.value, 0) === 45 ? 1 : 0;
    for (;i < token.value.length; i++) {
      if (!charCodeDefinitions.isDigit(charCodeAt(token.value, i))) {
        return 0;
      }
    }
    if (outOfRange(opts, token.value, i)) {
      return 0;
    }
    return 1;
  }
  var tokenTypes = {
    "ident-token": tokenType(types.Ident),
    "function-token": tokenType(types.Function),
    "at-keyword-token": tokenType(types.AtKeyword),
    "hash-token": tokenType(types.Hash),
    "string-token": tokenType(types.String),
    "bad-string-token": tokenType(types.BadString),
    "url-token": tokenType(types.Url),
    "bad-url-token": tokenType(types.BadUrl),
    "delim-token": tokenType(types.Delim),
    "number-token": tokenType(types.Number),
    "percentage-token": tokenType(types.Percentage),
    "dimension-token": tokenType(types.Dimension),
    "whitespace-token": tokenType(types.WhiteSpace),
    "CDO-token": tokenType(types.CDO),
    "CDC-token": tokenType(types.CDC),
    "colon-token": tokenType(types.Colon),
    "semicolon-token": tokenType(types.Semicolon),
    "comma-token": tokenType(types.Comma),
    "[-token": tokenType(types.LeftSquareBracket),
    "]-token": tokenType(types.RightSquareBracket),
    "(-token": tokenType(types.LeftParenthesis),
    ")-token": tokenType(types.RightParenthesis),
    "{-token": tokenType(types.LeftCurlyBracket),
    "}-token": tokenType(types.RightCurlyBracket)
  };
  var productionTypes = {
    string: tokenType(types.String),
    ident: tokenType(types.Ident),
    percentage: calc(percentage),
    zero: zero(),
    number: calc(number),
    integer: calc(integer),
    "custom-ident": customIdent,
    "custom-property-name": customPropertyName,
    "hex-color": hexColor,
    "id-selector": idSelector,
    "an-plus-b": genericAnPlusB,
    urange: genericUrange,
    "declaration-value": declarationValue,
    "any-value": anyValue
  };
  function createDemensionTypes(units) {
    const {
      angle,
      decibel,
      frequency,
      flex,
      length,
      resolution,
      semitones,
      time
    } = units || {};
    return {
      dimension: calc(dimension(null)),
      angle: calc(dimension(angle)),
      decibel: calc(dimension(decibel)),
      frequency: calc(dimension(frequency)),
      flex: calc(dimension(flex)),
      length: calc(zero(dimension(length))),
      resolution: calc(dimension(resolution)),
      semitones: calc(dimension(semitones)),
      time: calc(dimension(time))
    };
  }
  function createGenericTypes(units) {
    return {
      ...tokenTypes,
      ...productionTypes,
      ...createDemensionTypes(units)
    };
  }
  exports.createDemensionTypes = createDemensionTypes;
  exports.createGenericTypes = createGenericTypes;
  exports.productionTypes = productionTypes;
  exports.tokenTypes = tokenTypes;
});

// ../../../../node_modules/.bun/css-tree@2.3.1/node_modules/css-tree/cjs/lexer/units.cjs
var require_units = __commonJS((exports) => {
  var length = [
    "cm",
    "mm",
    "q",
    "in",
    "pt",
    "pc",
    "px",
    "em",
    "rem",
    "ex",
    "rex",
    "cap",
    "rcap",
    "ch",
    "rch",
    "ic",
    "ric",
    "lh",
    "rlh",
    "vw",
    "svw",
    "lvw",
    "dvw",
    "vh",
    "svh",
    "lvh",
    "dvh",
    "vi",
    "svi",
    "lvi",
    "dvi",
    "vb",
    "svb",
    "lvb",
    "dvb",
    "vmin",
    "svmin",
    "lvmin",
    "dvmin",
    "vmax",
    "svmax",
    "lvmax",
    "dvmax",
    "cqw",
    "cqh",
    "cqi",
    "cqb",
    "cqmin",
    "cqmax"
  ];
  var angle = ["deg", "grad", "rad", "turn"];
  var time = ["s", "ms"];
  var frequency = ["hz", "khz"];
  var resolution = ["dpi", "dpcm", "dppx", "x"];
  var flex = ["fr"];
  var decibel = ["db"];
  var semitones = ["st"];
  exports.angle = angle;
  exports.decibel = decibel;
  exports.flex = flex;
  exports.frequency = frequency;
  exports.length = length;
  exports.resolution = resolution;
  exports.semitones = semitones;
  exports.time = time;
});

// ../../../../node_modules/.bun/css-tree@2.3.1/node_modules/css-tree/cjs/lexer/prepare-tokens.cjs
var require_prepare_tokens = __commonJS((exports, module) => {
  var index = require_tokenizer();
  var astToTokens = {
    decorator(handlers) {
      const tokens = [];
      let curNode = null;
      return {
        ...handlers,
        node(node) {
          const tmp = curNode;
          curNode = node;
          handlers.node.call(this, node);
          curNode = tmp;
        },
        emit(value, type, auto) {
          tokens.push({
            type,
            value,
            node: auto ? null : curNode
          });
        },
        result() {
          return tokens;
        }
      };
    }
  };
  function stringToTokens(str) {
    const tokens = [];
    index.tokenize(str, (type, start, end) => tokens.push({
      type,
      value: str.slice(start, end),
      node: null
    }));
    return tokens;
  }
  function prepareTokens(value, syntax) {
    if (typeof value === "string") {
      return stringToTokens(value);
    }
    return syntax.generate(value, astToTokens);
  }
  module.exports = prepareTokens;
});

// ../../../../node_modules/.bun/css-tree@2.3.1/node_modules/css-tree/cjs/definition-syntax/SyntaxError.cjs
var require_SyntaxError2 = __commonJS((exports) => {
  var createCustomError = require_create_custom_error();
  function SyntaxError2(message, input, offset) {
    return Object.assign(createCustomError.createCustomError("SyntaxError", message), {
      input,
      offset,
      rawMessage: message,
      message: message + `
` + "  " + input + `
` + "--" + new Array((offset || input.length) + 1).join("-") + "^"
    });
  }
  exports.SyntaxError = SyntaxError2;
});

// ../../../../node_modules/.bun/css-tree@2.3.1/node_modules/css-tree/cjs/definition-syntax/tokenizer.cjs
var require_tokenizer2 = __commonJS((exports) => {
  var SyntaxError2 = require_SyntaxError2();
  var TAB = 9;
  var N = 10;
  var F = 12;
  var R = 13;
  var SPACE = 32;

  class Tokenizer {
    constructor(str) {
      this.str = str;
      this.pos = 0;
    }
    charCodeAt(pos) {
      return pos < this.str.length ? this.str.charCodeAt(pos) : 0;
    }
    charCode() {
      return this.charCodeAt(this.pos);
    }
    nextCharCode() {
      return this.charCodeAt(this.pos + 1);
    }
    nextNonWsCode(pos) {
      return this.charCodeAt(this.findWsEnd(pos));
    }
    findWsEnd(pos) {
      for (;pos < this.str.length; pos++) {
        const code = this.str.charCodeAt(pos);
        if (code !== R && code !== N && code !== F && code !== SPACE && code !== TAB) {
          break;
        }
      }
      return pos;
    }
    substringToPos(end) {
      return this.str.substring(this.pos, this.pos = end);
    }
    eat(code) {
      if (this.charCode() !== code) {
        this.error("Expect `" + String.fromCharCode(code) + "`");
      }
      this.pos++;
    }
    peek() {
      return this.pos < this.str.length ? this.str.charAt(this.pos++) : "";
    }
    error(message) {
      throw new SyntaxError2.SyntaxError(message, this.str, this.pos);
    }
  }
  exports.Tokenizer = Tokenizer;
});

// ../../../../node_modules/.bun/css-tree@2.3.1/node_modules/css-tree/cjs/definition-syntax/parse.cjs
var require_parse3 = __commonJS((exports) => {
  var tokenizer = require_tokenizer2();
  var TAB = 9;
  var N = 10;
  var F = 12;
  var R = 13;
  var SPACE = 32;
  var EXCLAMATIONMARK = 33;
  var NUMBERSIGN = 35;
  var AMPERSAND = 38;
  var APOSTROPHE = 39;
  var LEFTPARENTHESIS = 40;
  var RIGHTPARENTHESIS = 41;
  var ASTERISK = 42;
  var PLUSSIGN = 43;
  var COMMA = 44;
  var HYPERMINUS = 45;
  var LESSTHANSIGN = 60;
  var GREATERTHANSIGN = 62;
  var QUESTIONMARK = 63;
  var COMMERCIALAT = 64;
  var LEFTSQUAREBRACKET = 91;
  var RIGHTSQUAREBRACKET = 93;
  var LEFTCURLYBRACKET = 123;
  var VERTICALLINE = 124;
  var RIGHTCURLYBRACKET = 125;
  var INFINITY = 8734;
  var NAME_CHAR = new Uint8Array(128).map((_, idx) => /[a-zA-Z0-9\-]/.test(String.fromCharCode(idx)) ? 1 : 0);
  var COMBINATOR_PRECEDENCE = {
    " ": 1,
    "&&": 2,
    "||": 3,
    "|": 4
  };
  function scanSpaces(tokenizer2) {
    return tokenizer2.substringToPos(tokenizer2.findWsEnd(tokenizer2.pos));
  }
  function scanWord(tokenizer2) {
    let end = tokenizer2.pos;
    for (;end < tokenizer2.str.length; end++) {
      const code = tokenizer2.str.charCodeAt(end);
      if (code >= 128 || NAME_CHAR[code] === 0) {
        break;
      }
    }
    if (tokenizer2.pos === end) {
      tokenizer2.error("Expect a keyword");
    }
    return tokenizer2.substringToPos(end);
  }
  function scanNumber(tokenizer2) {
    let end = tokenizer2.pos;
    for (;end < tokenizer2.str.length; end++) {
      const code = tokenizer2.str.charCodeAt(end);
      if (code < 48 || code > 57) {
        break;
      }
    }
    if (tokenizer2.pos === end) {
      tokenizer2.error("Expect a number");
    }
    return tokenizer2.substringToPos(end);
  }
  function scanString(tokenizer2) {
    const end = tokenizer2.str.indexOf("'", tokenizer2.pos + 1);
    if (end === -1) {
      tokenizer2.pos = tokenizer2.str.length;
      tokenizer2.error("Expect an apostrophe");
    }
    return tokenizer2.substringToPos(end + 1);
  }
  function readMultiplierRange(tokenizer2) {
    let min = null;
    let max = null;
    tokenizer2.eat(LEFTCURLYBRACKET);
    min = scanNumber(tokenizer2);
    if (tokenizer2.charCode() === COMMA) {
      tokenizer2.pos++;
      if (tokenizer2.charCode() !== RIGHTCURLYBRACKET) {
        max = scanNumber(tokenizer2);
      }
    } else {
      max = min;
    }
    tokenizer2.eat(RIGHTCURLYBRACKET);
    return {
      min: Number(min),
      max: max ? Number(max) : 0
    };
  }
  function readMultiplier(tokenizer2) {
    let range = null;
    let comma = false;
    switch (tokenizer2.charCode()) {
      case ASTERISK:
        tokenizer2.pos++;
        range = {
          min: 0,
          max: 0
        };
        break;
      case PLUSSIGN:
        tokenizer2.pos++;
        range = {
          min: 1,
          max: 0
        };
        break;
      case QUESTIONMARK:
        tokenizer2.pos++;
        range = {
          min: 0,
          max: 1
        };
        break;
      case NUMBERSIGN:
        tokenizer2.pos++;
        comma = true;
        if (tokenizer2.charCode() === LEFTCURLYBRACKET) {
          range = readMultiplierRange(tokenizer2);
        } else if (tokenizer2.charCode() === QUESTIONMARK) {
          tokenizer2.pos++;
          range = {
            min: 0,
            max: 0
          };
        } else {
          range = {
            min: 1,
            max: 0
          };
        }
        break;
      case LEFTCURLYBRACKET:
        range = readMultiplierRange(tokenizer2);
        break;
      default:
        return null;
    }
    return {
      type: "Multiplier",
      comma,
      min: range.min,
      max: range.max,
      term: null
    };
  }
  function maybeMultiplied(tokenizer2, node) {
    const multiplier = readMultiplier(tokenizer2);
    if (multiplier !== null) {
      multiplier.term = node;
      if (tokenizer2.charCode() === NUMBERSIGN && tokenizer2.charCodeAt(tokenizer2.pos - 1) === PLUSSIGN) {
        return maybeMultiplied(tokenizer2, multiplier);
      }
      return multiplier;
    }
    return node;
  }
  function maybeToken(tokenizer2) {
    const ch = tokenizer2.peek();
    if (ch === "") {
      return null;
    }
    return {
      type: "Token",
      value: ch
    };
  }
  function readProperty(tokenizer2) {
    let name;
    tokenizer2.eat(LESSTHANSIGN);
    tokenizer2.eat(APOSTROPHE);
    name = scanWord(tokenizer2);
    tokenizer2.eat(APOSTROPHE);
    tokenizer2.eat(GREATERTHANSIGN);
    return maybeMultiplied(tokenizer2, {
      type: "Property",
      name
    });
  }
  function readTypeRange(tokenizer2) {
    let min = null;
    let max = null;
    let sign = 1;
    tokenizer2.eat(LEFTSQUAREBRACKET);
    if (tokenizer2.charCode() === HYPERMINUS) {
      tokenizer2.peek();
      sign = -1;
    }
    if (sign == -1 && tokenizer2.charCode() === INFINITY) {
      tokenizer2.peek();
    } else {
      min = sign * Number(scanNumber(tokenizer2));
      if (NAME_CHAR[tokenizer2.charCode()] !== 0) {
        min += scanWord(tokenizer2);
      }
    }
    scanSpaces(tokenizer2);
    tokenizer2.eat(COMMA);
    scanSpaces(tokenizer2);
    if (tokenizer2.charCode() === INFINITY) {
      tokenizer2.peek();
    } else {
      sign = 1;
      if (tokenizer2.charCode() === HYPERMINUS) {
        tokenizer2.peek();
        sign = -1;
      }
      max = sign * Number(scanNumber(tokenizer2));
      if (NAME_CHAR[tokenizer2.charCode()] !== 0) {
        max += scanWord(tokenizer2);
      }
    }
    tokenizer2.eat(RIGHTSQUAREBRACKET);
    return {
      type: "Range",
      min,
      max
    };
  }
  function readType(tokenizer2) {
    let name;
    let opts = null;
    tokenizer2.eat(LESSTHANSIGN);
    name = scanWord(tokenizer2);
    if (tokenizer2.charCode() === LEFTPARENTHESIS && tokenizer2.nextCharCode() === RIGHTPARENTHESIS) {
      tokenizer2.pos += 2;
      name += "()";
    }
    if (tokenizer2.charCodeAt(tokenizer2.findWsEnd(tokenizer2.pos)) === LEFTSQUAREBRACKET) {
      scanSpaces(tokenizer2);
      opts = readTypeRange(tokenizer2);
    }
    tokenizer2.eat(GREATERTHANSIGN);
    return maybeMultiplied(tokenizer2, {
      type: "Type",
      name,
      opts
    });
  }
  function readKeywordOrFunction(tokenizer2) {
    const name = scanWord(tokenizer2);
    if (tokenizer2.charCode() === LEFTPARENTHESIS) {
      tokenizer2.pos++;
      return {
        type: "Function",
        name
      };
    }
    return maybeMultiplied(tokenizer2, {
      type: "Keyword",
      name
    });
  }
  function regroupTerms(terms, combinators) {
    function createGroup(terms2, combinator2) {
      return {
        type: "Group",
        terms: terms2,
        combinator: combinator2,
        disallowEmpty: false,
        explicit: false
      };
    }
    let combinator;
    combinators = Object.keys(combinators).sort((a, b) => COMBINATOR_PRECEDENCE[a] - COMBINATOR_PRECEDENCE[b]);
    while (combinators.length > 0) {
      combinator = combinators.shift();
      let i = 0;
      let subgroupStart = 0;
      for (;i < terms.length; i++) {
        const term = terms[i];
        if (term.type === "Combinator") {
          if (term.value === combinator) {
            if (subgroupStart === -1) {
              subgroupStart = i - 1;
            }
            terms.splice(i, 1);
            i--;
          } else {
            if (subgroupStart !== -1 && i - subgroupStart > 1) {
              terms.splice(subgroupStart, i - subgroupStart, createGroup(terms.slice(subgroupStart, i), combinator));
              i = subgroupStart + 1;
            }
            subgroupStart = -1;
          }
        }
      }
      if (subgroupStart !== -1 && combinators.length) {
        terms.splice(subgroupStart, i - subgroupStart, createGroup(terms.slice(subgroupStart, i), combinator));
      }
    }
    return combinator;
  }
  function readImplicitGroup(tokenizer2) {
    const terms = [];
    const combinators = {};
    let token;
    let prevToken = null;
    let prevTokenPos = tokenizer2.pos;
    while (token = peek(tokenizer2)) {
      if (token.type !== "Spaces") {
        if (token.type === "Combinator") {
          if (prevToken === null || prevToken.type === "Combinator") {
            tokenizer2.pos = prevTokenPos;
            tokenizer2.error("Unexpected combinator");
          }
          combinators[token.value] = true;
        } else if (prevToken !== null && prevToken.type !== "Combinator") {
          combinators[" "] = true;
          terms.push({
            type: "Combinator",
            value: " "
          });
        }
        terms.push(token);
        prevToken = token;
        prevTokenPos = tokenizer2.pos;
      }
    }
    if (prevToken !== null && prevToken.type === "Combinator") {
      tokenizer2.pos -= prevTokenPos;
      tokenizer2.error("Unexpected combinator");
    }
    return {
      type: "Group",
      terms,
      combinator: regroupTerms(terms, combinators) || " ",
      disallowEmpty: false,
      explicit: false
    };
  }
  function readGroup(tokenizer2) {
    let result;
    tokenizer2.eat(LEFTSQUAREBRACKET);
    result = readImplicitGroup(tokenizer2);
    tokenizer2.eat(RIGHTSQUAREBRACKET);
    result.explicit = true;
    if (tokenizer2.charCode() === EXCLAMATIONMARK) {
      tokenizer2.pos++;
      result.disallowEmpty = true;
    }
    return result;
  }
  function peek(tokenizer2) {
    let code = tokenizer2.charCode();
    if (code < 128 && NAME_CHAR[code] === 1) {
      return readKeywordOrFunction(tokenizer2);
    }
    switch (code) {
      case RIGHTSQUAREBRACKET:
        break;
      case LEFTSQUAREBRACKET:
        return maybeMultiplied(tokenizer2, readGroup(tokenizer2));
      case LESSTHANSIGN:
        return tokenizer2.nextCharCode() === APOSTROPHE ? readProperty(tokenizer2) : readType(tokenizer2);
      case VERTICALLINE:
        return {
          type: "Combinator",
          value: tokenizer2.substringToPos(tokenizer2.pos + (tokenizer2.nextCharCode() === VERTICALLINE ? 2 : 1))
        };
      case AMPERSAND:
        tokenizer2.pos++;
        tokenizer2.eat(AMPERSAND);
        return {
          type: "Combinator",
          value: "&&"
        };
      case COMMA:
        tokenizer2.pos++;
        return {
          type: "Comma"
        };
      case APOSTROPHE:
        return maybeMultiplied(tokenizer2, {
          type: "String",
          value: scanString(tokenizer2)
        });
      case SPACE:
      case TAB:
      case N:
      case R:
      case F:
        return {
          type: "Spaces",
          value: scanSpaces(tokenizer2)
        };
      case COMMERCIALAT:
        code = tokenizer2.nextCharCode();
        if (code < 128 && NAME_CHAR[code] === 1) {
          tokenizer2.pos++;
          return {
            type: "AtKeyword",
            name: scanWord(tokenizer2)
          };
        }
        return maybeToken(tokenizer2);
      case ASTERISK:
      case PLUSSIGN:
      case QUESTIONMARK:
      case NUMBERSIGN:
      case EXCLAMATIONMARK:
        break;
      case LEFTCURLYBRACKET:
        code = tokenizer2.nextCharCode();
        if (code < 48 || code > 57) {
          return maybeToken(tokenizer2);
        }
        break;
      default:
        return maybeToken(tokenizer2);
    }
  }
  function parse(source) {
    const tokenizer$1 = new tokenizer.Tokenizer(source);
    const result = readImplicitGroup(tokenizer$1);
    if (tokenizer$1.pos !== source.length) {
      tokenizer$1.error("Unexpected input");
    }
    if (result.terms.length === 1 && result.terms[0].type === "Group") {
      return result.terms[0];
    }
    return result;
  }
  exports.parse = parse;
});

// ../../../../node_modules/.bun/css-tree@2.3.1/node_modules/css-tree/cjs/lexer/match-graph.cjs
var require_match_graph = __commonJS((exports) => {
  var parse = require_parse3();
  var MATCH = { type: "Match" };
  var MISMATCH = { type: "Mismatch" };
  var DISALLOW_EMPTY = { type: "DisallowEmpty" };
  var LEFTPARENTHESIS = 40;
  var RIGHTPARENTHESIS = 41;
  function createCondition(match, thenBranch, elseBranch) {
    if (thenBranch === MATCH && elseBranch === MISMATCH) {
      return match;
    }
    if (match === MATCH && thenBranch === MATCH && elseBranch === MATCH) {
      return match;
    }
    if (match.type === "If" && match.else === MISMATCH && thenBranch === MATCH) {
      thenBranch = match.then;
      match = match.match;
    }
    return {
      type: "If",
      match,
      then: thenBranch,
      else: elseBranch
    };
  }
  function isFunctionType(name) {
    return name.length > 2 && name.charCodeAt(name.length - 2) === LEFTPARENTHESIS && name.charCodeAt(name.length - 1) === RIGHTPARENTHESIS;
  }
  function isEnumCapatible(term) {
    return term.type === "Keyword" || term.type === "AtKeyword" || term.type === "Function" || term.type === "Type" && isFunctionType(term.name);
  }
  function buildGroupMatchGraph(combinator, terms, atLeastOneTermMatched) {
    switch (combinator) {
      case " ": {
        let result = MATCH;
        for (let i = terms.length - 1;i >= 0; i--) {
          const term = terms[i];
          result = createCondition(term, result, MISMATCH);
        }
        return result;
      }
      case "|": {
        let result = MISMATCH;
        let map = null;
        for (let i = terms.length - 1;i >= 0; i--) {
          let term = terms[i];
          if (isEnumCapatible(term)) {
            if (map === null && i > 0 && isEnumCapatible(terms[i - 1])) {
              map = Object.create(null);
              result = createCondition({
                type: "Enum",
                map
              }, MATCH, result);
            }
            if (map !== null) {
              const key = (isFunctionType(term.name) ? term.name.slice(0, -1) : term.name).toLowerCase();
              if (key in map === false) {
                map[key] = term;
                continue;
              }
            }
          }
          map = null;
          result = createCondition(term, MATCH, result);
        }
        return result;
      }
      case "&&": {
        if (terms.length > 5) {
          return {
            type: "MatchOnce",
            terms,
            all: true
          };
        }
        let result = MISMATCH;
        for (let i = terms.length - 1;i >= 0; i--) {
          const term = terms[i];
          let thenClause;
          if (terms.length > 1) {
            thenClause = buildGroupMatchGraph(combinator, terms.filter(function(newGroupTerm) {
              return newGroupTerm !== term;
            }), false);
          } else {
            thenClause = MATCH;
          }
          result = createCondition(term, thenClause, result);
        }
        return result;
      }
      case "||": {
        if (terms.length > 5) {
          return {
            type: "MatchOnce",
            terms,
            all: false
          };
        }
        let result = atLeastOneTermMatched ? MATCH : MISMATCH;
        for (let i = terms.length - 1;i >= 0; i--) {
          const term = terms[i];
          let thenClause;
          if (terms.length > 1) {
            thenClause = buildGroupMatchGraph(combinator, terms.filter(function(newGroupTerm) {
              return newGroupTerm !== term;
            }), true);
          } else {
            thenClause = MATCH;
          }
          result = createCondition(term, thenClause, result);
        }
        return result;
      }
    }
  }
  function buildMultiplierMatchGraph(node) {
    let result = MATCH;
    let matchTerm = buildMatchGraphInternal(node.term);
    if (node.max === 0) {
      matchTerm = createCondition(matchTerm, DISALLOW_EMPTY, MISMATCH);
      result = createCondition(matchTerm, null, MISMATCH);
      result.then = createCondition(MATCH, MATCH, result);
      if (node.comma) {
        result.then.else = createCondition({ type: "Comma", syntax: node }, result, MISMATCH);
      }
    } else {
      for (let i = node.min || 1;i <= node.max; i++) {
        if (node.comma && result !== MATCH) {
          result = createCondition({ type: "Comma", syntax: node }, result, MISMATCH);
        }
        result = createCondition(matchTerm, createCondition(MATCH, MATCH, result), MISMATCH);
      }
    }
    if (node.min === 0) {
      result = createCondition(MATCH, MATCH, result);
    } else {
      for (let i = 0;i < node.min - 1; i++) {
        if (node.comma && result !== MATCH) {
          result = createCondition({ type: "Comma", syntax: node }, result, MISMATCH);
        }
        result = createCondition(matchTerm, result, MISMATCH);
      }
    }
    return result;
  }
  function buildMatchGraphInternal(node) {
    if (typeof node === "function") {
      return {
        type: "Generic",
        fn: node
      };
    }
    switch (node.type) {
      case "Group": {
        let result = buildGroupMatchGraph(node.combinator, node.terms.map(buildMatchGraphInternal), false);
        if (node.disallowEmpty) {
          result = createCondition(result, DISALLOW_EMPTY, MISMATCH);
        }
        return result;
      }
      case "Multiplier":
        return buildMultiplierMatchGraph(node);
      case "Type":
      case "Property":
        return {
          type: node.type,
          name: node.name,
          syntax: node
        };
      case "Keyword":
        return {
          type: node.type,
          name: node.name.toLowerCase(),
          syntax: node
        };
      case "AtKeyword":
        return {
          type: node.type,
          name: "@" + node.name.toLowerCase(),
          syntax: node
        };
      case "Function":
        return {
          type: node.type,
          name: node.name.toLowerCase() + "(",
          syntax: node
        };
      case "String":
        if (node.value.length === 3) {
          return {
            type: "Token",
            value: node.value.charAt(1),
            syntax: node
          };
        }
        return {
          type: node.type,
          value: node.value.substr(1, node.value.length - 2).replace(/\\'/g, "'"),
          syntax: node
        };
      case "Token":
        return {
          type: node.type,
          value: node.value,
          syntax: node
        };
      case "Comma":
        return {
          type: node.type,
          syntax: node
        };
      default:
        throw new Error("Unknown node type:", node.type);
    }
  }
  function buildMatchGraph(syntaxTree, ref) {
    if (typeof syntaxTree === "string") {
      syntaxTree = parse.parse(syntaxTree);
    }
    return {
      type: "MatchGraph",
      match: buildMatchGraphInternal(syntaxTree),
      syntax: ref || null,
      source: syntaxTree
    };
  }
  exports.DISALLOW_EMPTY = DISALLOW_EMPTY;
  exports.MATCH = MATCH;
  exports.MISMATCH = MISMATCH;
  exports.buildMatchGraph = buildMatchGraph;
});

// ../../../../node_modules/.bun/css-tree@2.3.1/node_modules/css-tree/cjs/lexer/match.cjs
var require_match = __commonJS((exports) => {
  var matchGraph = require_match_graph();
  var types = require_types2();
  var { hasOwnProperty: hasOwnProperty2 } = Object.prototype;
  var STUB = 0;
  var TOKEN = 1;
  var OPEN_SYNTAX = 2;
  var CLOSE_SYNTAX = 3;
  var EXIT_REASON_MATCH = "Match";
  var EXIT_REASON_MISMATCH = "Mismatch";
  var EXIT_REASON_ITERATION_LIMIT = "Maximum iteration number exceeded (please fill an issue on https://github.com/csstree/csstree/issues)";
  var ITERATION_LIMIT = 15000;
  function reverseList(list) {
    let prev = null;
    let next = null;
    let item = list;
    while (item !== null) {
      next = item.prev;
      item.prev = prev;
      prev = item;
      item = next;
    }
    return prev;
  }
  function areStringsEqualCaseInsensitive(testStr, referenceStr) {
    if (testStr.length !== referenceStr.length) {
      return false;
    }
    for (let i = 0;i < testStr.length; i++) {
      const referenceCode = referenceStr.charCodeAt(i);
      let testCode = testStr.charCodeAt(i);
      if (testCode >= 65 && testCode <= 90) {
        testCode = testCode | 32;
      }
      if (testCode !== referenceCode) {
        return false;
      }
    }
    return true;
  }
  function isContextEdgeDelim(token) {
    if (token.type !== types.Delim) {
      return false;
    }
    return token.value !== "?";
  }
  function isCommaContextStart(token) {
    if (token === null) {
      return true;
    }
    return token.type === types.Comma || token.type === types.Function || token.type === types.LeftParenthesis || token.type === types.LeftSquareBracket || token.type === types.LeftCurlyBracket || isContextEdgeDelim(token);
  }
  function isCommaContextEnd(token) {
    if (token === null) {
      return true;
    }
    return token.type === types.RightParenthesis || token.type === types.RightSquareBracket || token.type === types.RightCurlyBracket || token.type === types.Delim && token.value === "/";
  }
  function internalMatch(tokens, state, syntaxes) {
    function moveToNextToken() {
      do {
        tokenIndex++;
        token = tokenIndex < tokens.length ? tokens[tokenIndex] : null;
      } while (token !== null && (token.type === types.WhiteSpace || token.type === types.Comment));
    }
    function getNextToken(offset) {
      const nextIndex = tokenIndex + offset;
      return nextIndex < tokens.length ? tokens[nextIndex] : null;
    }
    function stateSnapshotFromSyntax(nextState, prev) {
      return {
        nextState,
        matchStack,
        syntaxStack,
        thenStack,
        tokenIndex,
        prev
      };
    }
    function pushThenStack(nextState) {
      thenStack = {
        nextState,
        matchStack,
        syntaxStack,
        prev: thenStack
      };
    }
    function pushElseStack(nextState) {
      elseStack = stateSnapshotFromSyntax(nextState, elseStack);
    }
    function addTokenToMatch() {
      matchStack = {
        type: TOKEN,
        syntax: state.syntax,
        token,
        prev: matchStack
      };
      moveToNextToken();
      syntaxStash = null;
      if (tokenIndex > longestMatch) {
        longestMatch = tokenIndex;
      }
    }
    function openSyntax() {
      syntaxStack = {
        syntax: state.syntax,
        opts: state.syntax.opts || syntaxStack !== null && syntaxStack.opts || null,
        prev: syntaxStack
      };
      matchStack = {
        type: OPEN_SYNTAX,
        syntax: state.syntax,
        token: matchStack.token,
        prev: matchStack
      };
    }
    function closeSyntax() {
      if (matchStack.type === OPEN_SYNTAX) {
        matchStack = matchStack.prev;
      } else {
        matchStack = {
          type: CLOSE_SYNTAX,
          syntax: syntaxStack.syntax,
          token: matchStack.token,
          prev: matchStack
        };
      }
      syntaxStack = syntaxStack.prev;
    }
    let syntaxStack = null;
    let thenStack = null;
    let elseStack = null;
    let syntaxStash = null;
    let iterationCount = 0;
    let exitReason = null;
    let token = null;
    let tokenIndex = -1;
    let longestMatch = 0;
    let matchStack = {
      type: STUB,
      syntax: null,
      token: null,
      prev: null
    };
    moveToNextToken();
    while (exitReason === null && ++iterationCount < ITERATION_LIMIT) {
      switch (state.type) {
        case "Match":
          if (thenStack === null) {
            if (token !== null) {
              if (tokenIndex !== tokens.length - 1 || token.value !== "\\0" && token.value !== "\\9") {
                state = matchGraph.MISMATCH;
                break;
              }
            }
            exitReason = EXIT_REASON_MATCH;
            break;
          }
          state = thenStack.nextState;
          if (state === matchGraph.DISALLOW_EMPTY) {
            if (thenStack.matchStack === matchStack) {
              state = matchGraph.MISMATCH;
              break;
            } else {
              state = matchGraph.MATCH;
            }
          }
          while (thenStack.syntaxStack !== syntaxStack) {
            closeSyntax();
          }
          thenStack = thenStack.prev;
          break;
        case "Mismatch":
          if (syntaxStash !== null && syntaxStash !== false) {
            if (elseStack === null || tokenIndex > elseStack.tokenIndex) {
              elseStack = syntaxStash;
              syntaxStash = false;
            }
          } else if (elseStack === null) {
            exitReason = EXIT_REASON_MISMATCH;
            break;
          }
          state = elseStack.nextState;
          thenStack = elseStack.thenStack;
          syntaxStack = elseStack.syntaxStack;
          matchStack = elseStack.matchStack;
          tokenIndex = elseStack.tokenIndex;
          token = tokenIndex < tokens.length ? tokens[tokenIndex] : null;
          elseStack = elseStack.prev;
          break;
        case "MatchGraph":
          state = state.match;
          break;
        case "If":
          if (state.else !== matchGraph.MISMATCH) {
            pushElseStack(state.else);
          }
          if (state.then !== matchGraph.MATCH) {
            pushThenStack(state.then);
          }
          state = state.match;
          break;
        case "MatchOnce":
          state = {
            type: "MatchOnceBuffer",
            syntax: state,
            index: 0,
            mask: 0
          };
          break;
        case "MatchOnceBuffer": {
          const terms = state.syntax.terms;
          if (state.index === terms.length) {
            if (state.mask === 0 || state.syntax.all) {
              state = matchGraph.MISMATCH;
              break;
            }
            state = matchGraph.MATCH;
            break;
          }
          if (state.mask === (1 << terms.length) - 1) {
            state = matchGraph.MATCH;
            break;
          }
          for (;state.index < terms.length; state.index++) {
            const matchFlag = 1 << state.index;
            if ((state.mask & matchFlag) === 0) {
              pushElseStack(state);
              pushThenStack({
                type: "AddMatchOnce",
                syntax: state.syntax,
                mask: state.mask | matchFlag
              });
              state = terms[state.index++];
              break;
            }
          }
          break;
        }
        case "AddMatchOnce":
          state = {
            type: "MatchOnceBuffer",
            syntax: state.syntax,
            index: 0,
            mask: state.mask
          };
          break;
        case "Enum":
          if (token !== null) {
            let name = token.value.toLowerCase();
            if (name.indexOf("\\") !== -1) {
              name = name.replace(/\\[09].*$/, "");
            }
            if (hasOwnProperty2.call(state.map, name)) {
              state = state.map[name];
              break;
            }
          }
          state = matchGraph.MISMATCH;
          break;
        case "Generic": {
          const opts = syntaxStack !== null ? syntaxStack.opts : null;
          const lastTokenIndex2 = tokenIndex + Math.floor(state.fn(token, getNextToken, opts));
          if (!isNaN(lastTokenIndex2) && lastTokenIndex2 > tokenIndex) {
            while (tokenIndex < lastTokenIndex2) {
              addTokenToMatch();
            }
            state = matchGraph.MATCH;
          } else {
            state = matchGraph.MISMATCH;
          }
          break;
        }
        case "Type":
        case "Property": {
          const syntaxDict = state.type === "Type" ? "types" : "properties";
          const dictSyntax = hasOwnProperty2.call(syntaxes, syntaxDict) ? syntaxes[syntaxDict][state.name] : null;
          if (!dictSyntax || !dictSyntax.match) {
            throw new Error("Bad syntax reference: " + (state.type === "Type" ? "<" + state.name + ">" : "<'" + state.name + "'>"));
          }
          if (syntaxStash !== false && token !== null && state.type === "Type") {
            const lowPriorityMatching = state.name === "custom-ident" && token.type === types.Ident || state.name === "length" && token.value === "0";
            if (lowPriorityMatching) {
              if (syntaxStash === null) {
                syntaxStash = stateSnapshotFromSyntax(state, elseStack);
              }
              state = matchGraph.MISMATCH;
              break;
            }
          }
          openSyntax();
          state = dictSyntax.match;
          break;
        }
        case "Keyword": {
          const name = state.name;
          if (token !== null) {
            let keywordName = token.value;
            if (keywordName.indexOf("\\") !== -1) {
              keywordName = keywordName.replace(/\\[09].*$/, "");
            }
            if (areStringsEqualCaseInsensitive(keywordName, name)) {
              addTokenToMatch();
              state = matchGraph.MATCH;
              break;
            }
          }
          state = matchGraph.MISMATCH;
          break;
        }
        case "AtKeyword":
        case "Function":
          if (token !== null && areStringsEqualCaseInsensitive(token.value, state.name)) {
            addTokenToMatch();
            state = matchGraph.MATCH;
            break;
          }
          state = matchGraph.MISMATCH;
          break;
        case "Token":
          if (token !== null && token.value === state.value) {
            addTokenToMatch();
            state = matchGraph.MATCH;
            break;
          }
          state = matchGraph.MISMATCH;
          break;
        case "Comma":
          if (token !== null && token.type === types.Comma) {
            if (isCommaContextStart(matchStack.token)) {
              state = matchGraph.MISMATCH;
            } else {
              addTokenToMatch();
              state = isCommaContextEnd(token) ? matchGraph.MISMATCH : matchGraph.MATCH;
            }
          } else {
            state = isCommaContextStart(matchStack.token) || isCommaContextEnd(token) ? matchGraph.MATCH : matchGraph.MISMATCH;
          }
          break;
        case "String":
          let string = "";
          let lastTokenIndex = tokenIndex;
          for (;lastTokenIndex < tokens.length && string.length < state.value.length; lastTokenIndex++) {
            string += tokens[lastTokenIndex].value;
          }
          if (areStringsEqualCaseInsensitive(string, state.value)) {
            while (tokenIndex < lastTokenIndex) {
              addTokenToMatch();
            }
            state = matchGraph.MATCH;
          } else {
            state = matchGraph.MISMATCH;
          }
          break;
        default:
          throw new Error("Unknown node type: " + state.type);
      }
    }
    switch (exitReason) {
      case null:
        console.warn("[csstree-match] BREAK after " + ITERATION_LIMIT + " iterations");
        exitReason = EXIT_REASON_ITERATION_LIMIT;
        matchStack = null;
        break;
      case EXIT_REASON_MATCH:
        while (syntaxStack !== null) {
          closeSyntax();
        }
        break;
      default:
        matchStack = null;
    }
    return {
      tokens,
      reason: exitReason,
      iterations: iterationCount,
      match: matchStack,
      longestMatch
    };
  }
  function matchAsList(tokens, matchGraph2, syntaxes) {
    const matchResult = internalMatch(tokens, matchGraph2, syntaxes || {});
    if (matchResult.match !== null) {
      let item = reverseList(matchResult.match).prev;
      matchResult.match = [];
      while (item !== null) {
        switch (item.type) {
          case OPEN_SYNTAX:
          case CLOSE_SYNTAX:
            matchResult.match.push({
              type: item.type,
              syntax: item.syntax
            });
            break;
          default:
            matchResult.match.push({
              token: item.token.value,
              node: item.token.node
            });
            break;
        }
        item = item.prev;
      }
    }
    return matchResult;
  }
  function matchAsTree(tokens, matchGraph2, syntaxes) {
    const matchResult = internalMatch(tokens, matchGraph2, syntaxes || {});
    if (matchResult.match === null) {
      return matchResult;
    }
    let item = matchResult.match;
    let host = matchResult.match = {
      syntax: matchGraph2.syntax || null,
      match: []
    };
    const hostStack = [host];
    item = reverseList(item).prev;
    while (item !== null) {
      switch (item.type) {
        case OPEN_SYNTAX:
          host.match.push(host = {
            syntax: item.syntax,
            match: []
          });
          hostStack.push(host);
          break;
        case CLOSE_SYNTAX:
          hostStack.pop();
          host = hostStack[hostStack.length - 1];
          break;
        default:
          host.match.push({
            syntax: item.syntax || null,
            token: item.token.value,
            node: item.token.node
          });
      }
      item = item.prev;
    }
    return matchResult;
  }
  exports.matchAsList = matchAsList;
  exports.matchAsTree = matchAsTree;
});

// ../../../../node_modules/.bun/css-tree@2.3.1/node_modules/css-tree/cjs/lexer/trace.cjs
var require_trace = __commonJS((exports) => {
  function getTrace(node) {
    function shouldPutToTrace(syntax) {
      if (syntax === null) {
        return false;
      }
      return syntax.type === "Type" || syntax.type === "Property" || syntax.type === "Keyword";
    }
    function hasMatch(matchNode) {
      if (Array.isArray(matchNode.match)) {
        for (let i = 0;i < matchNode.match.length; i++) {
          if (hasMatch(matchNode.match[i])) {
            if (shouldPutToTrace(matchNode.syntax)) {
              result.unshift(matchNode.syntax);
            }
            return true;
          }
        }
      } else if (matchNode.node === node) {
        result = shouldPutToTrace(matchNode.syntax) ? [matchNode.syntax] : [];
        return true;
      }
      return false;
    }
    let result = null;
    if (this.matched !== null) {
      hasMatch(this.matched);
    }
    return result;
  }
  function isType(node, type) {
    return testNode(this, node, (match) => match.type === "Type" && match.name === type);
  }
  function isProperty(node, property) {
    return testNode(this, node, (match) => match.type === "Property" && match.name === property);
  }
  function isKeyword(node) {
    return testNode(this, node, (match) => match.type === "Keyword");
  }
  function testNode(match, node, fn) {
    const trace = getTrace.call(match, node);
    if (trace === null) {
      return false;
    }
    return trace.some(fn);
  }
  exports.getTrace = getTrace;
  exports.isKeyword = isKeyword;
  exports.isProperty = isProperty;
  exports.isType = isType;
});

// ../../../../node_modules/.bun/css-tree@2.3.1/node_modules/css-tree/cjs/lexer/search.cjs
var require_search = __commonJS((exports) => {
  var List = require_List();
  function getFirstMatchNode(matchNode) {
    if ("node" in matchNode) {
      return matchNode.node;
    }
    return getFirstMatchNode(matchNode.match[0]);
  }
  function getLastMatchNode(matchNode) {
    if ("node" in matchNode) {
      return matchNode.node;
    }
    return getLastMatchNode(matchNode.match[matchNode.match.length - 1]);
  }
  function matchFragments(lexer, ast, match, type, name) {
    function findFragments(matchNode) {
      if (matchNode.syntax !== null && matchNode.syntax.type === type && matchNode.syntax.name === name) {
        const start = getFirstMatchNode(matchNode);
        const end = getLastMatchNode(matchNode);
        lexer.syntax.walk(ast, function(node, item, list) {
          if (node === start) {
            const nodes = new List.List;
            do {
              nodes.appendData(item.data);
              if (item.data === end) {
                break;
              }
              item = item.next;
            } while (item !== null);
            fragments.push({
              parent: list,
              nodes
            });
          }
        });
      }
      if (Array.isArray(matchNode.match)) {
        matchNode.match.forEach(findFragments);
      }
    }
    const fragments = [];
    if (match.matched !== null) {
      findFragments(match.matched);
    }
    return fragments;
  }
  exports.matchFragments = matchFragments;
});

// ../../../../node_modules/.bun/css-tree@2.3.1/node_modules/css-tree/cjs/lexer/structure.cjs
var require_structure = __commonJS((exports) => {
  var List = require_List();
  var { hasOwnProperty: hasOwnProperty2 } = Object.prototype;
  function isValidNumber(value) {
    return typeof value === "number" && isFinite(value) && Math.floor(value) === value && value >= 0;
  }
  function isValidLocation(loc) {
    return Boolean(loc) && isValidNumber(loc.offset) && isValidNumber(loc.line) && isValidNumber(loc.column);
  }
  function createNodeStructureChecker(type, fields) {
    return function checkNode(node, warn) {
      if (!node || node.constructor !== Object) {
        return warn(node, "Type of node should be an Object");
      }
      for (let key in node) {
        let valid = true;
        if (hasOwnProperty2.call(node, key) === false) {
          continue;
        }
        if (key === "type") {
          if (node.type !== type) {
            warn(node, "Wrong node type `" + node.type + "`, expected `" + type + "`");
          }
        } else if (key === "loc") {
          if (node.loc === null) {
            continue;
          } else if (node.loc && node.loc.constructor === Object) {
            if (typeof node.loc.source !== "string") {
              key += ".source";
            } else if (!isValidLocation(node.loc.start)) {
              key += ".start";
            } else if (!isValidLocation(node.loc.end)) {
              key += ".end";
            } else {
              continue;
            }
          }
          valid = false;
        } else if (fields.hasOwnProperty(key)) {
          valid = false;
          for (let i = 0;!valid && i < fields[key].length; i++) {
            const fieldType = fields[key][i];
            switch (fieldType) {
              case String:
                valid = typeof node[key] === "string";
                break;
              case Boolean:
                valid = typeof node[key] === "boolean";
                break;
              case null:
                valid = node[key] === null;
                break;
              default:
                if (typeof fieldType === "string") {
                  valid = node[key] && node[key].type === fieldType;
                } else if (Array.isArray(fieldType)) {
                  valid = node[key] instanceof List.List;
                }
            }
          }
        } else {
          warn(node, "Unknown field `" + key + "` for " + type + " node type");
        }
        if (!valid) {
          warn(node, "Bad value for `" + type + "." + key + "`");
        }
      }
      for (const key in fields) {
        if (hasOwnProperty2.call(fields, key) && hasOwnProperty2.call(node, key) === false) {
          warn(node, "Field `" + type + "." + key + "` is missed");
        }
      }
    };
  }
  function processStructure(name, nodeType) {
    const structure = nodeType.structure;
    const fields = {
      type: String,
      loc: true
    };
    const docs = {
      type: '"' + name + '"'
    };
    for (const key in structure) {
      if (hasOwnProperty2.call(structure, key) === false) {
        continue;
      }
      const docsTypes = [];
      const fieldTypes = fields[key] = Array.isArray(structure[key]) ? structure[key].slice() : [structure[key]];
      for (let i = 0;i < fieldTypes.length; i++) {
        const fieldType = fieldTypes[i];
        if (fieldType === String || fieldType === Boolean) {
          docsTypes.push(fieldType.name);
        } else if (fieldType === null) {
          docsTypes.push("null");
        } else if (typeof fieldType === "string") {
          docsTypes.push("<" + fieldType + ">");
        } else if (Array.isArray(fieldType)) {
          docsTypes.push("List");
        } else {
          throw new Error("Wrong value `" + fieldType + "` in `" + name + "." + key + "` structure definition");
        }
      }
      docs[key] = docsTypes.join(" | ");
    }
    return {
      docs,
      check: createNodeStructureChecker(name, fields)
    };
  }
  function getStructureFromConfig(config) {
    const structure = {};
    if (config.node) {
      for (const name in config.node) {
        if (hasOwnProperty2.call(config.node, name)) {
          const nodeType = config.node[name];
          if (nodeType.structure) {
            structure[name] = processStructure(name, nodeType);
          } else {
            throw new Error("Missed `structure` field in `" + name + "` node type definition");
          }
        }
      }
    }
    return structure;
  }
  exports.getStructureFromConfig = getStructureFromConfig;
});

// ../../../../node_modules/.bun/css-tree@2.3.1/node_modules/css-tree/cjs/definition-syntax/walk.cjs
var require_walk = __commonJS((exports) => {
  var noop = function() {};
  function ensureFunction(value) {
    return typeof value === "function" ? value : noop;
  }
  function walk(node, options, context) {
    function walk2(node2) {
      enter.call(context, node2);
      switch (node2.type) {
        case "Group":
          node2.terms.forEach(walk2);
          break;
        case "Multiplier":
          walk2(node2.term);
          break;
        case "Type":
        case "Property":
        case "Keyword":
        case "AtKeyword":
        case "Function":
        case "String":
        case "Token":
        case "Comma":
          break;
        default:
          throw new Error("Unknown type: " + node2.type);
      }
      leave.call(context, node2);
    }
    let enter = noop;
    let leave = noop;
    if (typeof options === "function") {
      enter = options;
    } else if (options) {
      enter = ensureFunction(options.enter);
      leave = ensureFunction(options.leave);
    }
    if (enter === noop && leave === noop) {
      throw new Error("Neither `enter` nor `leave` walker handler is set or both aren't a function");
    }
    walk2(node);
  }
  exports.walk = walk;
});

// ../../../../node_modules/.bun/css-tree@2.3.1/node_modules/css-tree/cjs/lexer/Lexer.cjs
var require_Lexer = __commonJS((exports) => {
  var error = require_error();
  var names = require_names2();
  var genericConst = require_generic_const();
  var generic = require_generic();
  var units = require_units();
  var prepareTokens = require_prepare_tokens();
  var matchGraph = require_match_graph();
  var match = require_match();
  var trace = require_trace();
  var search = require_search();
  var structure = require_structure();
  var parse = require_parse3();
  var generate = require_generate();
  var walk = require_walk();
  var cssWideKeywordsSyntax = matchGraph.buildMatchGraph(genericConst.cssWideKeywords.join(" | "));
  function dumpMapSyntax(map, compact, syntaxAsAst) {
    const result = {};
    for (const name in map) {
      if (map[name].syntax) {
        result[name] = syntaxAsAst ? map[name].syntax : generate.generate(map[name].syntax, { compact });
      }
    }
    return result;
  }
  function dumpAtruleMapSyntax(map, compact, syntaxAsAst) {
    const result = {};
    for (const [name, atrule] of Object.entries(map)) {
      result[name] = {
        prelude: atrule.prelude && (syntaxAsAst ? atrule.prelude.syntax : generate.generate(atrule.prelude.syntax, { compact })),
        descriptors: atrule.descriptors && dumpMapSyntax(atrule.descriptors, compact, syntaxAsAst)
      };
    }
    return result;
  }
  function valueHasVar(tokens) {
    for (let i = 0;i < tokens.length; i++) {
      if (tokens[i].value.toLowerCase() === "var(") {
        return true;
      }
    }
    return false;
  }
  function buildMatchResult(matched, error2, iterations) {
    return {
      matched,
      iterations,
      error: error2,
      ...trace
    };
  }
  function matchSyntax(lexer, syntax, value, useCssWideKeywords) {
    const tokens = prepareTokens(value, lexer.syntax);
    let result;
    if (valueHasVar(tokens)) {
      return buildMatchResult(null, new Error("Matching for a tree with var() is not supported"));
    }
    if (useCssWideKeywords) {
      result = match.matchAsTree(tokens, lexer.cssWideKeywordsSyntax, lexer);
    }
    if (!useCssWideKeywords || !result.match) {
      result = match.matchAsTree(tokens, syntax.match, lexer);
      if (!result.match) {
        return buildMatchResult(null, new error.SyntaxMatchError(result.reason, syntax.syntax, value, result), result.iterations);
      }
    }
    return buildMatchResult(result.match, null, result.iterations);
  }

  class Lexer {
    constructor(config, syntax, structure$1) {
      this.cssWideKeywordsSyntax = cssWideKeywordsSyntax;
      this.syntax = syntax;
      this.generic = false;
      this.units = { ...units };
      this.atrules = Object.create(null);
      this.properties = Object.create(null);
      this.types = Object.create(null);
      this.structure = structure$1 || structure.getStructureFromConfig(config);
      if (config) {
        if (config.units) {
          for (const group of Object.keys(units)) {
            if (Array.isArray(config.units[group])) {
              this.units[group] = config.units[group];
            }
          }
        }
        if (config.types) {
          for (const name in config.types) {
            this.addType_(name, config.types[name]);
          }
        }
        if (config.generic) {
          this.generic = true;
          for (const [name, value] of Object.entries(generic.createGenericTypes(this.units))) {
            this.addType_(name, value);
          }
        }
        if (config.atrules) {
          for (const name in config.atrules) {
            this.addAtrule_(name, config.atrules[name]);
          }
        }
        if (config.properties) {
          for (const name in config.properties) {
            this.addProperty_(name, config.properties[name]);
          }
        }
      }
    }
    checkStructure(ast) {
      function collectWarning(node, message) {
        warns.push({ node, message });
      }
      const structure2 = this.structure;
      const warns = [];
      this.syntax.walk(ast, function(node) {
        if (structure2.hasOwnProperty(node.type)) {
          structure2[node.type].check(node, collectWarning);
        } else {
          collectWarning(node, "Unknown node type `" + node.type + "`");
        }
      });
      return warns.length ? warns : false;
    }
    createDescriptor(syntax, type, name, parent = null) {
      const ref = {
        type,
        name
      };
      const descriptor = {
        type,
        name,
        parent,
        serializable: typeof syntax === "string" || syntax && typeof syntax.type === "string",
        syntax: null,
        match: null
      };
      if (typeof syntax === "function") {
        descriptor.match = matchGraph.buildMatchGraph(syntax, ref);
      } else {
        if (typeof syntax === "string") {
          Object.defineProperty(descriptor, "syntax", {
            get() {
              Object.defineProperty(descriptor, "syntax", {
                value: parse.parse(syntax)
              });
              return descriptor.syntax;
            }
          });
        } else {
          descriptor.syntax = syntax;
        }
        Object.defineProperty(descriptor, "match", {
          get() {
            Object.defineProperty(descriptor, "match", {
              value: matchGraph.buildMatchGraph(descriptor.syntax, ref)
            });
            return descriptor.match;
          }
        });
      }
      return descriptor;
    }
    addAtrule_(name, syntax) {
      if (!syntax) {
        return;
      }
      this.atrules[name] = {
        type: "Atrule",
        name,
        prelude: syntax.prelude ? this.createDescriptor(syntax.prelude, "AtrulePrelude", name) : null,
        descriptors: syntax.descriptors ? Object.keys(syntax.descriptors).reduce((map, descName) => {
          map[descName] = this.createDescriptor(syntax.descriptors[descName], "AtruleDescriptor", descName, name);
          return map;
        }, Object.create(null)) : null
      };
    }
    addProperty_(name, syntax) {
      if (!syntax) {
        return;
      }
      this.properties[name] = this.createDescriptor(syntax, "Property", name);
    }
    addType_(name, syntax) {
      if (!syntax) {
        return;
      }
      this.types[name] = this.createDescriptor(syntax, "Type", name);
    }
    checkAtruleName(atruleName) {
      if (!this.getAtrule(atruleName)) {
        return new error.SyntaxReferenceError("Unknown at-rule", "@" + atruleName);
      }
    }
    checkAtrulePrelude(atruleName, prelude) {
      const error2 = this.checkAtruleName(atruleName);
      if (error2) {
        return error2;
      }
      const atrule = this.getAtrule(atruleName);
      if (!atrule.prelude && prelude) {
        return new SyntaxError("At-rule `@" + atruleName + "` should not contain a prelude");
      }
      if (atrule.prelude && !prelude) {
        if (!matchSyntax(this, atrule.prelude, "", false).matched) {
          return new SyntaxError("At-rule `@" + atruleName + "` should contain a prelude");
        }
      }
    }
    checkAtruleDescriptorName(atruleName, descriptorName) {
      const error$1 = this.checkAtruleName(atruleName);
      if (error$1) {
        return error$1;
      }
      const atrule = this.getAtrule(atruleName);
      const descriptor = names.keyword(descriptorName);
      if (!atrule.descriptors) {
        return new SyntaxError("At-rule `@" + atruleName + "` has no known descriptors");
      }
      if (!atrule.descriptors[descriptor.name] && !atrule.descriptors[descriptor.basename]) {
        return new error.SyntaxReferenceError("Unknown at-rule descriptor", descriptorName);
      }
    }
    checkPropertyName(propertyName) {
      if (!this.getProperty(propertyName)) {
        return new error.SyntaxReferenceError("Unknown property", propertyName);
      }
    }
    matchAtrulePrelude(atruleName, prelude) {
      const error2 = this.checkAtrulePrelude(atruleName, prelude);
      if (error2) {
        return buildMatchResult(null, error2);
      }
      const atrule = this.getAtrule(atruleName);
      if (!atrule.prelude) {
        return buildMatchResult(null, null);
      }
      return matchSyntax(this, atrule.prelude, prelude || "", false);
    }
    matchAtruleDescriptor(atruleName, descriptorName, value) {
      const error2 = this.checkAtruleDescriptorName(atruleName, descriptorName);
      if (error2) {
        return buildMatchResult(null, error2);
      }
      const atrule = this.getAtrule(atruleName);
      const descriptor = names.keyword(descriptorName);
      return matchSyntax(this, atrule.descriptors[descriptor.name] || atrule.descriptors[descriptor.basename], value, false);
    }
    matchDeclaration(node) {
      if (node.type !== "Declaration") {
        return buildMatchResult(null, new Error("Not a Declaration node"));
      }
      return this.matchProperty(node.property, node.value);
    }
    matchProperty(propertyName, value) {
      if (names.property(propertyName).custom) {
        return buildMatchResult(null, new Error("Lexer matching doesn't applicable for custom properties"));
      }
      const error2 = this.checkPropertyName(propertyName);
      if (error2) {
        return buildMatchResult(null, error2);
      }
      return matchSyntax(this, this.getProperty(propertyName), value, true);
    }
    matchType(typeName, value) {
      const typeSyntax = this.getType(typeName);
      if (!typeSyntax) {
        return buildMatchResult(null, new error.SyntaxReferenceError("Unknown type", typeName));
      }
      return matchSyntax(this, typeSyntax, value, false);
    }
    match(syntax, value) {
      if (typeof syntax !== "string" && (!syntax || !syntax.type)) {
        return buildMatchResult(null, new error.SyntaxReferenceError("Bad syntax"));
      }
      if (typeof syntax === "string" || !syntax.match) {
        syntax = this.createDescriptor(syntax, "Type", "anonymous");
      }
      return matchSyntax(this, syntax, value, false);
    }
    findValueFragments(propertyName, value, type, name) {
      return search.matchFragments(this, value, this.matchProperty(propertyName, value), type, name);
    }
    findDeclarationValueFragments(declaration, type, name) {
      return search.matchFragments(this, declaration.value, this.matchDeclaration(declaration), type, name);
    }
    findAllFragments(ast, type, name) {
      const result = [];
      this.syntax.walk(ast, {
        visit: "Declaration",
        enter: (declaration) => {
          result.push.apply(result, this.findDeclarationValueFragments(declaration, type, name));
        }
      });
      return result;
    }
    getAtrule(atruleName, fallbackBasename = true) {
      const atrule = names.keyword(atruleName);
      const atruleEntry = atrule.vendor && fallbackBasename ? this.atrules[atrule.name] || this.atrules[atrule.basename] : this.atrules[atrule.name];
      return atruleEntry || null;
    }
    getAtrulePrelude(atruleName, fallbackBasename = true) {
      const atrule = this.getAtrule(atruleName, fallbackBasename);
      return atrule && atrule.prelude || null;
    }
    getAtruleDescriptor(atruleName, name) {
      return this.atrules.hasOwnProperty(atruleName) && this.atrules.declarators ? this.atrules[atruleName].declarators[name] || null : null;
    }
    getProperty(propertyName, fallbackBasename = true) {
      const property = names.property(propertyName);
      const propertyEntry = property.vendor && fallbackBasename ? this.properties[property.name] || this.properties[property.basename] : this.properties[property.name];
      return propertyEntry || null;
    }
    getType(name) {
      return hasOwnProperty.call(this.types, name) ? this.types[name] : null;
    }
    validate() {
      function validate(syntax, name, broken, descriptor) {
        if (broken.has(name)) {
          return broken.get(name);
        }
        broken.set(name, false);
        if (descriptor.syntax !== null) {
          walk.walk(descriptor.syntax, function(node) {
            if (node.type !== "Type" && node.type !== "Property") {
              return;
            }
            const map = node.type === "Type" ? syntax.types : syntax.properties;
            const brokenMap = node.type === "Type" ? brokenTypes : brokenProperties;
            if (!hasOwnProperty.call(map, node.name) || validate(syntax, node.name, brokenMap, map[node.name])) {
              broken.set(name, true);
            }
          }, this);
        }
      }
      let brokenTypes = new Map;
      let brokenProperties = new Map;
      for (const key in this.types) {
        validate(this, key, brokenTypes, this.types[key]);
      }
      for (const key in this.properties) {
        validate(this, key, brokenProperties, this.properties[key]);
      }
      brokenTypes = [...brokenTypes.keys()].filter((name) => brokenTypes.get(name));
      brokenProperties = [...brokenProperties.keys()].filter((name) => brokenProperties.get(name));
      if (brokenTypes.length || brokenProperties.length) {
        return {
          types: brokenTypes,
          properties: brokenProperties
        };
      }
      return null;
    }
    dump(syntaxAsAst, pretty) {
      return {
        generic: this.generic,
        units: this.units,
        types: dumpMapSyntax(this.types, !pretty, syntaxAsAst),
        properties: dumpMapSyntax(this.properties, !pretty, syntaxAsAst),
        atrules: dumpAtruleMapSyntax(this.atrules, !pretty, syntaxAsAst)
      };
    }
    toString() {
      return JSON.stringify(this.dump());
    }
  }
  exports.Lexer = Lexer;
});

// ../../../../node_modules/.bun/css-tree@2.3.1/node_modules/css-tree/cjs/syntax/config/mix.cjs
var require_mix = __commonJS((exports, module) => {
  function appendOrSet(a, b) {
    if (typeof b === "string" && /^\s*\|/.test(b)) {
      return typeof a === "string" ? a + b : b.replace(/^\s*\|\s*/, "");
    }
    return b || null;
  }
  function sliceProps(obj, props) {
    const result = Object.create(null);
    for (const [key, value] of Object.entries(obj)) {
      if (value) {
        result[key] = {};
        for (const prop of Object.keys(value)) {
          if (props.includes(prop)) {
            result[key][prop] = value[prop];
          }
        }
      }
    }
    return result;
  }
  function mix(dest, src) {
    const result = { ...dest };
    for (const [prop, value] of Object.entries(src)) {
      switch (prop) {
        case "generic":
          result[prop] = Boolean(value);
          break;
        case "units":
          result[prop] = { ...dest[prop] };
          for (const [name, patch] of Object.entries(value)) {
            result[prop][name] = Array.isArray(patch) ? patch : [];
          }
          break;
        case "atrules":
          result[prop] = { ...dest[prop] };
          for (const [name, atrule] of Object.entries(value)) {
            const exists = result[prop][name] || {};
            const current = result[prop][name] = {
              prelude: exists.prelude || null,
              descriptors: {
                ...exists.descriptors
              }
            };
            if (!atrule) {
              continue;
            }
            current.prelude = atrule.prelude ? appendOrSet(current.prelude, atrule.prelude) : current.prelude || null;
            for (const [descriptorName, descriptorValue] of Object.entries(atrule.descriptors || {})) {
              current.descriptors[descriptorName] = descriptorValue ? appendOrSet(current.descriptors[descriptorName], descriptorValue) : null;
            }
            if (!Object.keys(current.descriptors).length) {
              current.descriptors = null;
            }
          }
          break;
        case "types":
        case "properties":
          result[prop] = { ...dest[prop] };
          for (const [name, syntax] of Object.entries(value)) {
            result[prop][name] = appendOrSet(result[prop][name], syntax);
          }
          break;
        case "scope":
          result[prop] = { ...dest[prop] };
          for (const [name, props] of Object.entries(value)) {
            result[prop][name] = { ...result[prop][name], ...props };
          }
          break;
        case "parseContext":
          result[prop] = {
            ...dest[prop],
            ...value
          };
          break;
        case "atrule":
        case "pseudo":
          result[prop] = {
            ...dest[prop],
            ...sliceProps(value, ["parse"])
          };
          break;
        case "node":
          result[prop] = {
            ...dest[prop],
            ...sliceProps(value, ["name", "structure", "parse", "generate", "walkContext"])
          };
          break;
      }
    }
    return result;
  }
  module.exports = mix;
});

// ../../../../node_modules/.bun/css-tree@2.3.1/node_modules/css-tree/cjs/syntax/create.cjs
var require_create5 = __commonJS((exports, module) => {
  var index = require_tokenizer();
  var create = require_create();
  var create$2 = require_create2();
  var create$3 = require_create3();
  var create$1 = require_create4();
  var Lexer = require_Lexer();
  var mix = require_mix();
  function createSyntax(config) {
    const parse = create.createParser(config);
    const walk = create$1.createWalker(config);
    const generate = create$2.createGenerator(config);
    const { fromPlainObject, toPlainObject } = create$3.createConvertor(walk);
    const syntax = {
      lexer: null,
      createLexer: (config2) => new Lexer.Lexer(config2, syntax, syntax.lexer.structure),
      tokenize: index.tokenize,
      parse,
      generate,
      walk,
      find: walk.find,
      findLast: walk.findLast,
      findAll: walk.findAll,
      fromPlainObject,
      toPlainObject,
      fork(extension) {
        const base = mix({}, config);
        return createSyntax(typeof extension === "function" ? extension(base, Object.assign) : mix(base, extension));
      }
    };
    syntax.lexer = new Lexer.Lexer({
      generic: true,
      units: config.units,
      types: config.types,
      atrules: config.atrules,
      properties: config.properties,
      node: config.node
    }, syntax);
    return syntax;
  }
  var createSyntax$1 = (config) => createSyntax(mix({}, config));
  module.exports = createSyntax$1;
});

// ../../../../node_modules/.bun/css-tree@2.3.1/node_modules/css-tree/data/patch.json
var require_patch = __commonJS((exports, module) => {
  module.exports = {
    atrules: {
      charset: {
        prelude: "<string>"
      },
      "font-face": {
        descriptors: {
          "unicode-range": {
            comment: "replaces <unicode-range>, an old production name",
            syntax: "<urange>#"
          }
        }
      },
      nest: {
        prelude: "<complex-selector-list>"
      }
    },
    properties: {
      "-moz-background-clip": {
        comment: "deprecated syntax in old Firefox, https://developer.mozilla.org/en/docs/Web/CSS/background-clip",
        syntax: "padding | border"
      },
      "-moz-border-radius-bottomleft": {
        comment: "https://developer.mozilla.org/en-US/docs/Web/CSS/border-bottom-left-radius",
        syntax: "<'border-bottom-left-radius'>"
      },
      "-moz-border-radius-bottomright": {
        comment: "https://developer.mozilla.org/en-US/docs/Web/CSS/border-bottom-right-radius",
        syntax: "<'border-bottom-right-radius'>"
      },
      "-moz-border-radius-topleft": {
        comment: "https://developer.mozilla.org/en-US/docs/Web/CSS/border-top-left-radius",
        syntax: "<'border-top-left-radius'>"
      },
      "-moz-border-radius-topright": {
        comment: "https://developer.mozilla.org/en-US/docs/Web/CSS/border-bottom-right-radius",
        syntax: "<'border-bottom-right-radius'>"
      },
      "-moz-control-character-visibility": {
        comment: "firefox specific keywords, https://bugzilla.mozilla.org/show_bug.cgi?id=947588",
        syntax: "visible | hidden"
      },
      "-moz-osx-font-smoothing": {
        comment: "misssed old syntax https://developer.mozilla.org/en-US/docs/Web/CSS/font-smooth",
        syntax: "auto | grayscale"
      },
      "-moz-user-select": {
        comment: "https://developer.mozilla.org/en-US/docs/Web/CSS/user-select",
        syntax: "none | text | all | -moz-none"
      },
      "-ms-flex-align": {
        comment: "misssed old syntax implemented in IE, https://www.w3.org/TR/2012/WD-css3-flexbox-20120322/#flex-align",
        syntax: "start | end | center | baseline | stretch"
      },
      "-ms-flex-item-align": {
        comment: "misssed old syntax implemented in IE, https://www.w3.org/TR/2012/WD-css3-flexbox-20120322/#flex-align",
        syntax: "auto | start | end | center | baseline | stretch"
      },
      "-ms-flex-line-pack": {
        comment: "misssed old syntax implemented in IE, https://www.w3.org/TR/2012/WD-css3-flexbox-20120322/#flex-line-pack",
        syntax: "start | end | center | justify | distribute | stretch"
      },
      "-ms-flex-negative": {
        comment: "misssed old syntax implemented in IE; TODO: find references for comfirmation",
        syntax: "<'flex-shrink'>"
      },
      "-ms-flex-pack": {
        comment: "misssed old syntax implemented in IE, https://www.w3.org/TR/2012/WD-css3-flexbox-20120322/#flex-pack",
        syntax: "start | end | center | justify | distribute"
      },
      "-ms-flex-order": {
        comment: "misssed old syntax implemented in IE; https://msdn.microsoft.com/en-us/library/jj127303(v=vs.85).aspx",
        syntax: "<integer>"
      },
      "-ms-flex-positive": {
        comment: "misssed old syntax implemented in IE; TODO: find references for comfirmation",
        syntax: "<'flex-grow'>"
      },
      "-ms-flex-preferred-size": {
        comment: "misssed old syntax implemented in IE; TODO: find references for comfirmation",
        syntax: "<'flex-basis'>"
      },
      "-ms-interpolation-mode": {
        comment: "https://msdn.microsoft.com/en-us/library/ff521095(v=vs.85).aspx",
        syntax: "nearest-neighbor | bicubic"
      },
      "-ms-grid-column-align": {
        comment: "add this property first since it uses as fallback for flexbox, https://msdn.microsoft.com/en-us/library/windows/apps/hh466338.aspx",
        syntax: "start | end | center | stretch"
      },
      "-ms-grid-row-align": {
        comment: "add this property first since it uses as fallback for flexbox, https://msdn.microsoft.com/en-us/library/windows/apps/hh466348.aspx",
        syntax: "start | end | center | stretch"
      },
      "-ms-hyphenate-limit-last": {
        comment: "misssed old syntax implemented in IE; https://www.w3.org/TR/css-text-4/#hyphenate-line-limits",
        syntax: "none | always | column | page | spread"
      },
      "-webkit-appearance": {
        comment: "webkit specific keywords",
        references: [
          "http://css-infos.net/property/-webkit-appearance"
        ],
        syntax: "none | button | button-bevel | caps-lock-indicator | caret | checkbox | default-button | inner-spin-button | listbox | listitem | media-controls-background | media-controls-fullscreen-background | media-current-time-display | media-enter-fullscreen-button | media-exit-fullscreen-button | media-fullscreen-button | media-mute-button | media-overlay-play-button | media-play-button | media-seek-back-button | media-seek-forward-button | media-slider | media-sliderthumb | media-time-remaining-display | media-toggle-closed-captions-button | media-volume-slider | media-volume-slider-container | media-volume-sliderthumb | menulist | menulist-button | menulist-text | menulist-textfield | meter | progress-bar | progress-bar-value | push-button | radio | scrollbarbutton-down | scrollbarbutton-left | scrollbarbutton-right | scrollbarbutton-up | scrollbargripper-horizontal | scrollbargripper-vertical | scrollbarthumb-horizontal | scrollbarthumb-vertical | scrollbartrack-horizontal | scrollbartrack-vertical | searchfield | searchfield-cancel-button | searchfield-decoration | searchfield-results-button | searchfield-results-decoration | slider-horizontal | slider-vertical | sliderthumb-horizontal | sliderthumb-vertical | square-button | textarea | textfield | -apple-pay-button"
      },
      "-webkit-background-clip": {
        comment: "https://developer.mozilla.org/en/docs/Web/CSS/background-clip",
        syntax: "[ <box> | border | padding | content | text ]#"
      },
      "-webkit-column-break-after": {
        comment: "added, http://help.dottoro.com/lcrthhhv.php",
        syntax: "always | auto | avoid"
      },
      "-webkit-column-break-before": {
        comment: "added, http://help.dottoro.com/lcxquvkf.php",
        syntax: "always | auto | avoid"
      },
      "-webkit-column-break-inside": {
        comment: "added, http://help.dottoro.com/lclhnthl.php",
        syntax: "always | auto | avoid"
      },
      "-webkit-font-smoothing": {
        comment: "https://developer.mozilla.org/en-US/docs/Web/CSS/font-smooth",
        syntax: "auto | none | antialiased | subpixel-antialiased"
      },
      "-webkit-mask-box-image": {
        comment: "missed; https://developer.mozilla.org/en-US/docs/Web/CSS/-webkit-mask-box-image",
        syntax: "[ <url> | <gradient> | none ] [ <length-percentage>{4} <-webkit-mask-box-repeat>{2} ]?"
      },
      "-webkit-print-color-adjust": {
        comment: "missed",
        references: [
          "https://developer.mozilla.org/en/docs/Web/CSS/-webkit-print-color-adjust"
        ],
        syntax: "economy | exact"
      },
      "-webkit-text-security": {
        comment: "missed; http://help.dottoro.com/lcbkewgt.php",
        syntax: "none | circle | disc | square"
      },
      "-webkit-user-drag": {
        comment: "missed; http://help.dottoro.com/lcbixvwm.php",
        syntax: "none | element | auto"
      },
      "-webkit-user-select": {
        comment: "auto is supported by old webkit, https://developer.mozilla.org/en-US/docs/Web/CSS/user-select",
        syntax: "auto | none | text | all"
      },
      "alignment-baseline": {
        comment: "added SVG property",
        references: [
          "https://www.w3.org/TR/SVG/text.html#AlignmentBaselineProperty"
        ],
        syntax: "auto | baseline | before-edge | text-before-edge | middle | central | after-edge | text-after-edge | ideographic | alphabetic | hanging | mathematical"
      },
      "background-clip": {
        comment: "used <bg-clip> from CSS Backgrounds and Borders 4 since it adds new values",
        references: [
          "https://github.com/csstree/csstree/issues/190"
        ],
        syntax: "<bg-clip>#"
      },
      "baseline-shift": {
        comment: "added SVG property",
        references: [
          "https://www.w3.org/TR/SVG/text.html#BaselineShiftProperty"
        ],
        syntax: "baseline | sub | super | <svg-length>"
      },
      behavior: {
        comment: "added old IE property https://msdn.microsoft.com/en-us/library/ms530723(v=vs.85).aspx",
        syntax: "<url>+"
      },
      "clip-rule": {
        comment: "added SVG property",
        references: [
          "https://www.w3.org/TR/SVG/masking.html#ClipRuleProperty"
        ],
        syntax: "nonzero | evenodd"
      },
      cue: {
        comment: "https://www.w3.org/TR/css3-speech/#property-index",
        syntax: "<'cue-before'> <'cue-after'>?"
      },
      "cue-after": {
        comment: "https://www.w3.org/TR/css3-speech/#property-index",
        syntax: "<url> <decibel>? | none"
      },
      "cue-before": {
        comment: "https://www.w3.org/TR/css3-speech/#property-index",
        syntax: "<url> <decibel>? | none"
      },
      cursor: {
        comment: "added legacy keywords: hand, -webkit-grab. -webkit-grabbing, -webkit-zoom-in, -webkit-zoom-out, -moz-grab, -moz-grabbing, -moz-zoom-in, -moz-zoom-out",
        references: [
          "https://www.sitepoint.com/css3-cursor-styles/"
        ],
        syntax: "[ [ <url> [ <x> <y> ]? , ]* [ auto | default | none | context-menu | help | pointer | progress | wait | cell | crosshair | text | vertical-text | alias | copy | move | no-drop | not-allowed | e-resize | n-resize | ne-resize | nw-resize | s-resize | se-resize | sw-resize | w-resize | ew-resize | ns-resize | nesw-resize | nwse-resize | col-resize | row-resize | all-scroll | zoom-in | zoom-out | grab | grabbing | hand | -webkit-grab | -webkit-grabbing | -webkit-zoom-in | -webkit-zoom-out | -moz-grab | -moz-grabbing | -moz-zoom-in | -moz-zoom-out ] ]"
      },
      display: {
        comment: "extended with -ms-flexbox",
        syntax: "| <-non-standard-display>"
      },
      position: {
        comment: "extended with -webkit-sticky",
        syntax: "| -webkit-sticky"
      },
      "dominant-baseline": {
        comment: "added SVG property",
        references: [
          "https://www.w3.org/TR/SVG/text.html#DominantBaselineProperty"
        ],
        syntax: "auto | use-script | no-change | reset-size | ideographic | alphabetic | hanging | mathematical | central | middle | text-after-edge | text-before-edge"
      },
      "image-rendering": {
        comment: "extended with <-non-standard-image-rendering>, added SVG keywords optimizeSpeed and optimizeQuality",
        references: [
          "https://developer.mozilla.org/en/docs/Web/CSS/image-rendering",
          "https://www.w3.org/TR/SVG/painting.html#ImageRenderingProperty"
        ],
        syntax: "| optimizeSpeed | optimizeQuality | <-non-standard-image-rendering>"
      },
      fill: {
        comment: "added SVG property",
        references: [
          "https://www.w3.org/TR/SVG/painting.html#FillProperty"
        ],
        syntax: "<paint>"
      },
      "fill-opacity": {
        comment: "added SVG property",
        references: [
          "https://www.w3.org/TR/SVG/painting.html#FillProperty"
        ],
        syntax: "<number-zero-one>"
      },
      "fill-rule": {
        comment: "added SVG property",
        references: [
          "https://www.w3.org/TR/SVG/painting.html#FillProperty"
        ],
        syntax: "nonzero | evenodd"
      },
      filter: {
        comment: "extend with IE legacy syntaxes",
        syntax: "| <-ms-filter-function-list>"
      },
      "glyph-orientation-horizontal": {
        comment: "added SVG property",
        references: [
          "https://www.w3.org/TR/SVG/text.html#GlyphOrientationHorizontalProperty"
        ],
        syntax: "<angle>"
      },
      "glyph-orientation-vertical": {
        comment: "added SVG property",
        references: [
          "https://www.w3.org/TR/SVG/text.html#GlyphOrientationVerticalProperty"
        ],
        syntax: "<angle>"
      },
      kerning: {
        comment: "added SVG property",
        references: [
          "https://www.w3.org/TR/SVG/text.html#KerningProperty"
        ],
        syntax: "auto | <svg-length>"
      },
      "letter-spacing": {
        comment: "fix syntax <length> -> <length-percentage>",
        references: [
          "https://developer.mozilla.org/en-US/docs/Web/SVG/Attribute/letter-spacing"
        ],
        syntax: "normal | <length-percentage>"
      },
      marker: {
        comment: "added SVG property",
        references: [
          "https://www.w3.org/TR/SVG/painting.html#MarkerProperties"
        ],
        syntax: "none | <url>"
      },
      "marker-end": {
        comment: "added SVG property",
        references: [
          "https://www.w3.org/TR/SVG/painting.html#MarkerProperties"
        ],
        syntax: "none | <url>"
      },
      "marker-mid": {
        comment: "added SVG property",
        references: [
          "https://www.w3.org/TR/SVG/painting.html#MarkerProperties"
        ],
        syntax: "none | <url>"
      },
      "marker-start": {
        comment: "added SVG property",
        references: [
          "https://www.w3.org/TR/SVG/painting.html#MarkerProperties"
        ],
        syntax: "none | <url>"
      },
      "max-width": {
        comment: "extend by non-standard width keywords https://developer.mozilla.org/en-US/docs/Web/CSS/max-width",
        syntax: "| <-non-standard-width>"
      },
      width: {
        references: [
          "https://developer.mozilla.org/en-US/docs/Web/CSS/width",
          "https://github.com/csstree/stylelint-validator/issues/29"
        ],
        syntax: "| fill | stretch | intrinsic | -moz-max-content | -webkit-max-content | -moz-fit-content | -webkit-fit-content"
      },
      "min-width": {
        comment: "extend by non-standard width keywords https://developer.mozilla.org/en-US/docs/Web/CSS/width",
        syntax: "| <-non-standard-width>"
      },
      overflow: {
        comment: "extend by vendor keywords https://developer.mozilla.org/en-US/docs/Web/CSS/overflow",
        syntax: "| <-non-standard-overflow>"
      },
      pause: {
        comment: "https://www.w3.org/TR/css3-speech/#property-index",
        syntax: "<'pause-before'> <'pause-after'>?"
      },
      "pause-after": {
        comment: "https://www.w3.org/TR/css3-speech/#property-index",
        syntax: "<time> | none | x-weak | weak | medium | strong | x-strong"
      },
      "pause-before": {
        comment: "https://www.w3.org/TR/css3-speech/#property-index",
        syntax: "<time> | none | x-weak | weak | medium | strong | x-strong"
      },
      rest: {
        comment: "https://www.w3.org/TR/css3-speech/#property-index",
        syntax: "<'rest-before'> <'rest-after'>?"
      },
      "rest-after": {
        comment: "https://www.w3.org/TR/css3-speech/#property-index",
        syntax: "<time> | none | x-weak | weak | medium | strong | x-strong"
      },
      "rest-before": {
        comment: "https://www.w3.org/TR/css3-speech/#property-index",
        syntax: "<time> | none | x-weak | weak | medium | strong | x-strong"
      },
      "shape-rendering": {
        comment: "added SVG property",
        references: [
          "https://www.w3.org/TR/SVG/painting.html#ShapeRenderingPropert"
        ],
        syntax: "auto | optimizeSpeed | crispEdges | geometricPrecision"
      },
      src: {
        comment: "added @font-face's src property https://developer.mozilla.org/en-US/docs/Web/CSS/@font-face/src",
        syntax: "[ <url> [ format( <string># ) ]? | local( <family-name> ) ]#"
      },
      speak: {
        comment: "https://www.w3.org/TR/css3-speech/#property-index",
        syntax: "auto | none | normal"
      },
      "speak-as": {
        comment: "https://www.w3.org/TR/css3-speech/#property-index",
        syntax: "normal | spell-out || digits || [ literal-punctuation | no-punctuation ]"
      },
      stroke: {
        comment: "added SVG property",
        references: [
          "https://www.w3.org/TR/SVG/painting.html#StrokeProperties"
        ],
        syntax: "<paint>"
      },
      "stroke-dasharray": {
        comment: "added SVG property; a list of comma and/or white space separated <length>s and <percentage>s",
        references: [
          "https://www.w3.org/TR/SVG/painting.html#StrokeProperties"
        ],
        syntax: "none | [ <svg-length>+ ]#"
      },
      "stroke-dashoffset": {
        comment: "added SVG property",
        references: [
          "https://www.w3.org/TR/SVG/painting.html#StrokeProperties"
        ],
        syntax: "<svg-length>"
      },
      "stroke-linecap": {
        comment: "added SVG property",
        references: [
          "https://www.w3.org/TR/SVG/painting.html#StrokeProperties"
        ],
        syntax: "butt | round | square"
      },
      "stroke-linejoin": {
        comment: "added SVG property",
        references: [
          "https://www.w3.org/TR/SVG/painting.html#StrokeProperties"
        ],
        syntax: "miter | round | bevel"
      },
      "stroke-miterlimit": {
        comment: "added SVG property (<miterlimit> = <number-one-or-greater>) ",
        references: [
          "https://www.w3.org/TR/SVG/painting.html#StrokeProperties"
        ],
        syntax: "<number-one-or-greater>"
      },
      "stroke-opacity": {
        comment: "added SVG property",
        references: [
          "https://www.w3.org/TR/SVG/painting.html#StrokeProperties"
        ],
        syntax: "<number-zero-one>"
      },
      "stroke-width": {
        comment: "added SVG property",
        references: [
          "https://www.w3.org/TR/SVG/painting.html#StrokeProperties"
        ],
        syntax: "<svg-length>"
      },
      "text-anchor": {
        comment: "added SVG property",
        references: [
          "https://www.w3.org/TR/SVG/text.html#TextAlignmentProperties"
        ],
        syntax: "start | middle | end"
      },
      "unicode-bidi": {
        comment: "added prefixed keywords https://developer.mozilla.org/en-US/docs/Web/CSS/unicode-bidi",
        syntax: "| -moz-isolate | -moz-isolate-override | -moz-plaintext | -webkit-isolate | -webkit-isolate-override | -webkit-plaintext"
      },
      "unicode-range": {
        comment: "added missed property https://developer.mozilla.org/en-US/docs/Web/CSS/%40font-face/unicode-range",
        syntax: "<urange>#"
      },
      "voice-balance": {
        comment: "https://www.w3.org/TR/css3-speech/#property-index",
        syntax: "<number> | left | center | right | leftwards | rightwards"
      },
      "voice-duration": {
        comment: "https://www.w3.org/TR/css3-speech/#property-index",
        syntax: "auto | <time>"
      },
      "voice-family": {
        comment: "<name> -> <family-name>, https://www.w3.org/TR/css3-speech/#property-index",
        syntax: "[ [ <family-name> | <generic-voice> ] , ]* [ <family-name> | <generic-voice> ] | preserve"
      },
      "voice-pitch": {
        comment: "https://www.w3.org/TR/css3-speech/#property-index",
        syntax: "<frequency> && absolute | [ [ x-low | low | medium | high | x-high ] || [ <frequency> | <semitones> | <percentage> ] ]"
      },
      "voice-range": {
        comment: "https://www.w3.org/TR/css3-speech/#property-index",
        syntax: "<frequency> && absolute | [ [ x-low | low | medium | high | x-high ] || [ <frequency> | <semitones> | <percentage> ] ]"
      },
      "voice-rate": {
        comment: "https://www.w3.org/TR/css3-speech/#property-index",
        syntax: "[ normal | x-slow | slow | medium | fast | x-fast ] || <percentage>"
      },
      "voice-stress": {
        comment: "https://www.w3.org/TR/css3-speech/#property-index",
        syntax: "normal | strong | moderate | none | reduced"
      },
      "voice-volume": {
        comment: "https://www.w3.org/TR/css3-speech/#property-index",
        syntax: "silent | [ [ x-soft | soft | medium | loud | x-loud ] || <decibel> ]"
      },
      "writing-mode": {
        comment: "extend with SVG keywords",
        syntax: "| <svg-writing-mode>"
      }
    },
    types: {
      "-legacy-gradient": {
        comment: "added collection of legacy gradient syntaxes",
        syntax: "<-webkit-gradient()> | <-legacy-linear-gradient> | <-legacy-repeating-linear-gradient> | <-legacy-radial-gradient> | <-legacy-repeating-radial-gradient>"
      },
      "-legacy-linear-gradient": {
        comment: "like standard syntax but w/o `to` keyword https://developer.mozilla.org/en-US/docs/Web/CSS/linear-gradient",
        syntax: "-moz-linear-gradient( <-legacy-linear-gradient-arguments> ) | -webkit-linear-gradient( <-legacy-linear-gradient-arguments> ) | -o-linear-gradient( <-legacy-linear-gradient-arguments> )"
      },
      "-legacy-repeating-linear-gradient": {
        comment: "like standard syntax but w/o `to` keyword https://developer.mozilla.org/en-US/docs/Web/CSS/linear-gradient",
        syntax: "-moz-repeating-linear-gradient( <-legacy-linear-gradient-arguments> ) | -webkit-repeating-linear-gradient( <-legacy-linear-gradient-arguments> ) | -o-repeating-linear-gradient( <-legacy-linear-gradient-arguments> )"
      },
      "-legacy-linear-gradient-arguments": {
        comment: "like standard syntax but w/o `to` keyword https://developer.mozilla.org/en-US/docs/Web/CSS/linear-gradient",
        syntax: "[ <angle> | <side-or-corner> ]? , <color-stop-list>"
      },
      "-legacy-radial-gradient": {
        comment: "deprecated syntax that implemented by some browsers https://www.w3.org/TR/2011/WD-css3-images-20110908/#radial-gradients",
        syntax: "-moz-radial-gradient( <-legacy-radial-gradient-arguments> ) | -webkit-radial-gradient( <-legacy-radial-gradient-arguments> ) | -o-radial-gradient( <-legacy-radial-gradient-arguments> )"
      },
      "-legacy-repeating-radial-gradient": {
        comment: "deprecated syntax that implemented by some browsers https://www.w3.org/TR/2011/WD-css3-images-20110908/#radial-gradients",
        syntax: "-moz-repeating-radial-gradient( <-legacy-radial-gradient-arguments> ) | -webkit-repeating-radial-gradient( <-legacy-radial-gradient-arguments> ) | -o-repeating-radial-gradient( <-legacy-radial-gradient-arguments> )"
      },
      "-legacy-radial-gradient-arguments": {
        comment: "deprecated syntax that implemented by some browsers https://www.w3.org/TR/2011/WD-css3-images-20110908/#radial-gradients",
        syntax: "[ <position> , ]? [ [ [ <-legacy-radial-gradient-shape> || <-legacy-radial-gradient-size> ] | [ <length> | <percentage> ]{2} ] , ]? <color-stop-list>"
      },
      "-legacy-radial-gradient-size": {
        comment: "before a standard it contains 2 extra keywords (`contain` and `cover`) https://www.w3.org/TR/2011/WD-css3-images-20110908/#ltsize",
        syntax: "closest-side | closest-corner | farthest-side | farthest-corner | contain | cover"
      },
      "-legacy-radial-gradient-shape": {
        comment: "define to double sure it doesn't extends in future https://www.w3.org/TR/2011/WD-css3-images-20110908/#ltshape",
        syntax: "circle | ellipse"
      },
      "-non-standard-font": {
        comment: "non standard fonts",
        references: [
          "https://webkit.org/blog/3709/using-the-system-font-in-web-content/"
        ],
        syntax: "-apple-system-body | -apple-system-headline | -apple-system-subheadline | -apple-system-caption1 | -apple-system-caption2 | -apple-system-footnote | -apple-system-short-body | -apple-system-short-headline | -apple-system-short-subheadline | -apple-system-short-caption1 | -apple-system-short-footnote | -apple-system-tall-body"
      },
      "-non-standard-color": {
        comment: "non standard colors",
        references: [
          "http://cssdot.ru/%D0%A1%D0%BF%D1%80%D0%B0%D0%B2%D0%BE%D1%87%D0%BD%D0%B8%D0%BA_CSS/color-i305.html",
          "https://developer.mozilla.org/en-US/docs/Web/CSS/color_value#Mozilla_Color_Preference_Extensions"
        ],
        syntax: "-moz-ButtonDefault | -moz-ButtonHoverFace | -moz-ButtonHoverText | -moz-CellHighlight | -moz-CellHighlightText | -moz-Combobox | -moz-ComboboxText | -moz-Dialog | -moz-DialogText | -moz-dragtargetzone | -moz-EvenTreeRow | -moz-Field | -moz-FieldText | -moz-html-CellHighlight | -moz-html-CellHighlightText | -moz-mac-accentdarkestshadow | -moz-mac-accentdarkshadow | -moz-mac-accentface | -moz-mac-accentlightesthighlight | -moz-mac-accentlightshadow | -moz-mac-accentregularhighlight | -moz-mac-accentregularshadow | -moz-mac-chrome-active | -moz-mac-chrome-inactive | -moz-mac-focusring | -moz-mac-menuselect | -moz-mac-menushadow | -moz-mac-menutextselect | -moz-MenuHover | -moz-MenuHoverText | -moz-MenuBarText | -moz-MenuBarHoverText | -moz-nativehyperlinktext | -moz-OddTreeRow | -moz-win-communicationstext | -moz-win-mediatext | -moz-activehyperlinktext | -moz-default-background-color | -moz-default-color | -moz-hyperlinktext | -moz-visitedhyperlinktext | -webkit-activelink | -webkit-focus-ring-color | -webkit-link | -webkit-text"
      },
      "-non-standard-image-rendering": {
        comment: "non-standard keywords http://phrogz.net/tmp/canvas_image_zoom.html",
        syntax: "optimize-contrast | -moz-crisp-edges | -o-crisp-edges | -webkit-optimize-contrast"
      },
      "-non-standard-overflow": {
        comment: "non-standard keywords https://developer.mozilla.org/en-US/docs/Web/CSS/overflow",
        syntax: "-moz-scrollbars-none | -moz-scrollbars-horizontal | -moz-scrollbars-vertical | -moz-hidden-unscrollable"
      },
      "-non-standard-width": {
        comment: "non-standard keywords https://developer.mozilla.org/en-US/docs/Web/CSS/width",
        syntax: "fill-available | min-intrinsic | intrinsic | -moz-available | -moz-fit-content | -moz-min-content | -moz-max-content | -webkit-min-content | -webkit-max-content"
      },
      "-webkit-gradient()": {
        comment: "first Apple proposal gradient syntax https://webkit.org/blog/175/introducing-css-gradients/ - TODO: simplify when after match algorithm improvement ( [, point, radius | , point] -> [, radius]? , point )",
        syntax: "-webkit-gradient( <-webkit-gradient-type>, <-webkit-gradient-point> [, <-webkit-gradient-point> | , <-webkit-gradient-radius>, <-webkit-gradient-point> ] [, <-webkit-gradient-radius>]? [, <-webkit-gradient-color-stop>]* )"
      },
      "-webkit-gradient-color-stop": {
        comment: "first Apple proposal gradient syntax https://webkit.org/blog/175/introducing-css-gradients/",
        syntax: "from( <color> ) | color-stop( [ <number-zero-one> | <percentage> ] , <color> ) | to( <color> )"
      },
      "-webkit-gradient-point": {
        comment: "first Apple proposal gradient syntax https://webkit.org/blog/175/introducing-css-gradients/",
        syntax: "[ left | center | right | <length-percentage> ] [ top | center | bottom | <length-percentage> ]"
      },
      "-webkit-gradient-radius": {
        comment: "first Apple proposal gradient syntax https://webkit.org/blog/175/introducing-css-gradients/",
        syntax: "<length> | <percentage>"
      },
      "-webkit-gradient-type": {
        comment: "first Apple proposal gradient syntax https://webkit.org/blog/175/introducing-css-gradients/",
        syntax: "linear | radial"
      },
      "-webkit-mask-box-repeat": {
        comment: "missed; https://developer.mozilla.org/en-US/docs/Web/CSS/-webkit-mask-box-image",
        syntax: "repeat | stretch | round"
      },
      "-webkit-mask-clip-style": {
        comment: "missed; there is no enough information about `-webkit-mask-clip` property, but looks like all those keywords are working",
        syntax: "border | border-box | padding | padding-box | content | content-box | text"
      },
      "-ms-filter-function-list": {
        comment: "https://developer.mozilla.org/en-US/docs/Web/CSS/-ms-filter",
        syntax: "<-ms-filter-function>+"
      },
      "-ms-filter-function": {
        comment: "https://developer.mozilla.org/en-US/docs/Web/CSS/-ms-filter",
        syntax: "<-ms-filter-function-progid> | <-ms-filter-function-legacy>"
      },
      "-ms-filter-function-progid": {
        comment: "https://developer.mozilla.org/en-US/docs/Web/CSS/-ms-filter",
        syntax: "'progid:' [ <ident-token> '.' ]* [ <ident-token> | <function-token> <any-value>? ) ]"
      },
      "-ms-filter-function-legacy": {
        comment: "https://developer.mozilla.org/en-US/docs/Web/CSS/-ms-filter",
        syntax: "<ident-token> | <function-token> <any-value>? )"
      },
      "-ms-filter": {
        syntax: "<string>"
      },
      age: {
        comment: "https://www.w3.org/TR/css3-speech/#voice-family",
        syntax: "child | young | old"
      },
      "attr-name": {
        syntax: "<wq-name>"
      },
      "attr-fallback": {
        syntax: "<any-value>"
      },
      "bg-clip": {
        comment: "missed, https://drafts.csswg.org/css-backgrounds-4/#typedef-bg-clip",
        syntax: "<box> | border | text"
      },
      bottom: {
        comment: "missed; not sure we should add it, but no others except `shape` is using it so it's ok for now; https://drafts.fxtf.org/css-masking-1/#funcdef-clip-rect",
        syntax: "<length> | auto"
      },
      "content-list": {
        comment: "added attr(), see https://github.com/csstree/csstree/issues/201",
        syntax: "[ <string> | contents | <image> | <counter> | <quote> | <target> | <leader()> | <attr()> ]+"
      },
      "element()": {
        comment: "https://drafts.csswg.org/css-gcpm/#element-syntax & https://drafts.csswg.org/css-images-4/#element-notation",
        syntax: "element( <custom-ident> , [ first | start | last | first-except ]? ) | element( <id-selector> )"
      },
      "generic-voice": {
        comment: "https://www.w3.org/TR/css3-speech/#voice-family",
        syntax: "[ <age>? <gender> <integer>? ]"
      },
      gender: {
        comment: "https://www.w3.org/TR/css3-speech/#voice-family",
        syntax: "male | female | neutral"
      },
      "generic-family": {
        comment: "added -apple-system",
        references: [
          "https://webkit.org/blog/3709/using-the-system-font-in-web-content/"
        ],
        syntax: "| -apple-system"
      },
      gradient: {
        comment: "added legacy syntaxes support",
        syntax: "| <-legacy-gradient>"
      },
      left: {
        comment: "missed; not sure we should add it, but no others except `shape` is using it so it's ok for now; https://drafts.fxtf.org/css-masking-1/#funcdef-clip-rect",
        syntax: "<length> | auto"
      },
      "mask-image": {
        comment: "missed; https://drafts.fxtf.org/css-masking-1/#the-mask-image",
        syntax: "<mask-reference>#"
      },
      "named-color": {
        comment: "added non standard color names",
        syntax: "| <-non-standard-color>"
      },
      paint: {
        comment: "used by SVG https://www.w3.org/TR/SVG/painting.html#SpecifyingPaint",
        syntax: "none | <color> | <url> [ none | <color> ]? | context-fill | context-stroke"
      },
      right: {
        comment: "missed; not sure we should add it, but no others except `shape` is using it so it's ok for now; https://drafts.fxtf.org/css-masking-1/#funcdef-clip-rect",
        syntax: "<length> | auto"
      },
      shape: {
        comment: "missed spaces in function body and add backwards compatible syntax",
        syntax: "rect( <top>, <right>, <bottom>, <left> ) | rect( <top> <right> <bottom> <left> )"
      },
      "scroll-timeline-axis": {
        comment: "missed definition",
        syntax: "block | inline | vertical | horizontal"
      },
      "scroll-timeline-name": {
        comment: "missed definition",
        references: [
          "https://w3c.github.io/csswg-drafts/scroll-animations/#propdef-scroll-timeline-name"
        ],
        syntax: "none | <custom-ident>"
      },
      "single-animation-composition": {
        comment: "missed definition",
        references: [
          "https://w3c.github.io/csswg-drafts/css-animations-2/#typedef-single-animation-composition"
        ],
        syntax: "replace | add | accumulate"
      },
      "svg-length": {
        comment: "All coordinates and lengths in SVG can be specified with or without a unit identifier",
        references: [
          "https://www.w3.org/TR/SVG11/coords.html#Units"
        ],
        syntax: "<percentage> | <length> | <number>"
      },
      "svg-writing-mode": {
        comment: "SVG specific keywords (deprecated for CSS)",
        references: [
          "https://developer.mozilla.org/en/docs/Web/CSS/writing-mode",
          "https://www.w3.org/TR/SVG/text.html#WritingModeProperty"
        ],
        syntax: "lr-tb | rl-tb | tb-rl | lr | rl | tb"
      },
      top: {
        comment: "missed; not sure we should add it, but no others except `shape` is using it so it's ok for now; https://drafts.fxtf.org/css-masking-1/#funcdef-clip-rect",
        syntax: "<length> | auto"
      },
      x: {
        comment: "missed; not sure we should add it, but no others except `cursor` is using it so it's ok for now; https://drafts.csswg.org/css-ui-3/#cursor",
        syntax: "<number>"
      },
      y: {
        comment: "missed; not sure we should add it, but no others except `cursor` is using so it's ok for now; https://drafts.csswg.org/css-ui-3/#cursor",
        syntax: "<number>"
      },
      declaration: {
        comment: "missed, restored by https://drafts.csswg.org/css-syntax",
        syntax: "<ident-token> : <declaration-value>? [ '!' important ]?"
      },
      "declaration-list": {
        comment: "missed, restored by https://drafts.csswg.org/css-syntax",
        syntax: "[ <declaration>? ';' ]* <declaration>?"
      },
      url: {
        comment: "https://drafts.csswg.org/css-values-4/#urls",
        syntax: "url( <string> <url-modifier>* ) | <url-token>"
      },
      "url-modifier": {
        comment: "https://drafts.csswg.org/css-values-4/#typedef-url-modifier",
        syntax: "<ident> | <function-token> <any-value> )"
      },
      "number-zero-one": {
        syntax: "<number [0,1]>"
      },
      "number-one-or-greater": {
        syntax: "<number [1,]>"
      },
      "-non-standard-display": {
        syntax: "-ms-inline-flexbox | -ms-grid | -ms-inline-grid | -webkit-flex | -webkit-inline-flex | -webkit-box | -webkit-inline-box | -moz-inline-stack | -moz-box | -moz-inline-box"
      }
    }
  };
});

// ../../../../node_modules/.bun/css-tree@2.3.1/node_modules/css-tree/cjs/data-patch.cjs
var require_data_patch = __commonJS((exports, module) => {
  var patch = require_patch();
  var patch$1 = patch;
  module.exports = patch$1;
});

// ../../../../node_modules/.bun/mdn-data@2.0.30/node_modules/mdn-data/css/at-rules.json
var require_at_rules = __commonJS((exports, module) => {
  module.exports = {
    "@charset": {
      syntax: '@charset "<charset>";',
      groups: [
        "CSS Charsets"
      ],
      status: "standard",
      mdn_url: "https://developer.mozilla.org/docs/Web/CSS/@charset"
    },
    "@counter-style": {
      syntax: `@counter-style <counter-style-name> {
  [ system: <counter-system>; ] ||
  [ symbols: <counter-symbols>; ] ||
  [ additive-symbols: <additive-symbols>; ] ||
  [ negative: <negative-symbol>; ] ||
  [ prefix: <prefix>; ] ||
  [ suffix: <suffix>; ] ||
  [ range: <range>; ] ||
  [ pad: <padding>; ] ||
  [ speak-as: <speak-as>; ] ||
  [ fallback: <counter-style-name>; ]
}`,
      interfaces: [
        "CSSCounterStyleRule"
      ],
      groups: [
        "CSS Counter Styles"
      ],
      descriptors: {
        "additive-symbols": {
          syntax: "[ <integer> && <symbol> ]#",
          media: "all",
          initial: "n/a (required)",
          percentages: "no",
          computed: "asSpecified",
          order: "orderOfAppearance",
          status: "standard"
        },
        fallback: {
          syntax: "<counter-style-name>",
          media: "all",
          initial: "decimal",
          percentages: "no",
          computed: "asSpecified",
          order: "uniqueOrder",
          status: "standard"
        },
        negative: {
          syntax: "<symbol> <symbol>?",
          media: "all",
          initial: '"-" hyphen-minus',
          percentages: "no",
          computed: "asSpecified",
          order: "orderOfAppearance",
          status: "standard"
        },
        pad: {
          syntax: "<integer> && <symbol>",
          media: "all",
          initial: '0 ""',
          percentages: "no",
          computed: "asSpecified",
          order: "uniqueOrder",
          status: "standard"
        },
        prefix: {
          syntax: "<symbol>",
          media: "all",
          initial: '""',
          percentages: "no",
          computed: "asSpecified",
          order: "uniqueOrder",
          status: "standard"
        },
        range: {
          syntax: "[ [ <integer> | infinite ]{2} ]# | auto",
          media: "all",
          initial: "auto",
          percentages: "no",
          computed: "asSpecified",
          order: "orderOfAppearance",
          status: "standard"
        },
        "speak-as": {
          syntax: "auto | bullets | numbers | words | spell-out | <counter-style-name>",
          media: "all",
          initial: "auto",
          percentages: "no",
          computed: "asSpecified",
          order: "uniqueOrder",
          status: "standard"
        },
        suffix: {
          syntax: "<symbol>",
          media: "all",
          initial: '". "',
          percentages: "no",
          computed: "asSpecified",
          order: "uniqueOrder",
          status: "standard"
        },
        symbols: {
          syntax: "<symbol>+",
          media: "all",
          initial: "n/a (required)",
          percentages: "no",
          computed: "asSpecified",
          order: "orderOfAppearance",
          status: "standard"
        },
        system: {
          syntax: "cyclic | numeric | alphabetic | symbolic | additive | [ fixed <integer>? ] | [ extends <counter-style-name> ]",
          media: "all",
          initial: "symbolic",
          percentages: "no",
          computed: "asSpecified",
          order: "uniqueOrder",
          status: "standard"
        }
      },
      status: "standard",
      mdn_url: "https://developer.mozilla.org/docs/Web/CSS/@counter-style"
    },
    "@document": {
      syntax: `@document [ <url> | url-prefix(<string>) | domain(<string>) | media-document(<string>) | regexp(<string>) ]# {
  <group-rule-body>
}`,
      interfaces: [
        "CSSGroupingRule",
        "CSSConditionRule"
      ],
      groups: [
        "CSS Conditional Rules"
      ],
      status: "nonstandard",
      mdn_url: "https://developer.mozilla.org/docs/Web/CSS/@document"
    },
    "@font-face": {
      syntax: `@font-face {
  [ font-family: <family-name>; ] ||
  [ src: <src>; ] ||
  [ unicode-range: <unicode-range>; ] ||
  [ font-variant: <font-variant>; ] ||
  [ font-feature-settings: <font-feature-settings>; ] ||
  [ font-variation-settings: <font-variation-settings>; ] ||
  [ font-stretch: <font-stretch>; ] ||
  [ font-weight: <font-weight>; ] ||
  [ font-style: <font-style>; ] ||
  [ size-adjust: <size-adjust>; ] ||
  [ ascent-override: <ascent-override>; ] ||
  [ descent-override: <descent-override>; ] ||
  [ line-gap-override: <line-gap-override>; ]
}`,
      interfaces: [
        "CSSFontFaceRule"
      ],
      groups: [
        "CSS Fonts"
      ],
      descriptors: {
        "ascent-override": {
          syntax: "normal | <percentage>",
          media: "all",
          initial: "normal",
          percentages: "asSpecified",
          computed: "asSpecified",
          order: "orderOfAppearance",
          status: "experimental"
        },
        "descent-override": {
          syntax: "normal | <percentage>",
          media: "all",
          initial: "normal",
          percentages: "asSpecified",
          computed: "asSpecified",
          order: "orderOfAppearance",
          status: "experimental"
        },
        "font-display": {
          syntax: "[ auto | block | swap | fallback | optional ]",
          media: "visual",
          percentages: "no",
          initial: "auto",
          computed: "asSpecified",
          order: "uniqueOrder",
          status: "experimental"
        },
        "font-family": {
          syntax: "<family-name>",
          media: "all",
          initial: "n/a (required)",
          percentages: "no",
          computed: "asSpecified",
          order: "uniqueOrder",
          status: "standard"
        },
        "font-feature-settings": {
          syntax: "normal | <feature-tag-value>#",
          media: "all",
          initial: "normal",
          percentages: "no",
          computed: "asSpecified",
          order: "orderOfAppearance",
          status: "standard"
        },
        "font-variation-settings": {
          syntax: "normal | [ <string> <number> ]#",
          media: "all",
          initial: "normal",
          percentages: "no",
          computed: "asSpecified",
          order: "orderOfAppearance",
          status: "standard"
        },
        "font-stretch": {
          syntax: "<font-stretch-absolute>{1,2}",
          media: "all",
          initial: "normal",
          percentages: "no",
          computed: "asSpecified",
          order: "uniqueOrder",
          status: "standard"
        },
        "font-style": {
          syntax: "normal | italic | oblique <angle>{0,2}",
          media: "all",
          initial: "normal",
          percentages: "no",
          computed: "asSpecified",
          order: "uniqueOrder",
          status: "standard"
        },
        "font-weight": {
          syntax: "<font-weight-absolute>{1,2}",
          media: "all",
          initial: "normal",
          percentages: "no",
          computed: "asSpecified",
          order: "uniqueOrder",
          status: "standard"
        },
        "font-variant": {
          syntax: "normal | none | [ <common-lig-values> || <discretionary-lig-values> || <historical-lig-values> || <contextual-alt-values> || stylistic(<feature-value-name>) || historical-forms || styleset(<feature-value-name>#) || character-variant(<feature-value-name>#) || swash(<feature-value-name>) || ornaments(<feature-value-name>) || annotation(<feature-value-name>) || [ small-caps | all-small-caps | petite-caps | all-petite-caps | unicase | titling-caps ] || <numeric-figure-values> || <numeric-spacing-values> || <numeric-fraction-values> || ordinal || slashed-zero || <east-asian-variant-values> || <east-asian-width-values> || ruby ]",
          media: "all",
          initial: "normal",
          percentages: "no",
          computed: "asSpecified",
          order: "orderOfAppearance",
          status: "standard"
        },
        "line-gap-override": {
          syntax: "normal | <percentage>",
          media: "all",
          initial: "normal",
          percentages: "asSpecified",
          computed: "asSpecified",
          order: "orderOfAppearance",
          status: "experimental"
        },
        "size-adjust": {
          syntax: "<percentage>",
          media: "all",
          initial: "100%",
          percentages: "asSpecified",
          computed: "asSpecified",
          order: "orderOfAppearance",
          status: "experimental"
        },
        src: {
          syntax: "[ <url> [ format( <string># ) ]? | local( <family-name> ) ]#",
          media: "all",
          initial: "n/a (required)",
          percentages: "no",
          computed: "asSpecified",
          order: "orderOfAppearance",
          status: "standard"
        },
        "unicode-range": {
          syntax: "<unicode-range>#",
          media: "all",
          initial: "U+0-10FFFF",
          percentages: "no",
          computed: "asSpecified",
          order: "orderOfAppearance",
          status: "standard"
        }
      },
      status: "standard",
      mdn_url: "https://developer.mozilla.org/docs/Web/CSS/@font-face"
    },
    "@font-feature-values": {
      syntax: `@font-feature-values <family-name># {
  <feature-value-block-list>
}`,
      interfaces: [
        "CSSFontFeatureValuesRule"
      ],
      groups: [
        "CSS Fonts"
      ],
      status: "standard",
      mdn_url: "https://developer.mozilla.org/docs/Web/CSS/@font-feature-values"
    },
    "@import": {
      syntax: `@import [ <string> | <url> ]
        [ layer | layer(<layer-name>) ]?
        [ supports( [ <supports-condition> | <declaration> ] ) ]?
        <media-query-list>? ;`,
      groups: [
        "CSS Conditional Rules",
        "Media Queries"
      ],
      status: "standard",
      mdn_url: "https://developer.mozilla.org/docs/Web/CSS/@import"
    },
    "@keyframes": {
      syntax: `@keyframes <keyframes-name> {
  <keyframe-block-list>
}`,
      interfaces: [
        "CSSKeyframeRule",
        "CSSKeyframesRule"
      ],
      groups: [
        "CSS Animations"
      ],
      status: "standard",
      mdn_url: "https://developer.mozilla.org/docs/Web/CSS/@keyframes"
    },
    "@layer": {
      syntax: `@layer [ <layer-name># | <layer-name>?  {
  <stylesheet>
} ]`,
      interfaces: [
        "CSSLayerBlockRule",
        "CSSLayerStatementRule"
      ],
      groups: [
        "CSS Cascading and Inheritance"
      ],
      status: "standard",
      mdn_url: "https://developer.mozilla.org/docs/Web/CSS/@layer"
    },
    "@media": {
      syntax: `@media <media-query-list> {
  <group-rule-body>
}`,
      interfaces: [
        "CSSGroupingRule",
        "CSSConditionRule",
        "CSSMediaRule",
        "CSSCustomMediaRule"
      ],
      groups: [
        "CSS Conditional Rules",
        "Media Queries"
      ],
      status: "standard",
      mdn_url: "https://developer.mozilla.org/docs/Web/CSS/@media"
    },
    "@namespace": {
      syntax: "@namespace <namespace-prefix>? [ <string> | <url> ];",
      groups: [
        "CSS Namespaces"
      ],
      status: "standard",
      mdn_url: "https://developer.mozilla.org/docs/Web/CSS/@namespace"
    },
    "@page": {
      syntax: `@page <page-selector-list> {
  <page-body>
}`,
      interfaces: [
        "CSSPageRule"
      ],
      groups: [
        "CSS Pages"
      ],
      descriptors: {
        bleed: {
          syntax: "auto | <length>",
          media: [
            "visual",
            "paged"
          ],
          initial: "auto",
          percentages: "no",
          computed: "asSpecified",
          order: "uniqueOrder",
          status: "standard"
        },
        marks: {
          syntax: "none | [ crop || cross ]",
          media: [
            "visual",
            "paged"
          ],
          initial: "none",
          percentages: "no",
          computed: "asSpecified",
          order: "orderOfAppearance",
          status: "standard"
        },
        size: {
          syntax: "<length>{1,2} | auto | [ <page-size> || [ portrait | landscape ] ]",
          media: [
            "visual",
            "paged"
          ],
          initial: "auto",
          percentages: "no",
          computed: "asSpecifiedRelativeToAbsoluteLengths",
          order: "orderOfAppearance",
          status: "standard"
        }
      },
      status: "standard",
      mdn_url: "https://developer.mozilla.org/docs/Web/CSS/@page"
    },
    "@property": {
      syntax: `@property <custom-property-name> {
  <declaration-list>
}`,
      interfaces: [
        "CSS",
        "CSSPropertyRule"
      ],
      groups: [
        "CSS Houdini"
      ],
      descriptors: {
        syntax: {
          syntax: "<string>",
          media: "all",
          percentages: "no",
          initial: "n/a (required)",
          computed: "asSpecified",
          order: "uniqueOrder",
          status: "experimental"
        },
        inherits: {
          syntax: "true | false",
          media: "all",
          percentages: "no",
          initial: "auto",
          computed: "asSpecified",
          order: "uniqueOrder",
          status: "experimental"
        },
        "initial-value": {
          syntax: "<string>",
          media: "all",
          initial: "n/a (required)",
          percentages: "no",
          computed: "asSpecified",
          order: "uniqueOrder",
          status: "experimental"
        }
      },
      status: "experimental",
      mdn_url: "https://developer.mozilla.org/docs/Web/CSS/@property"
    },
    "@scroll-timeline": {
      syntax: "@scroll-timeline <timeline-name> { <declaration-list> }",
      interfaces: [
        "ScrollTimeline"
      ],
      groups: [
        "CSS Animations"
      ],
      status: "standard",
      mdn_url: "https://developer.mozilla.org/docs/Web/CSS/@scroll-timeline"
    },
    "@supports": {
      syntax: `@supports <supports-condition> {
  <group-rule-body>
}`,
      interfaces: [
        "CSSGroupingRule",
        "CSSConditionRule",
        "CSSSupportsRule"
      ],
      groups: [
        "CSS Conditional Rules"
      ],
      status: "standard",
      mdn_url: "https://developer.mozilla.org/docs/Web/CSS/@supports"
    },
    "@viewport": {
      syntax: `@viewport {
  <group-rule-body>
}`,
      interfaces: [
        "CSSViewportRule"
      ],
      groups: [
        "CSS Device Adaptation"
      ],
      descriptors: {
        height: {
          syntax: "<viewport-length>{1,2}",
          media: [
            "visual",
            "continuous"
          ],
          initial: [
            "min-height",
            "max-height"
          ],
          percentages: [
            "min-height",
            "max-height"
          ],
          computed: [
            "min-height",
            "max-height"
          ],
          order: "orderOfAppearance",
          status: "standard"
        },
        "max-height": {
          syntax: "<viewport-length>",
          media: [
            "visual",
            "continuous"
          ],
          initial: "auto",
          percentages: "referToHeightOfInitialViewport",
          computed: "lengthAbsolutePercentageAsSpecifiedOtherwiseAuto",
          order: "uniqueOrder",
          status: "standard"
        },
        "max-width": {
          syntax: "<viewport-length>",
          media: [
            "visual",
            "continuous"
          ],
          initial: "auto",
          percentages: "referToWidthOfInitialViewport",
          computed: "lengthAbsolutePercentageAsSpecifiedOtherwiseAuto",
          order: "uniqueOrder",
          status: "standard"
        },
        "max-zoom": {
          syntax: "auto | <number> | <percentage>",
          media: [
            "visual",
            "continuous"
          ],
          initial: "auto",
          percentages: "the zoom factor itself",
          computed: "autoNonNegativeOrPercentage",
          order: "uniqueOrder",
          status: "standard"
        },
        "min-height": {
          syntax: "<viewport-length>",
          media: [
            "visual",
            "continuous"
          ],
          initial: "auto",
          percentages: "referToHeightOfInitialViewport",
          computed: "lengthAbsolutePercentageAsSpecifiedOtherwiseAuto",
          order: "uniqueOrder",
          status: "standard"
        },
        "min-width": {
          syntax: "<viewport-length>",
          media: [
            "visual",
            "continuous"
          ],
          initial: "auto",
          percentages: "referToWidthOfInitialViewport",
          computed: "lengthAbsolutePercentageAsSpecifiedOtherwiseAuto",
          order: "uniqueOrder",
          status: "standard"
        },
        "min-zoom": {
          syntax: "auto | <number> | <percentage>",
          media: [
            "visual",
            "continuous"
          ],
          initial: "auto",
          percentages: "the zoom factor itself",
          computed: "autoNonNegativeOrPercentage",
          order: "uniqueOrder",
          status: "standard"
        },
        orientation: {
          syntax: "auto | portrait | landscape",
          media: [
            "visual",
            "continuous"
          ],
          initial: "auto",
          percentages: "referToSizeOfBoundingBox",
          computed: "asSpecified",
          order: "uniqueOrder",
          status: "standard"
        },
        "user-zoom": {
          syntax: "zoom | fixed",
          media: [
            "visual",
            "continuous"
          ],
          initial: "zoom",
          percentages: "referToSizeOfBoundingBox",
          computed: "asSpecified",
          order: "uniqueOrder",
          status: "standard"
        },
        "viewport-fit": {
          syntax: "auto | contain | cover",
          media: [
            "visual",
            "continuous"
          ],
          initial: "auto",
          percentages: "no",
          computed: "asSpecified",
          order: "uniqueOrder",
          status: "standard"
        },
        width: {
          syntax: "<viewport-length>{1,2}",
          media: [
            "visual",
            "continuous"
          ],
          initial: [
            "min-width",
            "max-width"
          ],
          percentages: [
            "min-width",
            "max-width"
          ],
          computed: [
            "min-width",
            "max-width"
          ],
          order: "orderOfAppearance",
          status: "standard"
        },
        zoom: {
          syntax: "auto | <number> | <percentage>",
          media: [
            "visual",
            "continuous"
          ],
          initial: "auto",
          percentages: "the zoom factor itself",
          computed: "autoNonNegativeOrPercentage",
          order: "uniqueOrder",
          status: "standard"
        }
      },
      status: "standard",
      mdn_url: "https://developer.mozilla.org/docs/Web/CSS/@viewport"
    }
  };
});

// ../../../../node_modules/.bun/mdn-data@2.0.30/node_modules/mdn-data/css/properties.json
var require_properties = __commonJS((exports, module) => {
  module.exports = {
    "--*": {
      syntax: "<declaration-value>",
      media: "all",
      inherited: true,
      animationType: "discrete",
      percentages: "no",
      groups: [
        "CSS Variables"
      ],
      initial: "seeProse",
      appliesto: "allElements",
      computed: "asSpecifiedWithVarsSubstituted",
      order: "perGrammar",
      status: "experimental",
      mdn_url: "https://developer.mozilla.org/docs/Web/CSS/--*"
    },
    "-ms-accelerator": {
      syntax: "false | true",
      media: "visual",
      inherited: false,
      animationType: "discrete",
      percentages: "no",
      groups: [
        "Microsoft Extensions"
      ],
      initial: "false",
      appliesto: "allElements",
      computed: "asSpecified",
      order: "uniqueOrder",
      status: "nonstandard",
      mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-accelerator"
    },
    "-ms-block-progression": {
      syntax: "tb | rl | bt | lr",
      media: "visual",
      inherited: false,
      animationType: "discrete",
      percentages: "no",
      groups: [
        "Microsoft Extensions"
      ],
      initial: "tb",
      appliesto: "allElements",
      computed: "asSpecified",
      order: "uniqueOrder",
      status: "nonstandard",
      mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-block-progression"
    },
    "-ms-content-zoom-chaining": {
      syntax: "none | chained",
      media: "interactive",
      inherited: false,
      animationType: "discrete",
      percentages: "no",
      groups: [
        "Microsoft Extensions"
      ],
      initial: "none",
      appliesto: "nonReplacedBlockAndInlineBlockElements",
      computed: "asSpecified",
      order: "uniqueOrder",
      status: "nonstandard",
      mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-content-zoom-chaining"
    },
    "-ms-content-zooming": {
      syntax: "none | zoom",
      media: "interactive",
      inherited: false,
      animationType: "discrete",
      percentages: "no",
      groups: [
        "Microsoft Extensions"
      ],
      initial: "zoomForTheTopLevelNoneForTheRest",
      appliesto: "nonReplacedBlockAndInlineBlockElements",
      computed: "asSpecified",
      order: "uniqueOrder",
      status: "nonstandard",
      mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-content-zooming"
    },
    "-ms-content-zoom-limit": {
      syntax: "<'-ms-content-zoom-limit-min'> <'-ms-content-zoom-limit-max'>",
      media: "interactive",
      inherited: false,
      animationType: "discrete",
      percentages: [
        "-ms-content-zoom-limit-max",
        "-ms-content-zoom-limit-min"
      ],
      groups: [
        "Microsoft Extensions"
      ],
      initial: [
        "-ms-content-zoom-limit-max",
        "-ms-content-zoom-limit-min"
      ],
      appliesto: "nonReplacedBlockAndInlineBlockElements",
      computed: [
        "-ms-content-zoom-limit-max",
        "-ms-content-zoom-limit-min"
      ],
      order: "uniqueOrder",
      status: "nonstandard",
      mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-content-zoom-limit"
    },
    "-ms-content-zoom-limit-max": {
      syntax: "<percentage>",
      media: "interactive",
      inherited: false,
      animationType: "discrete",
      percentages: "maxZoomFactor",
      groups: [
        "Microsoft Extensions"
      ],
      initial: "400%",
      appliesto: "nonReplacedBlockAndInlineBlockElements",
      computed: "asSpecified",
      order: "uniqueOrder",
      status: "nonstandard",
      mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-content-zoom-limit-max"
    },
    "-ms-content-zoom-limit-min": {
      syntax: "<percentage>",
      media: "interactive",
      inherited: false,
      animationType: "discrete",
      percentages: "minZoomFactor",
      groups: [
        "Microsoft Extensions"
      ],
      initial: "100%",
      appliesto: "nonReplacedBlockAndInlineBlockElements",
      computed: "asSpecified",
      order: "uniqueOrder",
      status: "nonstandard",
      mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-content-zoom-limit-min"
    },
    "-ms-content-zoom-snap": {
      syntax: "<'-ms-content-zoom-snap-type'> || <'-ms-content-zoom-snap-points'>",
      media: "interactive",
      inherited: false,
      animationType: "discrete",
      percentages: "no",
      groups: [
        "Microsoft Extensions"
      ],
      initial: [
        "-ms-content-zoom-snap-type",
        "-ms-content-zoom-snap-points"
      ],
      appliesto: "nonReplacedBlockAndInlineBlockElements",
      computed: [
        "-ms-content-zoom-snap-type",
        "-ms-content-zoom-snap-points"
      ],
      order: "uniqueOrder",
      status: "nonstandard",
      mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-content-zoom-snap"
    },
    "-ms-content-zoom-snap-points": {
      syntax: "snapInterval( <percentage>, <percentage> ) | snapList( <percentage># )",
      media: "interactive",
      inherited: false,
      animationType: "discrete",
      percentages: "no",
      groups: [
        "Microsoft Extensions"
      ],
      initial: "snapInterval(0%, 100%)",
      appliesto: "nonReplacedBlockAndInlineBlockElements",
      computed: "asSpecified",
      order: "uniqueOrder",
      status: "nonstandard",
      mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-content-zoom-snap-points"
    },
    "-ms-content-zoom-snap-type": {
      syntax: "none | proximity | mandatory",
      media: "interactive",
      inherited: false,
      animationType: "discrete",
      percentages: "no",
      groups: [
        "Microsoft Extensions"
      ],
      initial: "none",
      appliesto: "nonReplacedBlockAndInlineBlockElements",
      computed: "asSpecified",
      order: "uniqueOrder",
      status: "nonstandard",
      mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-content-zoom-snap-type"
    },
    "-ms-filter": {
      syntax: "<string>",
      media: "visual",
      inherited: false,
      animationType: "discrete",
      percentages: "no",
      groups: [
        "Microsoft Extensions"
      ],
      initial: '""',
      appliesto: "allElements",
      computed: "asSpecified",
      order: "uniqueOrder",
      status: "nonstandard",
      mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-filter"
    },
    "-ms-flow-from": {
      syntax: "[ none | <custom-ident> ]#",
      media: "visual",
      inherited: false,
      animationType: "discrete",
      percentages: "no",
      groups: [
        "Microsoft Extensions"
      ],
      initial: "none",
      appliesto: "nonReplacedElements",
      computed: "asSpecified",
      order: "uniqueOrder",
      status: "nonstandard",
      mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-flow-from"
    },
    "-ms-flow-into": {
      syntax: "[ none | <custom-ident> ]#",
      media: "visual",
      inherited: false,
      animationType: "discrete",
      percentages: "no",
      groups: [
        "Microsoft Extensions"
      ],
      initial: "none",
      appliesto: "iframeElements",
      computed: "asSpecified",
      order: "uniqueOrder",
      status: "nonstandard",
      mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-flow-into"
    },
    "-ms-grid-columns": {
      syntax: "none | <track-list> | <auto-track-list>",
      media: "visual",
      inherited: false,
      animationType: "simpleListOfLpcDifferenceLpc",
      percentages: "referToDimensionOfContentArea",
      groups: [
        "CSS Grid Layout"
      ],
      initial: "none",
      appliesto: "gridContainers",
      computed: "asSpecifiedRelativeToAbsoluteLengths",
      order: "uniqueOrder",
      status: "nonstandard",
      mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-grid-columns"
    },
    "-ms-grid-rows": {
      syntax: "none | <track-list> | <auto-track-list>",
      media: "visual",
      inherited: false,
      animationType: "simpleListOfLpcDifferenceLpc",
      percentages: "referToDimensionOfContentArea",
      groups: [
        "CSS Grid Layout"
      ],
      initial: "none",
      appliesto: "gridContainers",
      computed: "asSpecifiedRelativeToAbsoluteLengths",
      order: "uniqueOrder",
      status: "nonstandard",
      mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-grid-rows"
    },
    "-ms-high-contrast-adjust": {
      syntax: "auto | none",
      media: "visual",
      inherited: true,
      animationType: "discrete",
      percentages: "no",
      groups: [
        "Microsoft Extensions"
      ],
      initial: "auto",
      appliesto: "allElements",
      computed: "asSpecified",
      order: "uniqueOrder",
      status: "nonstandard",
      mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-high-contrast-adjust"
    },
    "-ms-hyphenate-limit-chars": {
      syntax: "auto | <integer>{1,3}",
      media: "visual",
      inherited: true,
      animationType: "discrete",
      percentages: "no",
      groups: [
        "Microsoft Extensions"
      ],
      initial: "auto",
      appliesto: "allElements",
      computed: "asSpecified",
      order: "uniqueOrder",
      status: "nonstandard",
      mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-hyphenate-limit-chars"
    },
    "-ms-hyphenate-limit-lines": {
      syntax: "no-limit | <integer>",
      media: "visual",
      inherited: true,
      animationType: "discrete",
      percentages: "no",
      groups: [
        "Microsoft Extensions"
      ],
      initial: "no-limit",
      appliesto: "blockContainerElements",
      computed: "asSpecified",
      order: "uniqueOrder",
      status: "nonstandard",
      mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-hyphenate-limit-lines"
    },
    "-ms-hyphenate-limit-zone": {
      syntax: "<percentage> | <length>",
      media: "visual",
      inherited: true,
      animationType: "discrete",
      percentages: "referToLineBoxWidth",
      groups: [
        "Microsoft Extensions"
      ],
      initial: "0",
      appliesto: "blockContainerElements",
      computed: "asSpecified",
      order: "uniqueOrder",
      status: "nonstandard",
      mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-hyphenate-limit-zone"
    },
    "-ms-ime-align": {
      syntax: "auto | after",
      media: "visual",
      inherited: false,
      animationType: "discrete",
      percentages: "no",
      groups: [
        "Microsoft Extensions"
      ],
      initial: "auto",
      appliesto: "allElements",
      computed: "asSpecified",
      order: "uniqueOrder",
      status: "nonstandard",
      mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-ime-align"
    },
    "-ms-overflow-style": {
      syntax: "auto | none | scrollbar | -ms-autohiding-scrollbar",
      media: "interactive",
      inherited: true,
      animationType: "discrete",
      percentages: "no",
      groups: [
        "Microsoft Extensions"
      ],
      initial: "auto",
      appliesto: "nonReplacedBlockAndInlineBlockElements",
      computed: "asSpecified",
      order: "uniqueOrder",
      status: "nonstandard",
      mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-overflow-style"
    },
    "-ms-scrollbar-3dlight-color": {
      syntax: "<color>",
      media: "visual",
      inherited: true,
      animationType: "discrete",
      percentages: "no",
      groups: [
        "Microsoft Extensions"
      ],
      initial: "dependsOnUserAgent",
      appliesto: "allElements",
      computed: "asSpecified",
      order: "uniqueOrder",
      status: "nonstandard",
      mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scrollbar-3dlight-color"
    },
    "-ms-scrollbar-arrow-color": {
      syntax: "<color>",
      media: "visual",
      inherited: true,
      animationType: "discrete",
      percentages: "no",
      groups: [
        "Microsoft Extensions"
      ],
      initial: "ButtonText",
      appliesto: "allElements",
      computed: "asSpecified",
      order: "uniqueOrder",
      status: "nonstandard",
      mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scrollbar-arrow-color"
    },
    "-ms-scrollbar-base-color": {
      syntax: "<color>",
      media: "visual",
      inherited: true,
      animationType: "discrete",
      percentages: "no",
      groups: [
        "Microsoft Extensions"
      ],
      initial: "dependsOnUserAgent",
      appliesto: "allElements",
      computed: "asSpecified",
      order: "uniqueOrder",
      status: "nonstandard",
      mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scrollbar-base-color"
    },
    "-ms-scrollbar-darkshadow-color": {
      syntax: "<color>",
      media: "visual",
      inherited: true,
      animationType: "discrete",
      percentages: "no",
      groups: [
        "Microsoft Extensions"
      ],
      initial: "ThreeDDarkShadow",
      appliesto: "allElements",
      computed: "asSpecified",
      order: "uniqueOrder",
      status: "nonstandard",
      mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scrollbar-darkshadow-color"
    },
    "-ms-scrollbar-face-color": {
      syntax: "<color>",
      media: "visual",
      inherited: true,
      animationType: "discrete",
      percentages: "no",
      groups: [
        "Microsoft Extensions"
      ],
      initial: "ThreeDFace",
      appliesto: "allElements",
      computed: "asSpecified",
      order: "uniqueOrder",
      status: "nonstandard",
      mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scrollbar-face-color"
    },
    "-ms-scrollbar-highlight-color": {
      syntax: "<color>",
      media: "visual",
      inherited: true,
      animationType: "discrete",
      percentages: "no",
      groups: [
        "Microsoft Extensions"
      ],
      initial: "ThreeDHighlight",
      appliesto: "allElements",
      computed: "asSpecified",
      order: "uniqueOrder",
      status: "nonstandard",
      mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scrollbar-highlight-color"
    },
    "-ms-scrollbar-shadow-color": {
      syntax: "<color>",
      media: "visual",
      inherited: true,
      animationType: "discrete",
      percentages: "no",
      groups: [
        "Microsoft Extensions"
      ],
      initial: "ThreeDDarkShadow",
      appliesto: "allElements",
      computed: "asSpecified",
      order: "uniqueOrder",
      status: "nonstandard",
      mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scrollbar-shadow-color"
    },
    "-ms-scrollbar-track-color": {
      syntax: "<color>",
      media: "visual",
      inherited: true,
      animationType: "discrete",
      percentages: "no",
      groups: [
        "Microsoft Extensions"
      ],
      initial: "Scrollbar",
      appliesto: "allElements",
      computed: "asSpecified",
      order: "uniqueOrder",
      status: "nonstandard",
      mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scrollbar-track-color"
    },
    "-ms-scroll-chaining": {
      syntax: "chained | none",
      media: "interactive",
      inherited: false,
      animationType: "discrete",
      percentages: "no",
      groups: [
        "Microsoft Extensions"
      ],
      initial: "chained",
      appliesto: "nonReplacedBlockAndInlineBlockElements",
      computed: "asSpecified",
      order: "uniqueOrder",
      status: "nonstandard",
      mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scroll-chaining"
    },
    "-ms-scroll-limit": {
      syntax: "<'-ms-scroll-limit-x-min'> <'-ms-scroll-limit-y-min'> <'-ms-scroll-limit-x-max'> <'-ms-scroll-limit-y-max'>",
      media: "interactive",
      inherited: false,
      animationType: "discrete",
      percentages: "no",
      groups: [
        "Microsoft Extensions"
      ],
      initial: [
        "-ms-scroll-limit-x-min",
        "-ms-scroll-limit-y-min",
        "-ms-scroll-limit-x-max",
        "-ms-scroll-limit-y-max"
      ],
      appliesto: "nonReplacedBlockAndInlineBlockElements",
      computed: [
        "-ms-scroll-limit-x-min",
        "-ms-scroll-limit-y-min",
        "-ms-scroll-limit-x-max",
        "-ms-scroll-limit-y-max"
      ],
      order: "uniqueOrder",
      status: "nonstandard",
      mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scroll-limit"
    },
    "-ms-scroll-limit-x-max": {
      syntax: "auto | <length>",
      media: "interactive",
      inherited: false,
      animationType: "discrete",
      percentages: "no",
      groups: [
        "Microsoft Extensions"
      ],
      initial: "auto",
      appliesto: "nonReplacedBlockAndInlineBlockElements",
      computed: "asSpecified",
      order: "uniqueOrder",
      status: "nonstandard",
      mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scroll-limit-x-max"
    },
    "-ms-scroll-limit-x-min": {
      syntax: "<length>",
      media: "interactive",
      inherited: false,
      animationType: "discrete",
      percentages: "no",
      groups: [
        "Microsoft Extensions"
      ],
      initial: "0",
      appliesto: "nonReplacedBlockAndInlineBlockElements",
      computed: "asSpecified",
      order: "uniqueOrder",
      status: "nonstandard",
      mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scroll-limit-x-min"
    },
    "-ms-scroll-limit-y-max": {
      syntax: "auto | <length>",
      media: "interactive",
      inherited: false,
      animationType: "discrete",
      percentages: "no",
      groups: [
        "Microsoft Extensions"
      ],
      initial: "auto",
      appliesto: "nonReplacedBlockAndInlineBlockElements",
      computed: "asSpecified",
      order: "uniqueOrder",
      status: "nonstandard",
      mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scroll-limit-y-max"
    },
    "-ms-scroll-limit-y-min": {
      syntax: "<length>",
      media: "interactive",
      inherited: false,
      animationType: "discrete",
      percentages: "no",
      groups: [
        "Microsoft Extensions"
      ],
      initial: "0",
      appliesto: "nonReplacedBlockAndInlineBlockElements",
      computed: "asSpecified",
      order: "uniqueOrder",
      status: "nonstandard",
      mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scroll-limit-y-min"
    },
    "-ms-scroll-rails": {
      syntax: "none | railed",
      media: "interactive",
      inherited: false,
      animationType: "discrete",
      percentages: "no",
      groups: [
        "Microsoft Extensions"
      ],
      initial: "railed",
      appliesto: "nonReplacedBlockAndInlineBlockElements",
      computed: "asSpecified",
      order: "uniqueOrder",
      status: "nonstandard",
      mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scroll-rails"
    },
    "-ms-scroll-snap-points-x": {
      syntax: "snapInterval( <length-percentage>, <length-percentage> ) | snapList( <length-percentage># )",
      media: "interactive",
      inherited: false,
      animationType: "discrete",
      percentages: "no",
      groups: [
        "Microsoft Extensions"
      ],
      initial: "snapInterval(0px, 100%)",
      appliesto: "nonReplacedBlockAndInlineBlockElements",
      computed: "asSpecified",
      order: "uniqueOrder",
      status: "nonstandard",
      mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scroll-snap-points-x"
    },
    "-ms-scroll-snap-points-y": {
      syntax: "snapInterval( <length-percentage>, <length-percentage> ) | snapList( <length-percentage># )",
      media: "interactive",
      inherited: false,
      animationType: "discrete",
      percentages: "no",
      groups: [
        "Microsoft Extensions"
      ],
      initial: "snapInterval(0px, 100%)",
      appliesto: "nonReplacedBlockAndInlineBlockElements",
      computed: "asSpecified",
      order: "uniqueOrder",
      status: "nonstandard",
      mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scroll-snap-points-y"
    },
    "-ms-scroll-snap-type": {
      syntax: "none | proximity | mandatory",
      media: "interactive",
      inherited: false,
      animationType: "discrete",
      percentages: "no",
      groups: [
        "Microsoft Extensions"
      ],
      initial: "none",
      appliesto: "nonReplacedBlockAndInlineBlockElements",
      computed: "asSpecified",
      order: "uniqueOrder",
      status: "nonstandard",
      mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scroll-snap-type"
    },
    "-ms-scroll-snap-x": {
      syntax: "<'-ms-scroll-snap-type'> <'-ms-scroll-snap-points-x'>",
      media: "interactive",
      inherited: false,
      animationType: "discrete",
      percentages: "no",
      groups: [
        "Microsoft Extensions"
      ],
      initial: [
        "-ms-scroll-snap-type",
        "-ms-scroll-snap-points-x"
      ],
      appliesto: "nonReplacedBlockAndInlineBlockElements",
      computed: [
        "-ms-scroll-snap-type",
        "-ms-scroll-snap-points-x"
      ],
      order: "uniqueOrder",
      status: "nonstandard",
      mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scroll-snap-x"
    },
    "-ms-scroll-snap-y": {
      syntax: "<'-ms-scroll-snap-type'> <'-ms-scroll-snap-points-y'>",
      media: "interactive",
      inherited: false,
      animationType: "discrete",
      percentages: "no",
      groups: [
        "Microsoft Extensions"
      ],
      initial: [
        "-ms-scroll-snap-type",
        "-ms-scroll-snap-points-y"
      ],
      appliesto: "nonReplacedBlockAndInlineBlockElements",
      computed: [
        "-ms-scroll-snap-type",
        "-ms-scroll-snap-points-y"
      ],
      order: "uniqueOrder",
      status: "nonstandard",
      mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scroll-snap-y"
    },
    "-ms-scroll-translation": {
      syntax: "none | vertical-to-horizontal",
      media: "interactive",
      inherited: true,
      animationType: "discrete",
      percentages: "no",
      groups: [
        "Microsoft Extensions"
      ],
      initial: "none",
      appliesto: "allElements",
      computed: "asSpecified",
      order: "uniqueOrder",
      status: "nonstandard",
      mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scroll-translation"
    },
    "-ms-text-autospace": {
      syntax: "none | ideograph-alpha | ideograph-numeric | ideograph-parenthesis | ideograph-space",
      media: "visual",
      inherited: false,
      animationType: "discrete",
      percentages: "no",
      groups: [
        "Microsoft Extensions"
      ],
      initial: "none",
      appliesto: "allElements",
      computed: "asSpecified",
      order: "uniqueOrder",
      status: "nonstandard",
      mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-text-autospace"
    },
    "-ms-touch-select": {
      syntax: "grippers | none",
      media: "interactive",
      inherited: true,
      animationType: "discrete",
      percentages: "no",
      groups: [
        "Microsoft Extensions"
      ],
      initial: "grippers",
      appliesto: "allElements",
      computed: "asSpecified",
      order: "uniqueOrder",
      status: "nonstandard",
      mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-touch-select"
    },
    "-ms-user-select": {
      syntax: "none | element | text",
      media: "interactive",
      inherited: false,
      animationType: "discrete",
      percentages: "no",
      groups: [
        "Microsoft Extensions"
      ],
      initial: "text",
      appliesto: "nonReplacedElements",
      computed: "asSpecified",
      order: "uniqueOrder",
      status: "nonstandard",
      mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-user-select"
    },
    "-ms-wrap-flow": {
      syntax: "auto | both | start | end | maximum | clear",
      media: "visual",
      inherited: false,
      animationType: "discrete",
      percentages: "no",
      groups: [
        "Microsoft Extensions"
      ],
      initial: "auto",
      appliesto: "blockLevelElements",
      computed: "asSpecified",
      order: "uniqueOrder",
      status: "nonstandard",
      mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-wrap-flow"
    },
    "-ms-wrap-margin": {
      syntax: "<length>",
      media: "visual",
      inherited: false,
      animationType: "discrete",
      percentages: "no",
      groups: [
        "Microsoft Extensions"
      ],
      initial: "0",
      appliesto: "exclusionElements",
      computed: "asSpecified",
      order: "uniqueOrder",
      status: "nonstandard",
      mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-wrap-margin"
    },
    "-ms-wrap-through": {
      syntax: "wrap | none",
      media: "visual",
      inherited: false,
      animationType: "discrete",
      percentages: "no",
      groups: [
        "Microsoft Extensions"
      ],
      initial: "wrap",
      appliesto: "blockLevelElements",
      computed: "asSpecified",
      order: "uniqueOrder",
      status: "nonstandard",
      mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-wrap-through"
    },
    "-moz-appearance": {
      syntax: "none | button | button-arrow-down | button-arrow-next | button-arrow-previous | button-arrow-up | button-bevel | button-focus | caret | checkbox | checkbox-container | checkbox-label | checkmenuitem | dualbutton | groupbox | listbox | listitem | menuarrow | menubar | menucheckbox | menuimage | menuitem | menuitemtext | menulist | menulist-button | menulist-text | menulist-textfield | menupopup | menuradio | menuseparator | meterbar | meterchunk | progressbar | progressbar-vertical | progresschunk | progresschunk-vertical | radio | radio-container | radio-label | radiomenuitem | range | range-thumb | resizer | resizerpanel | scale-horizontal | scalethumbend | scalethumb-horizontal | scalethumbstart | scalethumbtick | scalethumb-vertical | scale-vertical | scrollbarbutton-down | scrollbarbutton-left | scrollbarbutton-right | scrollbarbutton-up | scrollbarthumb-horizontal | scrollbarthumb-vertical | scrollbartrack-horizontal | scrollbartrack-vertical | searchfield | separator | sheet | spinner | spinner-downbutton | spinner-textfield | spinner-upbutton | splitter | statusbar | statusbarpanel | tab | tabpanel | tabpanels | tab-scroll-arrow-back | tab-scroll-arrow-forward | textfield | textfield-multiline | toolbar | toolbarbutton | toolbarbutton-dropdown | toolbargripper | toolbox | tooltip | treeheader | treeheadercell | treeheadersortarrow | treeitem | treeline | treetwisty | treetwistyopen | treeview | -moz-mac-unified-toolbar | -moz-win-borderless-glass | -moz-win-browsertabbar-toolbox | -moz-win-communicationstext | -moz-win-communications-toolbox | -moz-win-exclude-glass | -moz-win-glass | -moz-win-mediatext | -moz-win-media-toolbox | -moz-window-button-box | -moz-window-button-box-maximized | -moz-window-button-close | -moz-window-button-maximize | -moz-window-button-minimize | -moz-window-button-restore | -moz-window-frame-bottom | -moz-window-frame-left | -moz-window-frame-right | -moz-window-titlebar | -moz-window-titlebar-maximized",
      media: "visual",
      inherited: false,
      animationType: "discrete",
      percentages: "no",
      groups: [
        "Mozilla Extensions",
        "WebKit Extensions"
      ],
      initial: "noneButOverriddenInUserAgentCSS",
      appliesto: "allElements",
      computed: "asSpecified",
      order: "uniqueOrder",
      status: "nonstandard",
      mdn_url: "https://developer.mozilla.org/docs/Web/CSS/appearance"
    },
    "-moz-binding": {
      syntax: "<url> | none",
      media: "visual",
      inherited: false,
      animationType: "discrete",
      percentages: "no",
      groups: [
        "Mozilla Extensions"
      ],
      initial: "none",
      appliesto: "allElementsExceptGeneratedContentOrPseudoElements",
      computed: "asSpecified",
      order: "uniqueOrder",
      status: "nonstandard",
      mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-binding"
    },
    "-moz-border-bottom-colors": {
      syntax: "<color>+ | none",
      media: "visual",
      inherited: false,
      animationType: "discrete",
      percentages: "no",
      groups: [
        "Mozilla Extensions"
      ],
      initial: "none",
      appliesto: "allElements",
      computed: "asSpecified",
      order: "uniqueOrder",
      status: "nonstandard",
      mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-border-bottom-colors"
    },
    "-moz-border-left-colors": {
      syntax: "<color>+ | none",
      media: "visual",
      inherited: false,
      animationType: "discrete",
      percentages: "no",
      groups: [
        "Mozilla Extensions"
      ],
      initial: "none",
      appliesto: "allElements",
      computed: "asSpecified",
      order: "uniqueOrder",
      status: "nonstandard",
      mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-border-left-colors"
    },
    "-moz-border-right-colors": {
      syntax: "<color>+ | none",
      media: "visual",
      inherited: false,
      animationType: "discrete",
      percentages: "no",
      groups: [
        "Mozilla Extensions"
      ],
      initial: "none",
      appliesto: "allElements",
      computed: "asSpecified",
      order: "uniqueOrder",
      status: "nonstandard",
      mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-border-right-colors"
    },
    "-moz-border-top-colors": {
      syntax: "<color>+ | none",
      media: "visual",
      inherited: false,
      animationType: "discrete",
      percentages: "no",
      groups: [
        "Mozilla Extensions"
      ],
      initial: "none",
      appliesto: "allElements",
      computed: "asSpecified",
      order: "uniqueOrder",
      status: "nonstandard",
      mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-border-top-colors"
    },
    "-moz-context-properties": {
      syntax: "none | [ fill | fill-opacity | stroke | stroke-opacity ]#",
      media: "visual",
      inherited: true,
      animationType: "discrete",
      percentages: "no",
      groups: [
        "Mozilla Extensions"
      ],
      initial: "none",
      appliesto: "allElementsThatCanReferenceImages",
      computed: "asSpecified",
      order: "uniqueOrder",
      status: "nonstandard",
      mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-context-properties"
    },
    "-moz-float-edge": {
      syntax: "border-box | content-box | margin-box | padding-box",
      media: "visual",
      inherited: false,
      animationType: "discrete",
      percentages: "no",
      groups: [
        "Mozilla Extensions"
      ],
      initial: "content-box",
      appliesto: "allElements",
      computed: "asSpecified",
      order: "uniqueOrder",
      status: "nonstandard",
      mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-float-edge"
    },
    "-moz-force-broken-image-icon": {
      syntax: "0 | 1",
      media: "visual",
      inherited: false,
      animationType: "discrete",
      percentages: "no",
      groups: [
        "Mozilla Extensions"
      ],
      initial: "0",
      appliesto: "images",
      computed: "asSpecified",
      order: "uniqueOrder",
      status: "nonstandard",
      mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-force-broken-image-icon"
    },
    "-moz-image-region": {
      syntax: "<shape> | auto",
      media: "visual",
      inherited: true,
      animationType: "discrete",
      percentages: "no",
      groups: [
        "Mozilla Extensions"
      ],
      initial: "auto",
      appliesto: "xulImageElements",
      computed: "asSpecified",
      order: "uniqueOrder",
      status: "nonstandard",
      mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-image-region"
    },
    "-moz-orient": {
      syntax: "inline | block | horizontal | vertical",
      media: "visual",
      inherited: false,
      animationType: "discrete",
      percentages: "no",
      groups: [
        "Mozilla Extensions"
      ],
      initial: "inline",
      appliesto: "anyElementEffectOnProgressAndMeter",
      computed: "asSpecified",
      order: "uniqueOrder",
      status: "nonstandard",
      mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-orient"
    },
    "-moz-outline-radius": {
      syntax: "<outline-radius>{1,4} [ / <outline-radius>{1,4} ]?",
      media: "visual",
      inherited: false,
      animationType: [
        "-moz-outline-radius-topleft",
        "-moz-outline-radius-topright",
        "-moz-outline-radius-bottomright",
        "-moz-outline-radius-bottomleft"
      ],
      percentages: [
        "-moz-outline-radius-topleft",
        "-moz-outline-radius-topright",
        "-moz-outline-radius-bottomright",
        "-moz-outline-radius-bottomleft"
      ],
      groups: [
        "Mozilla Extensions"
      ],
      initial: [
        "-moz-outline-radius-topleft",
        "-moz-outline-radius-topright",
        "-moz-outline-radius-bottomright",
        "-moz-outline-radius-bottomleft"
      ],
      appliesto: "allElements",
      computed: [
        "-moz-outline-radius-topleft",
        "-moz-outline-radius-topright",
        "-moz-outline-radius-bottomright",
        "-moz-outline-radius-bottomleft"
      ],
      order: "uniqueOrder",
      status: "nonstandard",
      mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-outline-radius"
    },
    "-moz-outline-radius-bottomleft": {
      syntax: "<outline-radius>",
      media: "visual",
      inherited: false,
      animationType: "lpc",
      percentages: "referToDimensionOfBorderBox",
      groups: [
        "Mozilla Extensions"
      ],
      initial: "0",
      appliesto: "allElements",
      computed: "asSpecified",
      order: "uniqueOrder",
      status: "nonstandard",
      mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-outline-radius-bottomleft"
    },
    "-moz-outline-radius-bottomright": {
      syntax: "<outline-radius>",
      media: "visual",
      inherited: false,
      animationType: "lpc",
      percentages: "referToDimensionOfBorderBox",
      groups: [
        "Mozilla Extensions"
      ],
      initial: "0",
      appliesto: "allElements",
      computed: "asSpecified",
      order: "uniqueOrder",
      status: "nonstandard",
      mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-outline-radius-bottomright"
    },
    "-moz-outline-radius-topleft": {
      syntax: "<outline-radius>",
      media: "visual",
      inherited: false,
      animationType: "lpc",
      percentages: "referToDimensionOfBorderBox",
      groups: [
        "Mozilla Extensions"
      ],
      initial: "0",
      appliesto: "allElements",
      computed: "asSpecified",
      order: "uniqueOrder",
      status: "nonstandard",
      mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-outline-radius-topleft"
    },
    "-moz-outline-radius-topright": {
      syntax: "<outline-radius>",
      media: "visual",
      inherited: false,
      animationType: "lpc",
      percentages: "referToDimensionOfBorderBox",
      groups: [
        "Mozilla Extensions"
      ],
      initial: "0",
      appliesto: "allElements",
      computed: "asSpecified",
      order: "uniqueOrder",
      status: "nonstandard",
      mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-outline-radius-topright"
    },
    "-moz-stack-sizing": {
      syntax: "ignore | stretch-to-fit",
      media: "visual",
      inherited: true,
      animationType: "discrete",
      percentages: "no",
      groups: [
        "Mozilla Extensions"
      ],
      initial: "stretch-to-fit",
      appliesto: "allElements",
      computed: "asSpecified",
      order: "uniqueOrder",
      status: "nonstandard",
      mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-stack-sizing"
    },
    "-moz-text-blink": {
      syntax: "none | blink",
      media: "visual",
      inherited: false,
      animationType: "discrete",
      percentages: "no",
      groups: [
        "Mozilla Extensions"
      ],
      initial: "none",
      appliesto: "allElements",
      computed: "asSpecified",
      order: "uniqueOrder",
      status: "nonstandard",
      mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-text-blink"
    },
    "-moz-user-focus": {
      syntax: "ignore | normal | select-after | select-before | select-menu | select-same | select-all | none",
      media: "interactive",
      inherited: false,
      animationType: "discrete",
      percentages: "no",
      groups: [
        "Mozilla Extensions"
      ],
      initial: "none",
      appliesto: "allElements",
      computed: "asSpecified",
      order: "uniqueOrder",
      status: "nonstandard",
      mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-user-focus"
    },
    "-moz-user-input": {
      syntax: "auto | none | enabled | disabled",
      media: "visual",
      inherited: true,
      animationType: "discrete",
      percentages: "no",
      groups: [
        "Mozilla Extensions"
      ],
      initial: "auto",
      appliesto: "allElements",
      computed: "asSpecified",
      order: "uniqueOrder",
      status: "nonstandard",
      mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-user-input"
    },
    "-moz-user-modify": {
      syntax: "read-only | read-write | write-only",
      media: "interactive",
      inherited: true,
      animationType: "discrete",
      percentages: "no",
      groups: [
        "Mozilla Extensions"
      ],
      initial: "read-only",
      appliesto: "allElements",
      computed: "asSpecified",
      order: "uniqueOrder",
      status: "nonstandard",
      mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-user-modify"
    },
    "-moz-window-dragging": {
      syntax: "drag | no-drag",
      media: "visual",
      inherited: false,
      animationType: "discrete",
      percentages: "no",
      groups: [
        "Mozilla Extensions"
      ],
      initial: "drag",
      appliesto: "allElementsCreatingNativeWindows",
      computed: "asSpecified",
      order: "uniqueOrder",
      status: "nonstandard",
      mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-window-dragging"
    },
    "-moz-window-shadow": {
      syntax: "default | menu | tooltip | sheet | none",
      media: "visual",
      inherited: false,
      animationType: "discrete",
      percentages: "no",
      groups: [
        "Mozilla Extensions"
      ],
      initial: "default",
      appliesto: "allElementsCreatingNativeWindows",
      computed: "asSpecified",
      order: "uniqueOrder",
      status: "nonstandard",
      mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-window-shadow"
    },
    "-webkit-appearance": {
      syntax: "none | button | button-bevel | caret | checkbox | default-button | inner-spin-button | listbox | listitem | media-controls-background | media-controls-fullscreen-background | media-current-time-display | media-enter-fullscreen-button | media-exit-fullscreen-button | media-fullscreen-button | media-mute-button | media-overlay-play-button | media-play-button | media-seek-back-button | media-seek-forward-button | media-slider | media-sliderthumb | media-time-remaining-display | media-toggle-closed-captions-button | media-volume-slider | media-volume-slider-container | media-volume-sliderthumb | menulist | menulist-button | menulist-text | menulist-textfield | meter | progress-bar | progress-bar-value | push-button | radio | searchfield | searchfield-cancel-button | searchfield-decoration | searchfield-results-button | searchfield-results-decoration | slider-horizontal | slider-vertical | sliderthumb-horizontal | sliderthumb-vertical | square-button | textarea | textfield | -apple-pay-button",
      media: "visual",
      inherited: false,
      animationType: "discrete",
      percentages: "no",
      groups: [
        "WebKit Extensions"
      ],
      initial: "noneButOverriddenInUserAgentCSS",
      appliesto: "allElements",
      computed: "asSpecified",
      order: "uniqueOrder",
      status: "nonstandard",
      mdn_url: "https://developer.mozilla.org/docs/Web/CSS/appearance"
    },
    "-webkit-border-before": {
      syntax: "<'border-width'> || <'border-style'> || <color>",
      media: "visual",
      inherited: true,
      animationType: "discrete",
      percentages: [
        "-webkit-border-before-width"
      ],
      groups: [
        "WebKit Extensions"
      ],
      initial: [
        "border-width",
        "border-style",
        "color"
      ],
      appliesto: "allElements",
      computed: [
        "border-width",
        "border-style",
        "color"
      ],
      order: "uniqueOrder",
      status: "nonstandard",
      mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-webkit-border-before"
    },
    "-webkit-border-before-color": {
      syntax: "<color>",
      media: "visual",
      inherited: true,
      animationType: "discrete",
      percentages: "no",
      groups: [
        "WebKit Extensions"
      ],
      initial: "currentcolor",
      appliesto: "allElements",
      computed: "computedColor",
      order: "uniqueOrder",
      status: "nonstandard"
    },
    "-webkit-border-before-style": {
      syntax: "<'border-style'>",
      media: "visual",
      inherited: true,
      animationType: "discrete",
      percentages: "no",
      groups: [
        "WebKit Extensions"
      ],
      initial: "none",
      appliesto: "allElements",
      computed: "asSpecified",
      order: "uniqueOrder",
      status: "nonstandard"
    },
    "-webkit-border-before-width": {
      syntax: "<'border-width'>",
      media: "visual",
      inherited: true,
      animationType: "discrete",
      percentages: "logicalWidthOfContainingBlock",
      groups: [
        "WebKit Extensions"
      ],
      initial: "medium",
      appliesto: "allElements",
      computed: "absoluteLengthZeroIfBorderStyleNoneOrHidden",
      order: "uniqueOrder",
      status: "nonstandard"
    },
    "-webkit-box-reflect": {
      syntax: "[ above | below | right | left ]? <length>? <image>?",
      media: "visual",
      inherited: false,
      animationType: "discrete",
      percentages: "no",
      groups: [
        "WebKit Extensions"
      ],
      initial: "none",
      appliesto: "allElements",
      computed: "asSpecified",
      order: "uniqueOrder",
      status: "nonstandard",
      mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-webkit-box-reflect"
    },
    "-webkit-line-clamp": {
      syntax: "none | <integer>",
      media: "visual",
      inherited: false,
      animationType: "byComputedValueType",
      percentages: "no",
      groups: [
        "WebKit Extensions",
        "CSS Overflow"
      ],
      initial: "none",
      appliesto: "allElements",
      computed: "asSpecified",
      order: "uniqueOrder",
      status: "standard",
      mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-webkit-line-clamp"
    },
    "-webkit-mask": {
      syntax: "[ <mask-reference> || <position> [ / <bg-size> ]? || <repeat-style> || [ <box> | border | padding | content | text ] || [ <box> | border | padding | content ] ]#",
      media: "visual",
      inherited: false,
      animationType: "discrete",
      percentages: "no",
      groups: [
        "WebKit Extensions"
      ],
      initial: [
        "-webkit-mask-image",
        "-webkit-mask-repeat",
        "-webkit-mask-attachment",
        "-webkit-mask-position",
        "-webkit-mask-origin",
        "-webkit-mask-clip"
      ],
      appliesto: "allElements",
      computed: [
        "-webkit-mask-image",
        "-webkit-mask-repeat",
        "-webkit-mask-attachment",
        "-webkit-mask-position",
        "-webkit-mask-origin",
        "-webkit-mask-clip"
      ],
      order: "uniqueOrder",
      status: "nonstandard",
      mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask"
    },
    "-webkit-mask-attachment": {
      syntax: "<attachment>#",
      media: "visual",
      inherited: false,
      animationType: "discrete",
      percentages: "no",
      groups: [
        "WebKit Extensions"
      ],
      initial: "scroll",
      appliesto: "allElements",
      computed: "asSpecified",
      order: "orderOfAppearance",
      status: "nonstandard",
      mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-webkit-mask-attachment"
    },
    "-webkit-mask-clip": {
      syntax: "[ <box> | border | padding | content | text ]#",
      media: "visual",
      inherited: false,
      animationType: "discrete",
      percentages: "no",
      groups: [
        "WebKit Extensions"
      ],
      initial: "border",
      appliesto: "allElements",
      computed: "asSpecified",
      order: "orderOfAppearance",
      status: "nonstandard",
      mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-clip"
    },
    "-webkit-mask-composite": {
      syntax: "<composite-style>#",
      media: "visual",
      inherited: false,
      animationType: "discrete",
      percentages: "no",
      groups: [
        "WebKit Extensions"
      ],
      initial: "source-over",
      appliesto: "allElements",
      computed: "asSpecified",
      order: "orderOfAppearance",
      status: "nonstandard",
      mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-webkit-mask-composite"
    },
    "-webkit-mask-image": {
      syntax: "<mask-reference>#",
      media: "visual",
      inherited: false,
      animationType: "discrete",
      percentages: "no",
      groups: [
        "WebKit Extensions"
      ],
      initial: "none",
      appliesto: "allElements",
      computed: "absoluteURIOrNone",
      order: "orderOfAppearance",
      status: "nonstandard",
      mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-image"
    },
    "-webkit-mask-origin": {
      syntax: "[ <box> | border | padding | content ]#",
      media: "visual",
      inherited: false,
      animationType: "discrete",
      percentages: "no",
      groups: [
        "WebKit Extensions"
      ],
      initial: "padding",
      appliesto: "allElements",
      computed: "asSpecified",
      order: "orderOfAppearance",
      status: "nonstandard",
      mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-origin"
    },
    "-webkit-mask-position": {
      syntax: "<position>#",
      media: "visual",
      inherited: false,
      animationType: "discrete",
      percentages: "referToSizeOfElement",
      groups: [
        "WebKit Extensions"
      ],
      initial: "0% 0%",
      appliesto: "allElements",
      computed: "absoluteLengthOrPercentage",
      order: "orderOfAppearance",
      status: "nonstandard",
      mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-position"
    },
    "-webkit-mask-position-x": {
      syntax: "[ <length-percentage> | left | center | right ]#",
      media: "visual",
      inherited: false,
      animationType: "discrete",
      percentages: "referToSizeOfElement",
      groups: [
        "WebKit Extensions"
      ],
      initial: "0%",
      appliesto: "allElements",
      computed: "absoluteLengthOrPercentage",
      order: "orderOfAppearance",
      status: "nonstandard",
      mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-webkit-mask-position-x"
    },
    "-webkit-mask-position-y": {
      syntax: "[ <length-percentage> | top | center | bottom ]#",
      media: "visual",
      inherited: false,
      animationType: "discrete",
      percentages: "referToSizeOfElement",
      groups: [
        "WebKit Extensions"
      ],
      initial: "0%",
      appliesto: "allElements",
      computed: "absoluteLengthOrPercentage",
      order: "orderOfAppearance",
      status: "nonstandard",
      mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-webkit-mask-position-y"
    },
    "-webkit-mask-repeat": {
      syntax: "<repeat-style>#",
      media: "visual",
      inherited: false,
      animationType: "discrete",
      percentages: "no",
      groups: [
        "WebKit Extensions"
      ],
      initial: "repeat",
      appliesto: "allElements",
      computed: "asSpecified",
      order: "orderOfAppearance",
      status: "nonstandard",
      mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-repeat"
    },
    "-webkit-mask-repeat-x": {
      syntax: "repeat | no-repeat | space | round",
      media: "visual",
      inherited: false,
      animationType: "discrete",
      percentages: "no",
      groups: [
        "WebKit Extensions"
      ],
      initial: "repeat",
      appliesto: "allElements",
      computed: "asSpecified",
      order: "orderOfAppearance",
      status: "nonstandard",
      mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-webkit-mask-repeat-x"
    },
    "-webkit-mask-repeat-y": {
      syntax: "repeat | no-repeat | space | round",
      media: "visual",
      inherited: false,
      animationType: "discrete",
      percentages: "no",
      groups: [
        "WebKit Extensions"
      ],
      initial: "repeat",
      appliesto: "allElements",
      computed: "absoluteLengthOrPercentage",
      order: "orderOfAppearance",
      status: "nonstandard",
      mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-webkit-mask-repeat-y"
    },
    "-webkit-mask-size": {
      syntax: "<bg-size>#",
      media: "visual",
      inherited: false,
      animationType: "discrete",
      percentages: "relativeToBackgroundPositioningArea",
      groups: [
        "WebKit Extensions"
      ],
      initial: "auto auto",
      appliesto: "allElements",
      computed: "asSpecified",
      order: "orderOfAppearance",
      status: "nonstandard",
      mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-size"
    },
    "-webkit-overflow-scrolling": {
      syntax: "auto | touch",
      media: "visual",
      inherited: true,
      animationType: "discrete",
      percentages: "no",
      groups: [
        "WebKit Extensions"
      ],
      initial: "auto",
      appliesto: "scrollingBoxes",
      computed: "asSpecified",
      order: "orderOfAppearance",
      status: "nonstandard",
      mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-webkit-overflow-scrolling"
    },
    "-webkit-tap-highlight-color": {
      syntax: "<color>",
      media: "visual",
      inherited: true,
      animationType: "discrete",
      percentages: "no",
      groups: [
        "WebKit Extensions"
      ],
      initial: "black",
      appliesto: "allElements",
      computed: "asSpecified",
      order: "uniqueOrder",
      status: "nonstandard",
      mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-webkit-tap-highlight-color"
    },
    "-webkit-text-fill-color": {
      syntax: "<color>",
      media: "visual",
      inherited: true,
      animationType: "color",
      percentages: "no",
      groups: [
        "WebKit Extensions"
      ],
      initial: "currentcolor",
      appliesto: "allElements",
      computed: "computedColor",
      order: "uniqueOrder",
      status: "nonstandard",
      mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-webkit-text-fill-color"
    },
    "-webkit-text-stroke": {
      syntax: "<length> || <color>",
      media: "visual",
      inherited: true,
      animationType: [
        "-webkit-text-stroke-width",
        "-webkit-text-stroke-color"
      ],
      percentages: "no",
      groups: [
        "WebKit Extensions"
      ],
      initial: [
        "-webkit-text-stroke-width",
        "-webkit-text-stroke-color"
      ],
      appliesto: "allElements",
      computed: [
        "-webkit-text-stroke-width",
        "-webkit-text-stroke-color"
      ],
      order: "canonicalOrder",
      status: "nonstandard",
      mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-webkit-text-stroke"
    },
    "-webkit-text-stroke-color": {
      syntax: "<color>",
      media: "visual",
      inherited: true,
      animationType: "color",
      percentages: "no",
      groups: [
        "WebKit Extensions"
      ],
      initial: "currentcolor",
      appliesto: "allElements",
      computed: "computedColor",
      order: "uniqueOrder",
      status: "nonstandard",
      mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-webkit-text-stroke-color"
    },
    "-webkit-text-stroke-width": {
      syntax: "<length>",
      media: "visual",
      inherited: true,
      animationType: "discrete",
      percentages: "no",
      groups: [
        "WebKit Extensions"
      ],
      initial: "0",
      appliesto: "allElements",
      computed: "absoluteLength",
      order: "uniqueOrder",
      status: "nonstandard",
      mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-webkit-text-stroke-width"
    },
    "-webkit-touch-callout": {
      syntax: "default | none",
      media: "visual",
      inherited: true,
      animationType: "discrete",
      percentages: "no",
      groups: [
        "WebKit Extensions"
      ],
      initial: "default",
      appliesto: "allElements",
      computed: "asSpecified",
      order: "uniqueOrder",
      status: "nonstandard",
      mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-webkit-touch-callout"
    },
    "-webkit-user-modify": {
      syntax: "read-only | read-write | read-write-plaintext-only",
      media: "interactive",
      inherited: true,
      animationType: "discrete",
      percentages: "no",
      groups: [
        "WebKit Extensions"
      ],
      initial: "read-only",
      appliesto: "allElements",
      computed: "asSpecified",
      order: "uniqueOrder",
      status: "nonstandard"
    },
    "accent-color": {
      syntax: "auto | <color>",
      media: "interactive",
      inherited: true,
      animationType: "byComputedValueType",
      percentages: "no",
      groups: [
        "CSS Basic User Interface"
      ],
      initial: "auto",
      appliesto: "allElements",
      computed: "asAutoOrColor",
      order: "perGrammar",
      status: "standard",
      mdn_url: "https://developer.mozilla.org/docs/Web/CSS/accent-color"
    },
    "align-content": {
      syntax: "normal | <baseline-position> | <content-distribution> | <overflow-position>? <content-position>",
      media: "visual",
      inherited: false,
      animationType: "discrete",
      percentages: "no",
      groups: [
        "CSS Box Alignment"
      ],
      initial: "normal",
      appliesto: "multilineFlexContainers",
      computed: "asSpecified",
      order: "uniqueOrder",
      status: "standard",
      mdn_url: "https://developer.mozilla.org/docs/Web/CSS/align-content"
    },
    "align-items": {
      syntax: "normal | stretch | <baseline-position> | [ <overflow-position>? <self-position> ]",
      media: "visual",
      inherited: false,
      animationType: "discrete",
      percentages: "no",
      groups: [
        "CSS Box Alignment"
      ],
      initial: "normal",
      appliesto: "allElements",
      computed: "asSpecified",
      order: "uniqueOrder",
      status: "standard",
      mdn_url: "https://developer.mozilla.org/docs/Web/CSS/align-items"
    },
    "align-self": {
      syntax: "auto | normal | stretch | <baseline-position> | <overflow-position>? <self-position>",
      media: "visual",
      inherited: false,
      animationType: "discrete",
      percentages: "no",
      groups: [
        "CSS Box Alignment"
      ],
      initial: "auto",
      appliesto: "flexItemsGridItemsAndAbsolutelyPositionedBoxes",
      computed: "autoOnAbsolutelyPositionedElementsValueOfAlignItemsOnParent",
      order: "uniqueOrder",
      status: "standard",
      mdn_url: "https://developer.mozilla.org/docs/Web/CSS/align-self"
    },
    "align-tracks": {
      syntax: "[ normal | <baseline-position> | <content-distribution> | <overflow-position>? <content-position> ]#",
      media: "visual",
      inherited: false,
      animationType: "discrete",
      percentages: "no",
      groups: [
        "CSS Grid Layout"
      ],
      initial: "normal",
      appliesto: "gridContainersWithMasonryLayoutInTheirBlockAxis",
      computed: "asSpecified",
      order: "uniqueOrder",
      status: "experimental",
      mdn_url: "https://developer.mozilla.org/docs/Web/CSS/align-tracks"
    },
    all: {
      syntax: "initial | inherit | unset | revert | revert-layer",
      media: "noPracticalMedia",
      inherited: false,
      animationType: "eachOfShorthandPropertiesExceptUnicodeBiDiAndDirection",
      percentages: "no",
      groups: [
        "CSS Miscellaneous"
      ],
      initial: "noPracticalInitialValue",
      appliesto: "allElements",
      computed: "asSpecifiedAppliesToEachProperty",
      order: "uniqueOrder",
      status: "standard",
      mdn_url: "https://developer.mozilla.org/docs/Web/CSS/all"
    },
    animation: {
      syntax: "<single-animation>#",
      media: "visual",
      inherited: false,
      animationType: "notAnimatable",
      percentages: "no",
      groups: [
        "CSS Animations"
      ],
      initial: [
        "animation-name",
        "animation-duration",
        "animation-timing-function",
        "animation-delay",
        "animation-iteration-count",
        "animation-direction",
        "animation-fill-mode",
        "animation-play-state",
        "animation-timeline"
      ],
      appliesto: "allElementsAndPseudos",
      computed: [
        "animation-name",
        "animation-duration",
        "animation-timing-function",
        "animation-delay",
        "animation-direction",
        "animation-iteration-count",
        "animation-fill-mode",
        "animation-play-state",
        "animation-timeline"
      ],
      order: "orderOfAppearance",
      status: "standard",
      mdn_url: "https://developer.mozilla.org/docs/Web/CSS/animation"
    },
    "animation-composition": {
      syntax: "<single-animation-composition>#",
      media: "visual",
      inherited: false,
      animationType: "notAnimatable",
      percentages: "no",
      groups: [
        "CSS Animations"
      ],
      initial: "replace",
      appliesto: "allElements",
      computed: "asSpecified",
      order: "uniqueOrder",
      status: "experimental",
      mdn_url: "https://developer.mozilla.org/docs/Web/CSS/animation-composition"
    },
    "animation-delay": {
      syntax: "<time>#",
      media: "visual",
      inherited: false,
      animationType: "notAnimatable",
      percentages: "no",
      groups: [
        "CSS Animations"
      ],
      initial: "0s",
      appliesto: "allElementsAndPseudos",
      computed: "asSpecified",
      order: "uniqueOrder",
      status: "standard",
      mdn_url: "https://developer.mozilla.org/docs/Web/CSS/animation-delay"
    },
    "animation-direction": {
      syntax: "<single-animation-direction>#",
      media: "visual",
      inherited: false,
      animationType: "notAnimatable",
      percentages: "no",
      groups: [
        "CSS Animations"
      ],
      initial: "normal",
      appliesto: "allElementsAndPseudos",
      computed: "asSpecified",
      order: "uniqueOrder",
      status: "standard",
      mdn_url: "https://developer.mozilla.org/docs/Web/CSS/animation-direction"
    },
    "animation-duration": {
      syntax: "<time>#",
      media: "visual",
      inherited: false,
      animationType: "notAnimatable",
      percentages: "no",
      groups: [
        "CSS Animations"
      ],
      initial: "0s",
      appliesto: "allElementsAndPseudos",
      computed: "asSpecified",
      order: "uniqueOrder",
      status: "standard",
      mdn_url: "https://developer.mozilla.org/docs/Web/CSS/animation-duration"
    },
    "animation-fill-mode": {
      syntax: "<single-animation-fill-mode>#",
      media: "visual",
      inherited: false,
      animationType: "notAnimatable",
      percentages: "no",
      groups: [
        "CSS Animations"
      ],
      initial: "none",
      appliesto: "allElementsAndPseudos",
      computed: "asSpecified",
      order: "uniqueOrder",
      status: "standard",
      mdn_url: "https://developer.mozilla.org/docs/Web/CSS/animation-fill-mode"
    },
    "animation-iteration-count": {
      syntax: "<single-animation-iteration-count>#",
      media: "visual",
      inherited: false,
      animationType: "notAnimatable",
      percentages: "no",
      groups: [
        "CSS Animations"
      ],
      initial: "1",
      appliesto: "allElementsAndPseudos",
      computed: "asSpecified",
      order: "uniqueOrder",
      status: "standard",
      mdn_url: "https://developer.mozilla.org/docs/Web/CSS/animation-iteration-count"
    },
    "animation-name": {
      syntax: "[ none | <keyframes-name> ]#",
      media: "visual",
      inherited: false,
      animationType: "notAnimatable",
      percentages: "no",
      groups: [
        "CSS Animations"
      ],
      initial: "none",
      appliesto: "allElementsAndPseudos",
      computed: "asSpecified",
      order: "uniqueOrder",
      status: "standard",
      mdn_url: "https://developer.mozilla.org/docs/Web/CSS/animation-name"
    },
    "animation-play-state": {
      syntax: "<single-animation-play-state>#",
      media: "visual",
      inherited: false,
      animationType: "notAnimatable",
      percentages: "no",
      groups: [
        "CSS Animations"
      ],
      initial: "running",
      appliesto: "allElementsAndPseudos",
      computed: "asSpecified",
      order: "uniqueOrder",
      status: "standard",
      mdn_url: "https://developer.mozilla.org/docs/Web/CSS/animation-play-state"
    },
    "animation-timing-function": {
      syntax: "<easing-function>#",
      media: "visual",
      inherited: false,
      animationType: "notAnimatable",
      percentages: "no",
      groups: [
        "CSS Animations"
      ],
      initial: "ease",
      appliesto: "allElementsAndPseudos",
      computed: "asSpecified",
      order: "uniqueOrder",
      status: "standard",
      mdn_url: "https://developer.mozilla.org/docs/Web/CSS/animation-timing-function"
    },
    "animation-timeline": {
      syntax: "<single-animation-timeline>#",
      media: "visual",
      inherited: false,
      animationType: "notAnimatable",
      percentages: "no",
      groups: [
        "CSS Animations"
      ],
      initial: "auto",
      appliesto: "allElements",
      computed: "listEachItemIdentifyerOrNoneAuto",
      order: "uniqueOrder",
      status: "experimental",
      mdn_url: "https://developer.mozilla.org/docs/Web/CSS/animation-timeline"
    },
    appearance: {
      syntax: "none | auto | textfield | menulist-button | <compat-auto>",
      media: "all",
      inherited: false,
      animationType: "discrete",
      percentages: "no",
      groups: [
        "CSS Basic User Interface"
      ],
      initial: "none",
      appliesto: "allElements",
      computed: "asSpecified",
      order: "perGrammar",
      status: "experimental",
      mdn_url: "https://developer.mozilla.org/docs/Web/CSS/appearance"
    },
    "aspect-ratio": {
      syntax: "auto | <ratio>",
      media: "all",
      inherited: false,
      animationType: "discrete",
      percentages: "no",
      groups: [
        "CSS Basic User Interface"
      ],
      initial: "auto",
      appliesto: "allElementsExceptInlineBoxesAndInternalRubyOrTableBoxes",
      computed: "asSpecified",
      order: "perGrammar",
      status: "experimental",
      mdn_url: "https://developer.mozilla.org/docs/Web/CSS/aspect-ratio"
    },
    azimuth: {
      syntax: "<angle> | [ [ left-side | far-left | left | center-left | center | center-right | right | far-right | right-side ] || behind ] | leftwards | rightwards",
      media: "aural",
      inherited: true,
      animationType: "discrete",
      percentages: "no",
      groups: [
        "CSS Speech"
      ],
      initial: "center",
      appliesto: "allElements",
      computed: "normalizedAngle",
      order: "orderOfAppearance",
      status: "obsolete",
      mdn_url: "https://developer.mozilla.org/docs/Web/CSS/azimuth"
    },
    "backdrop-filter": {
      syntax: "none | <filter-function-list>",
      media: "visual",
      inherited: false,
      animationType: "filterList",
      percentages: "no",
      groups: [
        "Filter Effects"
      ],
      initial: "none",
      appliesto: "allElementsSVGContainerElements",
      computed: "asSpecified",
      order: "uniqueOrder",
      status: "standard",
      mdn_url: "https://developer.mozilla.org/docs/Web/CSS/backdrop-filter"
    },
    "backface-visibility": {
      syntax: "visible | hidden",
      media: "visual",
      inherited: false,
      animationType: "discrete",
      percentages: "no",
      groups: [
        "CSS Transforms"
      ],
      initial: "visible",
      appliesto: "transformableElements",
      computed: "asSpecified",
      order: "uniqueOrder",
      status: "standard",
      mdn_url: "https://developer.mozilla.org/docs/Web/CSS/backface-visibility"
    },
    background: {
      syntax: "[ <bg-layer> , ]* <final-bg-layer>",
      media: "visual",
      inherited: false,
      animationType: [
        "background-color",
        "background-image",
        "background-clip",
        "background-position",
        "background-size",
        "background-repeat",
        "background-attachment"
      ],
      percentages: [
        "background-position",
        "background-size"
      ],
      groups: [
        "CSS Backgrounds and Borders"
      ],
      initial: [
        "background-image",
        "background-position",
        "background-size",
        "background-repeat",
        "background-origin",
        "background-clip",
        "background-attachment",
        "background-color"
      ],
      appliesto: "allElements",
      computed: [
        "background-image",
        "background-position",
        "background-size",
        "background-repeat",
        "background-origin",
        "background-clip",
        "background-attachment",
        "background-color"
      ],
      order: "orderOfAppearance",
      alsoAppliesTo: [
        "::first-letter",
        "::first-line",
        "::placeholder"
      ],
      status: "standard",
      mdn_url: "https://developer.mozilla.org/docs/Web/CSS/background"
    },
    "background-attachment": {
      syntax: "<attachment>#",
      media: "visual",
      inherited: false,
      animationType: "discrete",
      percentages: "no",
      groups: [
        "CSS Backgrounds and Borders"
      ],
      initial: "scroll",
      appliesto: "allElements",
      computed: "asSpecified",
      order: "uniqueOrder",
      alsoAppliesTo: [
        "::first-letter",
        "::first-line",
        "::placeholder"
      ],
      status: "standard",
      mdn_url: "https://developer.mozilla.org/docs/Web/CSS/background-attachment"
    },
    "background-blend-mode": {
      syntax: "<blend-mode>#",
      media: "none",
      inherited: false,
      animationType: "discrete",
      percentages: "no",
      groups: [
        "Compositing and Blending"
      ],
      initial: "normal",
      appliesto: "allElementsSVGContainerGraphicsAndGraphicsReferencingElements",
      computed: "asSpecified",
      order: "uniqueOrder",
      alsoAppliesTo: [
        "::first-letter",
        "::first-line",
        "::placeholder"
      ],
      status: "standard",
      mdn_url: "https://developer.mozilla.org/docs/Web/CSS/background-blend-mode"
    },
    "background-clip": {
      syntax: "<box>#",
      media: "visual",
      inherited: false,
      animationType: "discrete",
      percentages: "no",
      groups: [
        "CSS Backgrounds and Borders"
      ],
      initial: "border-box",
      appliesto: "allElements",
      computed: "asSpecified",
      order: "uniqueOrder",
      alsoAppliesTo: [
        "::first-letter",
        "::first-line",
        "::placeholder"
      ],
      status: "standard",
      mdn_url: "https://developer.mozilla.org/docs/Web/CSS/background-clip"
    },
    "background-color": {
      syntax: "<color>",
      media: "visual",
      inherited: false,
      animationType: "color",
      percentages: "no",
      groups: [
        "CSS Backgrounds and Borders"
      ],
      initial: "transparent",
      appliesto: "allElements",
      computed: "computedColor",
      order: "uniqueOrder",
      alsoAppliesTo: [
        "::first-letter",
        "::first-line",
        "::placeholder"
      ],
      status: "standard",
      mdn_url: "https://developer.mozilla.org/docs/Web/CSS/background-color"
    },
    "background-image": {
      syntax: "<bg-image>#",
      media: "visual",
      inherited: false,
      animationType: "discrete",
      percentages: "no",
      groups: [
        "CSS Backgrounds and Borders"
      ],
      initial: "none",
      appliesto: "allElements",
      computed: "asSpecifiedURLsAbsolute",
      order: "uniqueOrder",
      alsoAppliesTo: [
        "::first-letter",
        "::first-line",
        "::placeholder"
      ],
      status: "standard",
      mdn_url: "https://developer.mozilla.org/docs/Web/CSS/background-image"
    },
    "background-origin": {
      syntax: "<box>#",
      media: "visual",
      inherited: false,
      animationType: "discrete",
      percentages: "no",
      groups: [
        "CSS Backgrounds and Borders"
      ],
      initial: "padding-box",
      appliesto: "allElements",
      computed: "asSpecified",
      order: "uniqueOrder",
      alsoAppliesTo: [
        "::first-letter",
        "::first-line",
        "::placeholder"
      ],
      status: "standard",
      mdn_url: "https://developer.mozilla.org/docs/Web/CSS/background-origin"
    },
    "background-position": {
      syntax: "<bg-position>#",
      media: "visual",
      inherited: false,
      animationType: "repeatableListOfSimpleListOfLpc",
      percentages: "referToSizeOfBackgroundPositioningAreaMinusBackgroundImageSize",
      groups: [
        "CSS Backgrounds and Borders"
      ],
      initial: "0% 0%",
      appliesto: "allElements",
      computed: [
        "background-position-x",
        "background-position-y"
      ],
      order: "uniqueOrder",
      alsoAppliesTo: [
        "::first-letter",
        "::first-line",
        "::placeholder"
      ],
      status: "standard",
      mdn_url: "https://developer.mozilla.org/docs/Web/CSS/background-position"
    },
    "background-position-x": {
      syntax: "[ center | [ [ left | right | x-start | x-end ]? <length-percentage>? ]! ]#",
      media: "visual",
      inherited: false,
      animationType: "discrete",
      percentages: "referToWidthOfBackgroundPositioningAreaMinusBackgroundImageHeight",
      groups: [
        "CSS Backgrounds and Borders"
      ],
      initial: "0%",
      appliesto: "allElements",
      computed: "listEachItemConsistingOfAbsoluteLengthPercentageAndOrigin",
      order: "uniqueOrder",
      status: "experimental",
      mdn_url: "https://developer.mozilla.org/docs/Web/CSS/background-position-x"
    },
    "background-position-y": {
      syntax: "[ center | [ [ top | bottom | y-start | y-end ]? <length-percentage>? ]! ]#",
      media: "visual",
      inherited: false,
      animationType: "discrete",
      percentages: "referToHeightOfBackgroundPositioningAreaMinusBackgroundImageHeight",
      groups: [
        "CSS Backgrounds and Borders"
      ],
      initial: "0%",
      appliesto: "allElements",
      computed: "listEachItemConsistingOfAbsoluteLengthPercentageAndOrigin",
      order: "uniqueOrder",
      status: "experimental",
      mdn_url: "https://developer.mozilla.org/docs/Web/CSS/background-position-y"
    },
    "background-repeat": {
      syntax: "<repeat-style>#",
      media: "visual",
      inherited: false,
      animationType: "discrete",
      percentages: "no",
      groups: [
        "CSS Backgrounds and Borders"
      ],
      initial: "repeat",
      appliesto: "allElements",
      computed: "listEachItemHasTwoKeywordsOnePerDimension",
      order: "uniqueOrder",
      alsoAppliesTo: [
        "::first-letter",
        "::first-line",
        "::placeholder"
      ],
      status: "standard",
      mdn_url: "https://developer.mozilla.org/docs/Web/CSS/background-repeat"
    },
    "background-size": {
      syntax: "<bg-size>#",
      media: "visual",
      inherited: false,
      animationType: "repeatableListOfSimpleListOfLpc",
      percentages: "relativeToBackgroundPositioningArea",
      groups: [
        "CSS Backgrounds and Borders"
      ],
      initial: "auto auto",
      appliesto: "allElements",
      computed: "asSpecifiedRelativeToAbsoluteLengths",
      order: "uniqueOrder",
      alsoAppliesTo: [
        "::first-letter",
        "::first-line",
        "::placeholder"
      ],
      status: "standard",
      mdn_url: "https://developer.mozilla.org/docs/Web/CSS/background-size"
    },
    "block-overflow": {
      syntax: "clip | ellipsis | <string>",
      media: "visual",
      inherited: true,
      animationType: "discrete",
      percentages: "no",
      groups: [
        "CSS Overflow"
      ],
      initial: "clip",
      appliesto: "blockContainers",
      computed: "asSpecified",
      order: "perGrammar",
      status: "experimental"
    },
    "block-size": {
      syntax: "<'width'>",
      media: "visual",
      inherited: false,
      animationType: "lpc",
      percentages: "blockSizeOfContainingBlock",
      groups: [
        "CSS Logical Properties"
      ],
      initial: "auto",
      appliesto: "sameAsWidthAndHeight",
      computed: "sameAsWidthAndHeight",
      order: "uniqueOrder",
      status: "standard",
      mdn_url: "https://developer.mozilla.org/docs/Web/CSS/block-size"
    },
    border: {
      syntax: "<line-width> || <line-style> || <color>",
      media: "visual",
      inherited: false,
      animationType: [
        "border-color",
        "border-style",
        "border-width"
      ],
      percentages: "no",
      groups: [
        "CSS Backgrounds and Borders"
      ],
      initial: [
        "border-width",
        "border-style",
        "border-color"
      ],
      appliesto: "allElements",
      computed: [
        "border-width",
        "border-style",
        "border-color"
      ],
      order: "orderOfAppearance",
      alsoAppliesTo: [
        "::first-letter"
      ],
      status: "standard",
      mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border"
    },
    "border-block": {
      syntax: "<'border-top-width'> || <'border-top-style'> || <color>",
      media: "visual",
      inherited: false,
      animationType: "discrete",
      percentages: "no",
      groups: [
        "CSS Logical Properties"
      ],
      initial: [
        "border-top-width",
        "border-top-style",
        "border-top-color"
      ],
      appliesto: "allElements",
      computed: [
        "border-top-width",
        "border-top-style",
        "border-top-color"
      ],
      order: "uniqueOrder",
      status: "standard",
      mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-block"
    },
    "border-block-color": {
      syntax: "<'border-top-color'>{1,2}",
      media: "visual",
      inherited: false,
      animationType: "discrete",
      percentages: "no",
      groups: [
        "CSS Logical Properties"
      ],
      initial: "currentcolor",
      appliesto: "allElements",
      computed: "computedColor",
      order: "uniqueOrder",
      status: "standard",
      mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-block-color"
    },
    "border-block-style": {
      syntax: "<'border-top-style'>",
      media: "visual",
      inherited: false,
      animationType: "discrete",
      percentages: "no",
      groups: [
        "CSS Logical Properties"
      ],
      initial: "none",
      appliesto: "allElements",
      computed: "asSpecified",
      order: "uniqueOrder",
      status: "standard",
      mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-block-style"
    },
    "border-block-width": {
      syntax: "<'border-top-width'>",
      media: "visual",
      inherited: false,
      animationType: "discrete",
      percentages: "logicalWidthOfContainingBlock",
      groups: [
        "CSS Logical Properties"
      ],
      initial: "medium",
      appliesto: "allElements",
      computed: "absoluteLengthZeroIfBorderStyleNoneOrHidden",
      order: "uniqueOrder",
      status: "standard",
      mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-block-width"
    },
    "border-block-end": {
      syntax: "<'border-top-width'> || <'border-top-style'> || <color>",
      media: "visual",
      inherited: false,
      animationType: [
        "border-block-end-color",
        "border-block-end-style",
        "border-block-end-width"
      ],
      percentages: "no",
      groups: [
        "CSS Logical Properties"
      ],
      initial: [
        "border-top-width",
        "border-top-style",
        "border-top-color"
      ],
      appliesto: "allElements",
      computed: [
        "border-top-width",
        "border-top-style",
        "border-top-color"
      ],
      order: "uniqueOrder",
      status: "standard",
      mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-block-end"
    },
    "border-block-end-color": {
      syntax: "<'border-top-color'>",
      media: "visual",
      inherited: false,
      animationType: "color",
      percentages: "no",
      groups: [
        "CSS Logical Properties"
      ],
      initial: "currentcolor",
      appliesto: "allElements",
      computed: "computedColor",
      order: "uniqueOrder",
      status: "standard",
      mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-block-end-color"
    },
    "border-block-end-style": {
      syntax: "<'border-top-style'>",
      media: "visual",
      inherited: false,
      animationType: "discrete",
      percentages: "no",
      groups: [
        "CSS Logical Properties"
      ],
      initial: "none",
      appliesto: "allElements",
      computed: "asSpecified",
      order: "uniqueOrder",
      status: "standard",
      mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-block-end-style"
    },
    "border-block-end-width": {
      syntax: "<'border-top-width'>",
      media: "visual",
      inherited: false,
      animationType: "length",
      percentages: "logicalWidthOfContainingBlock",
      groups: [
        "CSS Logical Properties"
      ],
      initial: "medium",
      appliesto: "allElements",
      computed: "absoluteLengthZeroIfBorderStyleNoneOrHidden",
      order: "uniqueOrder",
      status: "standard",
      mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-block-end-width"
    },
    "border-block-start": {
      syntax: "<'border-top-width'> || <'border-top-style'> || <color>",
      media: "visual",
      inherited: false,
      animationType: [
        "border-block-start-color",
        "border-block-start-style",
        "border-block-start-width"
      ],
      percentages: "no",
      groups: [
        "CSS Logical Properties"
      ],
      initial: [
        "border-width",
        "border-style",
        "color"
      ],
      appliesto: "allElements",
      computed: [
        "border-width",
        "border-style",
        "border-block-start-color"
      ],
      order: "uniqueOrder",
      status: "standard",
      mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-block-start"
    },
    "border-block-start-color": {
      syntax: "<'border-top-color'>",
      media: "visual",
      inherited: false,
      animationType: "color",
      percentages: "no",
      groups: [
        "CSS Logical Properties"
      ],
      initial: "currentcolor",
      appliesto: "allElements",
      computed: "computedColor",
      order: "uniqueOrder",
      status: "standard",
      mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-block-start-color"
    },
    "border-block-start-style": {
      syntax: "<'border-top-style'>",
      media: "visual",
      inherited: false,
      animationType: "discrete",
      percentages: "no",
      groups: [
        "CSS Logical Properties"
      ],
      initial: "none",
      appliesto: "allElements",
      computed: "asSpecified",
      order: "uniqueOrder",
      status: "standard",
      mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-block-start-style"
    },
    "border-block-start-width": {
      syntax: "<'border-top-width'>",
      media: "visual",
      inherited: false,
      animationType: "length",
      percentages: "logicalWidthOfContainingBlock",
      groups: [
        "CSS Logical Properties"
      ],
      initial: "medium",
      appliesto: "allElements",
      computed: "absoluteLengthZeroIfBorderStyleNoneOrHidden",
      order: "uniqueOrder",
      status: "standard",
      mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-block-start-width"
    },
    "border-bottom": {
      syntax: "<line-width> || <line-style> || <color>",
      media: "visual",
      inherited: false,
      animationType: [
        "border-bottom-color",
        "border-bottom-style",
        "border-bottom-width"
      ],
      percentages: "no",
      groups: [
        "CSS Backgrounds and Borders"
      ],
      initial: [
        "border-bottom-width",
        "border-bottom-style",
        "border-bottom-color"
      ],
      appliesto: "allElements",
      computed: [
        "border-bottom-width",
        "border-bottom-style",
        "border-bottom-color"
      ],
      order: "orderOfAppearance",
      alsoAppliesTo: [
        "::first-letter"
      ],
      status: "standard",
      mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-bottom"
    },
    "border-bottom-color": {
      syntax: "<'border-top-color'>",
      media: "visual",
      inherited: false,
      animationType: "color",
      percentages: "no",
      groups: [
        "CSS Backgrounds and Borders"
      ],
      initial: "currentcolor",
      appliesto: "allElements",
      computed: "computedColor",
      order: "uniqueOrder",
      alsoAppliesTo: [
        "::first-letter"
      ],
      status: "standard",
      mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-bottom-color"
    },
    "border-bottom-left-radius": {
      syntax: "<length-percentage>{1,2}",
      media: "visual",
      inherited: false,
      animationType: "lpc",
      percentages: "referToDimensionOfBorderBox",
      groups: [
        "CSS Backgrounds and Borders"
      ],
      initial: "0",
      appliesto: "allElementsUAsNotRequiredWhenCollapse",
      computed: "twoAbsoluteLengthOrPercentages",
      order: "uniqueOrder",
      alsoAppliesTo: [
        "::first-letter"
      ],
      status: "standard",
      mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-bottom-left-radius"
    },
    "border-bottom-right-radius": {
      syntax: "<length-percentage>{1,2}",
      media: "visual",
      inherited: false,
      animationType: "lpc",
      percentages: "referToDimensionOfBorderBox",
      groups: [
        "CSS Backgrounds and Borders"
      ],
      initial: "0",
      appliesto: "allElementsUAsNotRequiredWhenCollapse",
      computed: "twoAbsoluteLengthOrPercentages",
      order: "uniqueOrder",
      alsoAppliesTo: [
        "::first-letter"
      ],
      status: "standard",
      mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-bottom-right-radius"
    },
    "border-bottom-style": {
      syntax: "<line-style>",
      media: "visual",
      inherited: false,
      animationType: "discrete",
      percentages: "no",
      groups: [
        "CSS Backgrounds and Borders"
      ],
      initial: "none",
      appliesto: "allElements",
      computed: "asSpecified",
      order: "uniqueOrder",
      alsoAppliesTo: [
        "::first-letter"
      ],
      status: "standard",
      mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-bottom-style"
    },
    "border-bottom-width": {
      syntax: "<line-width>",
      media: "visual",
      inherited: false,
      animationType: "length",
      percentages: "no",
      groups: [
        "CSS Backgrounds and Borders"
      ],
      initial: "medium",
      appliesto: "allElements",
      computed: "absoluteLengthOr0IfBorderBottomStyleNoneOrHidden",
      order: "uniqueOrder",
      alsoAppliesTo: [
        "::first-letter"
      ],
      status: "standard",
      mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-bottom-width"
    },
    "border-collapse": {
      syntax: "collapse | separate",
      media: "visual",
      inherited: true,
      animationType: "discrete",
      percentages: "no",
      groups: [
        "CSS Table"
      ],
      initial: "separate",
      appliesto: "tableElements",
      computed: "asSpecified",
      order: "uniqueOrder",
      status: "standard",
      mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-collapse"
    },
    "border-color": {
      syntax: "<color>{1,4}",
      media: "visual",
      inherited: false,
      animationType: [
        "border-bottom-color",
        "border-left-color",
        "border-right-color",
        "border-top-color"
      ],
      percentages: "no",
      groups: [
        "CSS Backgrounds and Borders"
      ],
      initial: [
        "border-top-color",
        "border-right-color",
        "border-bottom-color",
        "border-left-color"
      ],
      appliesto: "allElements",
      computed: [
        "border-bottom-color",
        "border-left-color",
        "border-right-color",
        "border-top-color"
      ],
      order: "uniqueOrder",
      alsoAppliesTo: [
        "::first-letter"
      ],
      status: "standard",
      mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-color"
    },
    "border-end-end-radius": {
      syntax: "<length-percentage>{1,2}",
      media: "visual",
      inherited: false,
      animationType: "lpc",
      percentages: "referToDimensionOfBorderBox",
      groups: [
        "CSS Logical Properties"
      ],
      initial: "0",
      appliesto: "allElementsUAsNotRequiredWhenCollapse",
      computed: "twoAbsoluteLengthOrPercentages",
      order: "uniqueOrder",
      alsoAppliesTo: [
        "::first-letter"
      ],
      status: "standard",
      mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-end-end-radius"
    },
    "border-end-start-radius": {
      syntax: "<length-percentage>{1,2}",
      media: "visual",
      inherited: false,
      animationType: "lpc",
      percentages: "referToDimensionOfBorderBox",
      groups: [
        "CSS Logical Properties"
      ],
      initial: "0",
      appliesto: "allElementsUAsNotRequiredWhenCollapse",
      computed: "twoAbsoluteLengthOrPercentages",
      order: "uniqueOrder",
      alsoAppliesTo: [
        "::first-letter"
      ],
      status: "standard",
      mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-end-start-radius"
    },
    "border-image": {
      syntax: "<'border-image-source'> || <'border-image-slice'> [ / <'border-image-width'> | / <'border-image-width'>? / <'border-image-outset'> ]? || <'border-image-repeat'>",
      media: "visual",
      inherited: false,
      animationType: "discrete",
      percentages: [
        "border-image-slice",
        "border-image-width"
      ],
      groups: [
        "CSS Backgrounds and Borders"
      ],
      initial: [
        "border-image-source",
        "border-image-slice",
        "border-image-width",
        "border-image-outset",
        "border-image-repeat"
      ],
      appliesto: "allElementsExceptTableElementsWhenCollapse",
      computed: [
        "border-image-outset",
        "border-image-repeat",
        "border-image-slice",
        "border-image-source",
        "border-image-width"
      ],
      order: "uniqueOrder",
      alsoAppliesTo: [
        "::first-letter"
      ],
      status: "standard",
      mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-image"
    },
    "border-image-outset": {
      syntax: "[ <length> | <number> ]{1,4}",
      media: "visual",
      inherited: false,
      animationType: "byComputedValueType",
      percentages: "no",
      groups: [
        "CSS Backgrounds and Borders"
      ],
      initial: "0",
      appliesto: "allElementsExceptTableElementsWhenCollapse",
      computed: "asSpecifiedRelativeToAbsoluteLengths",
      order: "uniqueOrder",
      alsoAppliesTo: [
        "::first-letter"
      ],
      status: "standard",
      mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-image-outset"
    },
    "border-image-repeat": {
      syntax: "[ stretch | repeat | round | space ]{1,2}",
      media: "visual",
      inherited: false,
      animationType: "discrete",
      percentages: "no",
      groups: [
        "CSS Backgrounds and Borders"
      ],
      initial: "stretch",
      appliesto: "allElementsExceptTableElementsWhenCollapse",
      computed: "asSpecified",
      order: "uniqueOrder",
      alsoAppliesTo: [
        "::first-letter"
      ],
      status: "standard",
      mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-image-repeat"
    },
    "border-image-slice": {
      syntax: "<number-percentage>{1,4} && fill?",
      media: "visual",
      inherited: false,
      animationType: "byComputedValueType",
      percentages: "referToSizeOfBorderImage",
      groups: [
        "CSS Backgrounds and Borders"
      ],
      initial: "100%",
      appliesto: "allElementsExceptTableElementsWhenCollapse",
      computed: "oneToFourPercentagesOrAbsoluteLengthsPlusFill",
      order: "percentagesOrLengthsFollowedByFill",
      alsoAppliesTo: [
        "::first-letter"
      ],
      status: "standard",
      mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-image-slice"
    },
    "border-image-source": {
      syntax: "none | <image>",
      media: "visual",
      inherited: false,
      animationType: "discrete",
      percentages: "no",
      groups: [
        "CSS Backgrounds and Borders"
      ],
      initial: "none",
      appliesto: "allElementsExceptTableElementsWhenCollapse",
      computed: "noneOrImageWithAbsoluteURI",
      order: "uniqueOrder",
      alsoAppliesTo: [
        "::first-letter"
      ],
      status: "standard",
      mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-image-source"
    },
    "border-image-width": {
      syntax: "[ <length-percentage> | <number> | auto ]{1,4}",
      media: "visual",
      inherited: false,
      animationType: "byComputedValueType",
      percentages: "referToWidthOrHeightOfBorderImageArea",
      groups: [
        "CSS Backgrounds and Borders"
      ],
      initial: "1",
      appliesto: "allElementsExceptTableElementsWhenCollapse",
      computed: "asSpecifiedRelativeToAbsoluteLengths",
      order: "uniqueOrder",
      alsoAppliesTo: [
        "::first-letter"
      ],
      status: "standard",
      mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-image-width"
    },
    "border-inline": {
      syntax: "<'border-top-width'> || <'border-top-style'> || <color>",
      media: "visual",
      inherited: false,
      animationType: "discrete",
      percentages: "no",
      groups: [
        "CSS Logical Properties"
      ],
      initial: [
        "border-top-width",
        "border-top-style",
        "border-top-color"
      ],
      appliesto: "allElements",
      computed: [
        "border-top-width",
        "border-top-style",
        "border-top-color"
      ],
      order: "uniqueOrder",
      status: "standard",
      mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-inline"
    },
    "border-inline-end": {
      syntax: "<'border-top-width'> || <'border-top-style'> || <color>",
      media: "visual",
      inherited: false,
      animationType: [
        "border-inline-end-color",
        "border-inline-end-style",
        "border-inline-end-width"
      ],
      percentages: "no",
      groups: [
        "CSS Logical Properties"
      ],
      initial: [
        "border-width",
        "border-style",
        "color"
      ],
      appliesto: "allElements",
      computed: [
        "border-width",
        "border-style",
        "border-inline-end-color"
      ],
      order: "uniqueOrder",
      status: "standard",
      mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-inline-end"
    },
    "border-inline-color": {
      syntax: "<'border-top-color'>{1,2}",
      media: "visual",
      inherited: false,
      animationType: "discrete",
      percentages: "no",
      groups: [
        "CSS Logical Properties"
      ],
      initial: "currentcolor",
      appliesto: "allElements",
      computed: "computedColor",
      order: "uniqueOrder",
      status: "standard",
      mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-inline-color"
    },
    "border-inline-style": {
      syntax: "<'border-top-style'>",
      media: "visual",
      inherited: false,
      animationType: "discrete",
      percentages: "no",
      groups: [
        "CSS Logical Properties"
      ],
      initial: "none",
      appliesto: "allElements",
      computed: "asSpecified",
      order: "uniqueOrder",
      status: "standard",
      mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-inline-style"
    },
    "border-inline-width": {
      syntax: "<'border-top-width'>",
      media: "visual",
      inherited: false,
      animationType: "discrete",
      percentages: "logicalWidthOfContainingBlock",
      groups: [
        "CSS Logical Properties"
      ],
      initial: "medium",
      appliesto: "allElements",
      computed: "absoluteLengthZeroIfBorderStyleNoneOrHidden",
      order: "uniqueOrder",
      status: "standard",
      mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-inline-width"
    },
    "border-inline-end-color": {
      syntax: "<'border-top-color'>",
      media: "visual",
      inherited: false,
      animationType: "color",
      percentages: "no",
      groups: [
        "CSS Logical Properties"
      ],
      initial: "currentcolor",
      appliesto: "allElements",
      computed: "computedColor",
      order: "uniqueOrder",
      status: "standard",
      mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-inline-end-color"
    },
    "border-inline-end-style": {
      syntax: "<'border-top-style'>",
      media: "visual",
      inherited: false,
      animationType: "discrete",
      percentages: "no",
      groups: [
        "CSS Logical Properties"
      ],
      initial: "none",
      appliesto: "allElements",
      computed: "asSpecified",
      order: "uniqueOrder",
      status: "standard",
      mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-inline-end-style"
    },
    "border-inline-end-width": {
      syntax: "<'border-top-width'>",
      media: "visual",
      inherited: false,
      animationType: "length",
      percentages: "logicalWidthOfContainingBlock",
      groups: [
        "CSS Logical Properties"
      ],
      initial: "medium",
      appliesto: "allElements",
      computed: "absoluteLengthZeroIfBorderStyleNoneOrHidden",
      order: "uniqueOrder",
      status: "standard",
      mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-inline-end-width"
    },
    "border-inline-start": {
      syntax: "<'border-top-width'> || <'border-top-style'> || <color>",
      media: "visual",
      inherited: false,
      animationType: [
        "border-inline-start-color",
        "border-inline-start-style",
        "border-inline-start-width"
      ],
      percentages: "no",
      groups: [
        "CSS Logical Properties"
      ],
      initial: [
        "border-width",
        "border-style",
        "color"
      ],
      appliesto: "allElements",
      computed: [
        "border-width",
        "border-style",
        "border-inline-start-color"
      ],
      order: "uniqueOrder",
      status: "standard",
      mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-inline-start"
    },
    "border-inline-start-color": {
      syntax: "<'border-top-color'>",
      media: "visual",
      inherited: false,
      animationType: "color",
      percentages: "no",
      groups: [
        "CSS Logical Properties"
      ],
      initial: "currentcolor",
      appliesto: "allElements",
      computed: "computedColor",
      order: "uniqueOrder",
      status: "standard",
      mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-inline-start-color"
    },
    "border-inline-start-style": {
      syntax: "<'border-top-style'>",
      media: "visual",
      inherited: false,
      animationType: "discrete",
      percentages: "no",
      groups: [
        "CSS Logical Properties"
      ],
      initial: "none",
      appliesto: "allElements",
      computed: "asSpecified",
      order: "uniqueOrder",
      status: "standard",
      mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-inline-start-style"
    },
    "border-inline-start-width": {
      syntax: "<'border-top-width'>",
      media: "visual",
      inherited: false,
      animationType: "length",
      percentages: "logicalWidthOfContainingBlock",
      groups: [
        "CSS Logical Properties"
      ],
      initial: "medium",
      appliesto: "allElements",
      computed: "absoluteLengthZeroIfBorderStyleNoneOrHidden",
      order: "uniqueOrder",
      status: "standard",
      mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-inline-start-width"
    },
    "border-left": {
      syntax: "<line-width> || <line-style> || <color>",
      media: "visual",
      inherited: false,
      animationType: [
        "border-left-color",
        "border-left-style",
        "border-left-width"
      ],
      percentages: "no",
      groups: [
        "CSS Backgrounds and Borders"
      ],
      initial: [
        "border-left-width",
        "border-left-style",
        "border-left-color"
      ],
      appliesto: "allElements",
      computed: [
        "border-left-width",
        "border-left-style",
        "border-left-color"
      ],
      order: "orderOfAppearance",
      alsoAppliesTo: [
        "::first-letter"
      ],
      status: "standard",
      mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-left"
    },
    "border-left-color": {
      syntax: "<color>",
      media: "visual",
      inherited: false,
      animationType: "color",
      percentages: "no",
      groups: [
        "CSS Backgrounds and Borders"
      ],
      initial: "currentcolor",
      appliesto: "allElements",
      computed: "computedColor",
      order: "uniqueOrder",
      alsoAppliesTo: [
        "::first-letter"
      ],
      status: "standard",
      mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-left-color"
    },
    "border-left-style": {
      syntax: "<line-style>",
      media: "visual",
      inherited: false,
      animationType: "discrete",
      percentages: "no",
      groups: [
        "CSS Backgrounds and Borders"
      ],
      initial: "none",
      appliesto: "allElements",
      computed: "asSpecified",
      order: "uniqueOrder",
      alsoAppliesTo: [
        "::first-letter"
      ],
      status: "standard",
      mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-left-style"
    },
    "border-left-width": {
      syntax: "<line-width>",
      media: "visual",
      inherited: false,
      animationType: "length",
      percentages: "no",
      groups: [
        "CSS Backgrounds and Borders"
      ],
      initial: "medium",
      appliesto: "allElements",
      computed: "absoluteLengthOr0IfBorderLeftStyleNoneOrHidden",
      order: "uniqueOrder",
      alsoAppliesTo: [
        "::first-letter"
      ],
      status: "standard",
      mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-left-width"
    },
    "border-radius": {
      syntax: "<length-percentage>{1,4} [ / <length-percentage>{1,4} ]?",
      media: "visual",
      inherited: false,
      animationType: [
        "border-top-left-radius",
        "border-top-right-radius",
        "border-bottom-right-radius",
        "border-bottom-left-radius"
      ],
      percentages: "referToDimensionOfBorderBox",
      groups: [
        "CSS Backgrounds and Borders"
      ],
      initial: [
        "border-top-left-radius",
        "border-top-right-radius",
        "border-bottom-right-radius",
        "border-bottom-left-radius"
      ],
      appliesto: "allElementsUAsNotRequiredWhenCollapse",
      computed: [
        "border-bottom-left-radius",
        "border-bottom-right-radius",
        "border-top-left-radius",
        "border-top-right-radius"
      ],
      order: "uniqueOrder",
      alsoAppliesTo: [
        "::first-letter"
      ],
      status: "standard",
      mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-radius"
    },
    "border-right": {
      syntax: "<line-width> || <line-style> || <color>",
      media: "visual",
      inherited: false,
      animationType: [
        "border-right-color",
        "border-right-style",
        "border-right-width"
      ],
      percentages: "no",
      groups: [
        "CSS Backgrounds and Borders"
      ],
      initial: [
        "border-right-width",
        "border-right-style",
        "border-right-color"
      ],
      appliesto: "allElements",
      computed: [
        "border-right-width",
        "border-right-style",
        "border-right-color"
      ],
      order: "orderOfAppearance",
      alsoAppliesTo: [
        "::first-letter"
      ],
      status: "standard",
      mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-right"
    },
    "border-right-color": {
      syntax: "<color>",
      media: "visual",
      inherited: false,
      animationType: "color",
      percentages: "no",
      groups: [
        "CSS Backgrounds and Borders"
      ],
      initial: "currentcolor",
      appliesto: "allElements",
      computed: "computedColor",
      order: "uniqueOrder",
      alsoAppliesTo: [
        "::first-letter"
      ],
      status: "standard",
      mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-right-color"
    },
    "border-right-style": {
      syntax: "<line-style>",
      media: "visual",
      inherited: false,
      animationType: "discrete",
      percentages: "no",
      groups: [
        "CSS Backgrounds and Borders"
      ],
      initial: "none",
      appliesto: "allElements",
      computed: "asSpecified",
      order: "uniqueOrder",
      alsoAppliesTo: [
        "::first-letter"
      ],
      status: "standard",
      mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-right-style"
    },
    "border-right-width": {
      syntax: "<line-width>",
      media: "visual",
      inherited: false,
      animationType: "length",
      percentages: "no",
      groups: [
        "CSS Backgrounds and Borders"
      ],
      initial: "medium",
      appliesto: "allElements",
      computed: "absoluteLengthOr0IfBorderRightStyleNoneOrHidden",
      order: "uniqueOrder",
      alsoAppliesTo: [
        "::first-letter"
      ],
      status: "standard",
      mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-right-width"
    },
    "border-spacing": {
      syntax: "<length> <length>?",
      media: "visual",
      inherited: true,
      animationType: "discrete",
      percentages: "no",
      groups: [
        "CSS Table"
      ],
      initial: "0",
      appliesto: "tableElements",
      computed: "twoAbsoluteLengths",
      order: "uniqueOrder",
      status: "standard",
      mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-spacing"
    },
    "border-start-end-radius": {
      syntax: "<length-percentage>{1,2}",
      media: "visual",
      inherited: false,
      animationType: "lpc",
      percentages: "referToDimensionOfBorderBox",
      groups: [
        "CSS Logical Properties"
      ],
      initial: "0",
      appliesto: "allElementsUAsNotRequiredWhenCollapse",
      computed: "twoAbsoluteLengthOrPercentages",
      order: "uniqueOrder",
      alsoAppliesTo: [
        "::first-letter"
      ],
      status: "standard",
      mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-start-end-radius"
    },
    "border-start-start-radius": {
      syntax: "<length-percentage>{1,2}",
      media: "visual",
      inherited: false,
      animationType: "lpc",
      percentages: "referToDimensionOfBorderBox",
      groups: [
        "CSS Logical Properties"
      ],
      initial: "0",
      appliesto: "allElementsUAsNotRequiredWhenCollapse",
      computed: "twoAbsoluteLengthOrPercentages",
      order: "uniqueOrder",
      alsoAppliesTo: [
        "::first-letter"
      ],
      status: "standard",
      mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-start-start-radius"
    },
    "border-style": {
      syntax: "<line-style>{1,4}",
      media: "visual",
      inherited: false,
      animationType: "discrete",
      percentages: "no",
      groups: [
        "CSS Backgrounds and Borders"
      ],
      initial: [
        "border-top-style",
        "border-right-style",
        "border-bottom-style",
        "border-left-style"
      ],
      appliesto: "allElements",
      computed: [
        "border-bottom-style",
        "border-left-style",
        "border-right-style",
        "border-top-style"
      ],
      order: "uniqueOrder",
      alsoAppliesTo: [
        "::first-letter"
      ],
      status: "standard",
      mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-style"
    },
    "border-top": {
      syntax: "<line-width> || <line-style> || <color>",
      media: "visual",
      inherited: false,
      animationType: [
        "border-top-color",
        "border-top-style",
        "border-top-width"
      ],
      percentages: "no",
      groups: [
        "CSS Backgrounds and Borders"
      ],
      initial: [
        "border-top-width",
        "border-top-style",
        "border-top-color"
      ],
      appliesto: "allElements",
      computed: [
        "border-top-width",
        "border-top-style",
        "border-top-color"
      ],
      order: "orderOfAppearance",
      alsoAppliesTo: [
        "::first-letter"
      ],
      status: "standard",
      mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-top"
    },
    "border-top-color": {
      syntax: "<color>",
      media: "visual",
      inherited: false,
      animationType: "color",
      percentages: "no",
      groups: [
        "CSS Backgrounds and Borders"
      ],
      initial: "currentcolor",
      appliesto: "allElements",
      computed: "computedColor",
      order: "uniqueOrder",
      alsoAppliesTo: [
        "::first-letter"
      ],
      status: "standard",
      mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-top-color"
    },
    "border-top-left-radius": {
      syntax: "<length-percentage>{1,2}",
      media: "visual",
      inherited: false,
      animationType: "lpc",
      percentages: "referToDimensionOfBorderBox",
      groups: [
        "CSS Backgrounds and Borders"
      ],
      initial: "0",
      appliesto: "allElementsUAsNotRequiredWhenCollapse",
      computed: "twoAbsoluteLengthOrPercentages",
      order: "uniqueOrder",
      alsoAppliesTo: [
        "::first-letter"
      ],
      status: "standard",
      mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-top-left-radius"
    },
    "border-top-right-radius": {
      syntax: "<length-percentage>{1,2}",
      media: "visual",
      inherited: false,
      animationType: "lpc",
      percentages: "referToDimensionOfBorderBox",
      groups: [
        "CSS Backgrounds and Borders"
      ],
      initial: "0",
      appliesto: "allElementsUAsNotRequiredWhenCollapse",
      computed: "twoAbsoluteLengthOrPercentages",
      order: "uniqueOrder",
      alsoAppliesTo: [
        "::first-letter"
      ],
      status: "standard",
      mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-top-right-radius"
    },
    "border-top-style": {
      syntax: "<line-style>",
      media: "visual",
      inherited: false,
      animationType: "discrete",
      percentages: "no",
      groups: [
        "CSS Backgrounds and Borders"
      ],
      initial: "none",
      appliesto: "allElements",
      computed: "asSpecified",
      order: "uniqueOrder",
      alsoAppliesTo: [
        "::first-letter"
      ],
      status: "standard",
      mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-top-style"
    },
    "border-top-width": {
      syntax: "<line-width>",
      media: "visual",
      inherited: false,
      animationType: "length",
      percentages: "no",
      groups: [
        "CSS Backgrounds and Borders"
      ],
      initial: "medium",
      appliesto: "allElements",
      computed: "absoluteLengthOr0IfBorderTopStyleNoneOrHidden",
      order: "uniqueOrder",
      alsoAppliesTo: [
        "::first-letter"
      ],
      status: "standard",
      mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-top-width"
    },
    "border-width": {
      syntax: "<line-width>{1,4}",
      media: "visual",
      inherited: false,
      animationType: [
        "border-bottom-width",
        "border-left-width",
        "border-right-width",
        "border-top-width"
      ],
      percentages: "no",
      groups: [
        "CSS Backgrounds and Borders"
      ],
      initial: [
        "border-top-width",
        "border-right-width",
        "border-bottom-width",
        "border-left-width"
      ],
      appliesto: "allElements",
      computed: [
        "border-bottom-width",
        "border-left-width",
        "border-right-width",
        "border-top-width"
      ],
      order: "uniqueOrder",
      alsoAppliesTo: [
        "::first-letter"
      ],
      status: "standard",
      mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-width"
    },
    bottom: {
      syntax: "<length> | <percentage> | auto",
      media: "visual",
      inherited: false,
      animationType: "lpc",
      percentages: "referToContainingBlockHeight",
      groups: [
        "CSS Positioning"
      ],
      initial: "auto",
      appliesto: "positionedElements",
      computed: "lengthAbsolutePercentageAsSpecifiedOtherwiseAuto",
      order: "uniqueOrder",
      status: "standard",
      mdn_url: "https://developer.mozilla.org/docs/Web/CSS/bottom"
    },
    "box-align": {
      syntax: "start | center | end | baseline | stretch",
      media: "visual",
      inherited: false,
      animationType: "discrete",
      percentages: "no",
      groups: [
        "Mozilla Extensions",
        "WebKit Extensions"
      ],
      initial: "stretch",
      appliesto: "elementsWithDisplayBoxOrInlineBox",
      computed: "asSpecified",
      order: "uniqueOrder",
      status: "nonstandard",
      mdn_url: "https://developer.mozilla.org/docs/Web/CSS/box-align"
    },
    "box-decoration-break": {
      syntax: "slice | clone",
      media: "visual",
      inherited: false,
      animationType: "discrete",
      percentages: "no",
      groups: [
        "CSS Fragmentation"
      ],
      initial: "slice",
      appliesto: "allElements",
      computed: "asSpecified",
      order: "uniqueOrder",
      status: "standard",
      mdn_url: "https://developer.mozilla.org/docs/Web/CSS/box-decoration-break"
    },
    "box-direction": {
      syntax: "normal | reverse | inherit",
      media: "visual",
      inherited: false,
      animationType: "discrete",
      percentages: "no",
      groups: [
        "Mozilla Extensions",
        "WebKit Extensions"
      ],
      initial: "normal",
      appliesto: "elementsWithDisplayBoxOrInlineBox",
      computed: "asSpecified",
      order: "uniqueOrder",
      status: "nonstandard",
      mdn_url: "https://developer.mozilla.org/docs/Web/CSS/box-direction"
    },
    "box-flex": {
      syntax: "<number>",
      media: "visual",
      inherited: false,
      animationType: "discrete",
      percentages: "no",
      groups: [
        "Mozilla Extensions",
        "WebKit Extensions"
      ],
      initial: "0",
      appliesto: "directChildrenOfElementsWithDisplayMozBoxMozInlineBox",
      computed: "asSpecified",
      order: "uniqueOrder",
      status: "nonstandard",
      mdn_url: "https://developer.mozilla.org/docs/Web/CSS/box-flex"
    },
    "box-flex-group": {
      syntax: "<integer>",
      media: "visual",
      inherited: false,
      animationType: "discrete",
      percentages: "no",
      groups: [
        "Mozilla Extensions",
        "WebKit Extensions"
      ],
      initial: "1",
      appliesto: "inFlowChildrenOfBoxElements",
      computed: "asSpecified",
      order: "uniqueOrder",
      status: "nonstandard",
      mdn_url: "https://developer.mozilla.org/docs/Web/CSS/box-flex-group"
    },
    "box-lines": {
      syntax: "single | multiple",
      media: "visual",
      inherited: false,
      animationType: "discrete",
      percentages: "no",
      groups: [
        "Mozilla Extensions",
        "WebKit Extensions"
      ],
      initial: "single",
      appliesto: "boxElements",
      computed: "asSpecified",
      order: "uniqueOrder",
      status: "nonstandard",
      mdn_url: "https://developer.mozilla.org/docs/Web/CSS/box-lines"
    },
    "box-ordinal-group": {
      syntax: "<integer>",
      media: "visual",
      inherited: false,
      animationType: "discrete",
      percentages: "no",
      groups: [
        "Mozilla Extensions",
        "WebKit Extensions"
      ],
      initial: "1",
      appliesto: "childrenOfBoxElements",
      computed: "asSpecified",
      order: "uniqueOrder",
      status: "nonstandard",
      mdn_url: "https://developer.mozilla.org/docs/Web/CSS/box-ordinal-group"
    },
    "box-orient": {
      syntax: "horizontal | vertical | inline-axis | block-axis | inherit",
      media: "visual",
      inherited: false,
      animationType: "discrete",
      percentages: "no",
      groups: [
        "Mozilla Extensions",
        "WebKit Extensions"
      ],
      initial: "inlineAxisHorizontalInXUL",
      appliesto: "elementsWithDisplayBoxOrInlineBox",
      computed: "asSpecified",
      order: "uniqueOrder",
      status: "nonstandard",
      mdn_url: "https://developer.mozilla.org/docs/Web/CSS/box-orient"
    },
    "box-pack": {
      syntax: "start | center | end | justify",
      media: "visual",
      inherited: false,
      animationType: "discrete",
      percentages: "no",
      groups: [
        "Mozilla Extensions",
        "WebKit Extensions"
      ],
      initial: "start",
      appliesto: "elementsWithDisplayMozBoxMozInlineBox",
      computed: "asSpecified",
      order: "uniqueOrder",
      status: "nonstandard",
      mdn_url: "https://developer.mozilla.org/docs/Web/CSS/box-pack"
    },
    "box-shadow": {
      syntax: "none | <shadow>#",
      media: "visual",
      inherited: false,
      animationType: "shadowList",
      percentages: "no",
      groups: [
        "CSS Backgrounds and Borders"
      ],
      initial: "none",
      appliesto: "allElements",
      computed: "absoluteLengthsSpecifiedColorAsSpecified",
      order: "uniqueOrder",
      alsoAppliesTo: [
        "::first-letter"
      ],
      status: "standard",
      mdn_url: "https://developer.mozilla.org/docs/Web/CSS/box-shadow"
    },
    "box-sizing": {
      syntax: "content-box | border-box",
      media: "visual",
      inherited: false,
      animationType: "discrete",
      percentages: "no",
      groups: [
        "CSS Box Model"
      ],
      initial: "content-box",
      appliesto: "allElementsAcceptingWidthOrHeight",
      computed: "asSpecified",
      order: "uniqueOrder",
      status: "standard",
      mdn_url: "https://developer.mozilla.org/docs/Web/CSS/box-sizing"
    },
    "break-after": {
      syntax: "auto | avoid | always | all | avoid-page | page | left | right | recto | verso | avoid-column | column | avoid-region | region",
      media: "visual",
      inherited: false,
      animationType: "discrete",
      percentages: "no",
      groups: [
        "CSS Fragmentation"
      ],
      initial: "auto",
      appliesto: "blockLevelElements",
      computed: "asSpecified",
      order: "uniqueOrder",
      status: "standard",
      mdn_url: "https://developer.mozilla.org/docs/Web/CSS/break-after"
    },
    "break-before": {
      syntax: "auto | avoid | always | all | avoid-page | page | left | right | recto | verso | avoid-column | column | avoid-region | region",
      media: "visual",
      inherited: false,
      animationType: "discrete",
      percentages: "no",
      groups: [
        "CSS Fragmentation"
      ],
      initial: "auto",
      appliesto: "blockLevelElements",
      computed: "asSpecified",
      order: "uniqueOrder",
      status: "standard",
      mdn_url: "https://developer.mozilla.org/docs/Web/CSS/break-before"
    },
    "break-inside": {
      syntax: "auto | avoid | avoid-page | avoid-column | avoid-region",
      media: "visual",
      inherited: false,
      animationType: "discrete",
      percentages: "no",
      groups: [
        "CSS Fragmentation"
      ],
      initial: "auto",
      appliesto: "blockLevelElements",
      computed: "asSpecified",
      order: "uniqueOrder",
      status: "standard",
      mdn_url: "https://developer.mozilla.org/docs/Web/CSS/break-inside"
    },
    "caption-side": {
      syntax: "top | bottom | block-start | block-end | inline-start | inline-end",
      media: "visual",
      inherited: true,
      animationType: "discrete",
      percentages: "no",
      groups: [
        "CSS Table"
      ],
      initial: "top",
      appliesto: "tableCaptionElements",
      computed: "asSpecified",
      order: "uniqueOrder",
      status: "standard",
      mdn_url: "https://developer.mozilla.org/docs/Web/CSS/caption-side"
    },
    caret: {
      syntax: "<'caret-color'> || <'caret-shape'>",
      media: "interactive",
      inherited: true,
      animationType: [
        "caret-color",
        "caret-shape"
      ],
      percentages: "no",
      groups: [
        "CSS Basic User Interface"
      ],
      initial: [
        "caret-color",
        "caret-shape"
      ],
      appliesto: "elementsThatAcceptInput",
      computed: [
        "caret-color",
        "caret-shape"
      ],
      order: "perGrammar",
      status: "standard"
    },
    "caret-color": {
      syntax: "auto | <color>",
      media: "interactive",
      inherited: true,
      animationType: "color",
      percentages: "no",
      groups: [
        "CSS Basic User Interface"
      ],
      initial: "auto",
      appliesto: "allElements",
      computed: "asAutoOrColor",
      order: "perGrammar",
      status: "standard",
      mdn_url: "https://developer.mozilla.org/docs/Web/CSS/caret-color"
    },
    "caret-shape": {
      syntax: "auto | bar | block | underscore",
      media: "interactive",
      inherited: true,
      animationType: "byComputedValueType",
      percentages: "no",
      groups: [
        "CSS Basic User Interface"
      ],
      initial: "auto",
      appliesto: "elementsThatAcceptInput",
      computed: "asSpecified",
      order: "perGrammar",
      status: "standard"
    },
    clear: {
      syntax: "none | left | right | both | inline-start | inline-end",
      media: "visual",
      inherited: false,
      animationType: "discrete",
      percentages: "no",
      groups: [
        "CSS Positioning"
      ],
      initial: "none",
      appliesto: "blockLevelElements",
      computed: "asSpecified",
      order: "uniqueOrder",
      status: "standard",
      mdn_url: "https://developer.mozilla.org/docs/Web/CSS/clear"
    },
    clip: {
      syntax: "<shape> | auto",
      media: "visual",
      inherited: false,
      animationType: "rectangle",
      percentages: "no",
      groups: [
        "CSS Masking"
      ],
      initial: "auto",
      appliesto: "absolutelyPositionedElements",
      computed: "autoOrRectangle",
      order: "uniqueOrder",
      status: "standard",
      mdn_url: "https://developer.mozilla.org/docs/Web/CSS/clip"
    },
    "clip-path": {
      syntax: "<clip-source> | [ <basic-shape> || <geometry-box> ] | none",
      media: "visual",
      inherited: false,
      animationType: "basicShapeOtherwiseNo",
      percentages: "referToReferenceBoxWhenSpecifiedOtherwiseBorderBox",
      groups: [
        "CSS Masking"
      ],
      initial: "none",
      appliesto: "allElementsSVGContainerElements",
      computed: "asSpecifiedURLsAbsolute",
      order: "uniqueOrder",
      status: "standard",
      mdn_url: "https://developer.mozilla.org/docs/Web/CSS/clip-path"
    },
    color: {
      syntax: "<color>",
      media: "visual",
      inherited: true,
      animationType: "byComputedValueType",
      percentages: "no",
      groups: [
        "CSS Color"
      ],
      initial: "canvastext",
      appliesto: "allElementsAndText",
      computed: "computedColor",
      order: "perGrammar",
      alsoAppliesTo: [
        "::first-letter",
        "::first-line",
        "::placeholder"
      ],
      status: "standard",
      mdn_url: "https://developer.mozilla.org/docs/Web/CSS/color"
    },
    "print-color-adjust": {
      syntax: "economy | exact",
      media: "visual",
      inherited: true,
      animationType: "discrete",
      percentages: "no",
      groups: [
        "CSS Color"
      ],
      initial: "economy",
      appliesto: "allElements",
      computed: "asSpecified",
      order: "perGrammar",
      status: "standard",
      mdn_url: "https://developer.mozilla.org/docs/Web/CSS/print-color-adjust"
    },
    "color-scheme": {
      syntax: "normal | [ light | dark | <custom-ident> ]+ && only?",
      media: "visual",
      inherited: true,
      animationType: "discrete",
      percentages: "no",
      groups: [
        "CSS Color"
      ],
      initial: "normal",
      appliesto: "allElementsAndText",
      computed: "asSpecified",
      order: "perGrammar",
      status: "standard",
      mdn_url: "https://developer.mozilla.org/docs/Web/CSS/color-scheme"
    },
    "column-count": {
      syntax: "<integer> | auto",
      media: "visual",
      inherited: false,
      animationType: "integer",
      percentages: "no",
      groups: [
        "CSS Columns"
      ],
      initial: "auto",
      appliesto: "blockContainersExceptTableWrappers",
      computed: "asSpecified",
      order: "perGrammar",
      status: "standard",
      mdn_url: "https://developer.mozilla.org/docs/Web/CSS/column-count"
    },
    "column-fill": {
      syntax: "auto | balance | balance-all",
      media: "visualInContinuousMediaNoEffectInOverflowColumns",
      inherited: false,
      animationType: "discrete",
      percentages: "no",
      groups: [
        "CSS Columns"
      ],
      initial: "balance",
      appliesto: "multicolElements",
      computed: "asSpecified",
      order: "perGrammar",
      status: "standard",
      mdn_url: "https://developer.mozilla.org/docs/Web/CSS/column-fill"
    },
    "column-gap": {
      syntax: "normal | <length-percentage>",
      media: "visual",
      inherited: false,
      animationType: "lpc",
      percentages: "referToDimensionOfContentArea",
      groups: [
        "CSS Box Alignment"
      ],
      initial: "normal",
      appliesto: "multiColumnElementsFlexContainersGridContainers",
      computed: "asSpecifiedWithLengthsAbsoluteAndNormalComputingToZeroExceptMultiColumn",
      order: "perGrammar",
      status: "standard",
      mdn_url: "https://developer.mozilla.org/docs/Web/CSS/column-gap"
    },
    "column-rule": {
      syntax: "<'column-rule-width'> || <'column-rule-style'> || <'column-rule-color'>",
      media: "visual",
      inherited: false,
      animationType: [
        "column-rule-color",
        "column-rule-style",
        "column-rule-width"
      ],
      percentages: "no",
      groups: [
        "CSS Columns"
      ],
      initial: [
        "column-rule-width",
        "column-rule-style",
        "column-rule-color"
      ],
      appliesto: "multicolElements",
      computed: [
        "column-rule-color",
        "column-rule-style",
        "column-rule-width"
      ],
      order: "perGrammar",
      status: "standard",
      mdn_url: "https://developer.mozilla.org/docs/Web/CSS/column-rule"
    },
    "column-rule-color": {
      syntax: "<color>",
      media: "visual",
      inherited: false,
      animationType: "color",
      percentages: "no",
      groups: [
        "CSS Columns"
      ],
      initial: "currentcolor",
      appliesto: "multicolElements",
      computed: "computedColor",
      order: "perGrammar",
      status: "standard",
      mdn_url: "https://developer.mozilla.org/docs/Web/CSS/column-rule-color"
    },
    "column-rule-style": {
      syntax: "<'border-style'>",
      media: "visual",
      inherited: false,
      animationType: "discrete",
      percentages: "no",
      groups: [
        "CSS Columns"
      ],
      initial: "none",
      appliesto: "multicolElements",
      computed: "asSpecified",
      order: "perGrammar",
      status: "standard",
      mdn_url: "https://developer.mozilla.org/docs/Web/CSS/column-rule-style"
    },
    "column-rule-width": {
      syntax: "<'border-width'>",
      media: "visual",
      inherited: false,
      animationType: "length",
      percentages: "no",
      groups: [
        "CSS Columns"
      ],
      initial: "medium",
      appliesto: "multicolElements",
      computed: "absoluteLength0IfColumnRuleStyleNoneOrHidden",
      order: "perGrammar",
      status: "standard",
      mdn_url: "https://developer.mozilla.org/docs/Web/CSS/column-rule-width"
    },
    "column-span": {
      syntax: "none | all",
      media: "visual",
      inherited: false,
      animationType: "discrete",
      percentages: "no",
      groups: [
        "CSS Columns"
      ],
      initial: "none",
      appliesto: "inFlowBlockLevelElements",
      computed: "asSpecified",
      order: "perGrammar",
      status: "standard",
      mdn_url: "https://developer.mozilla.org/docs/Web/CSS/column-span"
    },
    "column-width": {
      syntax: "<length> | auto",
      media: "visual",
      inherited: false,
      animationType: "length",
      percentages: "no",
      groups: [
        "CSS Columns"
      ],
      initial: "auto",
      appliesto: "blockContainersExceptTableWrappers",
      computed: "absoluteLengthZeroOrLarger",
      order: "perGrammar",
      status: "standard",
      mdn_url: "https://developer.mozilla.org/docs/Web/CSS/column-width"
    },
    columns: {
      syntax: "<'column-width'> || <'column-count'>",
      media: "visual",
      inherited: false,
      animationType: [
        "column-width",
        "column-count"
      ],
      percentages: "no",
      groups: [
        "CSS Columns"
      ],
      initial: [
        "column-width",
        "column-count"
      ],
      appliesto: "blockContainersExceptTableWrappers",
      computed: [
        "column-width",
        "column-count"
      ],
      order: "perGrammar",
      status: "standard",
      mdn_url: "https://developer.mozilla.org/docs/Web/CSS/columns"
    },
    contain: {
      syntax: "none | strict | content | [ [ size || inline-size ] || layout || style || paint ]",
      media: "all",
      inherited: false,
      animationType: "discrete",
      percentages: "no",
      groups: [
        "CSS Containment"
      ],
      initial: "none",
      appliesto: "allElements",
      computed: "asSpecified",
      order: "perGrammar",
      status: "standard",
      mdn_url: "https://developer.mozilla.org/docs/Web/CSS/contain"
    },
    "contain-intrinsic-size": {
      syntax: "[ none | <length> | auto <length> ]{1,2}",
      media: "visual",
      inherited: false,
      animationType: [
        "contain-intrinsic-width",
        "contain-intrinsic-height"
      ],
      percentages: [
        "contain-intrinsic-width",
        "contain-intrinsic-height"
      ],
      groups: [
        "CSS Containment"
      ],
      initial: [
        "contain-intrinsic-width",
        "contain-intrinsic-height"
      ],
      appliesto: "elementsForWhichSizeContainmentCanApply",
      computed: [
        "contain-intrinsic-width",
        "contain-intrinsic-height"
      ],
      order: "perGrammar",
      status: "experimental",
      mdn_url: "https://developer.mozilla.org/docs/Web/CSS/contain-intrinsic-size"
    },
    "contain-intrinsic-block-size": {
      syntax: "none | <length> | auto <length>",
      inherited: false,
      animationType: "byComputedValueType",
      percentages: "no",
      groups: [
        "CSS Containment"
      ],
      initial: "none",
      appliesto: "elementsForWhichSizeContainmentCanApply",
      computed: "asSpecifiedWithLengthValuesComputed",
      order: "perGrammar",
      status: "experimental",
      mdn_url: "https://developer.mozilla.org/docs/Web/CSS/contain-intrinsic-block-size"
    },
    "contain-intrinsic-height": {
      syntax: "none | <length> | auto <length>",
      inherited: false,
      animationType: "byComputedValueType",
      percentages: "no",
      groups: [
        "CSS Containment"
      ],
      initial: "none",
      appliesto: "elementsForWhichSizeContainmentCanApply",
      computed: "asSpecifiedWithLengthValuesComputed",
      order: "perGrammar",
      status: "experimental",
      mdn_url: "https://developer.mozilla.org/docs/Web/CSS/contain-intrinsic-height"
    },
    "contain-intrinsic-inline-size": {
      syntax: "none | <length> | auto <length>",
      inherited: false,
      animationType: "byComputedValueType",
      percentages: "no",
      groups: [
        "CSS Containment"
      ],
      initial: "none",
      appliesto: "elementsForWhichSizeContainmentCanApply",
      computed: "asSpecifiedWithLengthValuesComputed",
      order: "perGrammar",
      status: "experimental",
      mdn_url: "https://developer.mozilla.org/docs/Web/CSS/contain-intrinsic-inline-size"
    },
    "contain-intrinsic-width": {
      syntax: "none | <length> | auto <length>",
      media: "visual",
      inherited: false,
      animationType: "byComputedValueType",
      percentages: "no",
      groups: [
        "CSS Containment"
      ],
      initial: "none",
      appliesto: "elementsForWhichSizeContainmentCanApply",
      computed: "asSpecifiedWithLengthValuesComputed",
      order: "perGrammar",
      status: "experimental",
      mdn_url: "https://developer.mozilla.org/docs/Web/CSS/contain-intrinsic-width"
    },
    content: {
      syntax: "normal | none | [ <content-replacement> | <content-list> ] [/ [ <string> | <counter> ]+ ]?",
      media: "all",
      inherited: false,
      animationType: "discrete",
      percentages: "no",
      groups: [
        "CSS Generated Content"
      ],
      initial: "normal",
      appliesto: "allElementsTreeAbidingPseudoElementsPageMarginBoxes",
      computed: "normalOnElementsForPseudosNoneAbsoluteURIStringOrAsSpecified",
      order: "uniqueOrder",
      status: "standard",
      mdn_url: "https://developer.mozilla.org/docs/Web/CSS/content"
    },
    "content-visibility": {
      syntax: "visible | auto | hidden",
      media: "all",
      inherited: false,
      animationType: "discrete",
      percentages: "no",
      groups: [
        "CSS Containment"
      ],
      initial: "visible",
      appliesto: "elementsForWhichLayoutContainmentCanApply",
      computed: "asSpecified",
      order: "perGrammar",
      status: "standard",
      mdn_url: "https://developer.mozilla.org/docs/Web/CSS/content-visibility"
    },
    "counter-increment": {
      syntax: "[ <counter-name> <integer>? ]+ | none",
      media: "all",
      inherited: false,
      animationType: "discrete",
      percentages: "no",
      groups: [
        "CSS Counter Styles"
      ],
      initial: "none",
      appliesto: "allElements",
      computed: "asSpecified",
      order: "uniqueOrder",
      status: "standard",
      mdn_url: "https://developer.mozilla.org/docs/Web/CSS/counter-increment"
    },
    "counter-reset": {
      syntax: "[ <counter-name> <integer>? | <reversed-counter-name> <integer>? ]+ | none",
      media: "all",
      inherited: false,
      animationType: "discrete",
      percentages: "no",
      groups: [
        "CSS Counter Styles"
      ],
      initial: "none",
      appliesto: "allElements",
      computed: "asSpecified",
      order: "uniqueOrder",
      status: "standard",
      mdn_url: "https://developer.mozilla.org/docs/Web/CSS/counter-reset"
    },
    "counter-set": {
      syntax: "[ <counter-name> <integer>? ]+ | none",
      media: "all",
      inherited: false,
      animationType: "discrete",
      percentages: "no",
      groups: [
        "CSS Counter Styles"
      ],
      initial: "none",
      appliesto: "allElements",
      computed: "asSpecified",
      order: "uniqueOrder",
      status: "standard",
      mdn_url: "https://developer.mozilla.org/docs/Web/CSS/counter-set"
    },
    cursor: {
      syntax: "[ [ <url> [ <x> <y> ]? , ]* [ auto | default | none | context-menu | help | pointer | progress | wait | cell | crosshair | text | vertical-text | alias | copy | move | no-drop | not-allowed | e-resize | n-resize | ne-resize | nw-resize | s-resize | se-resize | sw-resize | w-resize | ew-resize | ns-resize | nesw-resize | nwse-resize | col-resize | row-resize | all-scroll | zoom-in | zoom-out | grab | grabbing ] ]",
      media: [
        "visual",
        "interactive"
      ],
      inherited: true,
      animationType: "discrete",
      percentages: "no",
      groups: [
        "CSS Basic User Interface"
      ],
      initial: "auto",
      appliesto: "allElements",
      computed: "asSpecifiedURLsAbsolute",
      order: "uniqueOrder",
      status: "standard",
      mdn_url: "https://developer.mozilla.org/docs/Web/CSS/cursor"
    },
    direction: {
      syntax: "ltr | rtl",
      media: "visual",
      inherited: true,
      animationType: "discrete",
      percentages: "no",
      groups: [
        "CSS Writing Modes"
      ],
      initial: "ltr",
      appliesto: "allElements",
      computed: "asSpecified",
      order: "uniqueOrder",
      status: "standard",
      mdn_url: "https://developer.mozilla.org/docs/Web/CSS/direction"
    },
    display: {
      syntax: "[ <display-outside> || <display-inside> ] | <display-listitem> | <display-internal> | <display-box> | <display-legacy>",
      media: "all",
      inherited: false,
      animationType: "notAnimatable",
      percentages: "no",
      groups: [
        "CSS Display"
      ],
      initial: "inline",
      appliesto: "allElements",
      computed: "asSpecifiedExceptPositionedFloatingAndRootElementsKeywordMaybeDifferent",
      order: "uniqueOrder",
      status: "standard",
      mdn_url: "https://developer.mozilla.org/docs/Web/CSS/display"
    },
    "empty-cells": {
      syntax: "show | hide",
      media: "visual",
      inherited: true,
      animationType: "discrete",
      percentages: "no",
      groups: [
        "CSS Table"
      ],
      initial: "show",
      appliesto: "tableCellElements",
      computed: "asSpecified",
      order: "uniqueOrder",
      status: "standard",
      mdn_url: "https://developer.mozilla.org/docs/Web/CSS/empty-cells"
    },
    filter: {
      syntax: "none | <filter-function-list>",
      media: "visual",
      inherited: false,
      animationType: "filterList",
      percentages: "no",
      groups: [
        "Filter Effects"
      ],
      initial: "none",
      appliesto: "allElementsSVGContainerElements",
      computed: "asSpecified",
      order: "uniqueOrder",
      status: "standard",
      mdn_url: "https://developer.mozilla.org/docs/Web/CSS/filter"
    },
    flex: {
      syntax: "none | [ <'flex-grow'> <'flex-shrink'>? || <'flex-basis'> ]",
      media: "visual",
      inherited: false,
      animationType: [
        "flex-grow",
        "flex-shrink",
        "flex-basis"
      ],
      percentages: "no",
      groups: [
        "CSS Flexible Box Layout"
      ],
      initial: [
        "flex-grow",
        "flex-shrink",
        "flex-basis"
      ],
      appliesto: "flexItemsAndInFlowPseudos",
      computed: [
        "flex-grow",
        "flex-shrink",
        "flex-basis"
      ],
      order: "orderOfAppearance",
      status: "standard",
      mdn_url: "https://developer.mozilla.org/docs/Web/CSS/flex"
    },
    "flex-basis": {
      syntax: "content | <'width'>",
      media: "visual",
      inherited: false,
      animationType: "lpc",
      percentages: "referToFlexContainersInnerMainSize",
      groups: [
        "CSS Flexible Box Layout"
      ],
      initial: "auto",
      appliesto: "flexItemsAndInFlowPseudos",
      computed: "asSpecifiedRelativeToAbsoluteLengths",
      order: "lengthOrPercentageBeforeKeywordIfBothPresent",
      status: "standard",
      mdn_url: "https://developer.mozilla.org/docs/Web/CSS/flex-basis"
    },
    "flex-direction": {
      syntax: "row | row-reverse | column | column-reverse",
      media: "visual",
      inherited: false,
      animationType: "discrete",
      percentages: "no",
      groups: [
        "CSS Flexible Box Layout"
      ],
      initial: "row",
      appliesto: "flexContainers",
      computed: "asSpecified",
      order: "uniqueOrder",
      status: "standard",
      mdn_url: "https://developer.mozilla.org/docs/Web/CSS/flex-direction"
    },
    "flex-flow": {
      syntax: "<'flex-direction'> || <'flex-wrap'>",
      media: "visual",
      inherited: false,
      animationType: "discrete",
      percentages: "no",
      groups: [
        "CSS Flexible Box Layout"
      ],
      initial: [
        "flex-direction",
        "flex-wrap"
      ],
      appliesto: "flexContainers",
      computed: [
        "flex-direction",
        "flex-wrap"
      ],
      order: "orderOfAppearance",
      status: "standard",
      mdn_url: "https://developer.mozilla.org/docs/Web/CSS/flex-flow"
    },
    "flex-grow": {
      syntax: "<number>",
      media: "visual",
      inherited: false,
      animationType: "number",
      percentages: "no",
      groups: [
        "CSS Flexible Box Layout"
      ],
      initial: "0",
      appliesto: "flexItemsAndInFlowPseudos",
      computed: "asSpecified",
      order: "uniqueOrder",
      status: "standard",
      mdn_url: "https://developer.mozilla.org/docs/Web/CSS/flex-grow"
    },
    "flex-shrink": {
      syntax: "<number>",
      media: "visual",
      inherited: false,
      animationType: "number",
      percentages: "no",
      groups: [
        "CSS Flexible Box Layout"
      ],
      initial: "1",
      appliesto: "flexItemsAndInFlowPseudos",
      computed: "asSpecified",
      order: "uniqueOrder",
      status: "standard",
      mdn_url: "https://developer.mozilla.org/docs/Web/CSS/flex-shrink"
    },
    "flex-wrap": {
      syntax: "nowrap | wrap | wrap-reverse",
      media: "visual",
      inherited: false,
      animationType: "discrete",
      percentages: "no",
      groups: [
        "CSS Flexible Box Layout"
      ],
      initial: "nowrap",
      appliesto: "flexContainers",
      computed: "asSpecified",
      order: "uniqueOrder",
      status: "standard",
      mdn_url: "https://developer.mozilla.org/docs/Web/CSS/flex-wrap"
    },
    float: {
      syntax: "left | right | none | inline-start | inline-end",
      media: "visual",
      inherited: false,
      animationType: "discrete",
      percentages: "no",
      groups: [
        "CSS Positioning"
      ],
      initial: "none",
      appliesto: "allElementsNoEffectIfDisplayNone",
      computed: "asSpecified",
      order: "uniqueOrder",
      status: "standard",
      mdn_url: "https://developer.mozilla.org/docs/Web/CSS/float"
    },
    font: {
      syntax: "[ [ <'font-style'> || <font-variant-css21> || <'font-weight'> || <'font-stretch'> ]? <'font-size'> [ / <'line-height'> ]? <'font-family'> ] | caption | icon | menu | message-box | small-caption | status-bar",
      media: "visual",
      inherited: true,
      animationType: [
        "font-style",
        "font-variant",
        "font-weight",
        "font-stretch",
        "font-size",
        "line-height",
        "font-family"
      ],
      percentages: [
        "font-size",
        "line-height"
      ],
      groups: [
        "CSS Fonts"
      ],
      initial: [
        "font-style",
        "font-variant",
        "font-weight",
        "font-stretch",
        "font-size",
        "line-height",
        "font-family"
      ],
      appliesto: "allElements",
      computed: [
        "font-style",
        "font-variant",
        "font-weight",
        "font-stretch",
        "font-size",
        "line-height",
        "font-family"
      ],
      order: "orderOfAppearance",
      alsoAppliesTo: [
        "::first-letter",
        "::first-line",
        "::placeholder"
      ],
      status: "standard",
      mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font"
    },
    "font-family": {
      syntax: "[ <family-name> | <generic-family> ]#",
      media: "visual",
      inherited: true,
      animationType: "discrete",
      percentages: "no",
      groups: [
        "CSS Fonts"
      ],
      initial: "dependsOnUserAgent",
      appliesto: "allElements",
      computed: "asSpecified",
      order: "uniqueOrder",
      alsoAppliesTo: [
        "::first-letter",
        "::first-line",
        "::placeholder"
      ],
      status: "standard",
      mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-family"
    },
    "font-feature-settings": {
      syntax: "normal | <feature-tag-value>#",
      media: "visual",
      inherited: true,
      animationType: "discrete",
      percentages: "no",
      groups: [
        "CSS Fonts"
      ],
      initial: "normal",
      appliesto: "allElements",
      computed: "asSpecified",
      order: "uniqueOrder",
      alsoAppliesTo: [
        "::first-letter",
        "::first-line",
        "::placeholder"
      ],
      status: "standard",
      mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-feature-settings"
    },
    "font-kerning": {
      syntax: "auto | normal | none",
      media: "visual",
      inherited: true,
      animationType: "discrete",
      percentages: "no",
      groups: [
        "CSS Fonts"
      ],
      initial: "auto",
      appliesto: "allElements",
      computed: "asSpecified",
      order: "uniqueOrder",
      alsoAppliesTo: [
        "::first-letter",
        "::first-line",
        "::placeholder"
      ],
      status: "standard",
      mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-kerning"
    },
    "font-language-override": {
      syntax: "normal | <string>",
      media: "visual",
      inherited: true,
      animationType: "discrete",
      percentages: "no",
      groups: [
        "CSS Fonts"
      ],
      initial: "normal",
      appliesto: "allElements",
      computed: "asSpecified",
      order: "uniqueOrder",
      alsoAppliesTo: [
        "::first-letter",
        "::first-line",
        "::placeholder"
      ],
      status: "standard",
      mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-language-override"
    },
    "font-optical-sizing": {
      syntax: "auto | none",
      media: "visual",
      inherited: true,
      animationType: "discrete",
      percentages: "no",
      groups: [
        "CSS Fonts"
      ],
      initial: "auto",
      appliesto: "allElements",
      computed: "asSpecified",
      order: "perGrammar",
      alsoAppliesTo: [
        "::first-letter",
        "::first-line",
        "::placeholder"
      ],
      status: "standard",
      mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-optical-sizing"
    },
    "font-variation-settings": {
      syntax: "normal | [ <string> <number> ]#",
      media: "visual",
      inherited: true,
      animationType: "transform",
      percentages: "no",
      groups: [
        "CSS Fonts"
      ],
      initial: "normal",
      appliesto: "allElements",
      computed: "asSpecified",
      order: "perGrammar",
      alsoAppliesTo: [
        "::first-letter",
        "::first-line",
        "::placeholder"
      ],
      status: "standard",
      mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-variation-settings"
    },
    "font-size": {
      syntax: "<absolute-size> | <relative-size> | <length-percentage>",
      media: "visual",
      inherited: true,
      animationType: "length",
      percentages: "referToParentElementsFontSize",
      groups: [
        "CSS Fonts"
      ],
      initial: "medium",
      appliesto: "allElements",
      computed: "asSpecifiedRelativeToAbsoluteLengths",
      order: "uniqueOrder",
      alsoAppliesTo: [
        "::first-letter",
        "::first-line",
        "::placeholder"
      ],
      status: "standard",
      mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-size"
    },
    "font-size-adjust": {
      syntax: "none | [ ex-height | cap-height | ch-width | ic-width | ic-height ]? [ from-font | <number> ]",
      media: "visual",
      inherited: true,
      animationType: "number",
      percentages: "no",
      groups: [
        "CSS Fonts"
      ],
      initial: "none",
      appliesto: "allElements",
      computed: "asSpecified",
      order: "uniqueOrder",
      alsoAppliesTo: [
        "::first-letter",
        "::first-line",
        "::placeholder"
      ],
      status: "standard",
      mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-size-adjust"
    },
    "font-smooth": {
      syntax: "auto | never | always | <absolute-size> | <length>",
      media: "visual",
      inherited: true,
      animationType: "discrete",
      percentages: "no",
      groups: [
        "CSS Fonts"
      ],
      initial: "auto",
      appliesto: "allElements",
      computed: "asSpecified",
      order: "uniqueOrder",
      status: "nonstandard",
      mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-smooth"
    },
    "font-stretch": {
      syntax: "<font-stretch-absolute>",
      media: "visual",
      inherited: true,
      animationType: "fontStretch",
      percentages: "no",
      groups: [
        "CSS Fonts"
      ],
      initial: "normal",
      appliesto: "allElements",
      computed: "asSpecified",
      order: "uniqueOrder",
      alsoAppliesTo: [
        "::first-letter",
        "::first-line",
        "::placeholder"
      ],
      status: "standard",
      mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-stretch"
    },
    "font-style": {
      syntax: "normal | italic | oblique <angle>?",
      media: "visual",
      inherited: true,
      animationType: "discrete",
      percentages: "no",
      groups: [
        "CSS Fonts"
      ],
      initial: "normal",
      appliesto: "allElements",
      computed: "asSpecified",
      order: "uniqueOrder",
      alsoAppliesTo: [
        "::first-letter",
        "::first-line",
        "::placeholder"
      ],
      status: "standard",
      mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-style"
    },
    "font-synthesis": {
      syntax: "none | [ weight || style || small-caps ]",
      media: "visual",
      inherited: true,
      animationType: "discrete",
      percentages: "no",
      groups: [
        "CSS Fonts"
      ],
      initial: "weight style",
      appliesto: "allElements",
      computed: "asSpecified",
      order: "orderOfAppearance",
      alsoAppliesTo: [
        "::first-letter",
        "::first-line",
        "::placeholder"
      ],
      status: "standard",
      mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-synthesis"
    },
    "font-variant": {
      syntax: "normal | none | [ <common-lig-values> || <discretionary-lig-values> || <historical-lig-values> || <contextual-alt-values> || stylistic( <feature-value-name> ) || historical-forms || styleset( <feature-value-name># ) || character-variant( <feature-value-name># ) || swash( <feature-value-name> ) || ornaments( <feature-value-name> ) || annotation( <feature-value-name> ) || [ small-caps | all-small-caps | petite-caps | all-petite-caps | unicase | titling-caps ] || <numeric-figure-values> || <numeric-spacing-values> || <numeric-fraction-values> || ordinal || slashed-zero || <east-asian-variant-values> || <east-asian-width-values> || ruby ]",
      media: "visual",
      inherited: true,
      animationType: "discrete",
      percentages: "no",
      groups: [
        "CSS Fonts"
      ],
      initial: "normal",
      appliesto: "allElements",
      computed: "asSpecified",
      order: "uniqueOrder",
      alsoAppliesTo: [
        "::first-letter",
        "::first-line",
        "::placeholder"
      ],
      status: "standard",
      mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-variant"
    },
    "font-variant-alternates": {
      syntax: "normal | [ stylistic( <feature-value-name> ) || historical-forms || styleset( <feature-value-name># ) || character-variant( <feature-value-name># ) || swash( <feature-value-name> ) || ornaments( <feature-value-name> ) || annotation( <feature-value-name> ) ]",
      media: "visual",
      inherited: true,
      animationType: "discrete",
      percentages: "no",
      groups: [
        "CSS Fonts"
      ],
      initial: "normal",
      appliesto: "allElements",
      computed: "asSpecified",
      order: "orderOfAppearance",
      alsoAppliesTo: [
        "::first-letter",
        "::first-line",
        "::placeholder"
      ],
      status: "standard",
      mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-variant-alternates"
    },
    "font-variant-caps": {
      syntax: "normal | small-caps | all-small-caps | petite-caps | all-petite-caps | unicase | titling-caps",
      media: "visual",
      inherited: true,
      animationType: "discrete",
      percentages: "no",
      groups: [
        "CSS Fonts"
      ],
      initial: "normal",
      appliesto: "allElements",
      computed: "asSpecified",
      order: "uniqueOrder",
      alsoAppliesTo: [
        "::first-letter",
        "::first-line",
        "::placeholder"
      ],
      status: "standard",
      mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-variant-caps"
    },
    "font-variant-east-asian": {
      syntax: "normal | [ <east-asian-variant-values> || <east-asian-width-values> || ruby ]",
      media: "visual",
      inherited: true,
      animationType: "discrete",
      percentages: "no",
      groups: [
        "CSS Fonts"
      ],
      initial: "normal",
      appliesto: "allElements",
      computed: "asSpecified",
      order: "orderOfAppearance",
      alsoAppliesTo: [
        "::first-letter",
        "::first-line",
        "::placeholder"
      ],
      status: "standard",
      mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-variant-east-asian"
    },
    "font-variant-ligatures": {
      syntax: "normal | none | [ <common-lig-values> || <discretionary-lig-values> || <historical-lig-values> || <contextual-alt-values> ]",
      media: "visual",
      inherited: true,
      animationType: "discrete",
      percentages: "no",
      groups: [
        "CSS Fonts"
      ],
      initial: "normal",
      appliesto: "allElements",
      computed: "asSpecified",
      order: "orderOfAppearance",
      alsoAppliesTo: [
        "::first-letter",
        "::first-line",
        "::placeholder"
      ],
      status: "standard",
      mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-variant-ligatures"
    },
    "font-variant-numeric": {
      syntax: "normal | [ <numeric-figure-values> || <numeric-spacing-values> || <numeric-fraction-values> || ordinal || slashed-zero ]",
      media: "visual",
      inherited: true,
      animationType: "discrete",
      percentages: "no",
      groups: [
        "CSS Fonts"
      ],
      initial: "normal",
      appliesto: "allElements",
      computed: "asSpecified",
      order: "orderOfAppearance",
      alsoAppliesTo: [
        "::first-letter",
        "::first-line",
        "::placeholder"
      ],
      status: "standard",
      mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-variant-numeric"
    },
    "font-variant-position": {
      syntax: "normal | sub | super",
      media: "visual",
      inherited: true,
      animationType: "discrete",
      percentages: "no",
      groups: [
        "CSS Fonts"
      ],
      initial: "normal",
      appliesto: "allElements",
      computed: "asSpecified",
      order: "uniqueOrder",
      alsoAppliesTo: [
        "::first-letter",
        "::first-line",
        "::placeholder"
      ],
      status: "standard",
      mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-variant-position"
    },
    "font-weight": {
      syntax: "<font-weight-absolute> | bolder | lighter",
      media: "visual",
      inherited: true,
      animationType: "fontWeight",
      percentages: "no",
      groups: [
        "CSS Fonts"
      ],
      initial: "normal",
      appliesto: "allElements",
      computed: "keywordOrNumericalValueBolderLighterTransformedToRealValue",
      order: "uniqueOrder",
      alsoAppliesTo: [
        "::first-letter",
        "::first-line",
        "::placeholder"
      ],
      status: "standard",
      mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-weight"
    },
    "forced-color-adjust": {
      syntax: "auto | none",
      media: "visual",
      inherited: true,
      animationType: "notAnimatable",
      percentages: "no",
      groups: [
        "CSS Color"
      ],
      initial: "auto",
      appliesto: "allElementsAndText",
      computed: "asSpecified",
      order: "perGrammar",
      status: "experimental",
      mdn_url: "https://developer.mozilla.org/docs/Web/CSS/forced-color-adjust"
    },
    gap: {
      syntax: "<'row-gap'> <'column-gap'>?",
      media: "visual",
      inherited: false,
      animationType: [
        "row-gap",
        "column-gap"
      ],
      percentages: "no",
      groups: [
        "CSS Box Alignment"
      ],
      initial: [
        "row-gap",
        "column-gap"
      ],
      appliesto: "multiColumnElementsFlexContainersGridContainers",
      computed: [
        "row-gap",
        "column-gap"
      ],
      order: "uniqueOrder",
      status: "standard",
      mdn_url: "https://developer.mozilla.org/docs/Web/CSS/gap"
    },
    grid: {
      syntax: "<'grid-template'> | <'grid-template-rows'> / [ auto-flow && dense? ] <'grid-auto-columns'>? | [ auto-flow && dense? ] <'grid-auto-rows'>? / <'grid-template-columns'>",
      media: "visual",
      inherited: false,
      animationType: "discrete",
      percentages: [
        "grid-template-rows",
        "grid-template-columns",
        "grid-auto-rows",
        "grid-auto-columns"
      ],
      groups: [
        "CSS Grid Layout"
      ],
      initial: [
        "grid-template-rows",
        "grid-template-columns",
        "grid-template-areas",
        "grid-auto-rows",
        "grid-auto-columns",
        "grid-auto-flow",
        "grid-column-gap",
        "grid-row-gap",
        "column-gap",
        "row-gap"
      ],
      appliesto: "gridContainers",
      computed: [
        "grid-template-rows",
        "grid-template-columns",
        "grid-template-areas",
        "grid-auto-rows",
        "grid-auto-columns",
        "grid-auto-flow",
        "grid-column-gap",
        "grid-row-gap",
        "column-gap",
        "row-gap"
      ],
      order: "uniqueOrder",
      status: "standard",
      mdn_url: "https://developer.mozilla.org/docs/Web/CSS/grid"
    },
    "grid-area": {
      syntax: "<grid-line> [ / <grid-line> ]{0,3}",
      media: "visual",
      inherited: false,
      animationType: "discrete",
      percentages: "no",
      groups: [
        "CSS Grid Layout"
      ],
      initial: [
        "grid-row-start",
        "grid-column-start",
        "grid-row-end",
        "grid-column-end"
      ],
      appliesto: "gridItemsAndBoxesWithinGridContainer",
      computed: [
        "grid-row-start",
        "grid-column-start",
        "grid-row-end",
        "grid-column-end"
      ],
      order: "uniqueOrder",
      status: "standard",
      mdn_url: "https://developer.mozilla.org/docs/Web/CSS/grid-area"
    },
    "grid-auto-columns": {
      syntax: "<track-size>+",
      media: "visual",
      inherited: false,
      animationType: "discrete",
      percentages: "referToDimensionOfContentArea",
      groups: [
        "CSS Grid Layout"
      ],
      initial: "auto",
      appliesto: "gridContainers",
      computed: "percentageAsSpecifiedOrAbsoluteLength",
      order: "uniqueOrder",
      status: "standard",
      mdn_url: "https://developer.mozilla.org/docs/Web/CSS/grid-auto-columns"
    },
    "grid-auto-flow": {
      syntax: "[ row | column ] || dense",
      media: "visual",
      inherited: false,
      animationType: "discrete",
      percentages: "no",
      groups: [
        "CSS Grid Layout"
      ],
      initial: "row",
      appliesto: "gridContainers",
      computed: "asSpecified",
      order: "uniqueOrder",
      status: "standard",
      mdn_url: "https://developer.mozilla.org/docs/Web/CSS/grid-auto-flow"
    },
    "grid-auto-rows": {
      syntax: "<track-size>+",
      media: "visual",
      inherited: false,
      animationType: "discrete",
      percentages: "referToDimensionOfContentArea",
      groups: [
        "CSS Grid Layout"
      ],
      initial: "auto",
      appliesto: "gridContainers",
      computed: "percentageAsSpecifiedOrAbsoluteLength",
      order: "uniqueOrder",
      status: "standard",
      mdn_url: "https://developer.mozilla.org/docs/Web/CSS/grid-auto-rows"
    },
    "grid-column": {
      syntax: "<grid-line> [ / <grid-line> ]?",
      media: "visual",
      inherited: false,
      animationType: "discrete",
      percentages: "no",
      groups: [
        "CSS Grid Layout"
      ],
      initial: [
        "grid-column-start",
        "grid-column-end"
      ],
      appliesto: "gridItemsAndBoxesWithinGridContainer",
      computed: [
        "grid-column-start",
        "grid-column-end"
      ],
      order: "uniqueOrder",
      status: "standard",
      mdn_url: "https://developer.mozilla.org/docs/Web/CSS/grid-column"
    },
    "grid-column-end": {
      syntax: "<grid-line>",
      media: "visual",
      inherited: false,
      animationType: "discrete",
      percentages: "no",
      groups: [
        "CSS Grid Layout"
      ],
      initial: "auto",
      appliesto: "gridItemsAndBoxesWithinGridContainer",
      computed: "asSpecified",
      order: "uniqueOrder",
      status: "standard",
      mdn_url: "https://developer.mozilla.org/docs/Web/CSS/grid-column-end"
    },
    "grid-column-gap": {
      syntax: "<length-percentage>",
      media: "visual",
      inherited: false,
      animationType: "length",
      percentages: "referToDimensionOfContentArea",
      groups: [
        "CSS Grid Layout"
      ],
      initial: "0",
      appliesto: "gridContainers",
      computed: "percentageAsSpecifiedOrAbsoluteLength",
      order: "uniqueOrder",
      status: "obsolete",
      mdn_url: "https://developer.mozilla.org/docs/Web/CSS/column-gap"
    },
    "grid-column-start": {
      syntax: "<grid-line>",
      media: "visual",
      inherited: false,
      animationType: "discrete",
      percentages: "no",
      groups: [
        "CSS Grid Layout"
      ],
      initial: "auto",
      appliesto: "gridItemsAndBoxesWithinGridContainer",
      computed: "asSpecified",
      order: "uniqueOrder",
      status: "standard",
      mdn_url: "https://developer.mozilla.org/docs/Web/CSS/grid-column-start"
    },
    "grid-gap": {
      syntax: "<'grid-row-gap'> <'grid-column-gap'>?",
      media: "visual",
      inherited: false,
      animationType: [
        "grid-row-gap",
        "grid-column-gap"
      ],
      percentages: "no",
      groups: [
        "CSS Grid Layout"
      ],
      initial: [
        "grid-row-gap",
        "grid-column-gap"
      ],
      appliesto: "gridContainers",
      computed: [
        "grid-row-gap",
        "grid-column-gap"
      ],
      order: "uniqueOrder",
      status: "obsolete",
      mdn_url: "https://developer.mozilla.org/docs/Web/CSS/gap"
    },
    "grid-row": {
      syntax: "<grid-line> [ / <grid-line> ]?",
      media: "visual",
      inherited: false,
      animationType: "discrete",
      percentages: "no",
      groups: [
        "CSS Grid Layout"
      ],
      initial: [
        "grid-row-start",
        "grid-row-end"
      ],
      appliesto: "gridItemsAndBoxesWithinGridContainer",
      computed: [
        "grid-row-start",
        "grid-row-end"
      ],
      order: "uniqueOrder",
      status: "standard",
      mdn_url: "https://developer.mozilla.org/docs/Web/CSS/grid-row"
    },
    "grid-row-end": {
      syntax: "<grid-line>",
      media: "visual",
      inherited: false,
      animationType: "discrete",
      percentages: "no",
      groups: [
        "CSS Grid Layout"
      ],
      initial: "auto",
      appliesto: "gridItemsAndBoxesWithinGridContainer",
      computed: "asSpecified",
      order: "uniqueOrder",
      status: "standard",
      mdn_url: "https://developer.mozilla.org/docs/Web/CSS/grid-row-end"
    },
    "grid-row-gap": {
      syntax: "<length-percentage>",
      media: "visual",
      inherited: false,
      animationType: "length",
      percentages: "referToDimensionOfContentArea",
      groups: [
        "CSS Grid Layout"
      ],
      initial: "0",
      appliesto: "gridContainers",
      computed: "percentageAsSpecifiedOrAbsoluteLength",
      order: "uniqueOrder",
      status: "obsolete",
      mdn_url: "https://developer.mozilla.org/docs/Web/CSS/row-gap"
    },
    "grid-row-start": {
      syntax: "<grid-line>",
      media: "visual",
      inherited: false,
      animationType: "discrete",
      percentages: "no",
      groups: [
        "CSS Grid Layout"
      ],
      initial: "auto",
      appliesto: "gridItemsAndBoxesWithinGridContainer",
      computed: "asSpecified",
      order: "uniqueOrder",
      status: "standard",
      mdn_url: "https://developer.mozilla.org/docs/Web/CSS/grid-row-start"
    },
    "grid-template": {
      syntax: "none | [ <'grid-template-rows'> / <'grid-template-columns'> ] | [ <line-names>? <string> <track-size>? <line-names>? ]+ [ / <explicit-track-list> ]?",
      media: "visual",
      inherited: false,
      animationType: "discrete",
      percentages: [
        "grid-template-columns",
        "grid-template-rows"
      ],
      groups: [
        "CSS Grid Layout"
      ],
      initial: [
        "grid-template-columns",
        "grid-template-rows",
        "grid-template-areas"
      ],
      appliesto: "gridContainers",
      computed: [
        "grid-template-columns",
        "grid-template-rows",
        "grid-template-areas"
      ],
      order: "uniqueOrder",
      status: "standard",
      mdn_url: "https://developer.mozilla.org/docs/Web/CSS/grid-template"
    },
    "grid-template-areas": {
      syntax: "none | <string>+",
      media: "visual",
      inherited: false,
      animationType: "discrete",
      percentages: "no",
      groups: [
        "CSS Grid Layout"
      ],
      initial: "none",
      appliesto: "gridContainers",
      computed: "asSpecified",
      order: "uniqueOrder",
      status: "standard",
      mdn_url: "https://developer.mozilla.org/docs/Web/CSS/grid-template-areas"
    },
    "grid-template-columns": {
      syntax: "none | <track-list> | <auto-track-list> | subgrid <line-name-list>?",
      media: "visual",
      inherited: false,
      animationType: "simpleListOfLpcDifferenceLpc",
      percentages: "referToDimensionOfContentArea",
      groups: [
        "CSS Grid Layout"
      ],
      initial: "none",
      appliesto: "gridContainers",
      computed: "asSpecifiedRelativeToAbsoluteLengths",
      order: "uniqueOrder",
      status: "standard",
      mdn_url: "https://developer.mozilla.org/docs/Web/CSS/grid-template-columns"
    },
    "grid-template-rows": {
      syntax: "none | <track-list> | <auto-track-list> | subgrid <line-name-list>?",
      media: "visual",
      inherited: false,
      animationType: "simpleListOfLpcDifferenceLpc",
      percentages: "referToDimensionOfContentArea",
      groups: [
        "CSS Grid Layout"
      ],
      initial: "none",
      appliesto: "gridContainers",
      computed: "asSpecifiedRelativeToAbsoluteLengths",
      order: "uniqueOrder",
      status: "standard",
      mdn_url: "https://developer.mozilla.org/docs/Web/CSS/grid-template-rows"
    },
    "hanging-punctuation": {
      syntax: "none | [ first || [ force-end | allow-end ] || last ]",
      media: "visual",
      inherited: true,
      animationType: "discrete",
      percentages: "no",
      groups: [
        "CSS Text"
      ],
      initial: "none",
      appliesto: "allElements",
      computed: "asSpecified",
      order: "uniqueOrder",
      status: "standard",
      mdn_url: "https://developer.mozilla.org/docs/Web/CSS/hanging-punctuation"
    },
    height: {
      syntax: "auto | <length> | <percentage> | min-content | max-content | fit-content | fit-content(<length-percentage>)",
      media: "visual",
      inherited: false,
      animationType: "lpc",
      percentages: "regardingHeightOfGeneratedBoxContainingBlockPercentagesRelativeToContainingBlock",
      groups: [
        "CSS Box Model"
      ],
      initial: "auto",
      appliesto: "allElementsButNonReplacedAndTableColumns",
      computed: "percentageAutoOrAbsoluteLength",
      order: "uniqueOrder",
      status: "standard",
      mdn_url: "https://developer.mozilla.org/docs/Web/CSS/height"
    },
    "hyphenate-character": {
      syntax: "auto | <string>",
      media: "visual",
      inherited: true,
      animationType: "discrete",
      percentages: "no",
      groups: [
        "CSS Text"
      ],
      initial: "auto",
      appliesto: "allElements",
      computed: "asSpecified",
      order: "perGrammar",
      status: "standard",
      mdn_url: "https://developer.mozilla.org/docs/Web/CSS/hyphenate-character"
    },
    hyphens: {
      syntax: "none | manual | auto",
      media: "visual",
      inherited: true,
      animationType: "discrete",
      percentages: "no",
      groups: [
        "CSS Text"
      ],
      initial: "manual",
      appliesto: "allElements",
      computed: "asSpecified",
      order: "uniqueOrder",
      status: "standard",
      mdn_url: "https://developer.mozilla.org/docs/Web/CSS/hyphens"
    },
    "image-orientation": {
      syntax: "from-image | <angle> | [ <angle>? flip ]",
      media: "visual",
      inherited: true,
      animationType: "discrete",
      percentages: "no",
      groups: [
        "CSS Images"
      ],
      initial: "from-image",
      appliesto: "allElements",
      computed: "angleRoundedToNextQuarter",
      order: "uniqueOrder",
      status: "standard",
      mdn_url: "https://developer.mozilla.org/docs/Web/CSS/image-orientation"
    },
    "image-rendering": {
      syntax: "auto | crisp-edges | pixelated",
      media: "visual",
      inherited: true,
      animationType: "discrete",
      percentages: "no",
      groups: [
        "CSS Images"
      ],
      initial: "auto",
      appliesto: "allElements",
      computed: "asSpecified",
      order: "uniqueOrder",
      status: "standard",
      mdn_url: "https://developer.mozilla.org/docs/Web/CSS/image-rendering"
    },
    "image-resolution": {
      syntax: "[ from-image || <resolution> ] && snap?",
      media: "visual",
      inherited: true,
      animationType: "discrete",
      percentages: "no",
      groups: [
        "CSS Images"
      ],
      initial: "1dppx",
      appliesto: "allElements",
      computed: "asSpecifiedWithExceptionOfResolution",
      order: "uniqueOrder",
      status: "experimental"
    },
    "ime-mode": {
      syntax: "auto | normal | active | inactive | disabled",
      media: "interactive",
      inherited: false,
      animationType: "discrete",
      percentages: "no",
      groups: [
        "CSS Basic User Interface"
      ],
      initial: "auto",
      appliesto: "textFields",
      computed: "asSpecified",
      order: "uniqueOrder",
      status: "obsolete",
      mdn_url: "https://developer.mozilla.org/docs/Web/CSS/ime-mode"
    },
    "initial-letter": {
      syntax: "normal | [ <number> <integer>? ]",
      media: "visual",
      inherited: false,
      animationType: "discrete",
      percentages: "no",
      groups: [
        "CSS Inline"
      ],
      initial: "normal",
      appliesto: "firstLetterPseudoElementsAndInlineLevelFirstChildren",
      computed: "asSpecified",
      order: "uniqueOrder",
      status: "experimental",
      mdn_url: "https://developer.mozilla.org/docs/Web/CSS/initial-letter"
    },
    "initial-letter-align": {
      syntax: "[ auto | alphabetic | hanging | ideographic ]",
      media: "visual",
      inherited: false,
      animationType: "discrete",
      percentages: "no",
      groups: [
        "CSS Inline"
      ],
      initial: "auto",
      appliesto: "firstLetterPseudoElementsAndInlineLevelFirstChildren",
      computed: "asSpecified",
      order: "uniqueOrder",
      status: "experimental",
      mdn_url: "https://developer.mozilla.org/docs/Web/CSS/initial-letter-align"
    },
    "inline-size": {
      syntax: "<'width'>",
      media: "visual",
      inherited: false,
      animationType: "lpc",
      percentages: "inlineSizeOfContainingBlock",
      groups: [
        "CSS Logical Properties"
      ],
      initial: "auto",
      appliesto: "sameAsWidthAndHeight",
      computed: "sameAsWidthAndHeight",
      order: "uniqueOrder",
      status: "standard",
      mdn_url: "https://developer.mozilla.org/docs/Web/CSS/inline-size"
    },
    "input-security": {
      syntax: "auto | none",
      media: "interactive",
      inherited: false,
      animationType: "byComputedValueType",
      percentages: "no",
      groups: [
        "CSS Basic User Interface"
      ],
      initial: "auto",
      appliesto: "sensitiveTextInputs",
      computed: "asSpecified",
      order: "perGrammar",
      status: "standard"
    },
    inset: {
      syntax: "<'top'>{1,4}",
      media: "visual",
      inherited: false,
      animationType: "lpc",
      percentages: "logicalHeightOrWidthOfContainingBlock",
      groups: [
        "CSS Logical Properties"
      ],
      initial: [
        "top",
        "bottom",
        "left",
        "right"
      ],
      appliesto: "positionedElements",
      computed: [
        "top",
        "bottom",
        "left",
        "right"
      ],
      order: "uniqueOrder",
      status: "standard",
      mdn_url: "https://developer.mozilla.org/docs/Web/CSS/inset"
    },
    "inset-block": {
      syntax: "<'top'>{1,2}",
      media: "visual",
      inherited: false,
      animationType: "lpc",
      percentages: "logicalHeightOfContainingBlock",
      groups: [
        "CSS Logical Properties"
      ],
      initial: [
        "inset-block-start",
        "inset-block-end"
      ],
      appliesto: "positionedElements",
      computed: [
        "inset-block-start",
        "inset-block-end"
      ],
      order: "uniqueOrder",
      status: "standard",
      mdn_url: "https://developer.mozilla.org/docs/Web/CSS/inset-block"
    },
    "inset-block-end": {
      syntax: "<'top'>",
      media: "visual",
      inherited: false,
      animationType: "lpc",
      percentages: "logicalHeightOfContainingBlock",
      groups: [
        "CSS Logical Properties"
      ],
      initial: "auto",
      appliesto: "positionedElements",
      computed: "sameAsBoxOffsets",
      order: "uniqueOrder",
      status: "standard",
      mdn_url: "https://developer.mozilla.org/docs/Web/CSS/inset-block-end"
    },
    "inset-block-start": {
      syntax: "<'top'>",
      media: "visual",
      inherited: false,
      animationType: "lpc",
      percentages: "logicalHeightOfContainingBlock",
      groups: [
        "CSS Logical Properties"
      ],
      initial: "auto",
      appliesto: "positionedElements",
      computed: "sameAsBoxOffsets",
      order: "uniqueOrder",
      status: "standard",
      mdn_url: "https://developer.mozilla.org/docs/Web/CSS/inset-block-start"
    },
    "inset-inline": {
      syntax: "<'top'>{1,2}",
      media: "visual",
      inherited: false,
      animationType: "lpc",
      percentages: "logicalWidthOfContainingBlock",
      groups: [
        "CSS Logical Properties"
      ],
      initial: [
        "inset-inline-start",
        "inset-inline-end"
      ],
      appliesto: "positionedElements",
      computed: [
        "inset-inline-start",
        "inset-inline-end"
      ],
      order: "uniqueOrder",
      status: "standard",
      mdn_url: "https://developer.mozilla.org/docs/Web/CSS/inset-inline"
    },
    "inset-inline-end": {
      syntax: "<'top'>",
      media: "visual",
      inherited: false,
      animationType: "lpc",
      percentages: "logicalWidthOfContainingBlock",
      groups: [
        "CSS Logical Properties"
      ],
      initial: "auto",
      appliesto: "positionedElements",
      computed: "sameAsBoxOffsets",
      order: "uniqueOrder",
      status: "standard",
      mdn_url: "https://developer.mozilla.org/docs/Web/CSS/inset-inline-end"
    },
    "inset-inline-start": {
      syntax: "<'top'>",
      media: "visual",
      inherited: false,
      animationType: "lpc",
      percentages: "logicalWidthOfContainingBlock",
      groups: [
        "CSS Logical Properties"
      ],
      initial: "auto",
      appliesto: "positionedElements",
      computed: "sameAsBoxOffsets",
      order: "uniqueOrder",
      status: "standard",
      mdn_url: "https://developer.mozilla.org/docs/Web/CSS/inset-inline-start"
    },
    isolation: {
      syntax: "auto | isolate",
      media: "visual",
      inherited: false,
      animationType: "discrete",
      percentages: "no",
      groups: [
        "Compositing and Blending"
      ],
      initial: "auto",
      appliesto: "allElementsSVGContainerGraphicsAndGraphicsReferencingElements",
      computed: "asSpecified",
      order: "uniqueOrder",
      status: "standard",
      mdn_url: "https://developer.mozilla.org/docs/Web/CSS/isolation"
    },
    "justify-content": {
      syntax: "normal | <content-distribution> | <overflow-position>? [ <content-position> | left | right ]",
      media: "visual",
      inherited: false,
      animationType: "discrete",
      percentages: "no",
      groups: [
        "CSS Box Alignment"
      ],
      initial: "normal",
      appliesto: "flexContainers",
      computed: "asSpecified",
      order: "uniqueOrder",
      status: "standard",
      mdn_url: "https://developer.mozilla.org/docs/Web/CSS/justify-content"
    },
    "justify-items": {
      syntax: "normal | stretch | <baseline-position> | <overflow-position>? [ <self-position> | left | right ] | legacy | legacy && [ left | right | center ]",
      media: "visual",
      inherited: false,
      animationType: "discrete",
      percentages: "no",
      groups: [
        "CSS Box Alignment"
      ],
      initial: "legacy",
      appliesto: "allElements",
      computed: "asSpecified",
      order: "perGrammar",
      status: "standard",
      mdn_url: "https://developer.mozilla.org/docs/Web/CSS/justify-items"
    },
    "justify-self": {
      syntax: "auto | normal | stretch | <baseline-position> | <overflow-position>? [ <self-position> | left | right ]",
      media: "visual",
      inherited: false,
      animationType: "discrete",
      percentages: "no",
      groups: [
        "CSS Box Alignment"
      ],
      initial: "auto",
      appliesto: "blockLevelBoxesAndAbsolutelyPositionedBoxesAndGridItems",
      computed: "asSpecified",
      order: "uniqueOrder",
      status: "standard",
      mdn_url: "https://developer.mozilla.org/docs/Web/CSS/justify-self"
    },
    "justify-tracks": {
      syntax: "[ normal | <content-distribution> | <overflow-position>? [ <content-position> | left | right ] ]#",
      media: "visual",
      inherited: false,
      animationType: "discrete",
      percentages: "no",
      groups: [
        "CSS Grid Layout"
      ],
      initial: "normal",
      appliesto: "gridContainersWithMasonryLayoutInTheirInlineAxis",
      computed: "asSpecified",
      order: "uniqueOrder",
      status: "experimental",
      mdn_url: "https://developer.mozilla.org/docs/Web/CSS/justify-tracks"
    },
    left: {
      syntax: "<length> | <percentage> | auto",
      media: "visual",
      inherited: false,
      animationType: "lpc",
      percentages: "referToWidthOfContainingBlock",
      groups: [
        "CSS Positioning"
      ],
      initial: "auto",
      appliesto: "positionedElements",
      computed: "lengthAbsolutePercentageAsSpecifiedOtherwiseAuto",
      order: "uniqueOrder",
      status: "standard",
      mdn_url: "https://developer.mozilla.org/docs/Web/CSS/left"
    },
    "letter-spacing": {
      syntax: "normal | <length>",
      media: "visual",
      inherited: true,
      animationType: "length",
      percentages: "no",
      groups: [
        "CSS Text"
      ],
      initial: "normal",
      appliesto: "allElements",
      computed: "optimumValueOfAbsoluteLengthOrNormal",
      order: "uniqueOrder",
      alsoAppliesTo: [
        "::first-letter",
        "::first-line"
      ],
      status: "standard",
      mdn_url: "https://developer.mozilla.org/docs/Web/CSS/letter-spacing"
    },
    "line-break": {
      syntax: "auto | loose | normal | strict | anywhere",
      media: "visual",
      inherited: true,
      animationType: "discrete",
      percentages: "no",
      groups: [
        "CSS Text"
      ],
      initial: "auto",
      appliesto: "allElements",
      computed: "asSpecified",
      order: "uniqueOrder",
      status: "standard",
      mdn_url: "https://developer.mozilla.org/docs/Web/CSS/line-break"
    },
    "line-clamp": {
      syntax: "none | <integer>",
      media: "visual",
      inherited: false,
      animationType: "integer",
      percentages: "no",
      groups: [
        "CSS Overflow"
      ],
      initial: "none",
      appliesto: "blockContainersExceptMultiColumnContainers",
      computed: "asSpecified",
      order: "perGrammar",
      status: "experimental"
    },
    "line-height": {
      syntax: "normal | <number> | <length> | <percentage>",
      media: "visual",
      inherited: true,
      animationType: "numberOrLength",
      percentages: "referToElementFontSize",
      groups: [
        "CSS Fonts"
      ],
      initial: "normal",
      appliesto: "allElements",
      computed: "absoluteLengthOrAsSpecified",
      order: "uniqueOrder",
      alsoAppliesTo: [
        "::first-letter",
        "::first-line",
        "::placeholder"
      ],
      status: "standard",
      mdn_url: "https://developer.mozilla.org/docs/Web/CSS/line-height"
    },
    "line-height-step": {
      syntax: "<length>",
      media: "visual",
      inherited: true,
      animationType: "discrete",
      percentages: "no",
      groups: [
        "CSS Fonts"
      ],
      initial: "0",
      appliesto: "blockContainers",
      computed: "absoluteLength",
      order: "perGrammar",
      status: "experimental",
      mdn_url: "https://developer.mozilla.org/docs/Web/CSS/line-height-step"
    },
    "list-style": {
      syntax: "<'list-style-type'> || <'list-style-position'> || <'list-style-image'>",
      media: "visual",
      inherited: true,
      animationType: "discrete",
      percentages: "no",
      groups: [
        "CSS Lists and Counters"
      ],
      initial: [
        "list-style-type",
        "list-style-position",
        "list-style-image"
      ],
      appliesto: "listItems",
      computed: [
        "list-style-image",
        "list-style-position",
        "list-style-type"
      ],
      order: "orderOfAppearance",
      status: "standard",
      mdn_url: "https://developer.mozilla.org/docs/Web/CSS/list-style"
    },
    "list-style-image": {
      syntax: "<image> | none",
      media: "visual",
      inherited: true,
      animationType: "discrete",
      percentages: "no",
      groups: [
        "CSS Lists and Counters"
      ],
      initial: "none",
      appliesto: "listItems",
      computed: "theKeywordListStyleImageNoneOrComputedValue",
      order: "uniqueOrder",
      status: "standard",
      mdn_url: "https://developer.mozilla.org/docs/Web/CSS/list-style-image"
    },
    "list-style-position": {
      syntax: "inside | outside",
      media: "visual",
      inherited: true,
      animationType: "discrete",
      percentages: "no",
      groups: [
        "CSS Lists and Counters"
      ],
      initial: "outside",
      appliesto: "listItems",
      computed: "asSpecified",
      order: "uniqueOrder",
      status: "standard",
      mdn_url: "https://developer.mozilla.org/docs/Web/CSS/list-style-position"
    },
    "list-style-type": {
      syntax: "<counter-style> | <string> | none",
      media: "visual",
      inherited: true,
      animationType: "discrete",
      percentages: "no",
      groups: [
        "CSS Lists and Counters"
      ],
      initial: "disc",
      appliesto: "listItems",
      computed: "asSpecified",
      order: "uniqueOrder",
      status: "standard",
      mdn_url: "https://developer.mozilla.org/docs/Web/CSS/list-style-type"
    },
    margin: {
      syntax: "[ <length> | <percentage> | auto ]{1,4}",
      media: "visual",
      inherited: false,
      animationType: "length",
      percentages: "referToWidthOfContainingBlock",
      groups: [
        "CSS Box Model"
      ],
      initial: [
        "margin-bottom",
        "margin-left",
        "margin-right",
        "margin-top"
      ],
      appliesto: "allElementsExceptTableDisplayTypes",
      computed: [
        "margin-bottom",
        "margin-left",
        "margin-right",
        "margin-top"
      ],
      order: "uniqueOrder",
      alsoAppliesTo: [
        "::first-letter",
        "::first-line"
      ],
      status: "standard",
      mdn_url: "https://developer.mozilla.org/docs/Web/CSS/margin"
    },
    "margin-block": {
      syntax: "<'margin-left'>{1,2}",
      media: "visual",
      inherited: false,
      animationType: "length",
      percentages: "dependsOnLayoutModel",
      groups: [
        "CSS Logical Properties"
      ],
      initial: [
        "margin-block-start",
        "margin-block-end"
      ],
      appliesto: "sameAsMargin",
      computed: [
        "margin-block-start",
        "margin-block-end"
      ],
      order: "uniqueOrder",
      status: "standard",
      mdn_url: "https://developer.mozilla.org/docs/Web/CSS/margin-block"
    },
    "margin-block-end": {
      syntax: "<'margin-left'>",
      media: "visual",
      inherited: false,
      animationType: "length",
      percentages: "dependsOnLayoutModel",
      groups: [
        "CSS Logical Properties"
      ],
      initial: "0",
      appliesto: "sameAsMargin",
      computed: "lengthAbsolutePercentageAsSpecifiedOtherwiseAuto",
      order: "uniqueOrder",
      status: "standard",
      mdn_url: "https://developer.mozilla.org/docs/Web/CSS/margin-block-end"
    },
    "margin-block-start": {
      syntax: "<'margin-left'>",
      media: "visual",
      inherited: false,
      animationType: "length",
      percentages: "dependsOnLayoutModel",
      groups: [
        "CSS Logical Properties"
      ],
      initial: "0",
      appliesto: "sameAsMargin",
      computed: "lengthAbsolutePercentageAsSpecifiedOtherwiseAuto",
      order: "uniqueOrder",
      status: "standard",
      mdn_url: "https://developer.mozilla.org/docs/Web/CSS/margin-block-start"
    },
    "margin-bottom": {
      syntax: "<length> | <percentage> | auto",
      media: "visual",
      inherited: false,
      animationType: "length",
      percentages: "referToWidthOfContainingBlock",
      groups: [
        "CSS Box Model"
      ],
      initial: "0",
      appliesto: "allElementsExceptTableDisplayTypes",
      computed: "percentageAsSpecifiedOrAbsoluteLength",
      order: "uniqueOrder",
      alsoAppliesTo: [
        "::first-letter",
        "::first-line"
      ],
      status: "standard",
      mdn_url: "https://developer.mozilla.org/docs/Web/CSS/margin-bottom"
    },
    "margin-inline": {
      syntax: "<'margin-left'>{1,2}",
      media: "visual",
      inherited: false,
      animationType: "length",
      percentages: "dependsOnLayoutModel",
      groups: [
        "CSS Logical Properties"
      ],
      initial: [
        "margin-inline-start",
        "margin-inline-end"
      ],
      appliesto: "sameAsMargin",
      computed: [
        "margin-inline-start",
        "margin-inline-end"
      ],
      order: "uniqueOrder",
      status: "standard",
      mdn_url: "https://developer.mozilla.org/docs/Web/CSS/margin-inline"
    },
    "margin-inline-end": {
      syntax: "<'margin-left'>",
      media: "visual",
      inherited: false,
      animationType: "length",
      percentages: "dependsOnLayoutModel",
      groups: [
        "CSS Logical Properties"
      ],
      initial: "0",
      appliesto: "sameAsMargin",
      computed: "lengthAbsolutePercentageAsSpecifiedOtherwiseAuto",
      order: "uniqueOrder",
      status: "standard",
      mdn_url: "https://developer.mozilla.org/docs/Web/CSS/margin-inline-end"
    },
    "margin-inline-start": {
      syntax: "<'margin-left'>",
      media: "visual",
      inherited: false,
      animationType: "length",
      percentages: "dependsOnLayoutModel",
      groups: [
        "CSS Logical Properties"
      ],
      initial: "0",
      appliesto: "sameAsMargin",
      computed: "lengthAbsolutePercentageAsSpecifiedOtherwiseAuto",
      order: "uniqueOrder",
      status: "standard",
      mdn_url: "https://developer.mozilla.org/docs/Web/CSS/margin-inline-start"
    },
    "margin-left": {
      syntax: "<length> | <percentage> | auto",
      media: "visual",
      inherited: false,
      animationType: "length",
      percentages: "referToWidthOfContainingBlock",
      groups: [
        "CSS Box Model"
      ],
      initial: "0",
      appliesto: "allElementsExceptTableDisplayTypes",
      computed: "percentageAsSpecifiedOrAbsoluteLength",
      order: "uniqueOrder",
      alsoAppliesTo: [
        "::first-letter",
        "::first-line"
      ],
      status: "standard",
      mdn_url: "https://developer.mozilla.org/docs/Web/CSS/margin-left"
    },
    "margin-right": {
      syntax: "<length> | <percentage> | auto",
      media: "visual",
      inherited: false,
      animationType: "length",
      percentages: "referToWidthOfContainingBlock",
      groups: [
        "CSS Box Model"
      ],
      initial: "0",
      appliesto: "allElementsExceptTableDisplayTypes",
      computed: "percentageAsSpecifiedOrAbsoluteLength",
      order: "uniqueOrder",
      alsoAppliesTo: [
        "::first-letter",
        "::first-line"
      ],
      status: "standard",
      mdn_url: "https://developer.mozilla.org/docs/Web/CSS/margin-right"
    },
    "margin-top": {
      syntax: "<length> | <percentage> | auto",
      media: "visual",
      inherited: false,
      animationType: "length",
      percentages: "referToWidthOfContainingBlock",
      groups: [
        "CSS Box Model"
      ],
      initial: "0",
      appliesto: "allElementsExceptTableDisplayTypes",
      computed: "percentageAsSpecifiedOrAbsoluteLength",
      order: "uniqueOrder",
      alsoAppliesTo: [
        "::first-letter",
        "::first-line"
      ],
      status: "standard",
      mdn_url: "https://developer.mozilla.org/docs/Web/CSS/margin-top"
    },
    "margin-trim": {
      syntax: "none | in-flow | all",
      media: "visual",
      inherited: false,
      animationType: "discrete",
      percentages: "no",
      groups: [
        "CSS Box Model"
      ],
      initial: "none",
      appliesto: "blockContainersAndMultiColumnContainers",
      computed: "asSpecified",
      order: "perGrammar",
      alsoAppliesTo: [
        "::first-letter",
        "::first-line"
      ],
      status: "experimental",
      mdn_url: "https://developer.mozilla.org/docs/Web/CSS/margin-trim"
    },
    mask: {
      syntax: "<mask-layer>#",
      media: "visual",
      inherited: false,
      animationType: [
        "mask-image",
        "mask-mode",
        "mask-repeat",
        "mask-position",
        "mask-clip",
        "mask-origin",
        "mask-size",
        "mask-composite"
      ],
      percentages: [
        "mask-position"
      ],
      groups: [
        "CSS Masking"
      ],
      initial: [
        "mask-image",
        "mask-mode",
        "mask-repeat",
        "mask-position",
        "mask-clip",
        "mask-origin",
        "mask-size",
        "mask-composite"
      ],
      appliesto: "allElementsSVGContainerElements",
      computed: [
        "mask-image",
        "mask-mode",
        "mask-repeat",
        "mask-position",
        "mask-clip",
        "mask-origin",
        "mask-size",
        "mask-composite"
      ],
      order: "perGrammar",
      stacking: true,
      status: "standard",
      mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask"
    },
    "mask-border": {
      syntax: "<'mask-border-source'> || <'mask-border-slice'> [ / <'mask-border-width'>? [ / <'mask-border-outset'> ]? ]? || <'mask-border-repeat'> || <'mask-border-mode'>",
      media: "visual",
      inherited: false,
      animationType: [
        "mask-border-mode",
        "mask-border-outset",
        "mask-border-repeat",
        "mask-border-slice",
        "mask-border-source",
        "mask-border-width"
      ],
      percentages: [
        "mask-border-slice",
        "mask-border-width"
      ],
      groups: [
        "CSS Masking"
      ],
      initial: [
        "mask-border-mode",
        "mask-border-outset",
        "mask-border-repeat",
        "mask-border-slice",
        "mask-border-source",
        "mask-border-width"
      ],
      appliesto: "allElementsSVGContainerElements",
      computed: [
        "mask-border-mode",
        "mask-border-outset",
        "mask-border-repeat",
        "mask-border-slice",
        "mask-border-source",
        "mask-border-width"
      ],
      order: "perGrammar",
      stacking: true,
      status: "standard",
      mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-border"
    },
    "mask-border-mode": {
      syntax: "luminance | alpha",
      media: "visual",
      inherited: false,
      animationType: "discrete",
      percentages: "no",
      groups: [
        "CSS Masking"
      ],
      initial: "alpha",
      appliesto: "allElementsSVGContainerElements",
      computed: "asSpecified",
      order: "perGrammar",
      status: "standard",
      mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-border-mode"
    },
    "mask-border-outset": {
      syntax: "[ <length> | <number> ]{1,4}",
      media: "visual",
      inherited: false,
      animationType: "discrete",
      percentages: "no",
      groups: [
        "CSS Masking"
      ],
      initial: "0",
      appliesto: "allElementsSVGContainerElements",
      computed: "asSpecifiedRelativeToAbsoluteLengths",
      order: "perGrammar",
      status: "standard",
      mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-border-outset"
    },
    "mask-border-repeat": {
      syntax: "[ stretch | repeat | round | space ]{1,2}",
      media: "visual",
      inherited: false,
      animationType: "discrete",
      percentages: "no",
      groups: [
        "CSS Masking"
      ],
      initial: "stretch",
      appliesto: "allElementsSVGContainerElements",
      computed: "asSpecified",
      order: "perGrammar",
      status: "standard",
      mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-border-repeat"
    },
    "mask-border-slice": {
      syntax: "<number-percentage>{1,4} fill?",
      media: "visual",
      inherited: false,
      animationType: "discrete",
      percentages: "referToSizeOfMaskBorderImage",
      groups: [
        "CSS Masking"
      ],
      initial: "0",
      appliesto: "allElementsSVGContainerElements",
      computed: "asSpecified",
      order: "perGrammar",
      status: "standard",
      mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-border-slice"
    },
    "mask-border-source": {
      syntax: "none | <image>",
      media: "visual",
      inherited: false,
      animationType: "discrete",
      percentages: "no",
      groups: [
        "CSS Masking"
      ],
      initial: "none",
      appliesto: "allElementsSVGContainerElements",
      computed: "asSpecifiedURLsAbsolute",
      order: "perGrammar",
      status: "standard",
      mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-border-source"
    },
    "mask-border-width": {
      syntax: "[ <length-percentage> | <number> | auto ]{1,4}",
      media: "visual",
      inherited: false,
      animationType: "discrete",
      percentages: "relativeToMaskBorderImageArea",
      groups: [
        "CSS Masking"
      ],
      initial: "auto",
      appliesto: "allElementsSVGContainerElements",
      computed: "asSpecifiedRelativeToAbsoluteLengths",
      order: "perGrammar",
      status: "standard",
      mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-border-width"
    },
    "mask-clip": {
      syntax: "[ <geometry-box> | no-clip ]#",
      media: "visual",
      inherited: false,
      animationType: "discrete",
      percentages: "no",
      groups: [
        "CSS Masking"
      ],
      initial: "border-box",
      appliesto: "allElementsSVGContainerElements",
      computed: "asSpecified",
      order: "perGrammar",
      status: "standard",
      mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-clip"
    },
    "mask-composite": {
      syntax: "<compositing-operator>#",
      media: "visual",
      inherited: false,
      animationType: "discrete",
      percentages: "no",
      groups: [
        "CSS Masking"
      ],
      initial: "add",
      appliesto: "allElementsSVGContainerElements",
      computed: "asSpecified",
      order: "perGrammar",
      status: "standard",
      mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-composite"
    },
    "mask-image": {
      syntax: "<mask-reference>#",
      media: "visual",
      inherited: false,
      animationType: "discrete",
      percentages: "no",
      groups: [
        "CSS Masking"
      ],
      initial: "none",
      appliesto: "allElementsSVGContainerElements",
      computed: "asSpecifiedURLsAbsolute",
      order: "perGrammar",
      status: "standard",
      mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-image"
    },
    "mask-mode": {
      syntax: "<masking-mode>#",
      media: "visual",
      inherited: false,
      animationType: "discrete",
      percentages: "no",
      groups: [
        "CSS Masking"
      ],
      initial: "match-source",
      appliesto: "allElementsSVGContainerElements",
      computed: "asSpecified",
      order: "perGrammar",
      status: "standard",
      mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-mode"
    },
    "mask-origin": {
      syntax: "<geometry-box>#",
      media: "visual",
      inherited: false,
      animationType: "discrete",
      percentages: "no",
      groups: [
        "CSS Masking"
      ],
      initial: "border-box",
      appliesto: "allElementsSVGContainerElements",
      computed: "asSpecified",
      order: "perGrammar",
      status: "standard",
      mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-origin"
    },
    "mask-position": {
      syntax: "<position>#",
      media: "visual",
      inherited: false,
      animationType: "repeatableListOfSimpleListOfLpc",
      percentages: "referToSizeOfMaskPaintingArea",
      groups: [
        "CSS Masking"
      ],
      initial: "center",
      appliesto: "allElementsSVGContainerElements",
      computed: "consistsOfTwoKeywordsForOriginAndOffsets",
      order: "perGrammar",
      status: "standard",
      mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-position"
    },
    "mask-repeat": {
      syntax: "<repeat-style>#",
      media: "visual",
      inherited: false,
      animationType: "discrete",
      percentages: "no",
      groups: [
        "CSS Masking"
      ],
      initial: "repeat",
      appliesto: "allElementsSVGContainerElements",
      computed: "consistsOfTwoDimensionKeywords",
      order: "perGrammar",
      status: "standard",
      mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-repeat"
    },
    "mask-size": {
      syntax: "<bg-size>#",
      media: "visual",
      inherited: false,
      animationType: "repeatableListOfSimpleListOfLpc",
      percentages: "no",
      groups: [
        "CSS Masking"
      ],
      initial: "auto",
      appliesto: "allElementsSVGContainerElements",
      computed: "asSpecifiedRelativeToAbsoluteLengths",
      order: "perGrammar",
      status: "standard",
      mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-size"
    },
    "mask-type": {
      syntax: "luminance | alpha",
      media: "visual",
      inherited: false,
      animationType: "discrete",
      percentages: "no",
      groups: [
        "CSS Masking"
      ],
      initial: "luminance",
      appliesto: "maskElements",
      computed: "asSpecified",
      order: "perGrammar",
      status: "standard",
      mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-type"
    },
    "masonry-auto-flow": {
      syntax: "[ pack | next ] || [ definite-first | ordered ]",
      media: "visual",
      inherited: false,
      animationType: "discrete",
      percentages: "no",
      groups: [
        "CSS Grid Layout"
      ],
      initial: "pack",
      appliesto: "gridContainersWithMasonryLayout",
      computed: "asSpecified",
      order: "uniqueOrder",
      status: "experimental",
      mdn_url: "https://developer.mozilla.org/docs/Web/CSS/masonry-auto-flow"
    },
    "math-depth": {
      syntax: "auto-add | add(<integer>) | <integer>",
      media: "visual",
      inherited: true,
      animationType: "notAnimatable",
      percentages: "no",
      groups: [
        "MathML"
      ],
      initial: "0",
      appliesto: "allElements",
      computed: "asSpecified",
      order: "perGrammar",
      status: "standard",
      mdn_url: "https://developer.mozilla.org/docs/Web/CSS/math-depth"
    },
    "math-shift": {
      syntax: "normal | compact",
      media: "visual",
      inherited: true,
      animationType: "notAnimatable",
      percentages: "no",
      groups: [
        "MathML"
      ],
      initial: "normal",
      appliesto: "allElements",
      computed: "asSpecified",
      order: "perGrammar",
      status: "standard",
      mdn_url: "https://developer.mozilla.org/docs/Web/CSS/math-shift"
    },
    "math-style": {
      syntax: "normal | compact",
      media: "visual",
      inherited: true,
      animationType: "notAnimatable",
      percentages: "no",
      groups: [
        "MathML"
      ],
      initial: "normal",
      appliesto: "allElements",
      computed: "asSpecified",
      order: "perGrammar",
      status: "standard",
      mdn_url: "https://developer.mozilla.org/docs/Web/CSS/math-style"
    },
    "max-block-size": {
      syntax: "<'max-width'>",
      media: "visual",
      inherited: false,
      animationType: "lpc",
      percentages: "blockSizeOfContainingBlock",
      groups: [
        "CSS Logical Properties"
      ],
      initial: "none",
      appliesto: "sameAsWidthAndHeight",
      computed: "sameAsMaxWidthAndMaxHeight",
      order: "uniqueOrder",
      status: "standard",
      mdn_url: "https://developer.mozilla.org/docs/Web/CSS/max-block-size"
    },
    "max-height": {
      syntax: "none | <length-percentage> | min-content | max-content | fit-content | fit-content(<length-percentage>)",
      media: "visual",
      inherited: false,
      animationType: "lpc",
      percentages: "regardingHeightOfGeneratedBoxContainingBlockPercentagesNone",
      groups: [
        "CSS Box Model"
      ],
      initial: "none",
      appliesto: "allElementsButNonReplacedAndTableColumns",
      computed: "percentageAsSpecifiedAbsoluteLengthOrNone",
      order: "uniqueOrder",
      status: "standard",
      mdn_url: "https://developer.mozilla.org/docs/Web/CSS/max-height"
    },
    "max-inline-size": {
      syntax: "<'max-width'>",
      media: "visual",
      inherited: false,
      animationType: "lpc",
      percentages: "inlineSizeOfContainingBlock",
      groups: [
        "CSS Logical Properties"
      ],
      initial: "none",
      appliesto: "sameAsWidthAndHeight",
      computed: "sameAsMaxWidthAndMaxHeight",
      order: "uniqueOrder",
      status: "standard",
      mdn_url: "https://developer.mozilla.org/docs/Web/CSS/max-inline-size"
    },
    "max-lines": {
      syntax: "none | <integer>",
      media: "visual",
      inherited: false,
      animationType: "integer",
      percentages: "no",
      groups: [
        "CSS Overflow"
      ],
      initial: "none",
      appliesto: "blockContainersExceptMultiColumnContainers",
      computed: "asSpecified",
      order: "perGrammar",
      status: "experimental"
    },
    "max-width": {
      syntax: "none | <length-percentage> | min-content | max-content | fit-content | fit-content(<length-percentage>)",
      media: "visual",
      inherited: false,
      animationType: "lpc",
      percentages: "referToWidthOfContainingBlock",
      groups: [
        "CSS Box Model"
      ],
      initial: "none",
      appliesto: "allElementsButNonReplacedAndTableRows",
      computed: "percentageAsSpecifiedAbsoluteLengthOrNone",
      order: "uniqueOrder",
      status: "standard",
      mdn_url: "https://developer.mozilla.org/docs/Web/CSS/max-width"
    },
    "min-block-size": {
      syntax: "<'min-width'>",
      media: "visual",
      inherited: false,
      animationType: "lpc",
      percentages: "blockSizeOfContainingBlock",
      groups: [
        "CSS Logical Properties"
      ],
      initial: "0",
      appliesto: "sameAsWidthAndHeight",
      computed: "sameAsMinWidthAndMinHeight",
      order: "uniqueOrder",
      status: "standard",
      mdn_url: "https://developer.mozilla.org/docs/Web/CSS/min-block-size"
    },
    "min-height": {
      syntax: "auto | <length> | <percentage> | min-content | max-content | fit-content | fit-content(<length-percentage>)",
      media: "visual",
      inherited: false,
      animationType: "lpc",
      percentages: "regardingHeightOfGeneratedBoxContainingBlockPercentages0",
      groups: [
        "CSS Box Model"
      ],
      initial: "auto",
      appliesto: "allElementsButNonReplacedAndTableColumns",
      computed: "percentageAsSpecifiedOrAbsoluteLength",
      order: "uniqueOrder",
      status: "standard",
      mdn_url: "https://developer.mozilla.org/docs/Web/CSS/min-height"
    },
    "min-inline-size": {
      syntax: "<'min-width'>",
      media: "visual",
      inherited: false,
      animationType: "lpc",
      percentages: "inlineSizeOfContainingBlock",
      groups: [
        "CSS Logical Properties"
      ],
      initial: "0",
      appliesto: "sameAsWidthAndHeight",
      computed: "sameAsMinWidthAndMinHeight",
      order: "uniqueOrder",
      status: "standard",
      mdn_url: "https://developer.mozilla.org/docs/Web/CSS/min-inline-size"
    },
    "min-width": {
      syntax: "auto | <length> | <percentage> | min-content | max-content | fit-content | fit-content(<length-percentage>)",
      media: "visual",
      inherited: false,
      animationType: "lpc",
      percentages: "referToWidthOfContainingBlock",
      groups: [
        "CSS Box Model"
      ],
      initial: "auto",
      appliesto: "allElementsButNonReplacedAndTableRows",
      computed: "percentageAsSpecifiedOrAbsoluteLength",
      order: "uniqueOrder",
      status: "standard",
      mdn_url: "https://developer.mozilla.org/docs/Web/CSS/min-width"
    },
    "mix-blend-mode": {
      syntax: "<blend-mode> | plus-lighter",
      media: "visual",
      inherited: false,
      animationType: "discrete",
      percentages: "no",
      groups: [
        "Compositing and Blending"
      ],
      initial: "normal",
      appliesto: "allElements",
      computed: "asSpecified",
      order: "uniqueOrder",
      stacking: true,
      status: "standard",
      mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mix-blend-mode"
    },
    "object-fit": {
      syntax: "fill | contain | cover | none | scale-down",
      media: "visual",
      inherited: false,
      animationType: "discrete",
      percentages: "no",
      groups: [
        "CSS Images"
      ],
      initial: "fill",
      appliesto: "replacedElements",
      computed: "asSpecified",
      order: "uniqueOrder",
      status: "standard",
      mdn_url: "https://developer.mozilla.org/docs/Web/CSS/object-fit"
    },
    "object-position": {
      syntax: "<position>",
      media: "visual",
      inherited: true,
      animationType: "repeatableListOfSimpleListOfLpc",
      percentages: "referToWidthAndHeightOfElement",
      groups: [
        "CSS Images"
      ],
      initial: "50% 50%",
      appliesto: "replacedElements",
      computed: "asSpecified",
      order: "uniqueOrder",
      status: "standard",
      mdn_url: "https://developer.mozilla.org/docs/Web/CSS/object-position"
    },
    offset: {
      syntax: "[ <'offset-position'>? [ <'offset-path'> [ <'offset-distance'> || <'offset-rotate'> ]? ]? ]! [ / <'offset-anchor'> ]?",
      media: "visual",
      inherited: false,
      animationType: [
        "offset-position",
        "offset-path",
        "offset-distance",
        "offset-anchor",
        "offset-rotate"
      ],
      percentages: [
        "offset-position",
        "offset-distance",
        "offset-anchor"
      ],
      groups: [
        "CSS Motion Path"
      ],
      initial: [
        "offset-position",
        "offset-path",
        "offset-distance",
        "offset-anchor",
        "offset-rotate"
      ],
      appliesto: "transformableElements",
      computed: [
        "offset-position",
        "offset-path",
        "offset-distance",
        "offset-anchor",
        "offset-rotate"
      ],
      order: "perGrammar",
      stacking: true,
      status: "standard",
      mdn_url: "https://developer.mozilla.org/docs/Web/CSS/offset"
    },
    "offset-anchor": {
      syntax: "auto | <position>",
      media: "visual",
      inherited: false,
      animationType: "position",
      percentages: "relativeToWidthAndHeight",
      groups: [
        "CSS Motion Path"
      ],
      initial: "auto",
      appliesto: "transformableElements",
      computed: "forLengthAbsoluteValueOtherwisePercentage",
      order: "perGrammar",
      status: "standard"
    },
    "offset-distance": {
      syntax: "<length-percentage>",
      media: "visual",
      inherited: false,
      animationType: "lpc",
      percentages: "referToTotalPathLength",
      groups: [
        "CSS Motion Path"
      ],
      initial: "0",
      appliesto: "transformableElements",
      computed: "forLengthAbsoluteValueOtherwisePercentage",
      order: "perGrammar",
      status: "standard",
      mdn_url: "https://developer.mozilla.org/docs/Web/CSS/offset-distance"
    },
    "offset-path": {
      syntax: "none | ray( [ <angle> && <size> && contain? ] ) | <path()> | <url> | [ <basic-shape> || <geometry-box> ]",
      media: "visual",
      inherited: false,
      animationType: "angleOrBasicShapeOrPath",
      percentages: "no",
      groups: [
        "CSS Motion Path"
      ],
      initial: "none",
      appliesto: "transformableElements",
      computed: "asSpecified",
      order: "perGrammar",
      stacking: true,
      status: "standard",
      mdn_url: "https://developer.mozilla.org/docs/Web/CSS/offset-path"
    },
    "offset-position": {
      syntax: "auto | <position>",
      media: "visual",
      inherited: false,
      animationType: "position",
      percentages: "referToSizeOfContainingBlock",
      groups: [
        "CSS Motion Path"
      ],
      initial: "auto",
      appliesto: "transformableElements",
      computed: "forLengthAbsoluteValueOtherwisePercentage",
      order: "perGrammar",
      status: "experimental"
    },
    "offset-rotate": {
      syntax: "[ auto | reverse ] || <angle>",
      media: "visual",
      inherited: false,
      animationType: "angleOrBasicShapeOrPath",
      percentages: "no",
      groups: [
        "CSS Motion Path"
      ],
      initial: "auto",
      appliesto: "transformableElements",
      computed: "asSpecified",
      order: "perGrammar",
      status: "standard",
      mdn_url: "https://developer.mozilla.org/docs/Web/CSS/offset-rotate"
    },
    opacity: {
      syntax: "<alpha-value>",
      media: "visual",
      inherited: false,
      animationType: "byComputedValueType",
      percentages: "mapToRange0To1",
      groups: [
        "CSS Color"
      ],
      initial: "1",
      appliesto: "allElements",
      computed: "specifiedValueNumberClipped0To1",
      order: "perGrammar",
      alsoAppliesTo: [
        "::placeholder"
      ],
      status: "standard",
      mdn_url: "https://developer.mozilla.org/docs/Web/CSS/opacity"
    },
    order: {
      syntax: "<integer>",
      media: "visual",
      inherited: false,
      animationType: "integer",
      percentages: "no",
      groups: [
        "CSS Flexible Box Layout"
      ],
      initial: "0",
      appliesto: "flexItemsGridItemsAbsolutelyPositionedContainerChildren",
      computed: "asSpecified",
      order: "uniqueOrder",
      status: "standard",
      mdn_url: "https://developer.mozilla.org/docs/Web/CSS/order"
    },
    orphans: {
      syntax: "<integer>",
      media: "visual",
      inherited: true,
      animationType: "discrete",
      percentages: "no",
      groups: [
        "CSS Fragmentation"
      ],
      initial: "2",
      appliesto: "blockContainerElements",
      computed: "asSpecified",
      order: "perGrammar",
      status: "standard",
      mdn_url: "https://developer.mozilla.org/docs/Web/CSS/orphans"
    },
    outline: {
      syntax: "[ <'outline-color'> || <'outline-style'> || <'outline-width'> ]",
      media: [
        "visual",
        "interactive"
      ],
      inherited: false,
      animationType: [
        "outline-color",
        "outline-width",
        "outline-style"
      ],
      percentages: "no",
      groups: [
        "CSS Basic User Interface"
      ],
      initial: [
        "outline-color",
        "outline-style",
        "outline-width"
      ],
      appliesto: "allElements",
      computed: [
        "outline-color",
        "outline-width",
        "outline-style"
      ],
      order: "orderOfAppearance",
      status: "standard",
      mdn_url: "https://developer.mozilla.org/docs/Web/CSS/outline"
    },
    "outline-color": {
      syntax: "<color> | invert",
      media: [
        "visual",
        "interactive"
      ],
      inherited: false,
      animationType: "color",
      percentages: "no",
      groups: [
        "CSS Basic User Interface"
      ],
      initial: "invertOrCurrentColor",
      appliesto: "allElements",
      computed: "invertForTranslucentColorRGBAOtherwiseRGB",
      order: "uniqueOrder",
      status: "standard",
      mdn_url: "https://developer.mozilla.org/docs/Web/CSS/outline-color"
    },
    "outline-offset": {
      syntax: "<length>",
      media: [
        "visual",
        "interactive"
      ],
      inherited: false,
      animationType: "length",
      percentages: "no",
      groups: [
        "CSS Basic User Interface"
      ],
      initial: "0",
      appliesto: "allElements",
      computed: "asSpecifiedRelativeToAbsoluteLengths",
      order: "uniqueOrder",
      status: "standard",
      mdn_url: "https://developer.mozilla.org/docs/Web/CSS/outline-offset"
    },
    "outline-style": {
      syntax: "auto | <'border-style'>",
      media: [
        "visual",
        "interactive"
      ],
      inherited: false,
      animationType: "discrete",
      percentages: "no",
      groups: [
        "CSS Basic User Interface"
      ],
      initial: "none",
      appliesto: "allElements",
      computed: "asSpecified",
      order: "uniqueOrder",
      status: "standard",
      mdn_url: "https://developer.mozilla.org/docs/Web/CSS/outline-style"
    },
    "outline-width": {
      syntax: "<line-width>",
      media: [
        "visual",
        "interactive"
      ],
      inherited: false,
      animationType: "length",
      percentages: "no",
      groups: [
        "CSS Basic User Interface"
      ],
      initial: "medium",
      appliesto: "allElements",
      computed: "absoluteLength0ForNone",
      order: "uniqueOrder",
      status: "standard",
      mdn_url: "https://developer.mozilla.org/docs/Web/CSS/outline-width"
    },
    overflow: {
      syntax: "[ visible | hidden | clip | scroll | auto ]{1,2}",
      media: "visual",
      inherited: false,
      animationType: "discrete",
      percentages: "no",
      groups: [
        "CSS Overflow"
      ],
      initial: "visible",
      appliesto: "blockContainersFlexContainersGridContainers",
      computed: [
        "overflow-x",
        "overflow-y"
      ],
      order: "uniqueOrder",
      status: "standard",
      mdn_url: "https://developer.mozilla.org/docs/Web/CSS/overflow"
    },
    "overflow-anchor": {
      syntax: "auto | none",
      media: "visual",
      inherited: false,
      animationType: "discrete",
      percentages: "no",
      groups: [
        "CSS Scroll Anchoring"
      ],
      initial: "auto",
      appliesto: "allElements",
      computed: "asSpecified",
      order: "perGrammar",
      status: "standard"
    },
    "overflow-block": {
      syntax: "visible | hidden | clip | scroll | auto",
      media: "visual",
      inherited: false,
      animationType: "discrete",
      percentages: "no",
      groups: [
        "CSS Overflow"
      ],
      initial: "auto",
      appliesto: "blockContainersFlexContainersGridContainers",
      computed: "asSpecifiedButVisibleOrClipReplacedToAutoOrHiddenIfOtherValueDifferent",
      order: "perGrammar",
      status: "standard"
    },
    "overflow-clip-box": {
      syntax: "padding-box | content-box",
      media: "visual",
      inherited: false,
      animationType: "discrete",
      percentages: "no",
      groups: [
        "Mozilla Extensions"
      ],
      initial: "padding-box",
      appliesto: "allElements",
      computed: "asSpecified",
      order: "uniqueOrder",
      status: "nonstandard",
      mdn_url: "https://developer.mozilla.org/docs/Mozilla/CSS/overflow-clip-box"
    },
    "overflow-clip-margin": {
      syntax: "<visual-box> || <length [0,]>",
      media: "visual",
      inherited: false,
      animationType: "discrete",
      percentages: "no",
      groups: [
        "CSS Overflow"
      ],
      initial: "0px",
      appliesto: "allElements",
      computed: "theComputedLength",
      order: "perGrammar",
      status: "standard"
    },
    "overflow-inline": {
      syntax: "visible | hidden | clip | scroll | auto",
      media: "visual",
      inherited: false,
      animationType: "discrete",
      percentages: "no",
      groups: [
        "CSS Overflow"
      ],
      initial: "auto",
      appliesto: "blockContainersFlexContainersGridContainers",
      computed: "asSpecifiedButVisibleOrClipReplacedToAutoOrHiddenIfOtherValueDifferent",
      order: "perGrammar",
      status: "standard"
    },
    "overflow-wrap": {
      syntax: "normal | break-word | anywhere",
      media: "visual",
      inherited: true,
      animationType: "discrete",
      percentages: "no",
      groups: [
        "CSS Text"
      ],
      initial: "normal",
      appliesto: "nonReplacedInlineElements",
      computed: "asSpecified",
      order: "uniqueOrder",
      status: "standard",
      mdn_url: "https://developer.mozilla.org/docs/Web/CSS/overflow-wrap"
    },
    "overflow-x": {
      syntax: "visible | hidden | clip | scroll | auto",
      media: "visual",
      inherited: false,
      animationType: "discrete",
      percentages: "no",
      groups: [
        "CSS Overflow"
      ],
      initial: "visible",
      appliesto: "blockContainersFlexContainersGridContainers",
      computed: "asSpecifiedButVisibleOrClipReplacedToAutoOrHiddenIfOtherValueDifferent",
      order: "uniqueOrder",
      status: "standard",
      mdn_url: "https://developer.mozilla.org/docs/Web/CSS/overflow-x"
    },
    "overflow-y": {
      syntax: "visible | hidden | clip | scroll | auto",
      media: "visual",
      inherited: false,
      animationType: "discrete",
      percentages: "no",
      groups: [
        "CSS Overflow"
      ],
      initial: "visible",
      appliesto: "blockContainersFlexContainersGridContainers",
      computed: "asSpecifiedButVisibleOrClipReplacedToAutoOrHiddenIfOtherValueDifferent",
      order: "uniqueOrder",
      status: "standard",
      mdn_url: "https://developer.mozilla.org/docs/Web/CSS/overflow-y"
    },
    "overscroll-behavior": {
      syntax: "[ contain | none | auto ]{1,2}",
      media: "visual",
      inherited: false,
      animationType: "discrete",
      percentages: "no",
      groups: [
        "CSS Box Model"
      ],
      initial: "auto",
      appliesto: "nonReplacedBlockAndInlineBlockElements",
      computed: [
        "overscroll-behavior-x",
        "overscroll-behavior-y"
      ],
      order: "uniqueOrder",
      status: "standard",
      mdn_url: "https://developer.mozilla.org/docs/Web/CSS/overscroll-behavior"
    },
    "overscroll-behavior-block": {
      syntax: "contain | none | auto",
      media: "visual",
      inherited: false,
      animationType: "discrete",
      percentages: "no",
      groups: [
        "CSS Box Model"
      ],
      initial: "auto",
      appliesto: "nonReplacedBlockAndInlineBlockElements",
      computed: "asSpecified",
      order: "uniqueOrder",
      status: "standard",
      mdn_url: "https://developer.mozilla.org/docs/Web/CSS/overscroll-behavior-block"
    },
    "overscroll-behavior-inline": {
      syntax: "contain | none | auto",
      media: "visual",
      inherited: false,
      animationType: "discrete",
      percentages: "no",
      groups: [
        "CSS Box Model"
      ],
      initial: "auto",
      appliesto: "nonReplacedBlockAndInlineBlockElements",
      computed: "asSpecified",
      order: "uniqueOrder",
      status: "standard",
      mdn_url: "https://developer.mozilla.org/docs/Web/CSS/overscroll-behavior-inline"
    },
    "overscroll-behavior-x": {
      syntax: "contain | none | auto",
      media: "visual",
      inherited: false,
      animationType: "discrete",
      percentages: "no",
      groups: [
        "CSS Box Model"
      ],
      initial: "auto",
      appliesto: "nonReplacedBlockAndInlineBlockElements",
      computed: "asSpecified",
      order: "uniqueOrder",
      status: "standard",
      mdn_url: "https://developer.mozilla.org/docs/Web/CSS/overscroll-behavior-x"
    },
    "overscroll-behavior-y": {
      syntax: "contain | none | auto",
      media: "visual",
      inherited: false,
      animationType: "discrete",
      percentages: "no",
      groups: [
        "CSS Box Model"
      ],
      initial: "auto",
      appliesto: "nonReplacedBlockAndInlineBlockElements",
      computed: "asSpecified",
      order: "uniqueOrder",
      status: "standard",
      mdn_url: "https://developer.mozilla.org/docs/Web/CSS/overscroll-behavior-y"
    },
    padding: {
      syntax: "[ <length> | <percentage> ]{1,4}",
      media: "visual",
      inherited: false,
      animationType: "length",
      percentages: "referToWidthOfContainingBlock",
      groups: [
        "CSS Box Model"
      ],
      initial: [
        "padding-bottom",
        "padding-left",
        "padding-right",
        "padding-top"
      ],
      appliesto: "allElementsExceptInternalTableDisplayTypes",
      computed: [
        "padding-bottom",
        "padding-left",
        "padding-right",
        "padding-top"
      ],
      order: "uniqueOrder",
      alsoAppliesTo: [
        "::first-letter",
        "::first-line"
      ],
      status: "standard",
      mdn_url: "https://developer.mozilla.org/docs/Web/CSS/padding"
    },
    "padding-block": {
      syntax: "<'padding-left'>{1,2}",
      media: "visual",
      inherited: false,
      animationType: "length",
      percentages: "logicalWidthOfContainingBlock",
      groups: [
        "CSS Logical Properties"
      ],
      initial: [
        "padding-block-start",
        "padding-block-end"
      ],
      appliesto: "allElementsExceptInternalTableDisplayTypes",
      computed: [
        "padding-block-start",
        "padding-block-end"
      ],
      order: "uniqueOrder",
      status: "standard",
      mdn_url: "https://developer.mozilla.org/docs/Web/CSS/padding-block"
    },
    "padding-block-end": {
      syntax: "<'padding-left'>",
      media: "visual",
      inherited: false,
      animationType: "length",
      percentages: "logicalWidthOfContainingBlock",
      groups: [
        "CSS Logical Properties"
      ],
      initial: "0",
      appliesto: "allElementsExceptInternalTableDisplayTypes",
      computed: "asLength",
      order: "uniqueOrder",
      status: "standard",
      mdn_url: "https://developer.mozilla.org/docs/Web/CSS/padding-block-end"
    },
    "padding-block-start": {
      syntax: "<'padding-left'>",
      media: "visual",
      inherited: false,
      animationType: "length",
      percentages: "logicalWidthOfContainingBlock",
      groups: [
        "CSS Logical Properties"
      ],
      initial: "0",
      appliesto: "allElementsExceptInternalTableDisplayTypes",
      computed: "asLength",
      order: "uniqueOrder",
      status: "standard",
      mdn_url: "https://developer.mozilla.org/docs/Web/CSS/padding-block-start"
    },
    "padding-bottom": {
      syntax: "<length> | <percentage>",
      media: "visual",
      inherited: false,
      animationType: "length",
      percentages: "referToWidthOfContainingBlock",
      groups: [
        "CSS Box Model"
      ],
      initial: "0",
      appliesto: "allElementsExceptInternalTableDisplayTypes",
      computed: "percentageAsSpecifiedOrAbsoluteLength",
      order: "uniqueOrder",
      alsoAppliesTo: [
        "::first-letter",
        "::first-line"
      ],
      status: "standard",
      mdn_url: "https://developer.mozilla.org/docs/Web/CSS/padding-bottom"
    },
    "padding-inline": {
      syntax: "<'padding-left'>{1,2}",
      media: "visual",
      inherited: false,
      animationType: "length",
      percentages: "logicalWidthOfContainingBlock",
      groups: [
        "CSS Logical Properties"
      ],
      initial: [
        "padding-inline-start",
        "padding-inline-end"
      ],
      appliesto: "allElementsExceptInternalTableDisplayTypes",
      computed: [
        "padding-inline-start",
        "padding-inline-end"
      ],
      order: "uniqueOrder",
      status: "standard",
      mdn_url: "https://developer.mozilla.org/docs/Web/CSS/padding-inline"
    },
    "padding-inline-end": {
      syntax: "<'padding-left'>",
      media: "visual",
      inherited: false,
      animationType: "length",
      percentages: "logicalWidthOfContainingBlock",
      groups: [
        "CSS Logical Properties"
      ],
      initial: "0",
      appliesto: "allElementsExceptInternalTableDisplayTypes",
      computed: "asLength",
      order: "uniqueOrder",
      status: "standard",
      mdn_url: "https://developer.mozilla.org/docs/Web/CSS/padding-inline-end"
    },
    "padding-inline-start": {
      syntax: "<'padding-left'>",
      media: "visual",
      inherited: false,
      animationType: "length",
      percentages: "logicalWidthOfContainingBlock",
      groups: [
        "CSS Logical Properties"
      ],
      initial: "0",
      appliesto: "allElementsExceptInternalTableDisplayTypes",
      computed: "asLength",
      order: "uniqueOrder",
      status: "standard",
      mdn_url: "https://developer.mozilla.org/docs/Web/CSS/padding-inline-start"
    },
    "padding-left": {
      syntax: "<length> | <percentage>",
      media: "visual",
      inherited: false,
      animationType: "length",
      percentages: "referToWidthOfContainingBlock",
      groups: [
        "CSS Box Model"
      ],
      initial: "0",
      appliesto: "allElementsExceptInternalTableDisplayTypes",
      computed: "percentageAsSpecifiedOrAbsoluteLength",
      order: "uniqueOrder",
      alsoAppliesTo: [
        "::first-letter",
        "::first-line"
      ],
      status: "standard",
      mdn_url: "https://developer.mozilla.org/docs/Web/CSS/padding-left"
    },
    "padding-right": {
      syntax: "<length> | <percentage>",
      media: "visual",
      inherited: false,
      animationType: "length",
      percentages: "referToWidthOfContainingBlock",
      groups: [
        "CSS Box Model"
      ],
      initial: "0",
      appliesto: "allElementsExceptInternalTableDisplayTypes",
      computed: "percentageAsSpecifiedOrAbsoluteLength",
      order: "uniqueOrder",
      alsoAppliesTo: [
        "::first-letter",
        "::first-line"
      ],
      status: "standard",
      mdn_url: "https://developer.mozilla.org/docs/Web/CSS/padding-right"
    },
    "padding-top": {
      syntax: "<length> | <percentage>",
      media: "visual",
      inherited: false,
      animationType: "length",
      percentages: "referToWidthOfContainingBlock",
      groups: [
        "CSS Box Model"
      ],
      initial: "0",
      appliesto: "allElementsExceptInternalTableDisplayTypes",
      computed: "percentageAsSpecifiedOrAbsoluteLength",
      order: "uniqueOrder",
      alsoAppliesTo: [
        "::first-letter",
        "::first-line"
      ],
      status: "standard",
      mdn_url: "https://developer.mozilla.org/docs/Web/CSS/padding-top"
    },
    "page-break-after": {
      syntax: "auto | always | avoid | left | right | recto | verso",
      media: [
        "visual",
        "paged"
      ],
      inherited: false,
      animationType: "discrete",
      percentages: "no",
      groups: [
        "CSS Pages"
      ],
      initial: "auto",
      appliesto: "blockElementsInNormalFlow",
      computed: "asSpecified",
      order: "uniqueOrder",
      status: "standard",
      mdn_url: "https://developer.mozilla.org/docs/Web/CSS/page-break-after"
    },
    "page-break-before": {
      syntax: "auto | always | avoid | left | right | recto | verso",
      media: [
        "visual",
        "paged"
      ],
      inherited: false,
      animationType: "discrete",
      percentages: "no",
      groups: [
        "CSS Pages"
      ],
      initial: "auto",
      appliesto: "blockElementsInNormalFlow",
      computed: "asSpecified",
      order: "uniqueOrder",
      status: "standard",
      mdn_url: "https://developer.mozilla.org/docs/Web/CSS/page-break-before"
    },
    "page-break-inside": {
      syntax: "auto | avoid",
      media: [
        "visual",
        "paged"
      ],
      inherited: false,
      animationType: "discrete",
      percentages: "no",
      groups: [
        "CSS Pages"
      ],
      initial: "auto",
      appliesto: "blockElementsInNormalFlow",
      computed: "asSpecified",
      order: "uniqueOrder",
      status: "standard",
      mdn_url: "https://developer.mozilla.org/docs/Web/CSS/page-break-inside"
    },
    "paint-order": {
      syntax: "normal | [ fill || stroke || markers ]",
      media: "visual",
      inherited: true,
      animationType: "discrete",
      percentages: "no",
      groups: [
        "CSS Text"
      ],
      initial: "normal",
      appliesto: "textElements",
      computed: "asSpecified",
      order: "uniqueOrder",
      status: "standard",
      mdn_url: "https://developer.mozilla.org/docs/Web/CSS/paint-order"
    },
    perspective: {
      syntax: "none | <length>",
      media: "visual",
      inherited: false,
      animationType: "length",
      percentages: "no",
      groups: [
        "CSS Transforms"
      ],
      initial: "none",
      appliesto: "transformableElements",
      computed: "absoluteLengthOrNone",
      order: "uniqueOrder",
      stacking: true,
      status: "standard",
      mdn_url: "https://developer.mozilla.org/docs/Web/CSS/perspective"
    },
    "perspective-origin": {
      syntax: "<position>",
      media: "visual",
      inherited: false,
      animationType: "simpleListOfLpc",
      percentages: "referToSizeOfBoundingBox",
      groups: [
        "CSS Transforms"
      ],
      initial: "50% 50%",
      appliesto: "transformableElements",
      computed: "forLengthAbsoluteValueOtherwisePercentage",
      order: "oneOrTwoValuesLengthAbsoluteKeywordsPercentages",
      status: "standard",
      mdn_url: "https://developer.mozilla.org/docs/Web/CSS/perspective-origin"
    },
    "place-content": {
      syntax: "<'align-content'> <'justify-content'>?",
      media: "visual",
      inherited: false,
      animationType: "discrete",
      percentages: "no",
      groups: [
        "CSS Box Alignment"
      ],
      initial: [
        "align-content",
        "justify-content"
      ],
      appliesto: "multilineFlexContainers",
      computed: [
        "align-content",
        "justify-content"
      ],
      order: "uniqueOrder",
      status: "standard",
      mdn_url: "https://developer.mozilla.org/docs/Web/CSS/place-content"
    },
    "place-items": {
      syntax: "<'align-items'> <'justify-items'>?",
      media: "visual",
      inherited: false,
      animationType: "discrete",
      percentages: "no",
      groups: [
        "CSS Box Alignment"
      ],
      initial: [
        "align-items",
        "justify-items"
      ],
      appliesto: "allElements",
      computed: [
        "align-items",
        "justify-items"
      ],
      order: "uniqueOrder",
      status: "standard",
      mdn_url: "https://developer.mozilla.org/docs/Web/CSS/place-items"
    },
    "place-self": {
      syntax: "<'align-self'> <'justify-self'>?",
      media: "visual",
      inherited: false,
      animationType: "discrete",
      percentages: "no",
      groups: [
        "CSS Box Alignment"
      ],
      initial: [
        "align-self",
        "justify-self"
      ],
      appliesto: "blockLevelBoxesAndAbsolutelyPositionedBoxesAndGridItems",
      computed: [
        "align-self",
        "justify-self"
      ],
      order: "uniqueOrder",
      status: "standard",
      mdn_url: "https://developer.mozilla.org/docs/Web/CSS/place-self"
    },
    "pointer-events": {
      syntax: "auto | none | visiblePainted | visibleFill | visibleStroke | visible | painted | fill | stroke | all | inherit",
      media: "visual",
      inherited: true,
      animationType: "discrete",
      percentages: "no",
      groups: [
        "CSS Basic User Interface"
      ],
      initial: "auto",
      appliesto: "allElements",
      computed: "asSpecified",
      order: "uniqueOrder",
      status: "standard",
      mdn_url: "https://developer.mozilla.org/docs/Web/CSS/pointer-events"
    },
    position: {
      syntax: "static | relative | absolute | sticky | fixed",
      media: "visual",
      inherited: false,
      animationType: "discrete",
      percentages: "no",
      groups: [
        "CSS Positioning"
      ],
      initial: "static",
      appliesto: "allElements",
      computed: "asSpecified",
      order: "uniqueOrder",
      stacking: true,
      status: "standard",
      mdn_url: "https://developer.mozilla.org/docs/Web/CSS/position"
    },
    quotes: {
      syntax: "none | auto | [ <string> <string> ]+",
      media: "visual",
      inherited: true,
      animationType: "discrete",
      percentages: "no",
      groups: [
        "CSS Generated Content"
      ],
      initial: "dependsOnUserAgent",
      appliesto: "allElements",
      computed: "asSpecified",
      order: "uniqueOrder",
      status: "standard",
      mdn_url: "https://developer.mozilla.org/docs/Web/CSS/quotes"
    },
    resize: {
      syntax: "none | both | horizontal | vertical | block | inline",
      media: "visual",
      inherited: false,
      animationType: "discrete",
      percentages: "no",
      groups: [
        "CSS Basic User Interface"
      ],
      initial: "none",
      appliesto: "elementsWithOverflowNotVisibleAndReplacedElements",
      computed: "asSpecified",
      order: "uniqueOrder",
      status: "standard",
      mdn_url: "https://developer.mozilla.org/docs/Web/CSS/resize"
    },
    right: {
      syntax: "<length> | <percentage> | auto",
      media: "visual",
      inherited: false,
      animationType: "lpc",
      percentages: "referToWidthOfContainingBlock",
      groups: [
        "CSS Positioning"
      ],
      initial: "auto",
      appliesto: "positionedElements",
      computed: "lengthAbsolutePercentageAsSpecifiedOtherwiseAuto",
      order: "uniqueOrder",
      status: "standard",
      mdn_url: "https://developer.mozilla.org/docs/Web/CSS/right"
    },
    rotate: {
      syntax: "none | <angle> | [ x | y | z | <number>{3} ] && <angle>",
      media: "visual",
      inherited: false,
      animationType: "transform",
      percentages: "no",
      groups: [
        "CSS Transforms"
      ],
      initial: "none",
      appliesto: "transformableElements",
      computed: "asSpecified",
      order: "perGrammar",
      stacking: true,
      status: "standard",
      mdn_url: "https://developer.mozilla.org/docs/Web/CSS/rotate"
    },
    "row-gap": {
      syntax: "normal | <length-percentage>",
      media: "visual",
      inherited: false,
      animationType: "lpc",
      percentages: "referToDimensionOfContentArea",
      groups: [
        "CSS Box Alignment"
      ],
      initial: "normal",
      appliesto: "multiColumnElementsFlexContainersGridContainers",
      computed: "asSpecifiedWithLengthsAbsoluteAndNormalComputingToZeroExceptMultiColumn",
      order: "perGrammar",
      status: "standard",
      mdn_url: "https://developer.mozilla.org/docs/Web/CSS/row-gap"
    },
    "ruby-align": {
      syntax: "start | center | space-between | space-around",
      media: "visual",
      inherited: true,
      animationType: "discrete",
      percentages: "no",
      groups: [
        "CSS Ruby"
      ],
      initial: "space-around",
      appliesto: "rubyBasesAnnotationsBaseAnnotationContainers",
      computed: "asSpecified",
      order: "uniqueOrder",
      status: "experimental",
      mdn_url: "https://developer.mozilla.org/docs/Web/CSS/ruby-align"
    },
    "ruby-merge": {
      syntax: "separate | collapse | auto",
      media: "visual",
      inherited: true,
      animationType: "discrete",
      percentages: "no",
      groups: [
        "CSS Ruby"
      ],
      initial: "separate",
      appliesto: "rubyAnnotationsContainers",
      computed: "asSpecified",
      order: "uniqueOrder",
      status: "experimental"
    },
    "ruby-position": {
      syntax: "[ alternate || [ over | under ] ] | inter-character",
      media: "visual",
      inherited: true,
      animationType: "discrete",
      percentages: "no",
      groups: [
        "CSS Ruby"
      ],
      initial: "alternate",
      appliesto: "rubyAnnotationsContainers",
      computed: "asSpecified",
      order: "uniqueOrder",
      status: "experimental",
      mdn_url: "https://developer.mozilla.org/docs/Web/CSS/ruby-position"
    },
    scale: {
      syntax: "none | <number>{1,3}",
      media: "visual",
      inherited: false,
      animationType: "transform",
      percentages: "no",
      groups: [
        "CSS Transforms"
      ],
      initial: "none",
      appliesto: "transformableElements",
      computed: "asSpecified",
      order: "perGrammar",
      stacking: true,
      status: "standard",
      mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scale"
    },
    "scrollbar-color": {
      syntax: "auto | <color>{2}",
      media: "visual",
      inherited: true,
      animationType: "color",
      percentages: "no",
      groups: [
        "CSS Scrollbars"
      ],
      initial: "auto",
      appliesto: "scrollingBoxes",
      computed: "asSpecified",
      order: "perGrammar",
      status: "standard",
      mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scrollbar-color"
    },
    "scrollbar-gutter": {
      syntax: "auto | stable && both-edges?",
      media: "visual",
      inherited: false,
      animationType: "discrete",
      percentages: "no",
      groups: [
        "CSS Overflow"
      ],
      initial: "auto",
      appliesto: "scrollingBoxes",
      computed: "asSpecified",
      order: "perGrammar",
      status: "standard",
      mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scrollbar-gutter"
    },
    "scrollbar-width": {
      syntax: "auto | thin | none",
      media: "visual",
      inherited: false,
      animationType: "discrete",
      percentages: "no",
      groups: [
        "CSS Scrollbars"
      ],
      initial: "auto",
      appliesto: "scrollingBoxes",
      computed: "asSpecified",
      order: "perGrammar",
      status: "standard",
      mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scrollbar-width"
    },
    "scroll-behavior": {
      syntax: "auto | smooth",
      media: "visual",
      inherited: false,
      animationType: "discrete",
      percentages: "no",
      groups: [
        "CSSOM View"
      ],
      initial: "auto",
      appliesto: "scrollingBoxes",
      computed: "asSpecified",
      order: "uniqueOrder",
      status: "standard",
      mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-behavior"
    },
    "scroll-margin": {
      syntax: "<length>{1,4}",
      media: "visual",
      inherited: false,
      animationType: "byComputedValueType",
      percentages: "no",
      groups: [
        "CSS Scroll Snap"
      ],
      initial: [
        "scroll-margin-bottom",
        "scroll-margin-left",
        "scroll-margin-right",
        "scroll-margin-top"
      ],
      appliesto: "allElements",
      computed: [
        "scroll-margin-bottom",
        "scroll-margin-left",
        "scroll-margin-right",
        "scroll-margin-top"
      ],
      order: "perGrammar",
      status: "standard",
      mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-margin"
    },
    "scroll-margin-block": {
      syntax: "<length>{1,2}",
      media: "visual",
      inherited: false,
      animationType: "byComputedValueType",
      percentages: "no",
      groups: [
        "CSS Scroll Snap"
      ],
      initial: [
        "scroll-margin-block-start",
        "scroll-margin-block-end"
      ],
      appliesto: "allElements",
      computed: [
        "scroll-margin-block-start",
        "scroll-margin-block-end"
      ],
      order: "perGrammar",
      status: "standard",
      mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-margin-block"
    },
    "scroll-margin-block-start": {
      syntax: "<length>",
      media: "visual",
      inherited: false,
      animationType: "byComputedValueType",
      percentages: "no",
      groups: [
        "CSS Scroll Snap"
      ],
      initial: "0",
      appliesto: "allElements",
      computed: "asSpecified",
      order: "perGrammar",
      status: "standard",
      mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-margin-block-start"
    },
    "scroll-margin-block-end": {
      syntax: "<length>",
      media: "visual",
      inherited: false,
      animationType: "byComputedValueType",
      percentages: "no",
      groups: [
        "CSS Scroll Snap"
      ],
      initial: "0",
      appliesto: "allElements",
      computed: "asSpecified",
      order: "perGrammar",
      status: "standard",
      mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-margin-block-end"
    },
    "scroll-margin-bottom": {
      syntax: "<length>",
      media: "visual",
      inherited: false,
      animationType: "byComputedValueType",
      percentages: "no",
      groups: [
        "CSS Scroll Snap"
      ],
      initial: "0",
      appliesto: "allElements",
      computed: "asSpecified",
      order: "perGrammar",
      status: "standard",
      mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-margin-bottom"
    },
    "scroll-margin-inline": {
      syntax: "<length>{1,2}",
      media: "visual",
      inherited: false,
      animationType: "byComputedValueType",
      percentages: "no",
      groups: [
        "CSS Scroll Snap"
      ],
      initial: [
        "scroll-margin-inline-start",
        "scroll-margin-inline-end"
      ],
      appliesto: "allElements",
      computed: [
        "scroll-margin-inline-start",
        "scroll-margin-inline-end"
      ],
      order: "perGrammar",
      status: "standard",
      mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-margin-inline"
    },
    "scroll-margin-inline-start": {
      syntax: "<length>",
      media: "visual",
      inherited: false,
      animationType: "byComputedValueType",
      percentages: "no",
      groups: [
        "CSS Scroll Snap"
      ],
      initial: "0",
      appliesto: "allElements",
      computed: "asSpecified",
      order: "perGrammar",
      status: "standard",
      mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-margin-inline-start"
    },
    "scroll-margin-inline-end": {
      syntax: "<length>",
      media: "visual",
      inherited: false,
      animationType: "byComputedValueType",
      percentages: "no",
      groups: [
        "CSS Scroll Snap"
      ],
      initial: "0",
      appliesto: "allElements",
      computed: "asSpecified",
      order: "perGrammar",
      status: "standard",
      mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-margin-inline-end"
    },
    "scroll-margin-left": {
      syntax: "<length>",
      media: "visual",
      inherited: false,
      animationType: "byComputedValueType",
      percentages: "no",
      groups: [
        "CSS Scroll Snap"
      ],
      initial: "0",
      appliesto: "allElements",
      computed: "asSpecified",
      order: "perGrammar",
      status: "standard",
      mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-margin-left"
    },
    "scroll-margin-right": {
      syntax: "<length>",
      media: "visual",
      inherited: false,
      animationType: "byComputedValueType",
      percentages: "no",
      groups: [
        "CSS Scroll Snap"
      ],
      initial: "0",
      appliesto: "allElements",
      computed: "asSpecified",
      order: "perGrammar",
      status: "standard",
      mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-margin-right"
    },
    "scroll-margin-top": {
      syntax: "<length>",
      media: "visual",
      inherited: false,
      animationType: "byComputedValueType",
      percentages: "no",
      groups: [
        "CSS Scroll Snap"
      ],
      initial: "0",
      appliesto: "allElements",
      computed: "asSpecified",
      order: "perGrammar",
      status: "standard",
      mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-margin-top"
    },
    "scroll-padding": {
      syntax: "[ auto | <length-percentage> ]{1,4}",
      media: "visual",
      inherited: false,
      animationType: "byComputedValueType",
      percentages: "relativeToTheScrollContainersScrollport",
      groups: [
        "CSS Scroll Snap"
      ],
      initial: [
        "scroll-padding-bottom",
        "scroll-padding-left",
        "scroll-padding-right",
        "scroll-padding-top"
      ],
      appliesto: "scrollContainers",
      computed: [
        "scroll-padding-bottom",
        "scroll-padding-left",
        "scroll-padding-right",
        "scroll-padding-top"
      ],
      order: "perGrammar",
      status: "standard",
      mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-padding"
    },
    "scroll-padding-block": {
      syntax: "[ auto | <length-percentage> ]{1,2}",
      media: "visual",
      inherited: false,
      animationType: "byComputedValueType",
      percentages: "relativeToTheScrollContainersScrollport",
      groups: [
        "CSS Scroll Snap"
      ],
      initial: [
        "scroll-padding-block-start",
        "scroll-padding-block-end"
      ],
      appliesto: "scrollContainers",
      computed: [
        "scroll-padding-block-start",
        "scroll-padding-block-end"
      ],
      order: "perGrammar",
      status: "standard",
      mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-padding-block"
    },
    "scroll-padding-block-start": {
      syntax: "auto | <length-percentage>",
      media: "visual",
      inherited: false,
      animationType: "byComputedValueType",
      percentages: "relativeToTheScrollContainersScrollport",
      groups: [
        "CSS Scroll Snap"
      ],
      initial: "auto",
      appliesto: "scrollContainers",
      computed: "asSpecified",
      order: "perGrammar",
      status: "standard",
      mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-padding-block-start"
    },
    "scroll-padding-block-end": {
      syntax: "auto | <length-percentage>",
      media: "visual",
      inherited: false,
      animationType: "byComputedValueType",
      percentages: "relativeToTheScrollContainersScrollport",
      groups: [
        "CSS Scroll Snap"
      ],
      initial: "auto",
      appliesto: "scrollContainers",
      computed: "asSpecified",
      order: "perGrammar",
      status: "standard",
      mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-padding-block-end"
    },
    "scroll-padding-bottom": {
      syntax: "auto | <length-percentage>",
      media: "visual",
      inherited: false,
      animationType: "byComputedValueType",
      percentages: "relativeToTheScrollContainersScrollport",
      groups: [
        "CSS Scroll Snap"
      ],
      initial: "auto",
      appliesto: "scrollContainers",
      computed: "asSpecified",
      order: "perGrammar",
      status: "standard",
      mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-padding-bottom"
    },
    "scroll-padding-inline": {
      syntax: "[ auto | <length-percentage> ]{1,2}",
      media: "visual",
      inherited: false,
      animationType: "byComputedValueType",
      percentages: "relativeToTheScrollContainersScrollport",
      groups: [
        "CSS Scroll Snap"
      ],
      initial: [
        "scroll-padding-inline-start",
        "scroll-padding-inline-end"
      ],
      appliesto: "scrollContainers",
      computed: [
        "scroll-padding-inline-start",
        "scroll-padding-inline-end"
      ],
      order: "perGrammar",
      status: "standard",
      mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-padding-inline"
    },
    "scroll-padding-inline-start": {
      syntax: "auto | <length-percentage>",
      media: "visual",
      inherited: false,
      animationType: "byComputedValueType",
      percentages: "relativeToTheScrollContainersScrollport",
      groups: [
        "CSS Scroll Snap"
      ],
      initial: "auto",
      appliesto: "scrollContainers",
      computed: "asSpecified",
      order: "perGrammar",
      status: "standard",
      mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-padding-inline-start"
    },
    "scroll-padding-inline-end": {
      syntax: "auto | <length-percentage>",
      media: "visual",
      inherited: false,
      animationType: "byComputedValueType",
      percentages: "relativeToTheScrollContainersScrollport",
      groups: [
        "CSS Scroll Snap"
      ],
      initial: "auto",
      appliesto: "scrollContainers",
      computed: "asSpecified",
      order: "perGrammar",
      status: "standard",
      mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-padding-inline-end"
    },
    "scroll-padding-left": {
      syntax: "auto | <length-percentage>",
      media: "visual",
      inherited: false,
      animationType: "byComputedValueType",
      percentages: "relativeToTheScrollContainersScrollport",
      groups: [
        "CSS Scroll Snap"
      ],
      initial: "auto",
      appliesto: "scrollContainers",
      computed: "asSpecified",
      order: "perGrammar",
      status: "standard",
      mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-padding-left"
    },
    "scroll-padding-right": {
      syntax: "auto | <length-percentage>",
      media: "visual",
      inherited: false,
      animationType: "byComputedValueType",
      percentages: "relativeToTheScrollContainersScrollport",
      groups: [
        "CSS Scroll Snap"
      ],
      initial: "auto",
      appliesto: "scrollContainers",
      computed: "asSpecified",
      order: "perGrammar",
      status: "standard",
      mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-padding-right"
    },
    "scroll-padding-top": {
      syntax: "auto | <length-percentage>",
      media: "visual",
      inherited: false,
      animationType: "byComputedValueType",
      percentages: "relativeToTheScrollContainersScrollport",
      groups: [
        "CSS Scroll Snap"
      ],
      initial: "auto",
      appliesto: "scrollContainers",
      computed: "asSpecified",
      order: "perGrammar",
      status: "standard",
      mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-padding-top"
    },
    "scroll-snap-align": {
      syntax: "[ none | start | end | center ]{1,2}",
      media: "visual",
      inherited: false,
      animationType: "discrete",
      percentages: "no",
      groups: [
        "CSS Scroll Snap"
      ],
      initial: "none",
      appliesto: "allElements",
      computed: "asSpecified",
      order: "perGrammar",
      status: "standard",
      mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-snap-align"
    },
    "scroll-snap-coordinate": {
      syntax: "none | <position>#",
      media: "interactive",
      inherited: false,
      animationType: "position",
      percentages: "referToBorderBox",
      groups: [
        "CSS Scroll Snap"
      ],
      initial: "none",
      appliesto: "allElements",
      computed: "asSpecifiedRelativeToAbsoluteLengths",
      order: "uniqueOrder",
      status: "obsolete",
      mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-snap-coordinate"
    },
    "scroll-snap-destination": {
      syntax: "<position>",
      media: "interactive",
      inherited: false,
      animationType: "position",
      percentages: "relativeToScrollContainerPaddingBoxAxis",
      groups: [
        "CSS Scroll Snap"
      ],
      initial: "0px 0px",
      appliesto: "scrollContainers",
      computed: "asSpecifiedRelativeToAbsoluteLengths",
      order: "uniqueOrder",
      status: "obsolete",
      mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-snap-destination"
    },
    "scroll-snap-points-x": {
      syntax: "none | repeat( <length-percentage> )",
      media: "interactive",
      inherited: false,
      animationType: "discrete",
      percentages: "relativeToScrollContainerPaddingBoxAxis",
      groups: [
        "CSS Scroll Snap"
      ],
      initial: "none",
      appliesto: "scrollContainers",
      computed: "asSpecifiedRelativeToAbsoluteLengths",
      order: "uniqueOrder",
      status: "obsolete",
      mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-snap-points-x"
    },
    "scroll-snap-points-y": {
      syntax: "none | repeat( <length-percentage> )",
      media: "interactive",
      inherited: false,
      animationType: "discrete",
      percentages: "relativeToScrollContainerPaddingBoxAxis",
      groups: [
        "CSS Scroll Snap"
      ],
      initial: "none",
      appliesto: "scrollContainers",
      computed: "asSpecifiedRelativeToAbsoluteLengths",
      order: "uniqueOrder",
      status: "obsolete",
      mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-snap-points-y"
    },
    "scroll-snap-stop": {
      syntax: "normal | always",
      media: "visual",
      inherited: false,
      animationType: "discrete",
      percentages: "no",
      groups: [
        "CSS Scroll Snap"
      ],
      initial: "normal",
      appliesto: "allElements",
      computed: "asSpecified",
      order: "perGrammar",
      status: "standard",
      mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-snap-stop"
    },
    "scroll-snap-type": {
      syntax: "none | [ x | y | block | inline | both ] [ mandatory | proximity ]?",
      media: "interactive",
      inherited: false,
      animationType: "discrete",
      percentages: "no",
      groups: [
        "CSS Scroll Snap"
      ],
      initial: "none",
      appliesto: "allElements",
      computed: "asSpecified",
      order: "uniqueOrder",
      status: "standard",
      mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-snap-type"
    },
    "scroll-snap-type-x": {
      syntax: "none | mandatory | proximity",
      media: "interactive",
      inherited: false,
      animationType: "discrete",
      percentages: "no",
      groups: [
        "CSS Scroll Snap"
      ],
      initial: "none",
      appliesto: "scrollContainers",
      computed: "asSpecified",
      order: "uniqueOrder",
      status: "obsolete",
      mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-snap-type-x"
    },
    "scroll-snap-type-y": {
      syntax: "none | mandatory | proximity",
      media: "interactive",
      inherited: false,
      animationType: "discrete",
      percentages: "no",
      groups: [
        "CSS Scroll Snap"
      ],
      initial: "none",
      appliesto: "scrollContainers",
      computed: "asSpecified",
      order: "uniqueOrder",
      status: "obsolete",
      mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-snap-type-y"
    },
    "scroll-timeline": {
      syntax: "<scroll-timeline-name> || <scroll-timeline-axis>",
      media: "visual",
      inherited: false,
      animationType: [
        "scroll-timeline-name",
        "scroll-timeline-axis"
      ],
      percentages: "no",
      groups: [
        "CSS Animations"
      ],
      initial: [
        "scroll-timeline-name",
        "scroll-timeline-axis"
      ],
      appliesto: "scrollContainers",
      computed: [
        "scroll-timeline-name",
        "scroll-timeline-axis"
      ],
      order: "perGrammar",
      status: "experimental",
      mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-timeline"
    },
    "scroll-timeline-axis": {
      syntax: "block | inline | vertical | horizontal",
      media: "interactive",
      inherited: false,
      animationType: "notAnimatable",
      percentages: "no",
      groups: [
        "CSS Animations"
      ],
      initial: "block",
      appliesto: "scrollContainers",
      computed: "asSpecified",
      order: "perGrammar",
      status: "experimental",
      mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-timeline-axis"
    },
    "scroll-timeline-name": {
      syntax: "none | <custom-ident>",
      media: "interactive",
      inherited: false,
      animationType: "notAnimatable",
      percentages: "no",
      groups: [
        "CSS Animations"
      ],
      initial: "none",
      appliesto: "scrollContainers",
      computed: "asSpecified",
      order: "perGrammar",
      status: "experimental",
      mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-timeline-name"
    },
    "shape-image-threshold": {
      syntax: "<alpha-value>",
      media: "visual",
      inherited: false,
      animationType: "number",
      percentages: "no",
      groups: [
        "CSS Shapes"
      ],
      initial: "0.0",
      appliesto: "floats",
      computed: "specifiedValueNumberClipped0To1",
      order: "uniqueOrder",
      status: "standard",
      mdn_url: "https://developer.mozilla.org/docs/Web/CSS/shape-image-threshold"
    },
    "shape-margin": {
      syntax: "<length-percentage>",
      media: "visual",
      inherited: false,
      animationType: "lpc",
      percentages: "referToWidthOfContainingBlock",
      groups: [
        "CSS Shapes"
      ],
      initial: "0",
      appliesto: "floats",
      computed: "asSpecifiedRelativeToAbsoluteLengths",
      order: "uniqueOrder",
      status: "standard",
      mdn_url: "https://developer.mozilla.org/docs/Web/CSS/shape-margin"
    },
    "shape-outside": {
      syntax: "none | [ <shape-box> || <basic-shape> ] | <image>",
      media: "visual",
      inherited: false,
      animationType: "basicShapeOtherwiseNo",
      percentages: "no",
      groups: [
        "CSS Shapes"
      ],
      initial: "none",
      appliesto: "floats",
      computed: "asDefinedForBasicShapeWithAbsoluteURIOtherwiseAsSpecified",
      order: "uniqueOrder",
      status: "standard",
      mdn_url: "https://developer.mozilla.org/docs/Web/CSS/shape-outside"
    },
    "tab-size": {
      syntax: "<integer> | <length>",
      media: "visual",
      inherited: true,
      animationType: "length",
      percentages: "no",
      groups: [
        "CSS Text"
      ],
      initial: "8",
      appliesto: "blockContainers",
      computed: "specifiedIntegerOrAbsoluteLength",
      order: "uniqueOrder",
      status: "standard",
      mdn_url: "https://developer.mozilla.org/docs/Web/CSS/tab-size"
    },
    "table-layout": {
      syntax: "auto | fixed",
      media: "visual",
      inherited: false,
      animationType: "discrete",
      percentages: "no",
      groups: [
        "CSS Table"
      ],
      initial: "auto",
      appliesto: "tableElements",
      computed: "asSpecified",
      order: "uniqueOrder",
      status: "standard",
      mdn_url: "https://developer.mozilla.org/docs/Web/CSS/table-layout"
    },
    "text-align": {
      syntax: "start | end | left | right | center | justify | match-parent",
      media: "visual",
      inherited: true,
      animationType: "discrete",
      percentages: "no",
      groups: [
        "CSS Text"
      ],
      initial: "startOrNamelessValueIfLTRRightIfRTL",
      appliesto: "blockContainers",
      computed: "asSpecifiedExceptMatchParent",
      order: "orderOfAppearance",
      alsoAppliesTo: [
        "::placeholder"
      ],
      status: "standard",
      mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-align"
    },
    "text-align-last": {
      syntax: "auto | start | end | left | right | center | justify",
      media: "visual",
      inherited: true,
      animationType: "discrete",
      percentages: "no",
      groups: [
        "CSS Text"
      ],
      initial: "auto",
      appliesto: "blockContainers",
      computed: "asSpecified",
      order: "uniqueOrder",
      status: "standard",
      mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-align-last"
    },
    "text-combine-upright": {
      syntax: "none | all | [ digits <integer>? ]",
      media: "visual",
      inherited: true,
      animationType: "notAnimatable",
      percentages: "no",
      groups: [
        "CSS Writing Modes"
      ],
      initial: "none",
      appliesto: "nonReplacedInlineElements",
      computed: "keywordPlusIntegerIfDigits",
      order: "uniqueOrder",
      status: "standard",
      mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-combine-upright"
    },
    "text-decoration": {
      syntax: "<'text-decoration-line'> || <'text-decoration-style'> || <'text-decoration-color'> || <'text-decoration-thickness'>",
      media: "visual",
      inherited: false,
      animationType: [
        "text-decoration-color",
        "text-decoration-style",
        "text-decoration-line",
        "text-decoration-thickness"
      ],
      percentages: "no",
      groups: [
        "CSS Text Decoration"
      ],
      initial: [
        "text-decoration-color",
        "text-decoration-style",
        "text-decoration-line"
      ],
      appliesto: "allElements",
      computed: [
        "text-decoration-line",
        "text-decoration-style",
        "text-decoration-color",
        "text-decoration-thickness"
      ],
      order: "orderOfAppearance",
      alsoAppliesTo: [
        "::first-letter",
        "::first-line",
        "::placeholder"
      ],
      status: "standard",
      mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-decoration"
    },
    "text-decoration-color": {
      syntax: "<color>",
      media: "visual",
      inherited: false,
      animationType: "color",
      percentages: "no",
      groups: [
        "CSS Text Decoration"
      ],
      initial: "currentcolor",
      appliesto: "allElements",
      computed: "computedColor",
      order: "uniqueOrder",
      alsoAppliesTo: [
        "::first-letter",
        "::first-line",
        "::placeholder"
      ],
      status: "standard",
      mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-decoration-color"
    },
    "text-decoration-line": {
      syntax: "none | [ underline || overline || line-through || blink ] | spelling-error | grammar-error",
      media: "visual",
      inherited: false,
      animationType: "discrete",
      percentages: "no",
      groups: [
        "CSS Text Decoration"
      ],
      initial: "none",
      appliesto: "allElements",
      computed: "asSpecified",
      order: "orderOfAppearance",
      alsoAppliesTo: [
        "::first-letter",
        "::first-line",
        "::placeholder"
      ],
      status: "standard",
      mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-decoration-line"
    },
    "text-decoration-skip": {
      syntax: "none | [ objects || [ spaces | [ leading-spaces || trailing-spaces ] ] || edges || box-decoration ]",
      media: "visual",
      inherited: true,
      animationType: "discrete",
      percentages: "no",
      groups: [
        "CSS Text Decoration"
      ],
      initial: "objects",
      appliesto: "allElements",
      computed: "asSpecified",
      order: "orderOfAppearance",
      status: "experimental",
      mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-decoration-skip"
    },
    "text-decoration-skip-ink": {
      syntax: "auto | all | none",
      media: "visual",
      inherited: true,
      animationType: "discrete",
      percentages: "no",
      groups: [
        "CSS Text Decoration"
      ],
      initial: "auto",
      appliesto: "allElements",
      computed: "asSpecified",
      order: "orderOfAppearance",
      status: "standard",
      mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-decoration-skip-ink"
    },
    "text-decoration-style": {
      syntax: "solid | double | dotted | dashed | wavy",
      media: "visual",
      inherited: false,
      animationType: "discrete",
      percentages: "no",
      groups: [
        "CSS Text Decoration"
      ],
      initial: "solid",
      appliesto: "allElements",
      computed: "asSpecified",
      order: "uniqueOrder",
      alsoAppliesTo: [
        "::first-letter",
        "::first-line",
        "::placeholder"
      ],
      status: "standard",
      mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-decoration-style"
    },
    "text-decoration-thickness": {
      syntax: "auto | from-font | <length> | <percentage> ",
      media: "visual",
      inherited: false,
      animationType: "byComputedValueType",
      percentages: "referToElementFontSize",
      groups: [
        "CSS Text Decoration"
      ],
      initial: "auto",
      appliesto: "allElements",
      computed: "asSpecified",
      order: "uniqueOrder",
      alsoAppliesTo: [
        "::first-letter",
        "::first-line",
        "::placeholder"
      ],
      status: "standard",
      mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-decoration-thickness"
    },
    "text-emphasis": {
      syntax: "<'text-emphasis-style'> || <'text-emphasis-color'>",
      media: "visual",
      inherited: false,
      animationType: [
        "text-emphasis-color",
        "text-emphasis-style"
      ],
      percentages: "no",
      groups: [
        "CSS Text Decoration"
      ],
      initial: [
        "text-emphasis-style",
        "text-emphasis-color"
      ],
      appliesto: "allElements",
      computed: [
        "text-emphasis-style",
        "text-emphasis-color"
      ],
      order: "orderOfAppearance",
      status: "standard",
      mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-emphasis"
    },
    "text-emphasis-color": {
      syntax: "<color>",
      media: "visual",
      inherited: false,
      animationType: "color",
      percentages: "no",
      groups: [
        "CSS Text Decoration"
      ],
      initial: "currentcolor",
      appliesto: "allElements",
      computed: "computedColor",
      order: "uniqueOrder",
      status: "standard",
      mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-emphasis-color"
    },
    "text-emphasis-position": {
      syntax: "[ over | under ] && [ right | left ]",
      media: "visual",
      inherited: false,
      animationType: "discrete",
      percentages: "no",
      groups: [
        "CSS Text Decoration"
      ],
      initial: "over right",
      appliesto: "allElements",
      computed: "asSpecified",
      order: "uniqueOrder",
      status: "standard",
      mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-emphasis-position"
    },
    "text-emphasis-style": {
      syntax: "none | [ [ filled | open ] || [ dot | circle | double-circle | triangle | sesame ] ] | <string>",
      media: "visual",
      inherited: false,
      animationType: "discrete",
      percentages: "no",
      groups: [
        "CSS Text Decoration"
      ],
      initial: "none",
      appliesto: "allElements",
      computed: "asSpecified",
      order: "uniqueOrder",
      status: "standard",
      mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-emphasis-style"
    },
    "text-indent": {
      syntax: "<length-percentage> && hanging? && each-line?",
      media: "visual",
      inherited: true,
      animationType: "lpc",
      percentages: "referToWidthOfContainingBlock",
      groups: [
        "CSS Text"
      ],
      initial: "0",
      appliesto: "blockContainers",
      computed: "percentageOrAbsoluteLengthPlusKeywords",
      order: "lengthOrPercentageBeforeKeywords",
      status: "standard",
      mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-indent"
    },
    "text-justify": {
      syntax: "auto | inter-character | inter-word | none",
      media: "visual",
      inherited: true,
      animationType: "discrete",
      percentages: "no",
      groups: [
        "CSS Text"
      ],
      initial: "auto",
      appliesto: "inlineLevelAndTableCellElements",
      computed: "asSpecified",
      order: "uniqueOrder",
      status: "standard",
      mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-justify"
    },
    "text-orientation": {
      syntax: "mixed | upright | sideways",
      media: "visual",
      inherited: true,
      animationType: "discrete",
      percentages: "no",
      groups: [
        "CSS Writing Modes"
      ],
      initial: "mixed",
      appliesto: "allElementsExceptTableRowGroupsRowsColumnGroupsAndColumns",
      computed: "asSpecified",
      order: "uniqueOrder",
      status: "standard",
      mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-orientation"
    },
    "text-overflow": {
      syntax: "[ clip | ellipsis | <string> ]{1,2}",
      media: "visual",
      inherited: false,
      animationType: "discrete",
      percentages: "no",
      groups: [
        "CSS Basic User Interface"
      ],
      initial: "clip",
      appliesto: "blockContainerElements",
      computed: "asSpecified",
      order: "uniqueOrder",
      alsoAppliesTo: [
        "::placeholder"
      ],
      status: "standard",
      mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-overflow"
    },
    "text-rendering": {
      syntax: "auto | optimizeSpeed | optimizeLegibility | geometricPrecision",
      media: "visual",
      inherited: true,
      animationType: "discrete",
      percentages: "no",
      groups: [
        "CSS Miscellaneous"
      ],
      initial: "auto",
      appliesto: "textElements",
      computed: "asSpecified",
      order: "uniqueOrder",
      status: "standard",
      mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-rendering"
    },
    "text-shadow": {
      syntax: "none | <shadow-t>#",
      media: "visual",
      inherited: true,
      animationType: "shadowList",
      percentages: "no",
      groups: [
        "CSS Text Decoration"
      ],
      initial: "none",
      appliesto: "allElements",
      computed: "colorPlusThreeAbsoluteLengths",
      order: "uniqueOrder",
      alsoAppliesTo: [
        "::first-letter",
        "::first-line",
        "::placeholder"
      ],
      status: "standard",
      mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-shadow"
    },
    "text-size-adjust": {
      syntax: "none | auto | <percentage>",
      media: "visual",
      inherited: true,
      animationType: "discrete",
      percentages: "referToSizeOfFont",
      groups: [
        "CSS Text"
      ],
      initial: "autoForSmartphoneBrowsersSupportingInflation",
      appliesto: "allElements",
      computed: "asSpecified",
      order: "uniqueOrder",
      status: "experimental",
      mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-size-adjust"
    },
    "text-transform": {
      syntax: "none | capitalize | uppercase | lowercase | full-width | full-size-kana",
      media: "visual",
      inherited: true,
      animationType: "discrete",
      percentages: "no",
      groups: [
        "CSS Text"
      ],
      initial: "none",
      appliesto: "allElements",
      computed: "asSpecified",
      order: "uniqueOrder",
      alsoAppliesTo: [
        "::first-letter",
        "::first-line",
        "::placeholder"
      ],
      status: "standard",
      mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-transform"
    },
    "text-underline-offset": {
      syntax: "auto | <length> | <percentage> ",
      media: "visual",
      inherited: true,
      animationType: "byComputedValueType",
      percentages: "referToElementFontSize",
      groups: [
        "CSS Text Decoration"
      ],
      initial: "auto",
      appliesto: "allElements",
      computed: "asSpecified",
      order: "uniqueOrder",
      alsoAppliesTo: [
        "::first-letter",
        "::first-line",
        "::placeholder"
      ],
      status: "standard",
      mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-underline-offset"
    },
    "text-underline-position": {
      syntax: "auto | from-font | [ under || [ left | right ] ]",
      media: "visual",
      inherited: true,
      animationType: "discrete",
      percentages: "no",
      groups: [
        "CSS Text Decoration"
      ],
      initial: "auto",
      appliesto: "allElements",
      computed: "asSpecified",
      order: "orderOfAppearance",
      status: "standard",
      mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-underline-position"
    },
    top: {
      syntax: "<length> | <percentage> | auto",
      media: "visual",
      inherited: false,
      animationType: "lpc",
      percentages: "referToContainingBlockHeight",
      groups: [
        "CSS Positioning"
      ],
      initial: "auto",
      appliesto: "positionedElements",
      computed: "lengthAbsolutePercentageAsSpecifiedOtherwiseAuto",
      order: "uniqueOrder",
      status: "standard",
      mdn_url: "https://developer.mozilla.org/docs/Web/CSS/top"
    },
    "touch-action": {
      syntax: "auto | none | [ [ pan-x | pan-left | pan-right ] || [ pan-y | pan-up | pan-down ] || pinch-zoom ] | manipulation",
      media: "visual",
      inherited: false,
      animationType: "discrete",
      percentages: "no",
      groups: [
        "Pointer Events"
      ],
      initial: "auto",
      appliesto: "allElementsExceptNonReplacedInlineElementsTableRowsColumnsRowColumnGroups",
      computed: "asSpecified",
      order: "uniqueOrder",
      status: "standard",
      mdn_url: "https://developer.mozilla.org/docs/Web/CSS/touch-action"
    },
    transform: {
      syntax: "none | <transform-list>",
      media: "visual",
      inherited: false,
      animationType: "transform",
      percentages: "referToSizeOfBoundingBox",
      groups: [
        "CSS Transforms"
      ],
      initial: "none",
      appliesto: "transformableElements",
      computed: "asSpecifiedRelativeToAbsoluteLengths",
      order: "uniqueOrder",
      stacking: true,
      status: "standard",
      mdn_url: "https://developer.mozilla.org/docs/Web/CSS/transform"
    },
    "transform-box": {
      syntax: "content-box | border-box | fill-box | stroke-box | view-box",
      media: "visual",
      inherited: false,
      animationType: "discrete",
      percentages: "no",
      groups: [
        "CSS Transforms"
      ],
      initial: "view-box",
      appliesto: "transformableElements",
      computed: "asSpecified",
      order: "perGrammar",
      status: "standard",
      mdn_url: "https://developer.mozilla.org/docs/Web/CSS/transform-box"
    },
    "transform-origin": {
      syntax: "[ <length-percentage> | left | center | right | top | bottom ] | [ [ <length-percentage> | left | center | right ] && [ <length-percentage> | top | center | bottom ] ] <length>?",
      media: "visual",
      inherited: false,
      animationType: "simpleListOfLpc",
      percentages: "referToSizeOfBoundingBox",
      groups: [
        "CSS Transforms"
      ],
      initial: "50% 50% 0",
      appliesto: "transformableElements",
      computed: "forLengthAbsoluteValueOtherwisePercentage",
      order: "oneOrTwoValuesLengthAbsoluteKeywordsPercentages",
      status: "standard",
      mdn_url: "https://developer.mozilla.org/docs/Web/CSS/transform-origin"
    },
    "transform-style": {
      syntax: "flat | preserve-3d",
      media: "visual",
      inherited: false,
      animationType: "discrete",
      percentages: "no",
      groups: [
        "CSS Transforms"
      ],
      initial: "flat",
      appliesto: "transformableElements",
      computed: "asSpecified",
      order: "uniqueOrder",
      stacking: true,
      status: "standard",
      mdn_url: "https://developer.mozilla.org/docs/Web/CSS/transform-style"
    },
    transition: {
      syntax: "<single-transition>#",
      media: "interactive",
      inherited: false,
      animationType: "discrete",
      percentages: "no",
      groups: [
        "CSS Transitions"
      ],
      initial: [
        "transition-delay",
        "transition-duration",
        "transition-property",
        "transition-timing-function"
      ],
      appliesto: "allElementsAndPseudos",
      computed: [
        "transition-delay",
        "transition-duration",
        "transition-property",
        "transition-timing-function"
      ],
      order: "orderOfAppearance",
      status: "standard",
      mdn_url: "https://developer.mozilla.org/docs/Web/CSS/transition"
    },
    "transition-delay": {
      syntax: "<time>#",
      media: "interactive",
      inherited: false,
      animationType: "discrete",
      percentages: "no",
      groups: [
        "CSS Transitions"
      ],
      initial: "0s",
      appliesto: "allElementsAndPseudos",
      computed: "asSpecified",
      order: "uniqueOrder",
      status: "standard",
      mdn_url: "https://developer.mozilla.org/docs/Web/CSS/transition-delay"
    },
    "transition-duration": {
      syntax: "<time>#",
      media: "interactive",
      inherited: false,
      animationType: "discrete",
      percentages: "no",
      groups: [
        "CSS Transitions"
      ],
      initial: "0s",
      appliesto: "allElementsAndPseudos",
      computed: "asSpecified",
      order: "uniqueOrder",
      status: "standard",
      mdn_url: "https://developer.mozilla.org/docs/Web/CSS/transition-duration"
    },
    "transition-property": {
      syntax: "none | <single-transition-property>#",
      media: "visual",
      inherited: false,
      animationType: "discrete",
      percentages: "no",
      groups: [
        "CSS Transitions"
      ],
      initial: "all",
      appliesto: "allElementsAndPseudos",
      computed: "asSpecified",
      order: "uniqueOrder",
      status: "standard",
      mdn_url: "https://developer.mozilla.org/docs/Web/CSS/transition-property"
    },
    "transition-timing-function": {
      syntax: "<easing-function>#",
      media: "interactive",
      inherited: false,
      animationType: "discrete",
      percentages: "no",
      groups: [
        "CSS Transitions"
      ],
      initial: "ease",
      appliesto: "allElementsAndPseudos",
      computed: "asSpecified",
      order: "uniqueOrder",
      status: "standard",
      mdn_url: "https://developer.mozilla.org/docs/Web/CSS/transition-timing-function"
    },
    translate: {
      syntax: "none | <length-percentage> [ <length-percentage> <length>? ]?",
      media: "visual",
      inherited: false,
      animationType: "transform",
      percentages: "referToSizeOfBoundingBox",
      groups: [
        "CSS Transforms"
      ],
      initial: "none",
      appliesto: "transformableElements",
      computed: "asSpecifiedRelativeToAbsoluteLengths",
      order: "perGrammar",
      stacking: true,
      status: "standard",
      mdn_url: "https://developer.mozilla.org/docs/Web/CSS/translate"
    },
    "unicode-bidi": {
      syntax: "normal | embed | isolate | bidi-override | isolate-override | plaintext",
      media: "visual",
      inherited: false,
      animationType: "discrete",
      percentages: "no",
      groups: [
        "CSS Writing Modes"
      ],
      initial: "normal",
      appliesto: "allElementsSomeValuesNoEffectOnNonInlineElements",
      computed: "asSpecified",
      order: "uniqueOrder",
      status: "standard",
      mdn_url: "https://developer.mozilla.org/docs/Web/CSS/unicode-bidi"
    },
    "user-select": {
      syntax: "auto | text | none | contain | all",
      media: "visual",
      inherited: false,
      animationType: "discrete",
      percentages: "no",
      groups: [
        "CSS Basic User Interface"
      ],
      initial: "auto",
      appliesto: "allElements",
      computed: "asSpecified",
      order: "uniqueOrder",
      status: "standard",
      mdn_url: "https://developer.mozilla.org/docs/Web/CSS/user-select"
    },
    "vertical-align": {
      syntax: "baseline | sub | super | text-top | text-bottom | middle | top | bottom | <percentage> | <length>",
      media: "visual",
      inherited: false,
      animationType: "length",
      percentages: "referToLineHeight",
      groups: [
        "CSS Table"
      ],
      initial: "baseline",
      appliesto: "inlineLevelAndTableCellElements",
      computed: "absoluteLengthOrKeyword",
      order: "uniqueOrder",
      alsoAppliesTo: [
        "::first-letter",
        "::first-line",
        "::placeholder"
      ],
      status: "standard",
      mdn_url: "https://developer.mozilla.org/docs/Web/CSS/vertical-align"
    },
    visibility: {
      syntax: "visible | hidden | collapse",
      media: "visual",
      inherited: true,
      animationType: "visibility",
      percentages: "no",
      groups: [
        "CSS Box Model"
      ],
      initial: "visible",
      appliesto: "allElements",
      computed: "asSpecified",
      order: "uniqueOrder",
      status: "standard",
      mdn_url: "https://developer.mozilla.org/docs/Web/CSS/visibility"
    },
    "white-space": {
      syntax: "normal | pre | nowrap | pre-wrap | pre-line | break-spaces",
      media: "visual",
      inherited: true,
      animationType: "discrete",
      percentages: "no",
      groups: [
        "CSS Text"
      ],
      initial: "normal",
      appliesto: "allElements",
      computed: "asSpecified",
      order: "uniqueOrder",
      status: "standard",
      mdn_url: "https://developer.mozilla.org/docs/Web/CSS/white-space"
    },
    widows: {
      syntax: "<integer>",
      media: "visual",
      inherited: true,
      animationType: "discrete",
      percentages: "no",
      groups: [
        "CSS Fragmentation"
      ],
      initial: "2",
      appliesto: "blockContainerElements",
      computed: "asSpecified",
      order: "perGrammar",
      status: "standard",
      mdn_url: "https://developer.mozilla.org/docs/Web/CSS/widows"
    },
    width: {
      syntax: "auto | <length> | <percentage> | min-content | max-content | fit-content | fit-content(<length-percentage>)",
      media: "visual",
      inherited: false,
      animationType: "lpc",
      percentages: "referToWidthOfContainingBlock",
      groups: [
        "CSS Box Model"
      ],
      initial: "auto",
      appliesto: "allElementsButNonReplacedAndTableRows",
      computed: "percentageAutoOrAbsoluteLength",
      order: "lengthOrPercentageBeforeKeywordIfBothPresent",
      status: "standard",
      mdn_url: "https://developer.mozilla.org/docs/Web/CSS/width"
    },
    "will-change": {
      syntax: "auto | <animateable-feature>#",
      media: "all",
      inherited: false,
      animationType: "discrete",
      percentages: "no",
      groups: [
        "CSS Will Change"
      ],
      initial: "auto",
      appliesto: "allElements",
      computed: "asSpecified",
      order: "uniqueOrder",
      status: "standard",
      mdn_url: "https://developer.mozilla.org/docs/Web/CSS/will-change"
    },
    "word-break": {
      syntax: "normal | break-all | keep-all | break-word",
      media: "visual",
      inherited: true,
      animationType: "discrete",
      percentages: "no",
      groups: [
        "CSS Text"
      ],
      initial: "normal",
      appliesto: "allElements",
      computed: "asSpecified",
      order: "uniqueOrder",
      status: "standard",
      mdn_url: "https://developer.mozilla.org/docs/Web/CSS/word-break"
    },
    "word-spacing": {
      syntax: "normal | <length>",
      media: "visual",
      inherited: true,
      animationType: "length",
      percentages: "referToWidthOfAffectedGlyph",
      groups: [
        "CSS Text"
      ],
      initial: "normal",
      appliesto: "allElements",
      computed: "absoluteLength",
      order: "uniqueOrder",
      alsoAppliesTo: [
        "::first-letter",
        "::first-line",
        "::placeholder"
      ],
      status: "standard",
      mdn_url: "https://developer.mozilla.org/docs/Web/CSS/word-spacing"
    },
    "word-wrap": {
      syntax: "normal | break-word",
      media: "visual",
      inherited: true,
      animationType: "discrete",
      percentages: "no",
      groups: [
        "CSS Text"
      ],
      initial: "normal",
      appliesto: "nonReplacedInlineElements",
      computed: "asSpecified",
      order: "uniqueOrder",
      status: "standard",
      mdn_url: "https://developer.mozilla.org/docs/Web/CSS/overflow-wrap"
    },
    "writing-mode": {
      syntax: "horizontal-tb | vertical-rl | vertical-lr | sideways-rl | sideways-lr",
      media: "visual",
      inherited: true,
      animationType: "discrete",
      percentages: "no",
      groups: [
        "CSS Writing Modes"
      ],
      initial: "horizontal-tb",
      appliesto: "allElementsExceptTableRowColumnGroupsTableRowsColumns",
      computed: "asSpecified",
      order: "uniqueOrder",
      status: "standard",
      mdn_url: "https://developer.mozilla.org/docs/Web/CSS/writing-mode"
    },
    "z-index": {
      syntax: "auto | <integer>",
      media: "visual",
      inherited: false,
      animationType: "integer",
      percentages: "no",
      groups: [
        "CSS Positioning"
      ],
      initial: "auto",
      appliesto: "positionedElements",
      computed: "asSpecified",
      order: "uniqueOrder",
      stacking: true,
      status: "standard",
      mdn_url: "https://developer.mozilla.org/docs/Web/CSS/z-index"
    },
    zoom: {
      syntax: "normal | reset | <number> | <percentage>",
      media: "visual",
      inherited: false,
      animationType: "integer",
      percentages: "no",
      groups: [
        "Microsoft Extensions"
      ],
      initial: "normal",
      appliesto: "allElements",
      computed: "asSpecified",
      order: "uniqueOrder",
      status: "nonstandard",
      mdn_url: "https://developer.mozilla.org/docs/Web/CSS/zoom"
    }
  };
});

// ../../../../node_modules/.bun/mdn-data@2.0.30/node_modules/mdn-data/css/syntaxes.json
var require_syntaxes = __commonJS((exports, module) => {
  module.exports = {
    "abs()": {
      syntax: "abs( <calc-sum> )"
    },
    "absolute-size": {
      syntax: "xx-small | x-small | small | medium | large | x-large | xx-large | xxx-large"
    },
    "acos()": {
      syntax: "acos( <calc-sum> )"
    },
    "alpha-value": {
      syntax: "<number> | <percentage>"
    },
    "angle-percentage": {
      syntax: "<angle> | <percentage>"
    },
    "angular-color-hint": {
      syntax: "<angle-percentage>"
    },
    "angular-color-stop": {
      syntax: "<color> && <color-stop-angle>?"
    },
    "angular-color-stop-list": {
      syntax: "[ <angular-color-stop> [, <angular-color-hint>]? ]# , <angular-color-stop>"
    },
    "animateable-feature": {
      syntax: "scroll-position | contents | <custom-ident>"
    },
    "asin()": {
      syntax: "asin( <calc-sum> )"
    },
    "atan()": {
      syntax: "atan( <calc-sum> )"
    },
    "atan2()": {
      syntax: "atan2( <calc-sum>, <calc-sum> )"
    },
    attachment: {
      syntax: "scroll | fixed | local"
    },
    "attr()": {
      syntax: "attr( <attr-name> <type-or-unit>? [, <attr-fallback> ]? )"
    },
    "attr-matcher": {
      syntax: "[ '~' | '|' | '^' | '$' | '*' ]? '='"
    },
    "attr-modifier": {
      syntax: "i | s"
    },
    "attribute-selector": {
      syntax: "'[' <wq-name> ']' | '[' <wq-name> <attr-matcher> [ <string-token> | <ident-token> ] <attr-modifier>? ']'"
    },
    "auto-repeat": {
      syntax: "repeat( [ auto-fill | auto-fit ] , [ <line-names>? <fixed-size> ]+ <line-names>? )"
    },
    "auto-track-list": {
      syntax: `[ <line-names>? [ <fixed-size> | <fixed-repeat> ] ]* <line-names>? <auto-repeat>
[ <line-names>? [ <fixed-size> | <fixed-repeat> ] ]* <line-names>?`
    },
    axis: {
      syntax: "block | inline | vertical | horizontal"
    },
    "baseline-position": {
      syntax: "[ first | last ]? baseline"
    },
    "basic-shape": {
      syntax: "<inset()> | <circle()> | <ellipse()> | <polygon()> | <path()>"
    },
    "bg-image": {
      syntax: "none | <image>"
    },
    "bg-layer": {
      syntax: "<bg-image> || <bg-position> [ / <bg-size> ]? || <repeat-style> || <attachment> || <box> || <box>"
    },
    "bg-position": {
      syntax: "[ [ left | center | right | top | bottom | <length-percentage> ] | [ left | center | right | <length-percentage> ] [ top | center | bottom | <length-percentage> ] | [ center | [ left | right ] <length-percentage>? ] && [ center | [ top | bottom ] <length-percentage>? ] ]"
    },
    "bg-size": {
      syntax: "[ <length-percentage> | auto ]{1,2} | cover | contain"
    },
    "blur()": {
      syntax: "blur( <length> )"
    },
    "blend-mode": {
      syntax: "normal | multiply | screen | overlay | darken | lighten | color-dodge | color-burn | hard-light | soft-light | difference | exclusion | hue | saturation | color | luminosity"
    },
    box: {
      syntax: "border-box | padding-box | content-box"
    },
    "brightness()": {
      syntax: "brightness( <number-percentage> )"
    },
    "calc()": {
      syntax: "calc( <calc-sum> )"
    },
    "calc-sum": {
      syntax: "<calc-product> [ [ '+' | '-' ] <calc-product> ]*"
    },
    "calc-product": {
      syntax: "<calc-value> [ '*' <calc-value> | '/' <number> ]*"
    },
    "calc-value": {
      syntax: "<number> | <dimension> | <percentage> | <calc-constant> | ( <calc-sum> )"
    },
    "calc-constant": {
      syntax: "e | pi | infinity | -infinity | NaN"
    },
    "cf-final-image": {
      syntax: "<image> | <color>"
    },
    "cf-mixing-image": {
      syntax: "<percentage>? && <image>"
    },
    "circle()": {
      syntax: "circle( [ <shape-radius> ]? [ at <position> ]? )"
    },
    "clamp()": {
      syntax: "clamp( <calc-sum>#{3} )"
    },
    "class-selector": {
      syntax: "'.' <ident-token>"
    },
    "clip-source": {
      syntax: "<url>"
    },
    color: {
      syntax: "<rgb()> | <rgba()> | <hsl()> | <hsla()> | <hwb()> | <lab()> | <lch()> | <hex-color> | <named-color> | currentcolor | <deprecated-system-color>"
    },
    "color-stop": {
      syntax: "<color-stop-length> | <color-stop-angle>"
    },
    "color-stop-angle": {
      syntax: "<angle-percentage>{1,2}"
    },
    "color-stop-length": {
      syntax: "<length-percentage>{1,2}"
    },
    "color-stop-list": {
      syntax: "[ <linear-color-stop> [, <linear-color-hint>]? ]# , <linear-color-stop>"
    },
    combinator: {
      syntax: "'>' | '+' | '~' | [ '||' ]"
    },
    "common-lig-values": {
      syntax: "[ common-ligatures | no-common-ligatures ]"
    },
    "compat-auto": {
      syntax: "searchfield | textarea | push-button | slider-horizontal | checkbox | radio | square-button | menulist | listbox | meter | progress-bar | button"
    },
    "composite-style": {
      syntax: "clear | copy | source-over | source-in | source-out | source-atop | destination-over | destination-in | destination-out | destination-atop | xor"
    },
    "compositing-operator": {
      syntax: "add | subtract | intersect | exclude"
    },
    "compound-selector": {
      syntax: "[ <type-selector>? <subclass-selector>* [ <pseudo-element-selector> <pseudo-class-selector>* ]* ]!"
    },
    "compound-selector-list": {
      syntax: "<compound-selector>#"
    },
    "complex-selector": {
      syntax: "<compound-selector> [ <combinator>? <compound-selector> ]*"
    },
    "complex-selector-list": {
      syntax: "<complex-selector>#"
    },
    "conic-gradient()": {
      syntax: "conic-gradient( [ from <angle> ]? [ at <position> ]?, <angular-color-stop-list> )"
    },
    "contextual-alt-values": {
      syntax: "[ contextual | no-contextual ]"
    },
    "content-distribution": {
      syntax: "space-between | space-around | space-evenly | stretch"
    },
    "content-list": {
      syntax: "[ <string> | contents | <image> | <counter> | <quote> | <target> | <leader()> ]+"
    },
    "content-position": {
      syntax: "center | start | end | flex-start | flex-end"
    },
    "content-replacement": {
      syntax: "<image>"
    },
    "contrast()": {
      syntax: "contrast( [ <number-percentage> ] )"
    },
    "cos()": {
      syntax: "cos( <calc-sum> )"
    },
    counter: {
      syntax: "<counter()> | <counters()>"
    },
    "counter()": {
      syntax: "counter( <counter-name>, <counter-style>? )"
    },
    "counter-name": {
      syntax: "<custom-ident>"
    },
    "counter-style": {
      syntax: "<counter-style-name> | symbols()"
    },
    "counter-style-name": {
      syntax: "<custom-ident>"
    },
    "counters()": {
      syntax: "counters( <counter-name>, <string>, <counter-style>? )"
    },
    "cross-fade()": {
      syntax: "cross-fade( <cf-mixing-image> , <cf-final-image>? )"
    },
    "cubic-bezier-timing-function": {
      syntax: "ease | ease-in | ease-out | ease-in-out | cubic-bezier(<number [0,1]>, <number>, <number [0,1]>, <number>)"
    },
    "deprecated-system-color": {
      syntax: "ActiveBorder | ActiveCaption | AppWorkspace | Background | ButtonFace | ButtonHighlight | ButtonShadow | ButtonText | CaptionText | GrayText | Highlight | HighlightText | InactiveBorder | InactiveCaption | InactiveCaptionText | InfoBackground | InfoText | Menu | MenuText | Scrollbar | ThreeDDarkShadow | ThreeDFace | ThreeDHighlight | ThreeDLightShadow | ThreeDShadow | Window | WindowFrame | WindowText"
    },
    "discretionary-lig-values": {
      syntax: "[ discretionary-ligatures | no-discretionary-ligatures ]"
    },
    "display-box": {
      syntax: "contents | none"
    },
    "display-inside": {
      syntax: "flow | flow-root | table | flex | grid | ruby"
    },
    "display-internal": {
      syntax: "table-row-group | table-header-group | table-footer-group | table-row | table-cell | table-column-group | table-column | table-caption | ruby-base | ruby-text | ruby-base-container | ruby-text-container"
    },
    "display-legacy": {
      syntax: "inline-block | inline-list-item | inline-table | inline-flex | inline-grid"
    },
    "display-listitem": {
      syntax: "<display-outside>? && [ flow | flow-root ]? && list-item"
    },
    "display-outside": {
      syntax: "block | inline | run-in"
    },
    "drop-shadow()": {
      syntax: "drop-shadow( <length>{2,3} <color>? )"
    },
    "east-asian-variant-values": {
      syntax: "[ jis78 | jis83 | jis90 | jis04 | simplified | traditional ]"
    },
    "east-asian-width-values": {
      syntax: "[ full-width | proportional-width ]"
    },
    "element()": {
      syntax: "element( <id-selector> )"
    },
    "ellipse()": {
      syntax: "ellipse( [ <shape-radius>{2} ]? [ at <position> ]? )"
    },
    "ending-shape": {
      syntax: "circle | ellipse"
    },
    "env()": {
      syntax: "env( <custom-ident> , <declaration-value>? )"
    },
    "exp()": {
      syntax: "exp( <calc-sum> )"
    },
    "explicit-track-list": {
      syntax: "[ <line-names>? <track-size> ]+ <line-names>?"
    },
    "family-name": {
      syntax: "<string> | <custom-ident>+"
    },
    "feature-tag-value": {
      syntax: "<string> [ <integer> | on | off ]?"
    },
    "feature-type": {
      syntax: "@stylistic | @historical-forms | @styleset | @character-variant | @swash | @ornaments | @annotation"
    },
    "feature-value-block": {
      syntax: "<feature-type> '{' <feature-value-declaration-list> '}'"
    },
    "feature-value-block-list": {
      syntax: "<feature-value-block>+"
    },
    "feature-value-declaration": {
      syntax: "<custom-ident>: <integer>+;"
    },
    "feature-value-declaration-list": {
      syntax: "<feature-value-declaration>"
    },
    "feature-value-name": {
      syntax: "<custom-ident>"
    },
    "fill-rule": {
      syntax: "nonzero | evenodd"
    },
    "filter-function": {
      syntax: "<blur()> | <brightness()> | <contrast()> | <drop-shadow()> | <grayscale()> | <hue-rotate()> | <invert()> | <opacity()> | <saturate()> | <sepia()>"
    },
    "filter-function-list": {
      syntax: "[ <filter-function> | <url> ]+"
    },
    "final-bg-layer": {
      syntax: "<'background-color'> || <bg-image> || <bg-position> [ / <bg-size> ]? || <repeat-style> || <attachment> || <box> || <box>"
    },
    "fixed-breadth": {
      syntax: "<length-percentage>"
    },
    "fixed-repeat": {
      syntax: "repeat( [ <integer [1,]> ] , [ <line-names>? <fixed-size> ]+ <line-names>? )"
    },
    "fixed-size": {
      syntax: "<fixed-breadth> | minmax( <fixed-breadth> , <track-breadth> ) | minmax( <inflexible-breadth> , <fixed-breadth> )"
    },
    "font-stretch-absolute": {
      syntax: "normal | ultra-condensed | extra-condensed | condensed | semi-condensed | semi-expanded | expanded | extra-expanded | ultra-expanded | <percentage>"
    },
    "font-variant-css21": {
      syntax: "[ normal | small-caps ]"
    },
    "font-weight-absolute": {
      syntax: "normal | bold | <number [1,1000]>"
    },
    "frequency-percentage": {
      syntax: "<frequency> | <percentage>"
    },
    "general-enclosed": {
      syntax: "[ <function-token> <any-value> ) ] | ( <ident> <any-value> )"
    },
    "generic-family": {
      syntax: "serif | sans-serif | cursive | fantasy | monospace"
    },
    "generic-name": {
      syntax: "serif | sans-serif | cursive | fantasy | monospace"
    },
    "geometry-box": {
      syntax: "<shape-box> | fill-box | stroke-box | view-box"
    },
    gradient: {
      syntax: "<linear-gradient()> | <repeating-linear-gradient()> | <radial-gradient()> | <repeating-radial-gradient()> | <conic-gradient()> | <repeating-conic-gradient()>"
    },
    "grayscale()": {
      syntax: "grayscale( <number-percentage> )"
    },
    "grid-line": {
      syntax: "auto | <custom-ident> | [ <integer> && <custom-ident>? ] | [ span && [ <integer> || <custom-ident> ] ]"
    },
    "historical-lig-values": {
      syntax: "[ historical-ligatures | no-historical-ligatures ]"
    },
    "hsl()": {
      syntax: "hsl( <hue> <percentage> <percentage> [ / <alpha-value> ]? ) | hsl( <hue>, <percentage>, <percentage>, <alpha-value>? )"
    },
    "hsla()": {
      syntax: "hsla( <hue> <percentage> <percentage> [ / <alpha-value> ]? ) | hsla( <hue>, <percentage>, <percentage>, <alpha-value>? )"
    },
    hue: {
      syntax: "<number> | <angle>"
    },
    "hue-rotate()": {
      syntax: "hue-rotate( <angle> )"
    },
    "hwb()": {
      syntax: "hwb( [<hue> | none] [<percentage> | none] [<percentage> | none] [ / [<alpha-value> | none] ]? )"
    },
    "hypot()": {
      syntax: "hypot( <calc-sum># )"
    },
    "id-selector": {
      syntax: "<hash-token>"
    },
    image: {
      syntax: "<url> | <image()> | <image-set()> | <element()> | <paint()> | <cross-fade()> | <gradient>"
    },
    "image()": {
      syntax: "image( <image-tags>? [ <image-src>? , <color>? ]! )"
    },
    "image-set()": {
      syntax: "image-set( <image-set-option># )"
    },
    "image-set-option": {
      syntax: "[ <image> | <string> ] [ <resolution> || type(<string>) ]"
    },
    "image-src": {
      syntax: "<url> | <string>"
    },
    "image-tags": {
      syntax: "ltr | rtl"
    },
    "inflexible-breadth": {
      syntax: "<length-percentage> | min-content | max-content | auto"
    },
    "inset()": {
      syntax: "inset( <length-percentage>{1,4} [ round <'border-radius'> ]? )"
    },
    "invert()": {
      syntax: "invert( <number-percentage> )"
    },
    "keyframes-name": {
      syntax: "<custom-ident> | <string>"
    },
    "keyframe-block": {
      syntax: `<keyframe-selector># {
  <declaration-list>
}`
    },
    "keyframe-block-list": {
      syntax: "<keyframe-block>+"
    },
    "keyframe-selector": {
      syntax: "from | to | <percentage>"
    },
    "lab()": {
      syntax: "lab( [<percentage> | <number> | none] [ <percentage> | <number> | none] [ <percentage> | <number> | none] [ / [<alpha-value> | none] ]? )"
    },
    "layer()": {
      syntax: "layer( <layer-name> )"
    },
    "layer-name": {
      syntax: "<ident> [ '.' <ident> ]*"
    },
    "lch()": {
      syntax: "lch( [<percentage> | <number> | none] [ <percentage> | <number> | none] [ <hue> | none] [ / [<alpha-value> | none] ]? )"
    },
    "leader()": {
      syntax: "leader( <leader-type> )"
    },
    "leader-type": {
      syntax: "dotted | solid | space | <string>"
    },
    "length-percentage": {
      syntax: "<length> | <percentage>"
    },
    "line-names": {
      syntax: "'[' <custom-ident>* ']'"
    },
    "line-name-list": {
      syntax: "[ <line-names> | <name-repeat> ]+"
    },
    "line-style": {
      syntax: "none | hidden | dotted | dashed | solid | double | groove | ridge | inset | outset"
    },
    "line-width": {
      syntax: "<length> | thin | medium | thick"
    },
    "linear-color-hint": {
      syntax: "<length-percentage>"
    },
    "linear-color-stop": {
      syntax: "<color> <color-stop-length>?"
    },
    "linear-gradient()": {
      syntax: "linear-gradient( [ <angle> | to <side-or-corner> ]? , <color-stop-list> )"
    },
    "log()": {
      syntax: "log( <calc-sum>, <calc-sum>? )"
    },
    "mask-layer": {
      syntax: "<mask-reference> || <position> [ / <bg-size> ]? || <repeat-style> || <geometry-box> || [ <geometry-box> | no-clip ] || <compositing-operator> || <masking-mode>"
    },
    "mask-position": {
      syntax: "[ <length-percentage> | left | center | right ] [ <length-percentage> | top | center | bottom ]?"
    },
    "mask-reference": {
      syntax: "none | <image> | <mask-source>"
    },
    "mask-source": {
      syntax: "<url>"
    },
    "masking-mode": {
      syntax: "alpha | luminance | match-source"
    },
    "matrix()": {
      syntax: "matrix( <number>#{6} )"
    },
    "matrix3d()": {
      syntax: "matrix3d( <number>#{16} )"
    },
    "max()": {
      syntax: "max( <calc-sum># )"
    },
    "media-and": {
      syntax: "<media-in-parens> [ and <media-in-parens> ]+"
    },
    "media-condition": {
      syntax: "<media-not> | <media-and> | <media-or> | <media-in-parens>"
    },
    "media-condition-without-or": {
      syntax: "<media-not> | <media-and> | <media-in-parens>"
    },
    "media-feature": {
      syntax: "( [ <mf-plain> | <mf-boolean> | <mf-range> ] )"
    },
    "media-in-parens": {
      syntax: "( <media-condition> ) | <media-feature> | <general-enclosed>"
    },
    "media-not": {
      syntax: "not <media-in-parens>"
    },
    "media-or": {
      syntax: "<media-in-parens> [ or <media-in-parens> ]+"
    },
    "media-query": {
      syntax: "<media-condition> | [ not | only ]? <media-type> [ and <media-condition-without-or> ]?"
    },
    "media-query-list": {
      syntax: "<media-query>#"
    },
    "media-type": {
      syntax: "<ident>"
    },
    "mf-boolean": {
      syntax: "<mf-name>"
    },
    "mf-name": {
      syntax: "<ident>"
    },
    "mf-plain": {
      syntax: "<mf-name> : <mf-value>"
    },
    "mf-range": {
      syntax: `<mf-name> [ '<' | '>' ]? '='? <mf-value>
| <mf-value> [ '<' | '>' ]? '='? <mf-name>
| <mf-value> '<' '='? <mf-name> '<' '='? <mf-value>
| <mf-value> '>' '='? <mf-name> '>' '='? <mf-value>`
    },
    "mf-value": {
      syntax: "<number> | <dimension> | <ident> | <ratio>"
    },
    "min()": {
      syntax: "min( <calc-sum># )"
    },
    "minmax()": {
      syntax: "minmax( [ <length-percentage> | min-content | max-content | auto ] , [ <length-percentage> | <flex> | min-content | max-content | auto ] )"
    },
    "mod()": {
      syntax: "mod( <calc-sum>, <calc-sum> )"
    },
    "name-repeat": {
      syntax: "repeat( [ <integer [1,]> | auto-fill ], <line-names>+ )"
    },
    "named-color": {
      syntax: "transparent | aliceblue | antiquewhite | aqua | aquamarine | azure | beige | bisque | black | blanchedalmond | blue | blueviolet | brown | burlywood | cadetblue | chartreuse | chocolate | coral | cornflowerblue | cornsilk | crimson | cyan | darkblue | darkcyan | darkgoldenrod | darkgray | darkgreen | darkgrey | darkkhaki | darkmagenta | darkolivegreen | darkorange | darkorchid | darkred | darksalmon | darkseagreen | darkslateblue | darkslategray | darkslategrey | darkturquoise | darkviolet | deeppink | deepskyblue | dimgray | dimgrey | dodgerblue | firebrick | floralwhite | forestgreen | fuchsia | gainsboro | ghostwhite | gold | goldenrod | gray | green | greenyellow | grey | honeydew | hotpink | indianred | indigo | ivory | khaki | lavender | lavenderblush | lawngreen | lemonchiffon | lightblue | lightcoral | lightcyan | lightgoldenrodyellow | lightgray | lightgreen | lightgrey | lightpink | lightsalmon | lightseagreen | lightskyblue | lightslategray | lightslategrey | lightsteelblue | lightyellow | lime | limegreen | linen | magenta | maroon | mediumaquamarine | mediumblue | mediumorchid | mediumpurple | mediumseagreen | mediumslateblue | mediumspringgreen | mediumturquoise | mediumvioletred | midnightblue | mintcream | mistyrose | moccasin | navajowhite | navy | oldlace | olive | olivedrab | orange | orangered | orchid | palegoldenrod | palegreen | paleturquoise | palevioletred | papayawhip | peachpuff | peru | pink | plum | powderblue | purple | rebeccapurple | red | rosybrown | royalblue | saddlebrown | salmon | sandybrown | seagreen | seashell | sienna | silver | skyblue | slateblue | slategray | slategrey | snow | springgreen | steelblue | tan | teal | thistle | tomato | turquoise | violet | wheat | white | whitesmoke | yellow | yellowgreen"
    },
    "namespace-prefix": {
      syntax: "<ident>"
    },
    "ns-prefix": {
      syntax: "[ <ident-token> | '*' ]? '|'"
    },
    "number-percentage": {
      syntax: "<number> | <percentage>"
    },
    "numeric-figure-values": {
      syntax: "[ lining-nums | oldstyle-nums ]"
    },
    "numeric-fraction-values": {
      syntax: "[ diagonal-fractions | stacked-fractions ]"
    },
    "numeric-spacing-values": {
      syntax: "[ proportional-nums | tabular-nums ]"
    },
    nth: {
      syntax: "<an-plus-b> | even | odd"
    },
    "opacity()": {
      syntax: "opacity( [ <number-percentage> ] )"
    },
    "overflow-position": {
      syntax: "unsafe | safe"
    },
    "outline-radius": {
      syntax: "<length> | <percentage>"
    },
    "page-body": {
      syntax: "<declaration>? [ ; <page-body> ]? | <page-margin-box> <page-body>"
    },
    "page-margin-box": {
      syntax: "<page-margin-box-type> '{' <declaration-list> '}'"
    },
    "page-margin-box-type": {
      syntax: "@top-left-corner | @top-left | @top-center | @top-right | @top-right-corner | @bottom-left-corner | @bottom-left | @bottom-center | @bottom-right | @bottom-right-corner | @left-top | @left-middle | @left-bottom | @right-top | @right-middle | @right-bottom"
    },
    "page-selector-list": {
      syntax: "[ <page-selector># ]?"
    },
    "page-selector": {
      syntax: "<pseudo-page>+ | <ident> <pseudo-page>*"
    },
    "page-size": {
      syntax: "A5 | A4 | A3 | B5 | B4 | JIS-B5 | JIS-B4 | letter | legal | ledger"
    },
    "path()": {
      syntax: "path( [ <fill-rule>, ]? <string> )"
    },
    "paint()": {
      syntax: "paint( <ident>, <declaration-value>? )"
    },
    "perspective()": {
      syntax: "perspective( [ <length [0,]> | none ] )"
    },
    "polygon()": {
      syntax: "polygon( <fill-rule>? , [ <length-percentage> <length-percentage> ]# )"
    },
    position: {
      syntax: "[ [ left | center | right ] || [ top | center | bottom ] | [ left | center | right | <length-percentage> ] [ top | center | bottom | <length-percentage> ]? | [ [ left | right ] <length-percentage> ] && [ [ top | bottom ] <length-percentage> ] ]"
    },
    "pow()": {
      syntax: "pow( <calc-sum>, <calc-sum> )"
    },
    "pseudo-class-selector": {
      syntax: "':' <ident-token> | ':' <function-token> <any-value> ')'"
    },
    "pseudo-element-selector": {
      syntax: "':' <pseudo-class-selector>"
    },
    "pseudo-page": {
      syntax: ": [ left | right | first | blank ]"
    },
    quote: {
      syntax: "open-quote | close-quote | no-open-quote | no-close-quote"
    },
    "radial-gradient()": {
      syntax: "radial-gradient( [ <ending-shape> || <size> ]? [ at <position> ]? , <color-stop-list> )"
    },
    ratio: {
      syntax: "<number [0,]> [ / <number [0,]> ]?"
    },
    "relative-selector": {
      syntax: "<combinator>? <complex-selector>"
    },
    "relative-selector-list": {
      syntax: "<relative-selector>#"
    },
    "relative-size": {
      syntax: "larger | smaller"
    },
    "rem()": {
      syntax: "rem( <calc-sum>, <calc-sum> )"
    },
    "repeat-style": {
      syntax: "repeat-x | repeat-y | [ repeat | space | round | no-repeat ]{1,2}"
    },
    "repeating-conic-gradient()": {
      syntax: "repeating-conic-gradient( [ from <angle> ]? [ at <position> ]?, <angular-color-stop-list> )"
    },
    "repeating-linear-gradient()": {
      syntax: "repeating-linear-gradient( [ <angle> | to <side-or-corner> ]? , <color-stop-list> )"
    },
    "repeating-radial-gradient()": {
      syntax: "repeating-radial-gradient( [ <ending-shape> || <size> ]? [ at <position> ]? , <color-stop-list> )"
    },
    "reversed-counter-name": {
      syntax: "reversed( <counter-name> )"
    },
    "rgb()": {
      syntax: "rgb( <percentage>{3} [ / <alpha-value> ]? ) | rgb( <number>{3} [ / <alpha-value> ]? ) | rgb( <percentage>#{3} , <alpha-value>? ) | rgb( <number>#{3} , <alpha-value>? )"
    },
    "rgba()": {
      syntax: "rgba( <percentage>{3} [ / <alpha-value> ]? ) | rgba( <number>{3} [ / <alpha-value> ]? ) | rgba( <percentage>#{3} , <alpha-value>? ) | rgba( <number>#{3} , <alpha-value>? )"
    },
    "rotate()": {
      syntax: "rotate( [ <angle> | <zero> ] )"
    },
    "rotate3d()": {
      syntax: "rotate3d( <number> , <number> , <number> , [ <angle> | <zero> ] )"
    },
    "rotateX()": {
      syntax: "rotateX( [ <angle> | <zero> ] )"
    },
    "rotateY()": {
      syntax: "rotateY( [ <angle> | <zero> ] )"
    },
    "rotateZ()": {
      syntax: "rotateZ( [ <angle> | <zero> ] )"
    },
    "round()": {
      syntax: "round( <rounding-strategy>?, <calc-sum>, <calc-sum> )"
    },
    "rounding-strategy": {
      syntax: "nearest | up | down | to-zero"
    },
    "saturate()": {
      syntax: "saturate( <number-percentage> )"
    },
    "scale()": {
      syntax: "scale( [ <number> | <percentage> ]#{1,2} )"
    },
    "scale3d()": {
      syntax: "scale3d( [ <number> | <percentage> ]#{3} )"
    },
    "scaleX()": {
      syntax: "scaleX( [ <number> | <percentage> ] )"
    },
    "scaleY()": {
      syntax: "scaleY( [ <number> | <percentage> ] )"
    },
    "scaleZ()": {
      syntax: "scaleZ( [ <number> | <percentage> ] )"
    },
    scroller: {
      syntax: "root | nearest"
    },
    "self-position": {
      syntax: "center | start | end | self-start | self-end | flex-start | flex-end"
    },
    "shape-radius": {
      syntax: "<length-percentage> | closest-side | farthest-side"
    },
    "sign()": {
      syntax: "sign( <calc-sum> )"
    },
    "skew()": {
      syntax: "skew( [ <angle> | <zero> ] , [ <angle> | <zero> ]? )"
    },
    "skewX()": {
      syntax: "skewX( [ <angle> | <zero> ] )"
    },
    "skewY()": {
      syntax: "skewY( [ <angle> | <zero> ] )"
    },
    "sepia()": {
      syntax: "sepia( <number-percentage> )"
    },
    shadow: {
      syntax: "inset? && <length>{2,4} && <color>?"
    },
    "shadow-t": {
      syntax: "[ <length>{2,3} && <color>? ]"
    },
    shape: {
      syntax: "rect(<top>, <right>, <bottom>, <left>)"
    },
    "shape-box": {
      syntax: "<box> | margin-box"
    },
    "side-or-corner": {
      syntax: "[ left | right ] || [ top | bottom ]"
    },
    "sin()": {
      syntax: "sin( <calc-sum> )"
    },
    "single-animation": {
      syntax: "<time> || <easing-function> || <time> || <single-animation-iteration-count> || <single-animation-direction> || <single-animation-fill-mode> || <single-animation-play-state> || [ none | <keyframes-name> ]"
    },
    "single-animation-direction": {
      syntax: "normal | reverse | alternate | alternate-reverse"
    },
    "single-animation-fill-mode": {
      syntax: "none | forwards | backwards | both"
    },
    "single-animation-iteration-count": {
      syntax: "infinite | <number>"
    },
    "single-animation-play-state": {
      syntax: "running | paused"
    },
    "single-animation-timeline": {
      syntax: "auto | none | <timeline-name> | scroll(<axis>? <scroller>?)"
    },
    "single-transition": {
      syntax: "[ none | <single-transition-property> ] || <time> || <easing-function> || <time>"
    },
    "single-transition-property": {
      syntax: "all | <custom-ident>"
    },
    size: {
      syntax: "closest-side | farthest-side | closest-corner | farthest-corner | <length> | <length-percentage>{2}"
    },
    "sqrt()": {
      syntax: "sqrt( <calc-sum> )"
    },
    "step-position": {
      syntax: "jump-start | jump-end | jump-none | jump-both | start | end"
    },
    "step-timing-function": {
      syntax: "step-start | step-end | steps(<integer>[, <step-position>]?)"
    },
    "subclass-selector": {
      syntax: "<id-selector> | <class-selector> | <attribute-selector> | <pseudo-class-selector>"
    },
    "supports-condition": {
      syntax: "not <supports-in-parens> | <supports-in-parens> [ and <supports-in-parens> ]* | <supports-in-parens> [ or <supports-in-parens> ]*"
    },
    "supports-in-parens": {
      syntax: "( <supports-condition> ) | <supports-feature> | <general-enclosed>"
    },
    "supports-feature": {
      syntax: "<supports-decl> | <supports-selector-fn>"
    },
    "supports-decl": {
      syntax: "( <declaration> )"
    },
    "supports-selector-fn": {
      syntax: "selector( <complex-selector> )"
    },
    symbol: {
      syntax: "<string> | <image> | <custom-ident>"
    },
    "tan()": {
      syntax: "tan( <calc-sum> )"
    },
    target: {
      syntax: "<target-counter()> | <target-counters()> | <target-text()>"
    },
    "target-counter()": {
      syntax: "target-counter( [ <string> | <url> ] , <custom-ident> , <counter-style>? )"
    },
    "target-counters()": {
      syntax: "target-counters( [ <string> | <url> ] , <custom-ident> , <string> , <counter-style>? )"
    },
    "target-text()": {
      syntax: "target-text( [ <string> | <url> ] , [ content | before | after | first-letter ]? )"
    },
    "time-percentage": {
      syntax: "<time> | <percentage>"
    },
    "timeline-name": {
      syntax: "<custom-ident> | <string>"
    },
    "easing-function": {
      syntax: "linear | <cubic-bezier-timing-function> | <step-timing-function>"
    },
    "track-breadth": {
      syntax: "<length-percentage> | <flex> | min-content | max-content | auto"
    },
    "track-list": {
      syntax: "[ <line-names>? [ <track-size> | <track-repeat> ] ]+ <line-names>?"
    },
    "track-repeat": {
      syntax: "repeat( [ <integer [1,]> ] , [ <line-names>? <track-size> ]+ <line-names>? )"
    },
    "track-size": {
      syntax: "<track-breadth> | minmax( <inflexible-breadth> , <track-breadth> ) | fit-content( <length-percentage> )"
    },
    "transform-function": {
      syntax: "<matrix()> | <translate()> | <translateX()> | <translateY()> | <scale()> | <scaleX()> | <scaleY()> | <rotate()> | <skew()> | <skewX()> | <skewY()> | <matrix3d()> | <translate3d()> | <translateZ()> | <scale3d()> | <scaleZ()> | <rotate3d()> | <rotateX()> | <rotateY()> | <rotateZ()> | <perspective()>"
    },
    "transform-list": {
      syntax: "<transform-function>+"
    },
    "translate()": {
      syntax: "translate( <length-percentage> , <length-percentage>? )"
    },
    "translate3d()": {
      syntax: "translate3d( <length-percentage> , <length-percentage> , <length> )"
    },
    "translateX()": {
      syntax: "translateX( <length-percentage> )"
    },
    "translateY()": {
      syntax: "translateY( <length-percentage> )"
    },
    "translateZ()": {
      syntax: "translateZ( <length> )"
    },
    "type-or-unit": {
      syntax: "string | color | url | integer | number | length | angle | time | frequency | cap | ch | em | ex | ic | lh | rlh | rem | vb | vi | vw | vh | vmin | vmax | mm | Q | cm | in | pt | pc | px | deg | grad | rad | turn | ms | s | Hz | kHz | %"
    },
    "type-selector": {
      syntax: "<wq-name> | <ns-prefix>? '*'"
    },
    "var()": {
      syntax: "var( <custom-property-name> , <declaration-value>? )"
    },
    "viewport-length": {
      syntax: "auto | <length-percentage>"
    },
    "visual-box": {
      syntax: "content-box | padding-box | border-box"
    },
    "wq-name": {
      syntax: "<ns-prefix>? <ident-token>"
    }
  };
});

// ../../../../node_modules/.bun/css-tree@2.3.1/node_modules/css-tree/cjs/data.cjs
var require_data = __commonJS((exports, module) => {
  var dataPatch = require_data_patch();
  var mdnAtrules = require_at_rules();
  var mdnProperties = require_properties();
  var mdnSyntaxes = require_syntaxes();
  var extendSyntax = /^\s*\|\s*/;
  function preprocessAtrules(dict) {
    const result = Object.create(null);
    for (const atruleName in dict) {
      const atrule = dict[atruleName];
      let descriptors = null;
      if (atrule.descriptors) {
        descriptors = Object.create(null);
        for (const descriptor in atrule.descriptors) {
          descriptors[descriptor] = atrule.descriptors[descriptor].syntax;
        }
      }
      result[atruleName.substr(1)] = {
        prelude: atrule.syntax.trim().replace(/\{(.|\s)+\}/, "").match(/^@\S+\s+([^;\{]*)/)[1].trim() || null,
        descriptors
      };
    }
    return result;
  }
  function patchDictionary(dict, patchDict) {
    const result = {};
    for (const key in dict) {
      result[key] = dict[key].syntax || dict[key];
    }
    for (const key in patchDict) {
      if (key in dict) {
        if (patchDict[key].syntax) {
          result[key] = extendSyntax.test(patchDict[key].syntax) ? result[key] + " " + patchDict[key].syntax.trim() : patchDict[key].syntax;
        } else {
          delete result[key];
        }
      } else {
        if (patchDict[key].syntax) {
          result[key] = patchDict[key].syntax.replace(extendSyntax, "");
        }
      }
    }
    return result;
  }
  function patchAtrules(dict, patchDict) {
    const result = {};
    for (const key in dict) {
      const atrulePatch = patchDict[key] || {};
      result[key] = {
        prelude: key in patchDict && "prelude" in atrulePatch ? atrulePatch.prelude : dict[key].prelude || null,
        descriptors: patchDictionary(dict[key].descriptors || {}, atrulePatch.descriptors || {})
      };
    }
    for (const key in patchDict) {
      if (!hasOwnProperty.call(dict, key)) {
        const atrulePatch = patchDict[key] || {};
        result[key] = {
          prelude: atrulePatch.prelude || null,
          descriptors: atrulePatch.descriptors && patchDictionary({}, atrulePatch.descriptors)
        };
      }
    }
    return result;
  }
  var definitions = {
    types: patchDictionary(mdnSyntaxes, dataPatch.types),
    atrules: patchAtrules(preprocessAtrules(mdnAtrules), dataPatch.atrules),
    properties: patchDictionary(mdnProperties, dataPatch.properties)
  };
  module.exports = definitions;
});

// ../../../../node_modules/.bun/css-tree@2.3.1/node_modules/css-tree/cjs/syntax/node/AnPlusB.cjs
var require_AnPlusB = __commonJS((exports) => {
  var types = require_types2();
  var charCodeDefinitions = require_char_code_definitions();
  var PLUSSIGN = 43;
  var HYPHENMINUS = 45;
  var N = 110;
  var DISALLOW_SIGN = true;
  var ALLOW_SIGN = false;
  function checkInteger(offset, disallowSign) {
    let pos = this.tokenStart + offset;
    const code = this.charCodeAt(pos);
    if (code === PLUSSIGN || code === HYPHENMINUS) {
      if (disallowSign) {
        this.error("Number sign is not allowed");
      }
      pos++;
    }
    for (;pos < this.tokenEnd; pos++) {
      if (!charCodeDefinitions.isDigit(this.charCodeAt(pos))) {
        this.error("Integer is expected", pos);
      }
    }
  }
  function checkTokenIsInteger(disallowSign) {
    return checkInteger.call(this, 0, disallowSign);
  }
  function expectCharCode(offset, code) {
    if (!this.cmpChar(this.tokenStart + offset, code)) {
      let msg = "";
      switch (code) {
        case N:
          msg = "N is expected";
          break;
        case HYPHENMINUS:
          msg = "HyphenMinus is expected";
          break;
      }
      this.error(msg, this.tokenStart + offset);
    }
  }
  function consumeB() {
    let offset = 0;
    let sign = 0;
    let type = this.tokenType;
    while (type === types.WhiteSpace || type === types.Comment) {
      type = this.lookupType(++offset);
    }
    if (type !== types.Number) {
      if (this.isDelim(PLUSSIGN, offset) || this.isDelim(HYPHENMINUS, offset)) {
        sign = this.isDelim(PLUSSIGN, offset) ? PLUSSIGN : HYPHENMINUS;
        do {
          type = this.lookupType(++offset);
        } while (type === types.WhiteSpace || type === types.Comment);
        if (type !== types.Number) {
          this.skip(offset);
          checkTokenIsInteger.call(this, DISALLOW_SIGN);
        }
      } else {
        return null;
      }
    }
    if (offset > 0) {
      this.skip(offset);
    }
    if (sign === 0) {
      type = this.charCodeAt(this.tokenStart);
      if (type !== PLUSSIGN && type !== HYPHENMINUS) {
        this.error("Number sign is expected");
      }
    }
    checkTokenIsInteger.call(this, sign !== 0);
    return sign === HYPHENMINUS ? "-" + this.consume(types.Number) : this.consume(types.Number);
  }
  var name = "AnPlusB";
  var structure = {
    a: [String, null],
    b: [String, null]
  };
  function parse() {
    const start = this.tokenStart;
    let a = null;
    let b = null;
    if (this.tokenType === types.Number) {
      checkTokenIsInteger.call(this, ALLOW_SIGN);
      b = this.consume(types.Number);
    } else if (this.tokenType === types.Ident && this.cmpChar(this.tokenStart, HYPHENMINUS)) {
      a = "-1";
      expectCharCode.call(this, 1, N);
      switch (this.tokenEnd - this.tokenStart) {
        case 2:
          this.next();
          b = consumeB.call(this);
          break;
        case 3:
          expectCharCode.call(this, 2, HYPHENMINUS);
          this.next();
          this.skipSC();
          checkTokenIsInteger.call(this, DISALLOW_SIGN);
          b = "-" + this.consume(types.Number);
          break;
        default:
          expectCharCode.call(this, 2, HYPHENMINUS);
          checkInteger.call(this, 3, DISALLOW_SIGN);
          this.next();
          b = this.substrToCursor(start + 2);
      }
    } else if (this.tokenType === types.Ident || this.isDelim(PLUSSIGN) && this.lookupType(1) === types.Ident) {
      let sign = 0;
      a = "1";
      if (this.isDelim(PLUSSIGN)) {
        sign = 1;
        this.next();
      }
      expectCharCode.call(this, 0, N);
      switch (this.tokenEnd - this.tokenStart) {
        case 1:
          this.next();
          b = consumeB.call(this);
          break;
        case 2:
          expectCharCode.call(this, 1, HYPHENMINUS);
          this.next();
          this.skipSC();
          checkTokenIsInteger.call(this, DISALLOW_SIGN);
          b = "-" + this.consume(types.Number);
          break;
        default:
          expectCharCode.call(this, 1, HYPHENMINUS);
          checkInteger.call(this, 2, DISALLOW_SIGN);
          this.next();
          b = this.substrToCursor(start + sign + 1);
      }
    } else if (this.tokenType === types.Dimension) {
      const code = this.charCodeAt(this.tokenStart);
      const sign = code === PLUSSIGN || code === HYPHENMINUS;
      let i = this.tokenStart + sign;
      for (;i < this.tokenEnd; i++) {
        if (!charCodeDefinitions.isDigit(this.charCodeAt(i))) {
          break;
        }
      }
      if (i === this.tokenStart + sign) {
        this.error("Integer is expected", this.tokenStart + sign);
      }
      expectCharCode.call(this, i - this.tokenStart, N);
      a = this.substring(start, i);
      if (i + 1 === this.tokenEnd) {
        this.next();
        b = consumeB.call(this);
      } else {
        expectCharCode.call(this, i - this.tokenStart + 1, HYPHENMINUS);
        if (i + 2 === this.tokenEnd) {
          this.next();
          this.skipSC();
          checkTokenIsInteger.call(this, DISALLOW_SIGN);
          b = "-" + this.consume(types.Number);
        } else {
          checkInteger.call(this, i - this.tokenStart + 2, DISALLOW_SIGN);
          this.next();
          b = this.substrToCursor(i + 1);
        }
      }
    } else {
      this.error();
    }
    if (a !== null && a.charCodeAt(0) === PLUSSIGN) {
      a = a.substr(1);
    }
    if (b !== null && b.charCodeAt(0) === PLUSSIGN) {
      b = b.substr(1);
    }
    return {
      type: "AnPlusB",
      loc: this.getLocation(start, this.tokenStart),
      a,
      b
    };
  }
  function generate(node) {
    if (node.a) {
      const a = node.a === "+1" && "n" || node.a === "1" && "n" || node.a === "-1" && "-n" || node.a + "n";
      if (node.b) {
        const b = node.b[0] === "-" || node.b[0] === "+" ? node.b : "+" + node.b;
        this.tokenize(a + b);
      } else {
        this.tokenize(a);
      }
    } else {
      this.tokenize(node.b);
    }
  }
  exports.generate = generate;
  exports.name = name;
  exports.parse = parse;
  exports.structure = structure;
});

// ../../../../node_modules/.bun/css-tree@2.3.1/node_modules/css-tree/cjs/syntax/node/Atrule.cjs
var require_Atrule = __commonJS((exports) => {
  var types = require_types2();
  function consumeRaw(startToken) {
    return this.Raw(startToken, this.consumeUntilLeftCurlyBracketOrSemicolon, true);
  }
  function isDeclarationBlockAtrule() {
    for (let offset = 1, type;type = this.lookupType(offset); offset++) {
      if (type === types.RightCurlyBracket) {
        return true;
      }
      if (type === types.LeftCurlyBracket || type === types.AtKeyword) {
        return false;
      }
    }
    return false;
  }
  var name = "Atrule";
  var walkContext = "atrule";
  var structure = {
    name: String,
    prelude: ["AtrulePrelude", "Raw", null],
    block: ["Block", null]
  };
  function parse(isDeclaration = false) {
    const start = this.tokenStart;
    let name2;
    let nameLowerCase;
    let prelude = null;
    let block = null;
    this.eat(types.AtKeyword);
    name2 = this.substrToCursor(start + 1);
    nameLowerCase = name2.toLowerCase();
    this.skipSC();
    if (this.eof === false && this.tokenType !== types.LeftCurlyBracket && this.tokenType !== types.Semicolon) {
      if (this.parseAtrulePrelude) {
        prelude = this.parseWithFallback(this.AtrulePrelude.bind(this, name2, isDeclaration), consumeRaw);
      } else {
        prelude = consumeRaw.call(this, this.tokenIndex);
      }
      this.skipSC();
    }
    switch (this.tokenType) {
      case types.Semicolon:
        this.next();
        break;
      case types.LeftCurlyBracket:
        if (hasOwnProperty.call(this.atrule, nameLowerCase) && typeof this.atrule[nameLowerCase].block === "function") {
          block = this.atrule[nameLowerCase].block.call(this, isDeclaration);
        } else {
          block = this.Block(isDeclarationBlockAtrule.call(this));
        }
        break;
    }
    return {
      type: "Atrule",
      loc: this.getLocation(start, this.tokenStart),
      name: name2,
      prelude,
      block
    };
  }
  function generate(node) {
    this.token(types.AtKeyword, "@" + node.name);
    if (node.prelude !== null) {
      this.node(node.prelude);
    }
    if (node.block) {
      this.node(node.block);
    } else {
      this.token(types.Semicolon, ";");
    }
  }
  exports.generate = generate;
  exports.name = name;
  exports.parse = parse;
  exports.structure = structure;
  exports.walkContext = walkContext;
});

// ../../../../node_modules/.bun/css-tree@2.3.1/node_modules/css-tree/cjs/syntax/node/AtrulePrelude.cjs
var require_AtrulePrelude = __commonJS((exports) => {
  var types = require_types2();
  var name = "AtrulePrelude";
  var walkContext = "atrulePrelude";
  var structure = {
    children: [[]]
  };
  function parse(name2) {
    let children = null;
    if (name2 !== null) {
      name2 = name2.toLowerCase();
    }
    this.skipSC();
    if (hasOwnProperty.call(this.atrule, name2) && typeof this.atrule[name2].prelude === "function") {
      children = this.atrule[name2].prelude.call(this);
    } else {
      children = this.readSequence(this.scope.AtrulePrelude);
    }
    this.skipSC();
    if (this.eof !== true && this.tokenType !== types.LeftCurlyBracket && this.tokenType !== types.Semicolon) {
      this.error("Semicolon or block is expected");
    }
    return {
      type: "AtrulePrelude",
      loc: this.getLocationFromList(children),
      children
    };
  }
  function generate(node) {
    this.children(node);
  }
  exports.generate = generate;
  exports.name = name;
  exports.parse = parse;
  exports.structure = structure;
  exports.walkContext = walkContext;
});

// ../../../../node_modules/.bun/css-tree@2.3.1/node_modules/css-tree/cjs/syntax/node/AttributeSelector.cjs
var require_AttributeSelector = __commonJS((exports) => {
  var types = require_types2();
  var DOLLARSIGN = 36;
  var ASTERISK = 42;
  var EQUALSSIGN = 61;
  var CIRCUMFLEXACCENT = 94;
  var VERTICALLINE = 124;
  var TILDE = 126;
  function getAttributeName() {
    if (this.eof) {
      this.error("Unexpected end of input");
    }
    const start = this.tokenStart;
    let expectIdent = false;
    if (this.isDelim(ASTERISK)) {
      expectIdent = true;
      this.next();
    } else if (!this.isDelim(VERTICALLINE)) {
      this.eat(types.Ident);
    }
    if (this.isDelim(VERTICALLINE)) {
      if (this.charCodeAt(this.tokenStart + 1) !== EQUALSSIGN) {
        this.next();
        this.eat(types.Ident);
      } else if (expectIdent) {
        this.error("Identifier is expected", this.tokenEnd);
      }
    } else if (expectIdent) {
      this.error("Vertical line is expected");
    }
    return {
      type: "Identifier",
      loc: this.getLocation(start, this.tokenStart),
      name: this.substrToCursor(start)
    };
  }
  function getOperator() {
    const start = this.tokenStart;
    const code = this.charCodeAt(start);
    if (code !== EQUALSSIGN && code !== TILDE && code !== CIRCUMFLEXACCENT && code !== DOLLARSIGN && code !== ASTERISK && code !== VERTICALLINE) {
      this.error("Attribute selector (=, ~=, ^=, $=, *=, |=) is expected");
    }
    this.next();
    if (code !== EQUALSSIGN) {
      if (!this.isDelim(EQUALSSIGN)) {
        this.error("Equal sign is expected");
      }
      this.next();
    }
    return this.substrToCursor(start);
  }
  var name = "AttributeSelector";
  var structure = {
    name: "Identifier",
    matcher: [String, null],
    value: ["String", "Identifier", null],
    flags: [String, null]
  };
  function parse() {
    const start = this.tokenStart;
    let name2;
    let matcher = null;
    let value = null;
    let flags = null;
    this.eat(types.LeftSquareBracket);
    this.skipSC();
    name2 = getAttributeName.call(this);
    this.skipSC();
    if (this.tokenType !== types.RightSquareBracket) {
      if (this.tokenType !== types.Ident) {
        matcher = getOperator.call(this);
        this.skipSC();
        value = this.tokenType === types.String ? this.String() : this.Identifier();
        this.skipSC();
      }
      if (this.tokenType === types.Ident) {
        flags = this.consume(types.Ident);
        this.skipSC();
      }
    }
    this.eat(types.RightSquareBracket);
    return {
      type: "AttributeSelector",
      loc: this.getLocation(start, this.tokenStart),
      name: name2,
      matcher,
      value,
      flags
    };
  }
  function generate(node) {
    this.token(types.Delim, "[");
    this.node(node.name);
    if (node.matcher !== null) {
      this.tokenize(node.matcher);
      this.node(node.value);
    }
    if (node.flags !== null) {
      this.token(types.Ident, node.flags);
    }
    this.token(types.Delim, "]");
  }
  exports.generate = generate;
  exports.name = name;
  exports.parse = parse;
  exports.structure = structure;
});

// ../../../../node_modules/.bun/css-tree@2.3.1/node_modules/css-tree/cjs/syntax/node/Block.cjs
var require_Block = __commonJS((exports) => {
  var types = require_types2();
  var AMPERSAND = 38;
  function consumeRaw(startToken) {
    return this.Raw(startToken, null, true);
  }
  function consumeRule() {
    return this.parseWithFallback(this.Rule, consumeRaw);
  }
  function consumeRawDeclaration(startToken) {
    return this.Raw(startToken, this.consumeUntilSemicolonIncluded, true);
  }
  function consumeDeclaration() {
    if (this.tokenType === types.Semicolon) {
      return consumeRawDeclaration.call(this, this.tokenIndex);
    }
    const node = this.parseWithFallback(this.Declaration, consumeRawDeclaration);
    if (this.tokenType === types.Semicolon) {
      this.next();
    }
    return node;
  }
  var name = "Block";
  var walkContext = "block";
  var structure = {
    children: [[
      "Atrule",
      "Rule",
      "Declaration"
    ]]
  };
  function parse(isStyleBlock) {
    const consumer = isStyleBlock ? consumeDeclaration : consumeRule;
    const start = this.tokenStart;
    let children = this.createList();
    this.eat(types.LeftCurlyBracket);
    scan:
      while (!this.eof) {
        switch (this.tokenType) {
          case types.RightCurlyBracket:
            break scan;
          case types.WhiteSpace:
          case types.Comment:
            this.next();
            break;
          case types.AtKeyword:
            children.push(this.parseWithFallback(this.Atrule.bind(this, isStyleBlock), consumeRaw));
            break;
          default:
            if (isStyleBlock && this.isDelim(AMPERSAND)) {
              children.push(consumeRule.call(this));
            } else {
              children.push(consumer.call(this));
            }
        }
      }
    if (!this.eof) {
      this.eat(types.RightCurlyBracket);
    }
    return {
      type: "Block",
      loc: this.getLocation(start, this.tokenStart),
      children
    };
  }
  function generate(node) {
    this.token(types.LeftCurlyBracket, "{");
    this.children(node, (prev) => {
      if (prev.type === "Declaration") {
        this.token(types.Semicolon, ";");
      }
    });
    this.token(types.RightCurlyBracket, "}");
  }
  exports.generate = generate;
  exports.name = name;
  exports.parse = parse;
  exports.structure = structure;
  exports.walkContext = walkContext;
});

// ../../../../node_modules/.bun/css-tree@2.3.1/node_modules/css-tree/cjs/syntax/node/Brackets.cjs
var require_Brackets = __commonJS((exports) => {
  var types = require_types2();
  var name = "Brackets";
  var structure = {
    children: [[]]
  };
  function parse(readSequence, recognizer) {
    const start = this.tokenStart;
    let children = null;
    this.eat(types.LeftSquareBracket);
    children = readSequence.call(this, recognizer);
    if (!this.eof) {
      this.eat(types.RightSquareBracket);
    }
    return {
      type: "Brackets",
      loc: this.getLocation(start, this.tokenStart),
      children
    };
  }
  function generate(node) {
    this.token(types.Delim, "[");
    this.children(node);
    this.token(types.Delim, "]");
  }
  exports.generate = generate;
  exports.name = name;
  exports.parse = parse;
  exports.structure = structure;
});

// ../../../../node_modules/.bun/css-tree@2.3.1/node_modules/css-tree/cjs/syntax/node/CDC.cjs
var require_CDC = __commonJS((exports) => {
  var types = require_types2();
  var name = "CDC";
  var structure = [];
  function parse() {
    const start = this.tokenStart;
    this.eat(types.CDC);
    return {
      type: "CDC",
      loc: this.getLocation(start, this.tokenStart)
    };
  }
  function generate() {
    this.token(types.CDC, "-->");
  }
  exports.generate = generate;
  exports.name = name;
  exports.parse = parse;
  exports.structure = structure;
});

// ../../../../node_modules/.bun/css-tree@2.3.1/node_modules/css-tree/cjs/syntax/node/CDO.cjs
var require_CDO = __commonJS((exports) => {
  var types = require_types2();
  var name = "CDO";
  var structure = [];
  function parse() {
    const start = this.tokenStart;
    this.eat(types.CDO);
    return {
      type: "CDO",
      loc: this.getLocation(start, this.tokenStart)
    };
  }
  function generate() {
    this.token(types.CDO, "<!--");
  }
  exports.generate = generate;
  exports.name = name;
  exports.parse = parse;
  exports.structure = structure;
});

// ../../../../node_modules/.bun/css-tree@2.3.1/node_modules/css-tree/cjs/syntax/node/ClassSelector.cjs
var require_ClassSelector = __commonJS((exports) => {
  var types = require_types2();
  var FULLSTOP = 46;
  var name = "ClassSelector";
  var structure = {
    name: String
  };
  function parse() {
    this.eatDelim(FULLSTOP);
    return {
      type: "ClassSelector",
      loc: this.getLocation(this.tokenStart - 1, this.tokenEnd),
      name: this.consume(types.Ident)
    };
  }
  function generate(node) {
    this.token(types.Delim, ".");
    this.token(types.Ident, node.name);
  }
  exports.generate = generate;
  exports.name = name;
  exports.parse = parse;
  exports.structure = structure;
});

// ../../../../node_modules/.bun/css-tree@2.3.1/node_modules/css-tree/cjs/syntax/node/Combinator.cjs
var require_Combinator = __commonJS((exports) => {
  var types = require_types2();
  var PLUSSIGN = 43;
  var SOLIDUS = 47;
  var GREATERTHANSIGN = 62;
  var TILDE = 126;
  var name = "Combinator";
  var structure = {
    name: String
  };
  function parse() {
    const start = this.tokenStart;
    let name2;
    switch (this.tokenType) {
      case types.WhiteSpace:
        name2 = " ";
        break;
      case types.Delim:
        switch (this.charCodeAt(this.tokenStart)) {
          case GREATERTHANSIGN:
          case PLUSSIGN:
          case TILDE:
            this.next();
            break;
          case SOLIDUS:
            this.next();
            this.eatIdent("deep");
            this.eatDelim(SOLIDUS);
            break;
          default:
            this.error("Combinator is expected");
        }
        name2 = this.substrToCursor(start);
        break;
    }
    return {
      type: "Combinator",
      loc: this.getLocation(start, this.tokenStart),
      name: name2
    };
  }
  function generate(node) {
    this.tokenize(node.name);
  }
  exports.generate = generate;
  exports.name = name;
  exports.parse = parse;
  exports.structure = structure;
});

// ../../../../node_modules/.bun/css-tree@2.3.1/node_modules/css-tree/cjs/syntax/node/Comment.cjs
var require_Comment = __commonJS((exports) => {
  var types = require_types2();
  var ASTERISK = 42;
  var SOLIDUS = 47;
  var name = "Comment";
  var structure = {
    value: String
  };
  function parse() {
    const start = this.tokenStart;
    let end = this.tokenEnd;
    this.eat(types.Comment);
    if (end - start + 2 >= 2 && this.charCodeAt(end - 2) === ASTERISK && this.charCodeAt(end - 1) === SOLIDUS) {
      end -= 2;
    }
    return {
      type: "Comment",
      loc: this.getLocation(start, this.tokenStart),
      value: this.substring(start + 2, end)
    };
  }
  function generate(node) {
    this.token(types.Comment, "/*" + node.value + "*/");
  }
  exports.generate = generate;
  exports.name = name;
  exports.parse = parse;
  exports.structure = structure;
});

// ../../../../node_modules/.bun/css-tree@2.3.1/node_modules/css-tree/cjs/syntax/node/Declaration.cjs
var require_Declaration = __commonJS((exports) => {
  var names = require_names2();
  var types = require_types2();
  var EXCLAMATIONMARK = 33;
  var NUMBERSIGN = 35;
  var DOLLARSIGN = 36;
  var AMPERSAND = 38;
  var ASTERISK = 42;
  var PLUSSIGN = 43;
  var SOLIDUS = 47;
  function consumeValueRaw(startToken) {
    return this.Raw(startToken, this.consumeUntilExclamationMarkOrSemicolon, true);
  }
  function consumeCustomPropertyRaw(startToken) {
    return this.Raw(startToken, this.consumeUntilExclamationMarkOrSemicolon, false);
  }
  function consumeValue() {
    const startValueToken = this.tokenIndex;
    const value = this.Value();
    if (value.type !== "Raw" && this.eof === false && this.tokenType !== types.Semicolon && this.isDelim(EXCLAMATIONMARK) === false && this.isBalanceEdge(startValueToken) === false) {
      this.error();
    }
    return value;
  }
  var name = "Declaration";
  var walkContext = "declaration";
  var structure = {
    important: [Boolean, String],
    property: String,
    value: ["Value", "Raw"]
  };
  function parse() {
    const start = this.tokenStart;
    const startToken = this.tokenIndex;
    const property = readProperty.call(this);
    const customProperty = names.isCustomProperty(property);
    const parseValue = customProperty ? this.parseCustomProperty : this.parseValue;
    const consumeRaw = customProperty ? consumeCustomPropertyRaw : consumeValueRaw;
    let important = false;
    let value;
    this.skipSC();
    this.eat(types.Colon);
    const valueStart = this.tokenIndex;
    if (!customProperty) {
      this.skipSC();
    }
    if (parseValue) {
      value = this.parseWithFallback(consumeValue, consumeRaw);
    } else {
      value = consumeRaw.call(this, this.tokenIndex);
    }
    if (customProperty && value.type === "Value" && value.children.isEmpty) {
      for (let offset = valueStart - this.tokenIndex;offset <= 0; offset++) {
        if (this.lookupType(offset) === types.WhiteSpace) {
          value.children.appendData({
            type: "WhiteSpace",
            loc: null,
            value: " "
          });
          break;
        }
      }
    }
    if (this.isDelim(EXCLAMATIONMARK)) {
      important = getImportant.call(this);
      this.skipSC();
    }
    if (this.eof === false && this.tokenType !== types.Semicolon && this.isBalanceEdge(startToken) === false) {
      this.error();
    }
    return {
      type: "Declaration",
      loc: this.getLocation(start, this.tokenStart),
      important,
      property,
      value
    };
  }
  function generate(node) {
    this.token(types.Ident, node.property);
    this.token(types.Colon, ":");
    this.node(node.value);
    if (node.important) {
      this.token(types.Delim, "!");
      this.token(types.Ident, node.important === true ? "important" : node.important);
    }
  }
  function readProperty() {
    const start = this.tokenStart;
    if (this.tokenType === types.Delim) {
      switch (this.charCodeAt(this.tokenStart)) {
        case ASTERISK:
        case DOLLARSIGN:
        case PLUSSIGN:
        case NUMBERSIGN:
        case AMPERSAND:
          this.next();
          break;
        case SOLIDUS:
          this.next();
          if (this.isDelim(SOLIDUS)) {
            this.next();
          }
          break;
      }
    }
    if (this.tokenType === types.Hash) {
      this.eat(types.Hash);
    } else {
      this.eat(types.Ident);
    }
    return this.substrToCursor(start);
  }
  function getImportant() {
    this.eat(types.Delim);
    this.skipSC();
    const important = this.consume(types.Ident);
    return important === "important" ? true : important;
  }
  exports.generate = generate;
  exports.name = name;
  exports.parse = parse;
  exports.structure = structure;
  exports.walkContext = walkContext;
});

// ../../../../node_modules/.bun/css-tree@2.3.1/node_modules/css-tree/cjs/syntax/node/DeclarationList.cjs
var require_DeclarationList = __commonJS((exports) => {
  var types = require_types2();
  var AMPERSAND = 38;
  function consumeRaw(startToken) {
    return this.Raw(startToken, this.consumeUntilSemicolonIncluded, true);
  }
  var name = "DeclarationList";
  var structure = {
    children: [[
      "Declaration",
      "Atrule",
      "Rule"
    ]]
  };
  function parse() {
    const children = this.createList();
    while (!this.eof) {
      switch (this.tokenType) {
        case types.WhiteSpace:
        case types.Comment:
        case types.Semicolon:
          this.next();
          break;
        case types.AtKeyword:
          children.push(this.parseWithFallback(this.Atrule.bind(this, true), consumeRaw));
          break;
        default:
          if (this.isDelim(AMPERSAND)) {
            children.push(this.parseWithFallback(this.Rule, consumeRaw));
          } else {
            children.push(this.parseWithFallback(this.Declaration, consumeRaw));
          }
      }
    }
    return {
      type: "DeclarationList",
      loc: this.getLocationFromList(children),
      children
    };
  }
  function generate(node) {
    this.children(node, (prev) => {
      if (prev.type === "Declaration") {
        this.token(types.Semicolon, ";");
      }
    });
  }
  exports.generate = generate;
  exports.name = name;
  exports.parse = parse;
  exports.structure = structure;
});

// ../../../../node_modules/.bun/css-tree@2.3.1/node_modules/css-tree/cjs/syntax/node/Dimension.cjs
var require_Dimension = __commonJS((exports) => {
  var types = require_types2();
  var name = "Dimension";
  var structure = {
    value: String,
    unit: String
  };
  function parse() {
    const start = this.tokenStart;
    const value = this.consumeNumber(types.Dimension);
    return {
      type: "Dimension",
      loc: this.getLocation(start, this.tokenStart),
      value,
      unit: this.substring(start + value.length, this.tokenStart)
    };
  }
  function generate(node) {
    this.token(types.Dimension, node.value + node.unit);
  }
  exports.generate = generate;
  exports.name = name;
  exports.parse = parse;
  exports.structure = structure;
});

// ../../../../node_modules/.bun/css-tree@2.3.1/node_modules/css-tree/cjs/syntax/node/Function.cjs
var require_Function = __commonJS((exports) => {
  var types = require_types2();
  var name = "Function";
  var walkContext = "function";
  var structure = {
    name: String,
    children: [[]]
  };
  function parse(readSequence, recognizer) {
    const start = this.tokenStart;
    const name2 = this.consumeFunctionName();
    const nameLowerCase = name2.toLowerCase();
    let children;
    children = recognizer.hasOwnProperty(nameLowerCase) ? recognizer[nameLowerCase].call(this, recognizer) : readSequence.call(this, recognizer);
    if (!this.eof) {
      this.eat(types.RightParenthesis);
    }
    return {
      type: "Function",
      loc: this.getLocation(start, this.tokenStart),
      name: name2,
      children
    };
  }
  function generate(node) {
    this.token(types.Function, node.name + "(");
    this.children(node);
    this.token(types.RightParenthesis, ")");
  }
  exports.generate = generate;
  exports.name = name;
  exports.parse = parse;
  exports.structure = structure;
  exports.walkContext = walkContext;
});

// ../../../../node_modules/.bun/css-tree@2.3.1/node_modules/css-tree/cjs/syntax/node/Hash.cjs
var require_Hash = __commonJS((exports) => {
  var types = require_types2();
  var xxx = "XXX";
  var name = "Hash";
  var structure = {
    value: String
  };
  function parse() {
    const start = this.tokenStart;
    this.eat(types.Hash);
    return {
      type: "Hash",
      loc: this.getLocation(start, this.tokenStart),
      value: this.substrToCursor(start + 1)
    };
  }
  function generate(node) {
    this.token(types.Hash, "#" + node.value);
  }
  exports.generate = generate;
  exports.name = name;
  exports.parse = parse;
  exports.structure = structure;
  exports.xxx = xxx;
});

// ../../../../node_modules/.bun/css-tree@2.3.1/node_modules/css-tree/cjs/syntax/node/Identifier.cjs
var require_Identifier = __commonJS((exports) => {
  var types = require_types2();
  var name = "Identifier";
  var structure = {
    name: String
  };
  function parse() {
    return {
      type: "Identifier",
      loc: this.getLocation(this.tokenStart, this.tokenEnd),
      name: this.consume(types.Ident)
    };
  }
  function generate(node) {
    this.token(types.Ident, node.name);
  }
  exports.generate = generate;
  exports.name = name;
  exports.parse = parse;
  exports.structure = structure;
});

// ../../../../node_modules/.bun/css-tree@2.3.1/node_modules/css-tree/cjs/syntax/node/IdSelector.cjs
var require_IdSelector = __commonJS((exports) => {
  var types = require_types2();
  var name = "IdSelector";
  var structure = {
    name: String
  };
  function parse() {
    const start = this.tokenStart;
    this.eat(types.Hash);
    return {
      type: "IdSelector",
      loc: this.getLocation(start, this.tokenStart),
      name: this.substrToCursor(start + 1)
    };
  }
  function generate(node) {
    this.token(types.Delim, "#" + node.name);
  }
  exports.generate = generate;
  exports.name = name;
  exports.parse = parse;
  exports.structure = structure;
});

// ../../../../node_modules/.bun/css-tree@2.3.1/node_modules/css-tree/cjs/syntax/node/MediaFeature.cjs
var require_MediaFeature = __commonJS((exports) => {
  var types = require_types2();
  var name = "MediaFeature";
  var structure = {
    name: String,
    value: ["Identifier", "Number", "Dimension", "Ratio", null]
  };
  function parse() {
    const start = this.tokenStart;
    let name2;
    let value = null;
    this.eat(types.LeftParenthesis);
    this.skipSC();
    name2 = this.consume(types.Ident);
    this.skipSC();
    if (this.tokenType !== types.RightParenthesis) {
      this.eat(types.Colon);
      this.skipSC();
      switch (this.tokenType) {
        case types.Number:
          if (this.lookupNonWSType(1) === types.Delim) {
            value = this.Ratio();
          } else {
            value = this.Number();
          }
          break;
        case types.Dimension:
          value = this.Dimension();
          break;
        case types.Ident:
          value = this.Identifier();
          break;
        default:
          this.error("Number, dimension, ratio or identifier is expected");
      }
      this.skipSC();
    }
    this.eat(types.RightParenthesis);
    return {
      type: "MediaFeature",
      loc: this.getLocation(start, this.tokenStart),
      name: name2,
      value
    };
  }
  function generate(node) {
    this.token(types.LeftParenthesis, "(");
    this.token(types.Ident, node.name);
    if (node.value !== null) {
      this.token(types.Colon, ":");
      this.node(node.value);
    }
    this.token(types.RightParenthesis, ")");
  }
  exports.generate = generate;
  exports.name = name;
  exports.parse = parse;
  exports.structure = structure;
});

// ../../../../node_modules/.bun/css-tree@2.3.1/node_modules/css-tree/cjs/syntax/node/MediaQuery.cjs
var require_MediaQuery = __commonJS((exports) => {
  var types = require_types2();
  var name = "MediaQuery";
  var structure = {
    children: [[
      "Identifier",
      "MediaFeature",
      "WhiteSpace"
    ]]
  };
  function parse() {
    const children = this.createList();
    let child = null;
    this.skipSC();
    scan:
      while (!this.eof) {
        switch (this.tokenType) {
          case types.Comment:
          case types.WhiteSpace:
            this.next();
            continue;
          case types.Ident:
            child = this.Identifier();
            break;
          case types.LeftParenthesis:
            child = this.MediaFeature();
            break;
          default:
            break scan;
        }
        children.push(child);
      }
    if (child === null) {
      this.error("Identifier or parenthesis is expected");
    }
    return {
      type: "MediaQuery",
      loc: this.getLocationFromList(children),
      children
    };
  }
  function generate(node) {
    this.children(node);
  }
  exports.generate = generate;
  exports.name = name;
  exports.parse = parse;
  exports.structure = structure;
});

// ../../../../node_modules/.bun/css-tree@2.3.1/node_modules/css-tree/cjs/syntax/node/MediaQueryList.cjs
var require_MediaQueryList = __commonJS((exports) => {
  var types = require_types2();
  var name = "MediaQueryList";
  var structure = {
    children: [[
      "MediaQuery"
    ]]
  };
  function parse() {
    const children = this.createList();
    this.skipSC();
    while (!this.eof) {
      children.push(this.MediaQuery());
      if (this.tokenType !== types.Comma) {
        break;
      }
      this.next();
    }
    return {
      type: "MediaQueryList",
      loc: this.getLocationFromList(children),
      children
    };
  }
  function generate(node) {
    this.children(node, () => this.token(types.Comma, ","));
  }
  exports.generate = generate;
  exports.name = name;
  exports.parse = parse;
  exports.structure = structure;
});

// ../../../../node_modules/.bun/css-tree@2.3.1/node_modules/css-tree/cjs/syntax/node/NestingSelector.cjs
var require_NestingSelector = __commonJS((exports) => {
  var types = require_types2();
  var AMPERSAND = 38;
  var name = "NestingSelector";
  var structure = {};
  function parse() {
    const start = this.tokenStart;
    this.eatDelim(AMPERSAND);
    return {
      type: "NestingSelector",
      loc: this.getLocation(start, this.tokenStart)
    };
  }
  function generate() {
    this.token(types.Delim, "&");
  }
  exports.generate = generate;
  exports.name = name;
  exports.parse = parse;
  exports.structure = structure;
});

// ../../../../node_modules/.bun/css-tree@2.3.1/node_modules/css-tree/cjs/syntax/node/Nth.cjs
var require_Nth = __commonJS((exports) => {
  var types = require_types2();
  var name = "Nth";
  var structure = {
    nth: ["AnPlusB", "Identifier"],
    selector: ["SelectorList", null]
  };
  function parse() {
    this.skipSC();
    const start = this.tokenStart;
    let end = start;
    let selector = null;
    let nth;
    if (this.lookupValue(0, "odd") || this.lookupValue(0, "even")) {
      nth = this.Identifier();
    } else {
      nth = this.AnPlusB();
    }
    end = this.tokenStart;
    this.skipSC();
    if (this.lookupValue(0, "of")) {
      this.next();
      selector = this.SelectorList();
      end = this.tokenStart;
    }
    return {
      type: "Nth",
      loc: this.getLocation(start, end),
      nth,
      selector
    };
  }
  function generate(node) {
    this.node(node.nth);
    if (node.selector !== null) {
      this.token(types.Ident, "of");
      this.node(node.selector);
    }
  }
  exports.generate = generate;
  exports.name = name;
  exports.parse = parse;
  exports.structure = structure;
});

// ../../../../node_modules/.bun/css-tree@2.3.1/node_modules/css-tree/cjs/syntax/node/Number.cjs
var require_Number = __commonJS((exports) => {
  var types = require_types2();
  var name = "Number";
  var structure = {
    value: String
  };
  function parse() {
    return {
      type: "Number",
      loc: this.getLocation(this.tokenStart, this.tokenEnd),
      value: this.consume(types.Number)
    };
  }
  function generate(node) {
    this.token(types.Number, node.value);
  }
  exports.generate = generate;
  exports.name = name;
  exports.parse = parse;
  exports.structure = structure;
});

// ../../../../node_modules/.bun/css-tree@2.3.1/node_modules/css-tree/cjs/syntax/node/Operator.cjs
var require_Operator = __commonJS((exports) => {
  var name = "Operator";
  var structure = {
    value: String
  };
  function parse() {
    const start = this.tokenStart;
    this.next();
    return {
      type: "Operator",
      loc: this.getLocation(start, this.tokenStart),
      value: this.substrToCursor(start)
    };
  }
  function generate(node) {
    this.tokenize(node.value);
  }
  exports.generate = generate;
  exports.name = name;
  exports.parse = parse;
  exports.structure = structure;
});

// ../../../../node_modules/.bun/css-tree@2.3.1/node_modules/css-tree/cjs/syntax/node/Parentheses.cjs
var require_Parentheses = __commonJS((exports) => {
  var types = require_types2();
  var name = "Parentheses";
  var structure = {
    children: [[]]
  };
  function parse(readSequence, recognizer) {
    const start = this.tokenStart;
    let children = null;
    this.eat(types.LeftParenthesis);
    children = readSequence.call(this, recognizer);
    if (!this.eof) {
      this.eat(types.RightParenthesis);
    }
    return {
      type: "Parentheses",
      loc: this.getLocation(start, this.tokenStart),
      children
    };
  }
  function generate(node) {
    this.token(types.LeftParenthesis, "(");
    this.children(node);
    this.token(types.RightParenthesis, ")");
  }
  exports.generate = generate;
  exports.name = name;
  exports.parse = parse;
  exports.structure = structure;
});

// ../../../../node_modules/.bun/css-tree@2.3.1/node_modules/css-tree/cjs/syntax/node/Percentage.cjs
var require_Percentage = __commonJS((exports) => {
  var types = require_types2();
  var name = "Percentage";
  var structure = {
    value: String
  };
  function parse() {
    return {
      type: "Percentage",
      loc: this.getLocation(this.tokenStart, this.tokenEnd),
      value: this.consumeNumber(types.Percentage)
    };
  }
  function generate(node) {
    this.token(types.Percentage, node.value + "%");
  }
  exports.generate = generate;
  exports.name = name;
  exports.parse = parse;
  exports.structure = structure;
});

// ../../../../node_modules/.bun/css-tree@2.3.1/node_modules/css-tree/cjs/syntax/node/PseudoClassSelector.cjs
var require_PseudoClassSelector = __commonJS((exports) => {
  var types = require_types2();
  var name = "PseudoClassSelector";
  var walkContext = "function";
  var structure = {
    name: String,
    children: [["Raw"], null]
  };
  function parse() {
    const start = this.tokenStart;
    let children = null;
    let name2;
    let nameLowerCase;
    this.eat(types.Colon);
    if (this.tokenType === types.Function) {
      name2 = this.consumeFunctionName();
      nameLowerCase = name2.toLowerCase();
      if (hasOwnProperty.call(this.pseudo, nameLowerCase)) {
        this.skipSC();
        children = this.pseudo[nameLowerCase].call(this);
        this.skipSC();
      } else {
        children = this.createList();
        children.push(this.Raw(this.tokenIndex, null, false));
      }
      this.eat(types.RightParenthesis);
    } else {
      name2 = this.consume(types.Ident);
    }
    return {
      type: "PseudoClassSelector",
      loc: this.getLocation(start, this.tokenStart),
      name: name2,
      children
    };
  }
  function generate(node) {
    this.token(types.Colon, ":");
    if (node.children === null) {
      this.token(types.Ident, node.name);
    } else {
      this.token(types.Function, node.name + "(");
      this.children(node);
      this.token(types.RightParenthesis, ")");
    }
  }
  exports.generate = generate;
  exports.name = name;
  exports.parse = parse;
  exports.structure = structure;
  exports.walkContext = walkContext;
});

// ../../../../node_modules/.bun/css-tree@2.3.1/node_modules/css-tree/cjs/syntax/node/PseudoElementSelector.cjs
var require_PseudoElementSelector = __commonJS((exports) => {
  var types = require_types2();
  var name = "PseudoElementSelector";
  var walkContext = "function";
  var structure = {
    name: String,
    children: [["Raw"], null]
  };
  function parse() {
    const start = this.tokenStart;
    let children = null;
    let name2;
    let nameLowerCase;
    this.eat(types.Colon);
    this.eat(types.Colon);
    if (this.tokenType === types.Function) {
      name2 = this.consumeFunctionName();
      nameLowerCase = name2.toLowerCase();
      if (hasOwnProperty.call(this.pseudo, nameLowerCase)) {
        this.skipSC();
        children = this.pseudo[nameLowerCase].call(this);
        this.skipSC();
      } else {
        children = this.createList();
        children.push(this.Raw(this.tokenIndex, null, false));
      }
      this.eat(types.RightParenthesis);
    } else {
      name2 = this.consume(types.Ident);
    }
    return {
      type: "PseudoElementSelector",
      loc: this.getLocation(start, this.tokenStart),
      name: name2,
      children
    };
  }
  function generate(node) {
    this.token(types.Colon, ":");
    this.token(types.Colon, ":");
    if (node.children === null) {
      this.token(types.Ident, node.name);
    } else {
      this.token(types.Function, node.name + "(");
      this.children(node);
      this.token(types.RightParenthesis, ")");
    }
  }
  exports.generate = generate;
  exports.name = name;
  exports.parse = parse;
  exports.structure = structure;
  exports.walkContext = walkContext;
});

// ../../../../node_modules/.bun/css-tree@2.3.1/node_modules/css-tree/cjs/syntax/node/Ratio.cjs
var require_Ratio = __commonJS((exports) => {
  var types = require_types2();
  var charCodeDefinitions = require_char_code_definitions();
  var SOLIDUS = 47;
  var FULLSTOP = 46;
  function consumeNumber() {
    this.skipSC();
    const value = this.consume(types.Number);
    for (let i = 0;i < value.length; i++) {
      const code = value.charCodeAt(i);
      if (!charCodeDefinitions.isDigit(code) && code !== FULLSTOP) {
        this.error("Unsigned number is expected", this.tokenStart - value.length + i);
      }
    }
    if (Number(value) === 0) {
      this.error("Zero number is not allowed", this.tokenStart - value.length);
    }
    return value;
  }
  var name = "Ratio";
  var structure = {
    left: String,
    right: String
  };
  function parse() {
    const start = this.tokenStart;
    const left = consumeNumber.call(this);
    let right;
    this.skipSC();
    this.eatDelim(SOLIDUS);
    right = consumeNumber.call(this);
    return {
      type: "Ratio",
      loc: this.getLocation(start, this.tokenStart),
      left,
      right
    };
  }
  function generate(node) {
    this.token(types.Number, node.left);
    this.token(types.Delim, "/");
    this.token(types.Number, node.right);
  }
  exports.generate = generate;
  exports.name = name;
  exports.parse = parse;
  exports.structure = structure;
});

// ../../../../node_modules/.bun/css-tree@2.3.1/node_modules/css-tree/cjs/syntax/node/Raw.cjs
var require_Raw = __commonJS((exports) => {
  var types = require_types2();
  function getOffsetExcludeWS() {
    if (this.tokenIndex > 0) {
      if (this.lookupType(-1) === types.WhiteSpace) {
        return this.tokenIndex > 1 ? this.getTokenStart(this.tokenIndex - 1) : this.firstCharOffset;
      }
    }
    return this.tokenStart;
  }
  var name = "Raw";
  var structure = {
    value: String
  };
  function parse(startToken, consumeUntil, excludeWhiteSpace) {
    const startOffset = this.getTokenStart(startToken);
    let endOffset;
    this.skipUntilBalanced(startToken, consumeUntil || this.consumeUntilBalanceEnd);
    if (excludeWhiteSpace && this.tokenStart > startOffset) {
      endOffset = getOffsetExcludeWS.call(this);
    } else {
      endOffset = this.tokenStart;
    }
    return {
      type: "Raw",
      loc: this.getLocation(startOffset, endOffset),
      value: this.substring(startOffset, endOffset)
    };
  }
  function generate(node) {
    this.tokenize(node.value);
  }
  exports.generate = generate;
  exports.name = name;
  exports.parse = parse;
  exports.structure = structure;
});

// ../../../../node_modules/.bun/css-tree@2.3.1/node_modules/css-tree/cjs/syntax/node/Rule.cjs
var require_Rule = __commonJS((exports) => {
  var types = require_types2();
  function consumeRaw(startToken) {
    return this.Raw(startToken, this.consumeUntilLeftCurlyBracket, true);
  }
  function consumePrelude() {
    const prelude = this.SelectorList();
    if (prelude.type !== "Raw" && this.eof === false && this.tokenType !== types.LeftCurlyBracket) {
      this.error();
    }
    return prelude;
  }
  var name = "Rule";
  var walkContext = "rule";
  var structure = {
    prelude: ["SelectorList", "Raw"],
    block: ["Block"]
  };
  function parse() {
    const startToken = this.tokenIndex;
    const startOffset = this.tokenStart;
    let prelude;
    let block;
    if (this.parseRulePrelude) {
      prelude = this.parseWithFallback(consumePrelude, consumeRaw);
    } else {
      prelude = consumeRaw.call(this, startToken);
    }
    block = this.Block(true);
    return {
      type: "Rule",
      loc: this.getLocation(startOffset, this.tokenStart),
      prelude,
      block
    };
  }
  function generate(node) {
    this.node(node.prelude);
    this.node(node.block);
  }
  exports.generate = generate;
  exports.name = name;
  exports.parse = parse;
  exports.structure = structure;
  exports.walkContext = walkContext;
});

// ../../../../node_modules/.bun/css-tree@2.3.1/node_modules/css-tree/cjs/syntax/node/Selector.cjs
var require_Selector = __commonJS((exports) => {
  var name = "Selector";
  var structure = {
    children: [[
      "TypeSelector",
      "IdSelector",
      "ClassSelector",
      "AttributeSelector",
      "PseudoClassSelector",
      "PseudoElementSelector",
      "Combinator",
      "WhiteSpace"
    ]]
  };
  function parse() {
    const children = this.readSequence(this.scope.Selector);
    if (this.getFirstListNode(children) === null) {
      this.error("Selector is expected");
    }
    return {
      type: "Selector",
      loc: this.getLocationFromList(children),
      children
    };
  }
  function generate(node) {
    this.children(node);
  }
  exports.generate = generate;
  exports.name = name;
  exports.parse = parse;
  exports.structure = structure;
});

// ../../../../node_modules/.bun/css-tree@2.3.1/node_modules/css-tree/cjs/syntax/node/SelectorList.cjs
var require_SelectorList = __commonJS((exports) => {
  var types = require_types2();
  var name = "SelectorList";
  var walkContext = "selector";
  var structure = {
    children: [[
      "Selector",
      "Raw"
    ]]
  };
  function parse() {
    const children = this.createList();
    while (!this.eof) {
      children.push(this.Selector());
      if (this.tokenType === types.Comma) {
        this.next();
        continue;
      }
      break;
    }
    return {
      type: "SelectorList",
      loc: this.getLocationFromList(children),
      children
    };
  }
  function generate(node) {
    this.children(node, () => this.token(types.Comma, ","));
  }
  exports.generate = generate;
  exports.name = name;
  exports.parse = parse;
  exports.structure = structure;
  exports.walkContext = walkContext;
});

// ../../../../node_modules/.bun/css-tree@2.3.1/node_modules/css-tree/cjs/utils/string.cjs
var require_string = __commonJS((exports) => {
  var charCodeDefinitions = require_char_code_definitions();
  var utils = require_utils();
  var REVERSE_SOLIDUS = 92;
  var QUOTATION_MARK = 34;
  var APOSTROPHE = 39;
  function decode(str) {
    const len = str.length;
    const firstChar = str.charCodeAt(0);
    const start = firstChar === QUOTATION_MARK || firstChar === APOSTROPHE ? 1 : 0;
    const end = start === 1 && len > 1 && str.charCodeAt(len - 1) === firstChar ? len - 2 : len - 1;
    let decoded = "";
    for (let i = start;i <= end; i++) {
      let code = str.charCodeAt(i);
      if (code === REVERSE_SOLIDUS) {
        if (i === end) {
          if (i !== len - 1) {
            decoded = str.substr(i + 1);
          }
          break;
        }
        code = str.charCodeAt(++i);
        if (charCodeDefinitions.isValidEscape(REVERSE_SOLIDUS, code)) {
          const escapeStart = i - 1;
          const escapeEnd = utils.consumeEscaped(str, escapeStart);
          i = escapeEnd - 1;
          decoded += utils.decodeEscaped(str.substring(escapeStart + 1, escapeEnd));
        } else {
          if (code === 13 && str.charCodeAt(i + 1) === 10) {
            i++;
          }
        }
      } else {
        decoded += str[i];
      }
    }
    return decoded;
  }
  function encode(str, apostrophe) {
    const quote = apostrophe ? "'" : '"';
    const quoteCode = apostrophe ? APOSTROPHE : QUOTATION_MARK;
    let encoded = "";
    let wsBeforeHexIsNeeded = false;
    for (let i = 0;i < str.length; i++) {
      const code = str.charCodeAt(i);
      if (code === 0) {
        encoded += "";
        continue;
      }
      if (code <= 31 || code === 127) {
        encoded += "\\" + code.toString(16);
        wsBeforeHexIsNeeded = true;
        continue;
      }
      if (code === quoteCode || code === REVERSE_SOLIDUS) {
        encoded += "\\" + str.charAt(i);
        wsBeforeHexIsNeeded = false;
      } else {
        if (wsBeforeHexIsNeeded && (charCodeDefinitions.isHexDigit(code) || charCodeDefinitions.isWhiteSpace(code))) {
          encoded += " ";
        }
        encoded += str.charAt(i);
        wsBeforeHexIsNeeded = false;
      }
    }
    return quote + encoded + quote;
  }
  exports.decode = decode;
  exports.encode = encode;
});

// ../../../../node_modules/.bun/css-tree@2.3.1/node_modules/css-tree/cjs/syntax/node/String.cjs
var require_String = __commonJS((exports) => {
  var string = require_string();
  var types = require_types2();
  var name = "String";
  var structure = {
    value: String
  };
  function parse() {
    return {
      type: "String",
      loc: this.getLocation(this.tokenStart, this.tokenEnd),
      value: string.decode(this.consume(types.String))
    };
  }
  function generate(node) {
    this.token(types.String, string.encode(node.value));
  }
  exports.generate = generate;
  exports.name = name;
  exports.parse = parse;
  exports.structure = structure;
});

// ../../../../node_modules/.bun/css-tree@2.3.1/node_modules/css-tree/cjs/syntax/node/StyleSheet.cjs
var require_StyleSheet = __commonJS((exports) => {
  var types = require_types2();
  var EXCLAMATIONMARK = 33;
  function consumeRaw(startToken) {
    return this.Raw(startToken, null, false);
  }
  var name = "StyleSheet";
  var walkContext = "stylesheet";
  var structure = {
    children: [[
      "Comment",
      "CDO",
      "CDC",
      "Atrule",
      "Rule",
      "Raw"
    ]]
  };
  function parse() {
    const start = this.tokenStart;
    const children = this.createList();
    let child;
    while (!this.eof) {
      switch (this.tokenType) {
        case types.WhiteSpace:
          this.next();
          continue;
        case types.Comment:
          if (this.charCodeAt(this.tokenStart + 2) !== EXCLAMATIONMARK) {
            this.next();
            continue;
          }
          child = this.Comment();
          break;
        case types.CDO:
          child = this.CDO();
          break;
        case types.CDC:
          child = this.CDC();
          break;
        case types.AtKeyword:
          child = this.parseWithFallback(this.Atrule, consumeRaw);
          break;
        default:
          child = this.parseWithFallback(this.Rule, consumeRaw);
      }
      children.push(child);
    }
    return {
      type: "StyleSheet",
      loc: this.getLocation(start, this.tokenStart),
      children
    };
  }
  function generate(node) {
    this.children(node);
  }
  exports.generate = generate;
  exports.name = name;
  exports.parse = parse;
  exports.structure = structure;
  exports.walkContext = walkContext;
});

// ../../../../node_modules/.bun/css-tree@2.3.1/node_modules/css-tree/cjs/syntax/node/TypeSelector.cjs
var require_TypeSelector = __commonJS((exports) => {
  var types = require_types2();
  var ASTERISK = 42;
  var VERTICALLINE = 124;
  function eatIdentifierOrAsterisk() {
    if (this.tokenType !== types.Ident && this.isDelim(ASTERISK) === false) {
      this.error("Identifier or asterisk is expected");
    }
    this.next();
  }
  var name = "TypeSelector";
  var structure = {
    name: String
  };
  function parse() {
    const start = this.tokenStart;
    if (this.isDelim(VERTICALLINE)) {
      this.next();
      eatIdentifierOrAsterisk.call(this);
    } else {
      eatIdentifierOrAsterisk.call(this);
      if (this.isDelim(VERTICALLINE)) {
        this.next();
        eatIdentifierOrAsterisk.call(this);
      }
    }
    return {
      type: "TypeSelector",
      loc: this.getLocation(start, this.tokenStart),
      name: this.substrToCursor(start)
    };
  }
  function generate(node) {
    this.tokenize(node.name);
  }
  exports.generate = generate;
  exports.name = name;
  exports.parse = parse;
  exports.structure = structure;
});

// ../../../../node_modules/.bun/css-tree@2.3.1/node_modules/css-tree/cjs/syntax/node/UnicodeRange.cjs
var require_UnicodeRange = __commonJS((exports) => {
  var types = require_types2();
  var charCodeDefinitions = require_char_code_definitions();
  var PLUSSIGN = 43;
  var HYPHENMINUS = 45;
  var QUESTIONMARK = 63;
  function eatHexSequence(offset, allowDash) {
    let len = 0;
    for (let pos = this.tokenStart + offset;pos < this.tokenEnd; pos++) {
      const code = this.charCodeAt(pos);
      if (code === HYPHENMINUS && allowDash && len !== 0) {
        eatHexSequence.call(this, offset + len + 1, false);
        return -1;
      }
      if (!charCodeDefinitions.isHexDigit(code)) {
        this.error(allowDash && len !== 0 ? "Hyphen minus" + (len < 6 ? " or hex digit" : "") + " is expected" : len < 6 ? "Hex digit is expected" : "Unexpected input", pos);
      }
      if (++len > 6) {
        this.error("Too many hex digits", pos);
      }
    }
    this.next();
    return len;
  }
  function eatQuestionMarkSequence(max) {
    let count = 0;
    while (this.isDelim(QUESTIONMARK)) {
      if (++count > max) {
        this.error("Too many question marks");
      }
      this.next();
    }
  }
  function startsWith(code) {
    if (this.charCodeAt(this.tokenStart) !== code) {
      this.error((code === PLUSSIGN ? "Plus sign" : "Hyphen minus") + " is expected");
    }
  }
  function scanUnicodeRange() {
    let hexLength = 0;
    switch (this.tokenType) {
      case types.Number:
        hexLength = eatHexSequence.call(this, 1, true);
        if (this.isDelim(QUESTIONMARK)) {
          eatQuestionMarkSequence.call(this, 6 - hexLength);
          break;
        }
        if (this.tokenType === types.Dimension || this.tokenType === types.Number) {
          startsWith.call(this, HYPHENMINUS);
          eatHexSequence.call(this, 1, false);
          break;
        }
        break;
      case types.Dimension:
        hexLength = eatHexSequence.call(this, 1, true);
        if (hexLength > 0) {
          eatQuestionMarkSequence.call(this, 6 - hexLength);
        }
        break;
      default:
        this.eatDelim(PLUSSIGN);
        if (this.tokenType === types.Ident) {
          hexLength = eatHexSequence.call(this, 0, true);
          if (hexLength > 0) {
            eatQuestionMarkSequence.call(this, 6 - hexLength);
          }
          break;
        }
        if (this.isDelim(QUESTIONMARK)) {
          this.next();
          eatQuestionMarkSequence.call(this, 5);
          break;
        }
        this.error("Hex digit or question mark is expected");
    }
  }
  var name = "UnicodeRange";
  var structure = {
    value: String
  };
  function parse() {
    const start = this.tokenStart;
    this.eatIdent("u");
    scanUnicodeRange.call(this);
    return {
      type: "UnicodeRange",
      loc: this.getLocation(start, this.tokenStart),
      value: this.substrToCursor(start)
    };
  }
  function generate(node) {
    this.tokenize(node.value);
  }
  exports.generate = generate;
  exports.name = name;
  exports.parse = parse;
  exports.structure = structure;
});

// ../../../../node_modules/.bun/css-tree@2.3.1/node_modules/css-tree/cjs/utils/url.cjs
var require_url = __commonJS((exports) => {
  var charCodeDefinitions = require_char_code_definitions();
  var utils = require_utils();
  var SPACE = 32;
  var REVERSE_SOLIDUS = 92;
  var QUOTATION_MARK = 34;
  var APOSTROPHE = 39;
  var LEFTPARENTHESIS = 40;
  var RIGHTPARENTHESIS = 41;
  function decode(str) {
    const len = str.length;
    let start = 4;
    let end = str.charCodeAt(len - 1) === RIGHTPARENTHESIS ? len - 2 : len - 1;
    let decoded = "";
    while (start < end && charCodeDefinitions.isWhiteSpace(str.charCodeAt(start))) {
      start++;
    }
    while (start < end && charCodeDefinitions.isWhiteSpace(str.charCodeAt(end))) {
      end--;
    }
    for (let i = start;i <= end; i++) {
      let code = str.charCodeAt(i);
      if (code === REVERSE_SOLIDUS) {
        if (i === end) {
          if (i !== len - 1) {
            decoded = str.substr(i + 1);
          }
          break;
        }
        code = str.charCodeAt(++i);
        if (charCodeDefinitions.isValidEscape(REVERSE_SOLIDUS, code)) {
          const escapeStart = i - 1;
          const escapeEnd = utils.consumeEscaped(str, escapeStart);
          i = escapeEnd - 1;
          decoded += utils.decodeEscaped(str.substring(escapeStart + 1, escapeEnd));
        } else {
          if (code === 13 && str.charCodeAt(i + 1) === 10) {
            i++;
          }
        }
      } else {
        decoded += str[i];
      }
    }
    return decoded;
  }
  function encode(str) {
    let encoded = "";
    let wsBeforeHexIsNeeded = false;
    for (let i = 0;i < str.length; i++) {
      const code = str.charCodeAt(i);
      if (code === 0) {
        encoded += "";
        continue;
      }
      if (code <= 31 || code === 127) {
        encoded += "\\" + code.toString(16);
        wsBeforeHexIsNeeded = true;
        continue;
      }
      if (code === SPACE || code === REVERSE_SOLIDUS || code === QUOTATION_MARK || code === APOSTROPHE || code === LEFTPARENTHESIS || code === RIGHTPARENTHESIS) {
        encoded += "\\" + str.charAt(i);
        wsBeforeHexIsNeeded = false;
      } else {
        if (wsBeforeHexIsNeeded && charCodeDefinitions.isHexDigit(code)) {
          encoded += " ";
        }
        encoded += str.charAt(i);
        wsBeforeHexIsNeeded = false;
      }
    }
    return "url(" + encoded + ")";
  }
  exports.decode = decode;
  exports.encode = encode;
});

// ../../../../node_modules/.bun/css-tree@2.3.1/node_modules/css-tree/cjs/syntax/node/Url.cjs
var require_Url = __commonJS((exports) => {
  var url = require_url();
  var string = require_string();
  var types = require_types2();
  var name = "Url";
  var structure = {
    value: String
  };
  function parse() {
    const start = this.tokenStart;
    let value;
    switch (this.tokenType) {
      case types.Url:
        value = url.decode(this.consume(types.Url));
        break;
      case types.Function:
        if (!this.cmpStr(this.tokenStart, this.tokenEnd, "url(")) {
          this.error("Function name must be `url`");
        }
        this.eat(types.Function);
        this.skipSC();
        value = string.decode(this.consume(types.String));
        this.skipSC();
        if (!this.eof) {
          this.eat(types.RightParenthesis);
        }
        break;
      default:
        this.error("Url or Function is expected");
    }
    return {
      type: "Url",
      loc: this.getLocation(start, this.tokenStart),
      value
    };
  }
  function generate(node) {
    this.token(types.Url, url.encode(node.value));
  }
  exports.generate = generate;
  exports.name = name;
  exports.parse = parse;
  exports.structure = structure;
});

// ../../../../node_modules/.bun/css-tree@2.3.1/node_modules/css-tree/cjs/syntax/node/Value.cjs
var require_Value = __commonJS((exports) => {
  var name = "Value";
  var structure = {
    children: [[]]
  };
  function parse() {
    const start = this.tokenStart;
    const children = this.readSequence(this.scope.Value);
    return {
      type: "Value",
      loc: this.getLocation(start, this.tokenStart),
      children
    };
  }
  function generate(node) {
    this.children(node);
  }
  exports.generate = generate;
  exports.name = name;
  exports.parse = parse;
  exports.structure = structure;
});

// ../../../../node_modules/.bun/css-tree@2.3.1/node_modules/css-tree/cjs/syntax/node/WhiteSpace.cjs
var require_WhiteSpace = __commonJS((exports) => {
  var types = require_types2();
  var SPACE = Object.freeze({
    type: "WhiteSpace",
    loc: null,
    value: " "
  });
  var name = "WhiteSpace";
  var structure = {
    value: String
  };
  function parse() {
    this.eat(types.WhiteSpace);
    return SPACE;
  }
  function generate(node) {
    this.token(types.WhiteSpace, node.value);
  }
  exports.generate = generate;
  exports.name = name;
  exports.parse = parse;
  exports.structure = structure;
});

// ../../../../node_modules/.bun/css-tree@2.3.1/node_modules/css-tree/cjs/syntax/node/index.cjs
var require_node2 = __commonJS((exports) => {
  var AnPlusB = require_AnPlusB();
  var Atrule = require_Atrule();
  var AtrulePrelude = require_AtrulePrelude();
  var AttributeSelector = require_AttributeSelector();
  var Block = require_Block();
  var Brackets = require_Brackets();
  var CDC = require_CDC();
  var CDO = require_CDO();
  var ClassSelector = require_ClassSelector();
  var Combinator = require_Combinator();
  var Comment = require_Comment();
  var Declaration = require_Declaration();
  var DeclarationList = require_DeclarationList();
  var Dimension = require_Dimension();
  var Function = require_Function();
  var Hash = require_Hash();
  var Identifier = require_Identifier();
  var IdSelector = require_IdSelector();
  var MediaFeature = require_MediaFeature();
  var MediaQuery = require_MediaQuery();
  var MediaQueryList = require_MediaQueryList();
  var NestingSelector = require_NestingSelector();
  var Nth = require_Nth();
  var Number$1 = require_Number();
  var Operator = require_Operator();
  var Parentheses = require_Parentheses();
  var Percentage = require_Percentage();
  var PseudoClassSelector = require_PseudoClassSelector();
  var PseudoElementSelector = require_PseudoElementSelector();
  var Ratio = require_Ratio();
  var Raw = require_Raw();
  var Rule = require_Rule();
  var Selector = require_Selector();
  var SelectorList = require_SelectorList();
  var String$1 = require_String();
  var StyleSheet = require_StyleSheet();
  var TypeSelector = require_TypeSelector();
  var UnicodeRange = require_UnicodeRange();
  var Url = require_Url();
  var Value = require_Value();
  var WhiteSpace = require_WhiteSpace();
  exports.AnPlusB = AnPlusB;
  exports.Atrule = Atrule;
  exports.AtrulePrelude = AtrulePrelude;
  exports.AttributeSelector = AttributeSelector;
  exports.Block = Block;
  exports.Brackets = Brackets;
  exports.CDC = CDC;
  exports.CDO = CDO;
  exports.ClassSelector = ClassSelector;
  exports.Combinator = Combinator;
  exports.Comment = Comment;
  exports.Declaration = Declaration;
  exports.DeclarationList = DeclarationList;
  exports.Dimension = Dimension;
  exports.Function = Function;
  exports.Hash = Hash;
  exports.Identifier = Identifier;
  exports.IdSelector = IdSelector;
  exports.MediaFeature = MediaFeature;
  exports.MediaQuery = MediaQuery;
  exports.MediaQueryList = MediaQueryList;
  exports.NestingSelector = NestingSelector;
  exports.Nth = Nth;
  exports.Number = Number$1;
  exports.Operator = Operator;
  exports.Parentheses = Parentheses;
  exports.Percentage = Percentage;
  exports.PseudoClassSelector = PseudoClassSelector;
  exports.PseudoElementSelector = PseudoElementSelector;
  exports.Ratio = Ratio;
  exports.Raw = Raw;
  exports.Rule = Rule;
  exports.Selector = Selector;
  exports.SelectorList = SelectorList;
  exports.String = String$1;
  exports.StyleSheet = StyleSheet;
  exports.TypeSelector = TypeSelector;
  exports.UnicodeRange = UnicodeRange;
  exports.Url = Url;
  exports.Value = Value;
  exports.WhiteSpace = WhiteSpace;
});

// ../../../../node_modules/.bun/css-tree@2.3.1/node_modules/css-tree/cjs/syntax/config/lexer.cjs
var require_lexer = __commonJS((exports, module) => {
  var data = require_data();
  var index = require_node2();
  var lexerConfig = {
    generic: true,
    ...data,
    node: index
  };
  module.exports = lexerConfig;
});

// ../../../../node_modules/.bun/css-tree@2.3.1/node_modules/css-tree/cjs/syntax/scope/default.cjs
var require_default = __commonJS((exports, module) => {
  var types = require_types2();
  var NUMBERSIGN = 35;
  var ASTERISK = 42;
  var PLUSSIGN = 43;
  var HYPHENMINUS = 45;
  var SOLIDUS = 47;
  var U = 117;
  function defaultRecognizer(context) {
    switch (this.tokenType) {
      case types.Hash:
        return this.Hash();
      case types.Comma:
        return this.Operator();
      case types.LeftParenthesis:
        return this.Parentheses(this.readSequence, context.recognizer);
      case types.LeftSquareBracket:
        return this.Brackets(this.readSequence, context.recognizer);
      case types.String:
        return this.String();
      case types.Dimension:
        return this.Dimension();
      case types.Percentage:
        return this.Percentage();
      case types.Number:
        return this.Number();
      case types.Function:
        return this.cmpStr(this.tokenStart, this.tokenEnd, "url(") ? this.Url() : this.Function(this.readSequence, context.recognizer);
      case types.Url:
        return this.Url();
      case types.Ident:
        if (this.cmpChar(this.tokenStart, U) && this.cmpChar(this.tokenStart + 1, PLUSSIGN)) {
          return this.UnicodeRange();
        } else {
          return this.Identifier();
        }
      case types.Delim: {
        const code = this.charCodeAt(this.tokenStart);
        if (code === SOLIDUS || code === ASTERISK || code === PLUSSIGN || code === HYPHENMINUS) {
          return this.Operator();
        }
        if (code === NUMBERSIGN) {
          this.error("Hex or identifier is expected", this.tokenStart + 1);
        }
        break;
      }
    }
  }
  module.exports = defaultRecognizer;
});

// ../../../../node_modules/.bun/css-tree@2.3.1/node_modules/css-tree/cjs/syntax/scope/atrulePrelude.cjs
var require_atrulePrelude = __commonJS((exports, module) => {
  var _default = require_default();
  var atrulePrelude = {
    getNode: _default
  };
  module.exports = atrulePrelude;
});

// ../../../../node_modules/.bun/css-tree@2.3.1/node_modules/css-tree/cjs/syntax/scope/selector.cjs
var require_selector = __commonJS((exports, module) => {
  var types = require_types2();
  var NUMBERSIGN = 35;
  var AMPERSAND = 38;
  var ASTERISK = 42;
  var PLUSSIGN = 43;
  var SOLIDUS = 47;
  var FULLSTOP = 46;
  var GREATERTHANSIGN = 62;
  var VERTICALLINE = 124;
  var TILDE = 126;
  function onWhiteSpace(next, children) {
    if (children.last !== null && children.last.type !== "Combinator" && next !== null && next.type !== "Combinator") {
      children.push({
        type: "Combinator",
        loc: null,
        name: " "
      });
    }
  }
  function getNode() {
    switch (this.tokenType) {
      case types.LeftSquareBracket:
        return this.AttributeSelector();
      case types.Hash:
        return this.IdSelector();
      case types.Colon:
        if (this.lookupType(1) === types.Colon) {
          return this.PseudoElementSelector();
        } else {
          return this.PseudoClassSelector();
        }
      case types.Ident:
        return this.TypeSelector();
      case types.Number:
      case types.Percentage:
        return this.Percentage();
      case types.Dimension:
        if (this.charCodeAt(this.tokenStart) === FULLSTOP) {
          this.error("Identifier is expected", this.tokenStart + 1);
        }
        break;
      case types.Delim: {
        const code = this.charCodeAt(this.tokenStart);
        switch (code) {
          case PLUSSIGN:
          case GREATERTHANSIGN:
          case TILDE:
          case SOLIDUS:
            return this.Combinator();
          case FULLSTOP:
            return this.ClassSelector();
          case ASTERISK:
          case VERTICALLINE:
            return this.TypeSelector();
          case NUMBERSIGN:
            return this.IdSelector();
          case AMPERSAND:
            return this.NestingSelector();
        }
        break;
      }
    }
  }
  var Selector = {
    onWhiteSpace,
    getNode
  };
  module.exports = Selector;
});

// ../../../../node_modules/.bun/css-tree@2.3.1/node_modules/css-tree/cjs/syntax/function/expression.cjs
var require_expression = __commonJS((exports, module) => {
  function expressionFn() {
    return this.createSingleNodeList(this.Raw(this.tokenIndex, null, false));
  }
  module.exports = expressionFn;
});

// ../../../../node_modules/.bun/css-tree@2.3.1/node_modules/css-tree/cjs/syntax/function/var.cjs
var require_var = __commonJS((exports, module) => {
  var types = require_types2();
  function varFn() {
    const children = this.createList();
    this.skipSC();
    children.push(this.Identifier());
    this.skipSC();
    if (this.tokenType === types.Comma) {
      children.push(this.Operator());
      const startIndex = this.tokenIndex;
      const value = this.parseCustomProperty ? this.Value(null) : this.Raw(this.tokenIndex, this.consumeUntilExclamationMarkOrSemicolon, false);
      if (value.type === "Value" && value.children.isEmpty) {
        for (let offset = startIndex - this.tokenIndex;offset <= 0; offset++) {
          if (this.lookupType(offset) === types.WhiteSpace) {
            value.children.appendData({
              type: "WhiteSpace",
              loc: null,
              value: " "
            });
            break;
          }
        }
      }
      children.push(value);
    }
    return children;
  }
  module.exports = varFn;
});

// ../../../../node_modules/.bun/css-tree@2.3.1/node_modules/css-tree/cjs/syntax/scope/value.cjs
var require_value = __commonJS((exports, module) => {
  var _default = require_default();
  var expression = require_expression();
  var _var = require_var();
  function isPlusMinusOperator(node) {
    return node !== null && node.type === "Operator" && (node.value[node.value.length - 1] === "-" || node.value[node.value.length - 1] === "+");
  }
  var value = {
    getNode: _default,
    onWhiteSpace(next, children) {
      if (isPlusMinusOperator(next)) {
        next.value = " " + next.value;
      }
      if (isPlusMinusOperator(children.last)) {
        children.last.value += " ";
      }
    },
    expression,
    var: _var
  };
  module.exports = value;
});

// ../../../../node_modules/.bun/css-tree@2.3.1/node_modules/css-tree/cjs/syntax/scope/index.cjs
var require_scope = __commonJS((exports) => {
  var atrulePrelude = require_atrulePrelude();
  var selector = require_selector();
  var value = require_value();
  exports.AtrulePrelude = atrulePrelude;
  exports.Selector = selector;
  exports.Value = value;
});

// ../../../../node_modules/.bun/css-tree@2.3.1/node_modules/css-tree/cjs/syntax/atrule/font-face.cjs
var require_font_face = __commonJS((exports, module) => {
  var fontFace = {
    parse: {
      prelude: null,
      block() {
        return this.Block(true);
      }
    }
  };
  module.exports = fontFace;
});

// ../../../../node_modules/.bun/css-tree@2.3.1/node_modules/css-tree/cjs/syntax/atrule/import.cjs
var require_import = __commonJS((exports, module) => {
  var types = require_types2();
  var importAtrule = {
    parse: {
      prelude() {
        const children = this.createList();
        this.skipSC();
        switch (this.tokenType) {
          case types.String:
            children.push(this.String());
            break;
          case types.Url:
          case types.Function:
            children.push(this.Url());
            break;
          default:
            this.error("String or url() is expected");
        }
        if (this.lookupNonWSType(0) === types.Ident || this.lookupNonWSType(0) === types.LeftParenthesis) {
          children.push(this.MediaQueryList());
        }
        return children;
      },
      block: null
    }
  };
  module.exports = importAtrule;
});

// ../../../../node_modules/.bun/css-tree@2.3.1/node_modules/css-tree/cjs/syntax/atrule/media.cjs
var require_media = __commonJS((exports, module) => {
  var media = {
    parse: {
      prelude() {
        return this.createSingleNodeList(this.MediaQueryList());
      },
      block(isStyleBlock = false) {
        return this.Block(isStyleBlock);
      }
    }
  };
  module.exports = media;
});

// ../../../../node_modules/.bun/css-tree@2.3.1/node_modules/css-tree/cjs/syntax/atrule/nest.cjs
var require_nest = __commonJS((exports, module) => {
  var nest = {
    parse: {
      prelude() {
        return this.createSingleNodeList(this.SelectorList());
      },
      block() {
        return this.Block(true);
      }
    }
  };
  module.exports = nest;
});

// ../../../../node_modules/.bun/css-tree@2.3.1/node_modules/css-tree/cjs/syntax/atrule/page.cjs
var require_page = __commonJS((exports, module) => {
  var page = {
    parse: {
      prelude() {
        return this.createSingleNodeList(this.SelectorList());
      },
      block() {
        return this.Block(true);
      }
    }
  };
  module.exports = page;
});

// ../../../../node_modules/.bun/css-tree@2.3.1/node_modules/css-tree/cjs/syntax/atrule/supports.cjs
var require_supports = __commonJS((exports, module) => {
  var types = require_types2();
  function consumeRaw() {
    return this.createSingleNodeList(this.Raw(this.tokenIndex, null, false));
  }
  function parentheses() {
    this.skipSC();
    if (this.tokenType === types.Ident && this.lookupNonWSType(1) === types.Colon) {
      return this.createSingleNodeList(this.Declaration());
    }
    return readSequence.call(this);
  }
  function readSequence() {
    const children = this.createList();
    let child;
    this.skipSC();
    scan:
      while (!this.eof) {
        switch (this.tokenType) {
          case types.Comment:
          case types.WhiteSpace:
            this.next();
            continue;
          case types.Function:
            child = this.Function(consumeRaw, this.scope.AtrulePrelude);
            break;
          case types.Ident:
            child = this.Identifier();
            break;
          case types.LeftParenthesis:
            child = this.Parentheses(parentheses, this.scope.AtrulePrelude);
            break;
          default:
            break scan;
        }
        children.push(child);
      }
    return children;
  }
  var supports = {
    parse: {
      prelude() {
        const children = readSequence.call(this);
        if (this.getFirstListNode(children) === null) {
          this.error("Condition is expected");
        }
        return children;
      },
      block(isStyleBlock = false) {
        return this.Block(isStyleBlock);
      }
    }
  };
  module.exports = supports;
});

// ../../../../node_modules/.bun/css-tree@2.3.1/node_modules/css-tree/cjs/syntax/atrule/index.cjs
var require_atrule = __commonJS((exports, module) => {
  var fontFace = require_font_face();
  var _import = require_import();
  var media = require_media();
  var nest = require_nest();
  var page = require_page();
  var supports = require_supports();
  var atrule = {
    "font-face": fontFace,
    import: _import,
    media,
    nest,
    page,
    supports
  };
  module.exports = atrule;
});

// ../../../../node_modules/.bun/css-tree@2.3.1/node_modules/css-tree/cjs/syntax/pseudo/index.cjs
var require_pseudo = __commonJS((exports, module) => {
  var selectorList = {
    parse() {
      return this.createSingleNodeList(this.SelectorList());
    }
  };
  var selector = {
    parse() {
      return this.createSingleNodeList(this.Selector());
    }
  };
  var identList = {
    parse() {
      return this.createSingleNodeList(this.Identifier());
    }
  };
  var nth = {
    parse() {
      return this.createSingleNodeList(this.Nth());
    }
  };
  var pseudo = {
    dir: identList,
    has: selectorList,
    lang: identList,
    matches: selectorList,
    is: selectorList,
    "-moz-any": selectorList,
    "-webkit-any": selectorList,
    where: selectorList,
    not: selectorList,
    "nth-child": nth,
    "nth-last-child": nth,
    "nth-last-of-type": nth,
    "nth-of-type": nth,
    slotted: selector,
    host: selector,
    "host-context": selector
  };
  module.exports = pseudo;
});

// ../../../../node_modules/.bun/css-tree@2.3.1/node_modules/css-tree/cjs/syntax/node/index-parse.cjs
var require_index_parse = __commonJS((exports) => {
  var AnPlusB = require_AnPlusB();
  var Atrule = require_Atrule();
  var AtrulePrelude = require_AtrulePrelude();
  var AttributeSelector = require_AttributeSelector();
  var Block = require_Block();
  var Brackets = require_Brackets();
  var CDC = require_CDC();
  var CDO = require_CDO();
  var ClassSelector = require_ClassSelector();
  var Combinator = require_Combinator();
  var Comment = require_Comment();
  var Declaration = require_Declaration();
  var DeclarationList = require_DeclarationList();
  var Dimension = require_Dimension();
  var Function = require_Function();
  var Hash = require_Hash();
  var Identifier = require_Identifier();
  var IdSelector = require_IdSelector();
  var MediaFeature = require_MediaFeature();
  var MediaQuery = require_MediaQuery();
  var MediaQueryList = require_MediaQueryList();
  var NestingSelector = require_NestingSelector();
  var Nth = require_Nth();
  var Number2 = require_Number();
  var Operator = require_Operator();
  var Parentheses = require_Parentheses();
  var Percentage = require_Percentage();
  var PseudoClassSelector = require_PseudoClassSelector();
  var PseudoElementSelector = require_PseudoElementSelector();
  var Ratio = require_Ratio();
  var Raw = require_Raw();
  var Rule = require_Rule();
  var Selector = require_Selector();
  var SelectorList = require_SelectorList();
  var String2 = require_String();
  var StyleSheet = require_StyleSheet();
  var TypeSelector = require_TypeSelector();
  var UnicodeRange = require_UnicodeRange();
  var Url = require_Url();
  var Value = require_Value();
  var WhiteSpace = require_WhiteSpace();
  exports.AnPlusB = AnPlusB.parse;
  exports.Atrule = Atrule.parse;
  exports.AtrulePrelude = AtrulePrelude.parse;
  exports.AttributeSelector = AttributeSelector.parse;
  exports.Block = Block.parse;
  exports.Brackets = Brackets.parse;
  exports.CDC = CDC.parse;
  exports.CDO = CDO.parse;
  exports.ClassSelector = ClassSelector.parse;
  exports.Combinator = Combinator.parse;
  exports.Comment = Comment.parse;
  exports.Declaration = Declaration.parse;
  exports.DeclarationList = DeclarationList.parse;
  exports.Dimension = Dimension.parse;
  exports.Function = Function.parse;
  exports.Hash = Hash.parse;
  exports.Identifier = Identifier.parse;
  exports.IdSelector = IdSelector.parse;
  exports.MediaFeature = MediaFeature.parse;
  exports.MediaQuery = MediaQuery.parse;
  exports.MediaQueryList = MediaQueryList.parse;
  exports.NestingSelector = NestingSelector.parse;
  exports.Nth = Nth.parse;
  exports.Number = Number2.parse;
  exports.Operator = Operator.parse;
  exports.Parentheses = Parentheses.parse;
  exports.Percentage = Percentage.parse;
  exports.PseudoClassSelector = PseudoClassSelector.parse;
  exports.PseudoElementSelector = PseudoElementSelector.parse;
  exports.Ratio = Ratio.parse;
  exports.Raw = Raw.parse;
  exports.Rule = Rule.parse;
  exports.Selector = Selector.parse;
  exports.SelectorList = SelectorList.parse;
  exports.String = String2.parse;
  exports.StyleSheet = StyleSheet.parse;
  exports.TypeSelector = TypeSelector.parse;
  exports.UnicodeRange = UnicodeRange.parse;
  exports.Url = Url.parse;
  exports.Value = Value.parse;
  exports.WhiteSpace = WhiteSpace.parse;
});

// ../../../../node_modules/.bun/css-tree@2.3.1/node_modules/css-tree/cjs/syntax/config/parser.cjs
var require_parser2 = __commonJS((exports, module) => {
  var index = require_scope();
  var index$1 = require_atrule();
  var index$2 = require_pseudo();
  var indexParse = require_index_parse();
  var config = {
    parseContext: {
      default: "StyleSheet",
      stylesheet: "StyleSheet",
      atrule: "Atrule",
      atrulePrelude(options) {
        return this.AtrulePrelude(options.atrule ? String(options.atrule) : null);
      },
      mediaQueryList: "MediaQueryList",
      mediaQuery: "MediaQuery",
      rule: "Rule",
      selectorList: "SelectorList",
      selector: "Selector",
      block() {
        return this.Block(true);
      },
      declarationList: "DeclarationList",
      declaration: "Declaration",
      value: "Value"
    },
    scope: index,
    atrule: index$1,
    pseudo: index$2,
    node: indexParse
  };
  module.exports = config;
});

// ../../../../node_modules/.bun/css-tree@2.3.1/node_modules/css-tree/cjs/syntax/config/walker.cjs
var require_walker = __commonJS((exports, module) => {
  var index = require_node2();
  var config = {
    node: index
  };
  module.exports = config;
});

// ../../../../node_modules/.bun/css-tree@2.3.1/node_modules/css-tree/cjs/syntax/index.cjs
var require_syntax = __commonJS((exports, module) => {
  var create = require_create5();
  var lexer = require_lexer();
  var parser = require_parser2();
  var walker = require_walker();
  var syntax = create({
    ...lexer,
    ...parser,
    ...walker
  });
  module.exports = syntax;
});

// ../../../../node_modules/.bun/css-tree@2.3.1/node_modules/css-tree/package.json
var require_package = __commonJS((exports, module) => {
  module.exports = {
    name: "css-tree",
    version: "2.3.1",
    description: "A tool set for CSS: fast detailed parser (CSS  AST), walker (AST traversal), generator (AST  CSS) and lexer (validation and matching) based on specs and browser implementations",
    author: "Roman Dvornov <rdvornov@gmail.com> (https://github.com/lahmatiy)",
    license: "MIT",
    repository: "csstree/csstree",
    keywords: [
      "css",
      "ast",
      "tokenizer",
      "parser",
      "walker",
      "lexer",
      "generator",
      "utils",
      "syntax",
      "validation"
    ],
    type: "module",
    module: "./lib/index.js",
    main: "./cjs/index.cjs",
    exports: {
      ".": {
        import: "./lib/index.js",
        require: "./cjs/index.cjs"
      },
      "./dist/*": "./dist/*.js",
      "./package.json": "./package.json",
      "./tokenizer": {
        import: "./lib/tokenizer/index.js",
        require: "./cjs/tokenizer/index.cjs"
      },
      "./parser": {
        import: "./lib/parser/index.js",
        require: "./cjs/parser/index.cjs"
      },
      "./selector-parser": {
        import: "./lib/parser/parse-selector.js",
        require: "./cjs/parser/parse-selector.cjs"
      },
      "./generator": {
        import: "./lib/generator/index.js",
        require: "./cjs/generator/index.cjs"
      },
      "./walker": {
        import: "./lib/walker/index.js",
        require: "./cjs/walker/index.cjs"
      },
      "./convertor": {
        import: "./lib/convertor/index.js",
        require: "./cjs/convertor/index.cjs"
      },
      "./lexer": {
        import: "./lib/lexer/index.js",
        require: "./cjs/lexer/index.cjs"
      },
      "./definition-syntax": {
        import: "./lib/definition-syntax/index.js",
        require: "./cjs/definition-syntax/index.cjs"
      },
      "./definition-syntax-data": {
        import: "./lib/data.js",
        require: "./cjs/data.cjs"
      },
      "./definition-syntax-data-patch": {
        import: "./lib/data-patch.js",
        require: "./cjs/data-patch.cjs"
      },
      "./utils": {
        import: "./lib/utils/index.js",
        require: "./cjs/utils/index.cjs"
      }
    },
    browser: {
      "./cjs/data.cjs": "./dist/data.cjs",
      "./cjs/version.cjs": "./dist/version.cjs",
      "./lib/data.js": "./dist/data.js",
      "./lib/version.js": "./dist/version.js"
    },
    unpkg: "dist/csstree.esm.js",
    jsdelivr: "dist/csstree.esm.js",
    scripts: {
      watch: "npm run build -- --watch",
      build: "npm run bundle && npm run esm-to-cjs --",
      "build-and-test": "npm run build && npm run test:dist && npm run test:cjs",
      bundle: "node scripts/bundle",
      "bundle-and-test": "npm run bundle && npm run test:dist",
      "esm-to-cjs": "node scripts/esm-to-cjs.cjs",
      "esm-to-cjs-and-test": "npm run esm-to-cjs && npm run test:cjs",
      lint: "eslint lib scripts && node scripts/review-syntax-patch --lint && node scripts/update-docs --lint",
      "lint-and-test": "npm run lint && npm test",
      "update:docs": "node scripts/update-docs",
      "review:syntax-patch": "node scripts/review-syntax-patch",
      test: "mocha lib/__tests --reporter ${REPORTER:-progress}",
      "test:cjs": "mocha cjs/__tests --reporter ${REPORTER:-progress}",
      "test:dist": "mocha dist/__tests --reporter ${REPORTER:-progress}",
      coverage: "c8 --exclude lib/__tests --reporter=lcovonly npm test",
      prepublishOnly: "npm run lint-and-test && npm run build-and-test",
      hydrogen: "node --trace-hydrogen --trace-phase=Z --trace-deopt --code-comments --hydrogen-track-positions --redirect-code-traces --redirect-code-traces-to=code.asm --trace_hydrogen_file=code.cfg --print-opt-code bin/parse --stat -o /dev/null"
    },
    dependencies: {
      "mdn-data": "2.0.30",
      "source-map-js": "^1.0.1"
    },
    devDependencies: {
      c8: "^7.12.0",
      clap: "^2.0.1",
      esbuild: "^0.14.53",
      eslint: "^8.4.1",
      "json-to-ast": "^2.1.0",
      mocha: "^9.2.2",
      rollup: "^2.68.0"
    },
    engines: {
      node: "^10 || ^12.20.0 || ^14.13.0 || >=15.0.0"
    },
    files: [
      "data",
      "dist",
      "cjs",
      "!cjs/__tests",
      "lib",
      "!lib/__tests"
    ]
  };
});

// ../../../../node_modules/.bun/css-tree@2.3.1/node_modules/css-tree/cjs/version.cjs
var require_version = __commonJS((exports) => {
  var { version } = require_package();
  exports.version = version;
});

// ../../../../node_modules/.bun/css-tree@2.3.1/node_modules/css-tree/cjs/definition-syntax/index.cjs
var require_definition_syntax = __commonJS((exports) => {
  var SyntaxError2 = require_SyntaxError2();
  var generate = require_generate();
  var parse = require_parse3();
  var walk = require_walk();
  exports.SyntaxError = SyntaxError2.SyntaxError;
  exports.generate = generate.generate;
  exports.parse = parse.parse;
  exports.walk = walk.walk;
});

// ../../../../node_modules/.bun/css-tree@2.3.1/node_modules/css-tree/cjs/utils/clone.cjs
var require_clone = __commonJS((exports) => {
  var List = require_List();
  function clone(node) {
    const result = {};
    for (const key in node) {
      let value = node[key];
      if (value) {
        if (Array.isArray(value) || value instanceof List.List) {
          value = value.map(clone);
        } else if (value.constructor === Object) {
          value = clone(value);
        }
      }
      result[key] = value;
    }
    return result;
  }
  exports.clone = clone;
});

// ../../../../node_modules/.bun/css-tree@2.3.1/node_modules/css-tree/cjs/utils/ident.cjs
var require_ident = __commonJS((exports) => {
  var charCodeDefinitions = require_char_code_definitions();
  var utils = require_utils();
  var REVERSE_SOLIDUS = 92;
  function decode(str) {
    const end = str.length - 1;
    let decoded = "";
    for (let i = 0;i < str.length; i++) {
      let code = str.charCodeAt(i);
      if (code === REVERSE_SOLIDUS) {
        if (i === end) {
          break;
        }
        code = str.charCodeAt(++i);
        if (charCodeDefinitions.isValidEscape(REVERSE_SOLIDUS, code)) {
          const escapeStart = i - 1;
          const escapeEnd = utils.consumeEscaped(str, escapeStart);
          i = escapeEnd - 1;
          decoded += utils.decodeEscaped(str.substring(escapeStart + 1, escapeEnd));
        } else {
          if (code === 13 && str.charCodeAt(i + 1) === 10) {
            i++;
          }
        }
      } else {
        decoded += str[i];
      }
    }
    return decoded;
  }
  function encode(str) {
    let encoded = "";
    if (str.length === 1 && str.charCodeAt(0) === 45) {
      return "\\-";
    }
    for (let i = 0;i < str.length; i++) {
      const code = str.charCodeAt(i);
      if (code === 0) {
        encoded += "";
        continue;
      }
      if (code <= 31 || code === 127 || code >= 48 && code <= 57 && (i === 0 || i === 1 && str.charCodeAt(0) === 45)) {
        encoded += "\\" + code.toString(16) + " ";
        continue;
      }
      if (charCodeDefinitions.isName(code)) {
        encoded += str.charAt(i);
      } else {
        encoded += "\\" + str.charAt(i);
      }
    }
    return encoded;
  }
  exports.decode = decode;
  exports.encode = encode;
});

// ../../../../node_modules/.bun/css-tree@2.3.1/node_modules/css-tree/cjs/index.cjs
var require_cjs = __commonJS((exports) => {
  var index$1 = require_syntax();
  var version = require_version();
  var create = require_create5();
  var List = require_List();
  var Lexer = require_Lexer();
  var index = require_definition_syntax();
  var clone = require_clone();
  var names$1 = require_names2();
  var ident = require_ident();
  var string = require_string();
  var url = require_url();
  var types = require_types2();
  var names = require_names();
  var TokenStream = require_TokenStream();
  var {
    tokenize,
    parse,
    generate,
    lexer,
    createLexer,
    walk,
    find,
    findLast,
    findAll,
    toPlainObject,
    fromPlainObject,
    fork
  } = index$1;
  exports.version = version.version;
  exports.createSyntax = create;
  exports.List = List.List;
  exports.Lexer = Lexer.Lexer;
  exports.definitionSyntax = index;
  exports.clone = clone.clone;
  exports.isCustomProperty = names$1.isCustomProperty;
  exports.keyword = names$1.keyword;
  exports.property = names$1.property;
  exports.vendorPrefix = names$1.vendorPrefix;
  exports.ident = ident;
  exports.string = string;
  exports.url = url;
  exports.tokenTypes = types;
  exports.tokenNames = names;
  exports.TokenStream = TokenStream.TokenStream;
  exports.createLexer = createLexer;
  exports.find = find;
  exports.findAll = findAll;
  exports.findLast = findLast;
  exports.fork = fork;
  exports.fromPlainObject = fromPlainObject;
  exports.generate = generate;
  exports.lexer = lexer;
  exports.parse = parse;
  exports.toPlainObject = toPlainObject;
  exports.tokenize = tokenize;
  exports.walk = walk;
});

// ../../../../node_modules/.bun/csso@5.0.5/node_modules/csso/package.json
var require_package2 = __commonJS((exports, module) => {
  module.exports = {
    name: "csso",
    version: "5.0.5",
    description: "CSS minifier with structural optimisations",
    author: "Sergey Kryzhanovsky <skryzhanovsky@ya.ru> (https://github.com/afelix)",
    maintainers: [
      {
        name: "Roman Dvornov",
        email: "rdvornov@gmail.com",
        "github-username": "lahmatiy"
      }
    ],
    repository: "css/csso",
    license: "MIT",
    keywords: [
      "css",
      "compress",
      "minifier",
      "minify",
      "optimise",
      "optimisation",
      "csstree"
    ],
    type: "module",
    unpkg: "dist/csso.esm.js",
    jsdelivr: "dist/csso.esm.js",
    browser: {
      "./cjs/version.cjs": "./dist/version.cjs",
      "./lib/version.js": "./dist/version.js"
    },
    main: "./cjs/index.cjs",
    module: "./lib/index.js",
    exports: {
      ".": {
        import: "./lib/index.js",
        require: "./cjs/index.cjs"
      },
      "./syntax": {
        import: "./lib/syntax.js",
        require: "./cjs/syntax.cjs"
      },
      "./dist/*": "./dist/*.js",
      "./package.json": "./package.json"
    },
    scripts: {
      test: "mocha test --reporter ${REPORTER:-progress}",
      "test:cjs": "mocha cjs-test --reporter ${REPORTER:-progress}",
      "test:dist": "mocha dist/test --reporter ${REPORTER:-progress}",
      lint: "eslint lib scripts test",
      "lint-and-test": "npm run lint && npm test",
      build: "npm run bundle && npm run esm-to-cjs",
      "build-and-test": "npm run build && npm run test:dist && npm run test:cjs",
      bundle: "node scripts/bundle",
      "bundle-and-test": "npm run bundle && npm run test:dist",
      "esm-to-cjs": "node scripts/esm-to-cjs.cjs",
      "esm-to-cjs-and-test": "npm run esm-to-cjs && npm run test:cjs",
      coverage: "c8 --reporter=lcovonly npm test",
      prepublishOnly: "npm run lint-and-test && npm run build-and-test",
      hydrogen: "node --trace-hydrogen --trace-phase=Z --trace-deopt --code-comments --hydrogen-track-positions --redirect-code-traces --redirect-code-traces-to=code.asm --trace_hydrogen_file=code.cfg --print-opt-code bin/csso --stat -o /dev/null"
    },
    dependencies: {
      "css-tree": "~2.2.0"
    },
    devDependencies: {
      c8: "^7.10.0",
      esbuild: "^0.14.54",
      eslint: "^7.24.0",
      mocha: "^9.2.2",
      rollup: "^2.60.2",
      "source-map-js": "^1.0.1"
    },
    engines: {
      node: "^10 || ^12.20.0 || ^14.13.0 || >=15.0.0",
      npm: ">=7.0.0"
    },
    files: [
      "dist",
      "!dist/test",
      "cjs",
      "lib"
    ]
  };
});

// ../../../../node_modules/.bun/csso@5.0.5/node_modules/csso/cjs/version.cjs
var require_version2 = __commonJS((exports) => {
  var { version } = require_package2();
  exports.version = version;
});

// ../../../../node_modules/.bun/css-tree@2.2.1/node_modules/css-tree/cjs/tokenizer/types.cjs
var require_types3 = __commonJS((exports) => {
  var EOF = 0;
  var Ident = 1;
  var Function = 2;
  var AtKeyword = 3;
  var Hash = 4;
  var String2 = 5;
  var BadString = 6;
  var Url = 7;
  var BadUrl = 8;
  var Delim = 9;
  var Number2 = 10;
  var Percentage = 11;
  var Dimension = 12;
  var WhiteSpace = 13;
  var CDO = 14;
  var CDC = 15;
  var Colon = 16;
  var Semicolon = 17;
  var Comma = 18;
  var LeftSquareBracket = 19;
  var RightSquareBracket = 20;
  var LeftParenthesis = 21;
  var RightParenthesis = 22;
  var LeftCurlyBracket = 23;
  var RightCurlyBracket = 24;
  var Comment = 25;
  exports.AtKeyword = AtKeyword;
  exports.BadString = BadString;
  exports.BadUrl = BadUrl;
  exports.CDC = CDC;
  exports.CDO = CDO;
  exports.Colon = Colon;
  exports.Comma = Comma;
  exports.Comment = Comment;
  exports.Delim = Delim;
  exports.Dimension = Dimension;
  exports.EOF = EOF;
  exports.Function = Function;
  exports.Hash = Hash;
  exports.Ident = Ident;
  exports.LeftCurlyBracket = LeftCurlyBracket;
  exports.LeftParenthesis = LeftParenthesis;
  exports.LeftSquareBracket = LeftSquareBracket;
  exports.Number = Number2;
  exports.Percentage = Percentage;
  exports.RightCurlyBracket = RightCurlyBracket;
  exports.RightParenthesis = RightParenthesis;
  exports.RightSquareBracket = RightSquareBracket;
  exports.Semicolon = Semicolon;
  exports.String = String2;
  exports.Url = Url;
  exports.WhiteSpace = WhiteSpace;
});

// ../../../../node_modules/.bun/css-tree@2.2.1/node_modules/css-tree/cjs/tokenizer/char-code-definitions.cjs
var require_char_code_definitions2 = __commonJS((exports) => {
  var EOF = 0;
  function isDigit(code) {
    return code >= 48 && code <= 57;
  }
  function isHexDigit(code) {
    return isDigit(code) || code >= 65 && code <= 70 || code >= 97 && code <= 102;
  }
  function isUppercaseLetter(code) {
    return code >= 65 && code <= 90;
  }
  function isLowercaseLetter(code) {
    return code >= 97 && code <= 122;
  }
  function isLetter(code) {
    return isUppercaseLetter(code) || isLowercaseLetter(code);
  }
  function isNonAscii(code) {
    return code >= 128;
  }
  function isNameStart(code) {
    return isLetter(code) || isNonAscii(code) || code === 95;
  }
  function isName(code) {
    return isNameStart(code) || isDigit(code) || code === 45;
  }
  function isNonPrintable(code) {
    return code >= 0 && code <= 8 || code === 11 || code >= 14 && code <= 31 || code === 127;
  }
  function isNewline(code) {
    return code === 10 || code === 13 || code === 12;
  }
  function isWhiteSpace(code) {
    return isNewline(code) || code === 32 || code === 9;
  }
  function isValidEscape(first, second) {
    if (first !== 92) {
      return false;
    }
    if (isNewline(second) || second === EOF) {
      return false;
    }
    return true;
  }
  function isIdentifierStart(first, second, third) {
    if (first === 45) {
      return isNameStart(second) || second === 45 || isValidEscape(second, third);
    }
    if (isNameStart(first)) {
      return true;
    }
    if (first === 92) {
      return isValidEscape(first, second);
    }
    return false;
  }
  function isNumberStart(first, second, third) {
    if (first === 43 || first === 45) {
      if (isDigit(second)) {
        return 2;
      }
      return second === 46 && isDigit(third) ? 3 : 0;
    }
    if (first === 46) {
      return isDigit(second) ? 2 : 0;
    }
    if (isDigit(first)) {
      return 1;
    }
    return 0;
  }
  function isBOM(code) {
    if (code === 65279) {
      return 1;
    }
    if (code === 65534) {
      return 1;
    }
    return 0;
  }
  var CATEGORY = new Array(128);
  var EofCategory = 128;
  var WhiteSpaceCategory = 130;
  var DigitCategory = 131;
  var NameStartCategory = 132;
  var NonPrintableCategory = 133;
  for (let i = 0;i < CATEGORY.length; i++) {
    CATEGORY[i] = isWhiteSpace(i) && WhiteSpaceCategory || isDigit(i) && DigitCategory || isNameStart(i) && NameStartCategory || isNonPrintable(i) && NonPrintableCategory || i || EofCategory;
  }
  function charCodeCategory(code) {
    return code < 128 ? CATEGORY[code] : NameStartCategory;
  }
  exports.DigitCategory = DigitCategory;
  exports.EofCategory = EofCategory;
  exports.NameStartCategory = NameStartCategory;
  exports.NonPrintableCategory = NonPrintableCategory;
  exports.WhiteSpaceCategory = WhiteSpaceCategory;
  exports.charCodeCategory = charCodeCategory;
  exports.isBOM = isBOM;
  exports.isDigit = isDigit;
  exports.isHexDigit = isHexDigit;
  exports.isIdentifierStart = isIdentifierStart;
  exports.isLetter = isLetter;
  exports.isLowercaseLetter = isLowercaseLetter;
  exports.isName = isName;
  exports.isNameStart = isNameStart;
  exports.isNewline = isNewline;
  exports.isNonAscii = isNonAscii;
  exports.isNonPrintable = isNonPrintable;
  exports.isNumberStart = isNumberStart;
  exports.isUppercaseLetter = isUppercaseLetter;
  exports.isValidEscape = isValidEscape;
  exports.isWhiteSpace = isWhiteSpace;
});

// ../../../../node_modules/.bun/css-tree@2.2.1/node_modules/css-tree/cjs/tokenizer/utils.cjs
var require_utils2 = __commonJS((exports) => {
  var charCodeDefinitions = require_char_code_definitions2();
  function getCharCode(source, offset) {
    return offset < source.length ? source.charCodeAt(offset) : 0;
  }
  function getNewlineLength(source, offset, code) {
    if (code === 13 && getCharCode(source, offset + 1) === 10) {
      return 2;
    }
    return 1;
  }
  function cmpChar(testStr, offset, referenceCode) {
    let code = testStr.charCodeAt(offset);
    if (charCodeDefinitions.isUppercaseLetter(code)) {
      code = code | 32;
    }
    return code === referenceCode;
  }
  function cmpStr(testStr, start, end, referenceStr) {
    if (end - start !== referenceStr.length) {
      return false;
    }
    if (start < 0 || end > testStr.length) {
      return false;
    }
    for (let i = start;i < end; i++) {
      const referenceCode = referenceStr.charCodeAt(i - start);
      let testCode = testStr.charCodeAt(i);
      if (charCodeDefinitions.isUppercaseLetter(testCode)) {
        testCode = testCode | 32;
      }
      if (testCode !== referenceCode) {
        return false;
      }
    }
    return true;
  }
  function findWhiteSpaceStart(source, offset) {
    for (;offset >= 0; offset--) {
      if (!charCodeDefinitions.isWhiteSpace(source.charCodeAt(offset))) {
        break;
      }
    }
    return offset + 1;
  }
  function findWhiteSpaceEnd(source, offset) {
    for (;offset < source.length; offset++) {
      if (!charCodeDefinitions.isWhiteSpace(source.charCodeAt(offset))) {
        break;
      }
    }
    return offset;
  }
  function findDecimalNumberEnd(source, offset) {
    for (;offset < source.length; offset++) {
      if (!charCodeDefinitions.isDigit(source.charCodeAt(offset))) {
        break;
      }
    }
    return offset;
  }
  function consumeEscaped(source, offset) {
    offset += 2;
    if (charCodeDefinitions.isHexDigit(getCharCode(source, offset - 1))) {
      for (const maxOffset = Math.min(source.length, offset + 5);offset < maxOffset; offset++) {
        if (!charCodeDefinitions.isHexDigit(getCharCode(source, offset))) {
          break;
        }
      }
      const code = getCharCode(source, offset);
      if (charCodeDefinitions.isWhiteSpace(code)) {
        offset += getNewlineLength(source, offset, code);
      }
    }
    return offset;
  }
  function consumeName(source, offset) {
    for (;offset < source.length; offset++) {
      const code = source.charCodeAt(offset);
      if (charCodeDefinitions.isName(code)) {
        continue;
      }
      if (charCodeDefinitions.isValidEscape(code, getCharCode(source, offset + 1))) {
        offset = consumeEscaped(source, offset) - 1;
        continue;
      }
      break;
    }
    return offset;
  }
  function consumeNumber(source, offset) {
    let code = source.charCodeAt(offset);
    if (code === 43 || code === 45) {
      code = source.charCodeAt(offset += 1);
    }
    if (charCodeDefinitions.isDigit(code)) {
      offset = findDecimalNumberEnd(source, offset + 1);
      code = source.charCodeAt(offset);
    }
    if (code === 46 && charCodeDefinitions.isDigit(source.charCodeAt(offset + 1))) {
      offset += 2;
      offset = findDecimalNumberEnd(source, offset);
    }
    if (cmpChar(source, offset, 101)) {
      let sign = 0;
      code = source.charCodeAt(offset + 1);
      if (code === 45 || code === 43) {
        sign = 1;
        code = source.charCodeAt(offset + 2);
      }
      if (charCodeDefinitions.isDigit(code)) {
        offset = findDecimalNumberEnd(source, offset + 1 + sign + 1);
      }
    }
    return offset;
  }
  function consumeBadUrlRemnants(source, offset) {
    for (;offset < source.length; offset++) {
      const code = source.charCodeAt(offset);
      if (code === 41) {
        offset++;
        break;
      }
      if (charCodeDefinitions.isValidEscape(code, getCharCode(source, offset + 1))) {
        offset = consumeEscaped(source, offset);
      }
    }
    return offset;
  }
  function decodeEscaped(escaped) {
    if (escaped.length === 1 && !charCodeDefinitions.isHexDigit(escaped.charCodeAt(0))) {
      return escaped[0];
    }
    let code = parseInt(escaped, 16);
    if (code === 0 || code >= 55296 && code <= 57343 || code > 1114111) {
      code = 65533;
    }
    return String.fromCodePoint(code);
  }
  exports.cmpChar = cmpChar;
  exports.cmpStr = cmpStr;
  exports.consumeBadUrlRemnants = consumeBadUrlRemnants;
  exports.consumeEscaped = consumeEscaped;
  exports.consumeName = consumeName;
  exports.consumeNumber = consumeNumber;
  exports.decodeEscaped = decodeEscaped;
  exports.findDecimalNumberEnd = findDecimalNumberEnd;
  exports.findWhiteSpaceEnd = findWhiteSpaceEnd;
  exports.findWhiteSpaceStart = findWhiteSpaceStart;
  exports.getNewlineLength = getNewlineLength;
});

// ../../../../node_modules/.bun/css-tree@2.2.1/node_modules/css-tree/cjs/tokenizer/names.cjs
var require_names3 = __commonJS((exports, module) => {
  var tokenNames = [
    "EOF-token",
    "ident-token",
    "function-token",
    "at-keyword-token",
    "hash-token",
    "string-token",
    "bad-string-token",
    "url-token",
    "bad-url-token",
    "delim-token",
    "number-token",
    "percentage-token",
    "dimension-token",
    "whitespace-token",
    "CDO-token",
    "CDC-token",
    "colon-token",
    "semicolon-token",
    "comma-token",
    "[-token",
    "]-token",
    "(-token",
    ")-token",
    "{-token",
    "}-token"
  ];
  module.exports = tokenNames;
});

// ../../../../node_modules/.bun/css-tree@2.2.1/node_modules/css-tree/cjs/tokenizer/adopt-buffer.cjs
var require_adopt_buffer2 = __commonJS((exports) => {
  var MIN_SIZE = 16 * 1024;
  function adoptBuffer(buffer = null, size) {
    if (buffer === null || buffer.length < size) {
      return new Uint32Array(Math.max(size + 1024, MIN_SIZE));
    }
    return buffer;
  }
  exports.adoptBuffer = adoptBuffer;
});

// ../../../../node_modules/.bun/css-tree@2.2.1/node_modules/css-tree/cjs/tokenizer/OffsetToLocation.cjs
var require_OffsetToLocation2 = __commonJS((exports) => {
  var adoptBuffer = require_adopt_buffer2();
  var charCodeDefinitions = require_char_code_definitions2();
  var N = 10;
  var F = 12;
  var R = 13;
  function computeLinesAndColumns(host) {
    const source = host.source;
    const sourceLength = source.length;
    const startOffset = source.length > 0 ? charCodeDefinitions.isBOM(source.charCodeAt(0)) : 0;
    const lines = adoptBuffer.adoptBuffer(host.lines, sourceLength);
    const columns = adoptBuffer.adoptBuffer(host.columns, sourceLength);
    let line = host.startLine;
    let column = host.startColumn;
    for (let i = startOffset;i < sourceLength; i++) {
      const code = source.charCodeAt(i);
      lines[i] = line;
      columns[i] = column++;
      if (code === N || code === R || code === F) {
        if (code === R && i + 1 < sourceLength && source.charCodeAt(i + 1) === N) {
          i++;
          lines[i] = line;
          columns[i] = column;
        }
        line++;
        column = 1;
      }
    }
    lines[sourceLength] = line;
    columns[sourceLength] = column;
    host.lines = lines;
    host.columns = columns;
    host.computed = true;
  }

  class OffsetToLocation {
    constructor() {
      this.lines = null;
      this.columns = null;
      this.computed = false;
    }
    setSource(source, startOffset = 0, startLine = 1, startColumn = 1) {
      this.source = source;
      this.startOffset = startOffset;
      this.startLine = startLine;
      this.startColumn = startColumn;
      this.computed = false;
    }
    getLocation(offset, filename) {
      if (!this.computed) {
        computeLinesAndColumns(this);
      }
      return {
        source: filename,
        offset: this.startOffset + offset,
        line: this.lines[offset],
        column: this.columns[offset]
      };
    }
    getLocationRange(start, end, filename) {
      if (!this.computed) {
        computeLinesAndColumns(this);
      }
      return {
        source: filename,
        start: {
          offset: this.startOffset + start,
          line: this.lines[start],
          column: this.columns[start]
        },
        end: {
          offset: this.startOffset + end,
          line: this.lines[end],
          column: this.columns[end]
        }
      };
    }
  }
  exports.OffsetToLocation = OffsetToLocation;
});

// ../../../../node_modules/.bun/css-tree@2.2.1/node_modules/css-tree/cjs/tokenizer/TokenStream.cjs
var require_TokenStream2 = __commonJS((exports) => {
  var adoptBuffer = require_adopt_buffer2();
  var utils = require_utils2();
  var names = require_names3();
  var types = require_types3();
  var OFFSET_MASK = 16777215;
  var TYPE_SHIFT = 24;
  var balancePair = new Map([
    [types.Function, types.RightParenthesis],
    [types.LeftParenthesis, types.RightParenthesis],
    [types.LeftSquareBracket, types.RightSquareBracket],
    [types.LeftCurlyBracket, types.RightCurlyBracket]
  ]);

  class TokenStream {
    constructor(source, tokenize) {
      this.setSource(source, tokenize);
    }
    reset() {
      this.eof = false;
      this.tokenIndex = -1;
      this.tokenType = 0;
      this.tokenStart = this.firstCharOffset;
      this.tokenEnd = this.firstCharOffset;
    }
    setSource(source = "", tokenize = () => {}) {
      source = String(source || "");
      const sourceLength = source.length;
      const offsetAndType = adoptBuffer.adoptBuffer(this.offsetAndType, source.length + 1);
      const balance = adoptBuffer.adoptBuffer(this.balance, source.length + 1);
      let tokenCount = 0;
      let balanceCloseType = 0;
      let balanceStart = 0;
      let firstCharOffset = -1;
      this.offsetAndType = null;
      this.balance = null;
      tokenize(source, (type, start, end) => {
        switch (type) {
          default:
            balance[tokenCount] = sourceLength;
            break;
          case balanceCloseType: {
            let balancePrev = balanceStart & OFFSET_MASK;
            balanceStart = balance[balancePrev];
            balanceCloseType = balanceStart >> TYPE_SHIFT;
            balance[tokenCount] = balancePrev;
            balance[balancePrev++] = tokenCount;
            for (;balancePrev < tokenCount; balancePrev++) {
              if (balance[balancePrev] === sourceLength) {
                balance[balancePrev] = tokenCount;
              }
            }
            break;
          }
          case types.LeftParenthesis:
          case types.Function:
          case types.LeftSquareBracket:
          case types.LeftCurlyBracket:
            balance[tokenCount] = balanceStart;
            balanceCloseType = balancePair.get(type);
            balanceStart = balanceCloseType << TYPE_SHIFT | tokenCount;
            break;
        }
        offsetAndType[tokenCount++] = type << TYPE_SHIFT | end;
        if (firstCharOffset === -1) {
          firstCharOffset = start;
        }
      });
      offsetAndType[tokenCount] = types.EOF << TYPE_SHIFT | sourceLength;
      balance[tokenCount] = sourceLength;
      balance[sourceLength] = sourceLength;
      while (balanceStart !== 0) {
        const balancePrev = balanceStart & OFFSET_MASK;
        balanceStart = balance[balancePrev];
        balance[balancePrev] = sourceLength;
      }
      this.source = source;
      this.firstCharOffset = firstCharOffset === -1 ? 0 : firstCharOffset;
      this.tokenCount = tokenCount;
      this.offsetAndType = offsetAndType;
      this.balance = balance;
      this.reset();
      this.next();
    }
    lookupType(offset) {
      offset += this.tokenIndex;
      if (offset < this.tokenCount) {
        return this.offsetAndType[offset] >> TYPE_SHIFT;
      }
      return types.EOF;
    }
    lookupOffset(offset) {
      offset += this.tokenIndex;
      if (offset < this.tokenCount) {
        return this.offsetAndType[offset - 1] & OFFSET_MASK;
      }
      return this.source.length;
    }
    lookupValue(offset, referenceStr) {
      offset += this.tokenIndex;
      if (offset < this.tokenCount) {
        return utils.cmpStr(this.source, this.offsetAndType[offset - 1] & OFFSET_MASK, this.offsetAndType[offset] & OFFSET_MASK, referenceStr);
      }
      return false;
    }
    getTokenStart(tokenIndex) {
      if (tokenIndex === this.tokenIndex) {
        return this.tokenStart;
      }
      if (tokenIndex > 0) {
        return tokenIndex < this.tokenCount ? this.offsetAndType[tokenIndex - 1] & OFFSET_MASK : this.offsetAndType[this.tokenCount] & OFFSET_MASK;
      }
      return this.firstCharOffset;
    }
    substrToCursor(start) {
      return this.source.substring(start, this.tokenStart);
    }
    isBalanceEdge(pos) {
      return this.balance[this.tokenIndex] < pos;
    }
    isDelim(code, offset) {
      if (offset) {
        return this.lookupType(offset) === types.Delim && this.source.charCodeAt(this.lookupOffset(offset)) === code;
      }
      return this.tokenType === types.Delim && this.source.charCodeAt(this.tokenStart) === code;
    }
    skip(tokenCount) {
      let next = this.tokenIndex + tokenCount;
      if (next < this.tokenCount) {
        this.tokenIndex = next;
        this.tokenStart = this.offsetAndType[next - 1] & OFFSET_MASK;
        next = this.offsetAndType[next];
        this.tokenType = next >> TYPE_SHIFT;
        this.tokenEnd = next & OFFSET_MASK;
      } else {
        this.tokenIndex = this.tokenCount;
        this.next();
      }
    }
    next() {
      let next = this.tokenIndex + 1;
      if (next < this.tokenCount) {
        this.tokenIndex = next;
        this.tokenStart = this.tokenEnd;
        next = this.offsetAndType[next];
        this.tokenType = next >> TYPE_SHIFT;
        this.tokenEnd = next & OFFSET_MASK;
      } else {
        this.eof = true;
        this.tokenIndex = this.tokenCount;
        this.tokenType = types.EOF;
        this.tokenStart = this.tokenEnd = this.source.length;
      }
    }
    skipSC() {
      while (this.tokenType === types.WhiteSpace || this.tokenType === types.Comment) {
        this.next();
      }
    }
    skipUntilBalanced(startToken, stopConsume) {
      let cursor = startToken;
      let balanceEnd;
      let offset;
      loop:
        for (;cursor < this.tokenCount; cursor++) {
          balanceEnd = this.balance[cursor];
          if (balanceEnd < startToken) {
            break loop;
          }
          offset = cursor > 0 ? this.offsetAndType[cursor - 1] & OFFSET_MASK : this.firstCharOffset;
          switch (stopConsume(this.source.charCodeAt(offset))) {
            case 1:
              break loop;
            case 2:
              cursor++;
              break loop;
            default:
              if (this.balance[balanceEnd] === cursor) {
                cursor = balanceEnd;
              }
          }
        }
      this.skip(cursor - this.tokenIndex);
    }
    forEachToken(fn) {
      for (let i = 0, offset = this.firstCharOffset;i < this.tokenCount; i++) {
        const start = offset;
        const item = this.offsetAndType[i];
        const end = item & OFFSET_MASK;
        const type = item >> TYPE_SHIFT;
        offset = end;
        fn(type, start, end, i);
      }
    }
    dump() {
      const tokens = new Array(this.tokenCount);
      this.forEachToken((type, start, end, index) => {
        tokens[index] = {
          idx: index,
          type: names[type],
          chunk: this.source.substring(start, end),
          balance: this.balance[index]
        };
      });
      return tokens;
    }
  }
  exports.TokenStream = TokenStream;
});

// ../../../../node_modules/.bun/css-tree@2.2.1/node_modules/css-tree/cjs/tokenizer/index.cjs
var require_tokenizer3 = __commonJS((exports) => {
  var types = require_types3();
  var charCodeDefinitions = require_char_code_definitions2();
  var utils = require_utils2();
  var names = require_names3();
  var OffsetToLocation = require_OffsetToLocation2();
  var TokenStream = require_TokenStream2();
  function tokenize(source, onToken) {
    function getCharCode(offset2) {
      return offset2 < sourceLength ? source.charCodeAt(offset2) : 0;
    }
    function consumeNumericToken() {
      offset = utils.consumeNumber(source, offset);
      if (charCodeDefinitions.isIdentifierStart(getCharCode(offset), getCharCode(offset + 1), getCharCode(offset + 2))) {
        type = types.Dimension;
        offset = utils.consumeName(source, offset);
        return;
      }
      if (getCharCode(offset) === 37) {
        type = types.Percentage;
        offset++;
        return;
      }
      type = types.Number;
    }
    function consumeIdentLikeToken() {
      const nameStartOffset = offset;
      offset = utils.consumeName(source, offset);
      if (utils.cmpStr(source, nameStartOffset, offset, "url") && getCharCode(offset) === 40) {
        offset = utils.findWhiteSpaceEnd(source, offset + 1);
        if (getCharCode(offset) === 34 || getCharCode(offset) === 39) {
          type = types.Function;
          offset = nameStartOffset + 4;
          return;
        }
        consumeUrlToken();
        return;
      }
      if (getCharCode(offset) === 40) {
        type = types.Function;
        offset++;
        return;
      }
      type = types.Ident;
    }
    function consumeStringToken(endingCodePoint) {
      if (!endingCodePoint) {
        endingCodePoint = getCharCode(offset++);
      }
      type = types.String;
      for (;offset < source.length; offset++) {
        const code = source.charCodeAt(offset);
        switch (charCodeDefinitions.charCodeCategory(code)) {
          case endingCodePoint:
            offset++;
            return;
          case charCodeDefinitions.WhiteSpaceCategory:
            if (charCodeDefinitions.isNewline(code)) {
              offset += utils.getNewlineLength(source, offset, code);
              type = types.BadString;
              return;
            }
            break;
          case 92:
            if (offset === source.length - 1) {
              break;
            }
            const nextCode = getCharCode(offset + 1);
            if (charCodeDefinitions.isNewline(nextCode)) {
              offset += utils.getNewlineLength(source, offset + 1, nextCode);
            } else if (charCodeDefinitions.isValidEscape(code, nextCode)) {
              offset = utils.consumeEscaped(source, offset) - 1;
            }
            break;
        }
      }
    }
    function consumeUrlToken() {
      type = types.Url;
      offset = utils.findWhiteSpaceEnd(source, offset);
      for (;offset < source.length; offset++) {
        const code = source.charCodeAt(offset);
        switch (charCodeDefinitions.charCodeCategory(code)) {
          case 41:
            offset++;
            return;
          case charCodeDefinitions.WhiteSpaceCategory:
            offset = utils.findWhiteSpaceEnd(source, offset);
            if (getCharCode(offset) === 41 || offset >= source.length) {
              if (offset < source.length) {
                offset++;
              }
              return;
            }
            offset = utils.consumeBadUrlRemnants(source, offset);
            type = types.BadUrl;
            return;
          case 34:
          case 39:
          case 40:
          case charCodeDefinitions.NonPrintableCategory:
            offset = utils.consumeBadUrlRemnants(source, offset);
            type = types.BadUrl;
            return;
          case 92:
            if (charCodeDefinitions.isValidEscape(code, getCharCode(offset + 1))) {
              offset = utils.consumeEscaped(source, offset) - 1;
              break;
            }
            offset = utils.consumeBadUrlRemnants(source, offset);
            type = types.BadUrl;
            return;
        }
      }
    }
    source = String(source || "");
    const sourceLength = source.length;
    let start = charCodeDefinitions.isBOM(getCharCode(0));
    let offset = start;
    let type;
    while (offset < sourceLength) {
      const code = source.charCodeAt(offset);
      switch (charCodeDefinitions.charCodeCategory(code)) {
        case charCodeDefinitions.WhiteSpaceCategory:
          type = types.WhiteSpace;
          offset = utils.findWhiteSpaceEnd(source, offset + 1);
          break;
        case 34:
          consumeStringToken();
          break;
        case 35:
          if (charCodeDefinitions.isName(getCharCode(offset + 1)) || charCodeDefinitions.isValidEscape(getCharCode(offset + 1), getCharCode(offset + 2))) {
            type = types.Hash;
            offset = utils.consumeName(source, offset + 1);
          } else {
            type = types.Delim;
            offset++;
          }
          break;
        case 39:
          consumeStringToken();
          break;
        case 40:
          type = types.LeftParenthesis;
          offset++;
          break;
        case 41:
          type = types.RightParenthesis;
          offset++;
          break;
        case 43:
          if (charCodeDefinitions.isNumberStart(code, getCharCode(offset + 1), getCharCode(offset + 2))) {
            consumeNumericToken();
          } else {
            type = types.Delim;
            offset++;
          }
          break;
        case 44:
          type = types.Comma;
          offset++;
          break;
        case 45:
          if (charCodeDefinitions.isNumberStart(code, getCharCode(offset + 1), getCharCode(offset + 2))) {
            consumeNumericToken();
          } else {
            if (getCharCode(offset + 1) === 45 && getCharCode(offset + 2) === 62) {
              type = types.CDC;
              offset = offset + 3;
            } else {
              if (charCodeDefinitions.isIdentifierStart(code, getCharCode(offset + 1), getCharCode(offset + 2))) {
                consumeIdentLikeToken();
              } else {
                type = types.Delim;
                offset++;
              }
            }
          }
          break;
        case 46:
          if (charCodeDefinitions.isNumberStart(code, getCharCode(offset + 1), getCharCode(offset + 2))) {
            consumeNumericToken();
          } else {
            type = types.Delim;
            offset++;
          }
          break;
        case 47:
          if (getCharCode(offset + 1) === 42) {
            type = types.Comment;
            offset = source.indexOf("*/", offset + 2);
            offset = offset === -1 ? source.length : offset + 2;
          } else {
            type = types.Delim;
            offset++;
          }
          break;
        case 58:
          type = types.Colon;
          offset++;
          break;
        case 59:
          type = types.Semicolon;
          offset++;
          break;
        case 60:
          if (getCharCode(offset + 1) === 33 && getCharCode(offset + 2) === 45 && getCharCode(offset + 3) === 45) {
            type = types.CDO;
            offset = offset + 4;
          } else {
            type = types.Delim;
            offset++;
          }
          break;
        case 64:
          if (charCodeDefinitions.isIdentifierStart(getCharCode(offset + 1), getCharCode(offset + 2), getCharCode(offset + 3))) {
            type = types.AtKeyword;
            offset = utils.consumeName(source, offset + 1);
          } else {
            type = types.Delim;
            offset++;
          }
          break;
        case 91:
          type = types.LeftSquareBracket;
          offset++;
          break;
        case 92:
          if (charCodeDefinitions.isValidEscape(code, getCharCode(offset + 1))) {
            consumeIdentLikeToken();
          } else {
            type = types.Delim;
            offset++;
          }
          break;
        case 93:
          type = types.RightSquareBracket;
          offset++;
          break;
        case 123:
          type = types.LeftCurlyBracket;
          offset++;
          break;
        case 125:
          type = types.RightCurlyBracket;
          offset++;
          break;
        case charCodeDefinitions.DigitCategory:
          consumeNumericToken();
          break;
        case charCodeDefinitions.NameStartCategory:
          consumeIdentLikeToken();
          break;
        default:
          type = types.Delim;
          offset++;
      }
      onToken(type, start, start = offset);
    }
  }
  exports.AtKeyword = types.AtKeyword;
  exports.BadString = types.BadString;
  exports.BadUrl = types.BadUrl;
  exports.CDC = types.CDC;
  exports.CDO = types.CDO;
  exports.Colon = types.Colon;
  exports.Comma = types.Comma;
  exports.Comment = types.Comment;
  exports.Delim = types.Delim;
  exports.Dimension = types.Dimension;
  exports.EOF = types.EOF;
  exports.Function = types.Function;
  exports.Hash = types.Hash;
  exports.Ident = types.Ident;
  exports.LeftCurlyBracket = types.LeftCurlyBracket;
  exports.LeftParenthesis = types.LeftParenthesis;
  exports.LeftSquareBracket = types.LeftSquareBracket;
  exports.Number = types.Number;
  exports.Percentage = types.Percentage;
  exports.RightCurlyBracket = types.RightCurlyBracket;
  exports.RightParenthesis = types.RightParenthesis;
  exports.RightSquareBracket = types.RightSquareBracket;
  exports.Semicolon = types.Semicolon;
  exports.String = types.String;
  exports.Url = types.Url;
  exports.WhiteSpace = types.WhiteSpace;
  exports.tokenTypes = types;
  exports.DigitCategory = charCodeDefinitions.DigitCategory;
  exports.EofCategory = charCodeDefinitions.EofCategory;
  exports.NameStartCategory = charCodeDefinitions.NameStartCategory;
  exports.NonPrintableCategory = charCodeDefinitions.NonPrintableCategory;
  exports.WhiteSpaceCategory = charCodeDefinitions.WhiteSpaceCategory;
  exports.charCodeCategory = charCodeDefinitions.charCodeCategory;
  exports.isBOM = charCodeDefinitions.isBOM;
  exports.isDigit = charCodeDefinitions.isDigit;
  exports.isHexDigit = charCodeDefinitions.isHexDigit;
  exports.isIdentifierStart = charCodeDefinitions.isIdentifierStart;
  exports.isLetter = charCodeDefinitions.isLetter;
  exports.isLowercaseLetter = charCodeDefinitions.isLowercaseLetter;
  exports.isName = charCodeDefinitions.isName;
  exports.isNameStart = charCodeDefinitions.isNameStart;
  exports.isNewline = charCodeDefinitions.isNewline;
  exports.isNonAscii = charCodeDefinitions.isNonAscii;
  exports.isNonPrintable = charCodeDefinitions.isNonPrintable;
  exports.isNumberStart = charCodeDefinitions.isNumberStart;
  exports.isUppercaseLetter = charCodeDefinitions.isUppercaseLetter;
  exports.isValidEscape = charCodeDefinitions.isValidEscape;
  exports.isWhiteSpace = charCodeDefinitions.isWhiteSpace;
  exports.cmpChar = utils.cmpChar;
  exports.cmpStr = utils.cmpStr;
  exports.consumeBadUrlRemnants = utils.consumeBadUrlRemnants;
  exports.consumeEscaped = utils.consumeEscaped;
  exports.consumeName = utils.consumeName;
  exports.consumeNumber = utils.consumeNumber;
  exports.decodeEscaped = utils.decodeEscaped;
  exports.findDecimalNumberEnd = utils.findDecimalNumberEnd;
  exports.findWhiteSpaceEnd = utils.findWhiteSpaceEnd;
  exports.findWhiteSpaceStart = utils.findWhiteSpaceStart;
  exports.getNewlineLength = utils.getNewlineLength;
  exports.tokenNames = names;
  exports.OffsetToLocation = OffsetToLocation.OffsetToLocation;
  exports.TokenStream = TokenStream.TokenStream;
  exports.tokenize = tokenize;
});

// ../../../../node_modules/.bun/css-tree@2.2.1/node_modules/css-tree/cjs/utils/List.cjs
var require_List2 = __commonJS((exports) => {
  var releasedCursors = null;

  class List {
    static createItem(data) {
      return {
        prev: null,
        next: null,
        data
      };
    }
    constructor() {
      this.head = null;
      this.tail = null;
      this.cursor = null;
    }
    createItem(data) {
      return List.createItem(data);
    }
    allocateCursor(prev, next) {
      let cursor;
      if (releasedCursors !== null) {
        cursor = releasedCursors;
        releasedCursors = releasedCursors.cursor;
        cursor.prev = prev;
        cursor.next = next;
        cursor.cursor = this.cursor;
      } else {
        cursor = {
          prev,
          next,
          cursor: this.cursor
        };
      }
      this.cursor = cursor;
      return cursor;
    }
    releaseCursor() {
      const { cursor } = this;
      this.cursor = cursor.cursor;
      cursor.prev = null;
      cursor.next = null;
      cursor.cursor = releasedCursors;
      releasedCursors = cursor;
    }
    updateCursors(prevOld, prevNew, nextOld, nextNew) {
      let { cursor } = this;
      while (cursor !== null) {
        if (cursor.prev === prevOld) {
          cursor.prev = prevNew;
        }
        if (cursor.next === nextOld) {
          cursor.next = nextNew;
        }
        cursor = cursor.cursor;
      }
    }
    *[Symbol.iterator]() {
      for (let cursor = this.head;cursor !== null; cursor = cursor.next) {
        yield cursor.data;
      }
    }
    get size() {
      let size = 0;
      for (let cursor = this.head;cursor !== null; cursor = cursor.next) {
        size++;
      }
      return size;
    }
    get isEmpty() {
      return this.head === null;
    }
    get first() {
      return this.head && this.head.data;
    }
    get last() {
      return this.tail && this.tail.data;
    }
    fromArray(array) {
      let cursor = null;
      this.head = null;
      for (let data of array) {
        const item = List.createItem(data);
        if (cursor !== null) {
          cursor.next = item;
        } else {
          this.head = item;
        }
        item.prev = cursor;
        cursor = item;
      }
      this.tail = cursor;
      return this;
    }
    toArray() {
      return [...this];
    }
    toJSON() {
      return [...this];
    }
    forEach(fn, thisArg = this) {
      const cursor = this.allocateCursor(null, this.head);
      while (cursor.next !== null) {
        const item = cursor.next;
        cursor.next = item.next;
        fn.call(thisArg, item.data, item, this);
      }
      this.releaseCursor();
    }
    forEachRight(fn, thisArg = this) {
      const cursor = this.allocateCursor(this.tail, null);
      while (cursor.prev !== null) {
        const item = cursor.prev;
        cursor.prev = item.prev;
        fn.call(thisArg, item.data, item, this);
      }
      this.releaseCursor();
    }
    reduce(fn, initialValue, thisArg = this) {
      let cursor = this.allocateCursor(null, this.head);
      let acc = initialValue;
      let item;
      while (cursor.next !== null) {
        item = cursor.next;
        cursor.next = item.next;
        acc = fn.call(thisArg, acc, item.data, item, this);
      }
      this.releaseCursor();
      return acc;
    }
    reduceRight(fn, initialValue, thisArg = this) {
      let cursor = this.allocateCursor(this.tail, null);
      let acc = initialValue;
      let item;
      while (cursor.prev !== null) {
        item = cursor.prev;
        cursor.prev = item.prev;
        acc = fn.call(thisArg, acc, item.data, item, this);
      }
      this.releaseCursor();
      return acc;
    }
    some(fn, thisArg = this) {
      for (let cursor = this.head;cursor !== null; cursor = cursor.next) {
        if (fn.call(thisArg, cursor.data, cursor, this)) {
          return true;
        }
      }
      return false;
    }
    map(fn, thisArg = this) {
      const result = new List;
      for (let cursor = this.head;cursor !== null; cursor = cursor.next) {
        result.appendData(fn.call(thisArg, cursor.data, cursor, this));
      }
      return result;
    }
    filter(fn, thisArg = this) {
      const result = new List;
      for (let cursor = this.head;cursor !== null; cursor = cursor.next) {
        if (fn.call(thisArg, cursor.data, cursor, this)) {
          result.appendData(cursor.data);
        }
      }
      return result;
    }
    nextUntil(start, fn, thisArg = this) {
      if (start === null) {
        return;
      }
      const cursor = this.allocateCursor(null, start);
      while (cursor.next !== null) {
        const item = cursor.next;
        cursor.next = item.next;
        if (fn.call(thisArg, item.data, item, this)) {
          break;
        }
      }
      this.releaseCursor();
    }
    prevUntil(start, fn, thisArg = this) {
      if (start === null) {
        return;
      }
      const cursor = this.allocateCursor(start, null);
      while (cursor.prev !== null) {
        const item = cursor.prev;
        cursor.prev = item.prev;
        if (fn.call(thisArg, item.data, item, this)) {
          break;
        }
      }
      this.releaseCursor();
    }
    clear() {
      this.head = null;
      this.tail = null;
    }
    copy() {
      const result = new List;
      for (let data of this) {
        result.appendData(data);
      }
      return result;
    }
    prepend(item) {
      this.updateCursors(null, item, this.head, item);
      if (this.head !== null) {
        this.head.prev = item;
        item.next = this.head;
      } else {
        this.tail = item;
      }
      this.head = item;
      return this;
    }
    prependData(data) {
      return this.prepend(List.createItem(data));
    }
    append(item) {
      return this.insert(item);
    }
    appendData(data) {
      return this.insert(List.createItem(data));
    }
    insert(item, before = null) {
      if (before !== null) {
        this.updateCursors(before.prev, item, before, item);
        if (before.prev === null) {
          if (this.head !== before) {
            throw new Error("before doesn't belong to list");
          }
          this.head = item;
          before.prev = item;
          item.next = before;
          this.updateCursors(null, item);
        } else {
          before.prev.next = item;
          item.prev = before.prev;
          before.prev = item;
          item.next = before;
        }
      } else {
        this.updateCursors(this.tail, item, null, item);
        if (this.tail !== null) {
          this.tail.next = item;
          item.prev = this.tail;
        } else {
          this.head = item;
        }
        this.tail = item;
      }
      return this;
    }
    insertData(data, before) {
      return this.insert(List.createItem(data), before);
    }
    remove(item) {
      this.updateCursors(item, item.prev, item, item.next);
      if (item.prev !== null) {
        item.prev.next = item.next;
      } else {
        if (this.head !== item) {
          throw new Error("item doesn't belong to list");
        }
        this.head = item.next;
      }
      if (item.next !== null) {
        item.next.prev = item.prev;
      } else {
        if (this.tail !== item) {
          throw new Error("item doesn't belong to list");
        }
        this.tail = item.prev;
      }
      item.prev = null;
      item.next = null;
      return item;
    }
    push(data) {
      this.insert(List.createItem(data));
    }
    pop() {
      return this.tail !== null ? this.remove(this.tail) : null;
    }
    unshift(data) {
      this.prepend(List.createItem(data));
    }
    shift() {
      return this.head !== null ? this.remove(this.head) : null;
    }
    prependList(list) {
      return this.insertList(list, this.head);
    }
    appendList(list) {
      return this.insertList(list);
    }
    insertList(list, before) {
      if (list.head === null) {
        return this;
      }
      if (before !== undefined && before !== null) {
        this.updateCursors(before.prev, list.tail, before, list.head);
        if (before.prev !== null) {
          before.prev.next = list.head;
          list.head.prev = before.prev;
        } else {
          this.head = list.head;
        }
        before.prev = list.tail;
        list.tail.next = before;
      } else {
        this.updateCursors(this.tail, list.tail, null, list.head);
        if (this.tail !== null) {
          this.tail.next = list.head;
          list.head.prev = this.tail;
        } else {
          this.head = list.head;
        }
        this.tail = list.tail;
      }
      list.head = null;
      list.tail = null;
      return this;
    }
    replace(oldItem, newItemOrList) {
      if ("head" in newItemOrList) {
        this.insertList(newItemOrList, oldItem);
      } else {
        this.insert(newItemOrList, oldItem);
      }
      this.remove(oldItem);
    }
  }
  exports.List = List;
});

// ../../../../node_modules/.bun/css-tree@2.2.1/node_modules/css-tree/cjs/utils/create-custom-error.cjs
var require_create_custom_error2 = __commonJS((exports) => {
  function createCustomError(name, message) {
    const error = Object.create(SyntaxError.prototype);
    const errorStack = new Error;
    return Object.assign(error, {
      name,
      message,
      get stack() {
        return (errorStack.stack || "").replace(/^(.+\n){1,3}/, `${name}: ${message}
`);
      }
    });
  }
  exports.createCustomError = createCustomError;
});

// ../../../../node_modules/.bun/css-tree@2.2.1/node_modules/css-tree/cjs/parser/SyntaxError.cjs
var require_SyntaxError3 = __commonJS((exports) => {
  var createCustomError = require_create_custom_error2();
  var MAX_LINE_LENGTH = 100;
  var OFFSET_CORRECTION = 60;
  var TAB_REPLACEMENT = "    ";
  function sourceFragment({ source, line, column }, extraLines) {
    function processLines(start, end) {
      return lines.slice(start, end).map((line2, idx) => String(start + idx + 1).padStart(maxNumLength) + " |" + line2).join(`
`);
    }
    const lines = source.split(/\r\n?|\n|\f/);
    const startLine = Math.max(1, line - extraLines) - 1;
    const endLine = Math.min(line + extraLines, lines.length + 1);
    const maxNumLength = Math.max(4, String(endLine).length) + 1;
    let cutLeft = 0;
    column += (TAB_REPLACEMENT.length - 1) * (lines[line - 1].substr(0, column - 1).match(/\t/g) || []).length;
    if (column > MAX_LINE_LENGTH) {
      cutLeft = column - OFFSET_CORRECTION + 3;
      column = OFFSET_CORRECTION - 2;
    }
    for (let i = startLine;i <= endLine; i++) {
      if (i >= 0 && i < lines.length) {
        lines[i] = lines[i].replace(/\t/g, TAB_REPLACEMENT);
        lines[i] = (cutLeft > 0 && lines[i].length > cutLeft ? "" : "") + lines[i].substr(cutLeft, MAX_LINE_LENGTH - 2) + (lines[i].length > cutLeft + MAX_LINE_LENGTH - 1 ? "" : "");
      }
    }
    return [
      processLines(startLine, line),
      new Array(column + maxNumLength + 2).join("-") + "^",
      processLines(line, endLine)
    ].filter(Boolean).join(`
`);
  }
  function SyntaxError2(message, source, offset, line, column) {
    const error = Object.assign(createCustomError.createCustomError("SyntaxError", message), {
      source,
      offset,
      line,
      column,
      sourceFragment(extraLines) {
        return sourceFragment({ source, line, column }, isNaN(extraLines) ? 0 : extraLines);
      },
      get formattedMessage() {
        return `Parse error: ${message}
` + sourceFragment({ source, line, column }, 2);
      }
    });
    return error;
  }
  exports.SyntaxError = SyntaxError2;
});

// ../../../../node_modules/.bun/css-tree@2.2.1/node_modules/css-tree/cjs/parser/sequence.cjs
var require_sequence2 = __commonJS((exports) => {
  var types = require_types3();
  function readSequence(recognizer) {
    const children = this.createList();
    let space = false;
    const context = {
      recognizer
    };
    while (!this.eof) {
      switch (this.tokenType) {
        case types.Comment:
          this.next();
          continue;
        case types.WhiteSpace:
          space = true;
          this.next();
          continue;
      }
      let child = recognizer.getNode.call(this, context);
      if (child === undefined) {
        break;
      }
      if (space) {
        if (recognizer.onWhiteSpace) {
          recognizer.onWhiteSpace.call(this, child, children, context);
        }
        space = false;
      }
      children.push(child);
    }
    if (space && recognizer.onWhiteSpace) {
      recognizer.onWhiteSpace.call(this, null, children, context);
    }
    return children;
  }
  exports.readSequence = readSequence;
});

// ../../../../node_modules/.bun/css-tree@2.2.1/node_modules/css-tree/cjs/parser/create.cjs
var require_create6 = __commonJS((exports) => {
  var List = require_List2();
  var SyntaxError2 = require_SyntaxError3();
  var index = require_tokenizer3();
  var sequence = require_sequence2();
  var OffsetToLocation = require_OffsetToLocation2();
  var TokenStream = require_TokenStream2();
  var utils = require_utils2();
  var types = require_types3();
  var names = require_names3();
  var NOOP = () => {};
  var EXCLAMATIONMARK = 33;
  var NUMBERSIGN = 35;
  var SEMICOLON = 59;
  var LEFTCURLYBRACKET = 123;
  var NULL = 0;
  function createParseContext(name) {
    return function() {
      return this[name]();
    };
  }
  function fetchParseValues(dict) {
    const result = Object.create(null);
    for (const name in dict) {
      const item = dict[name];
      const fn = item.parse || item;
      if (fn) {
        result[name] = fn;
      }
    }
    return result;
  }
  function processConfig(config) {
    const parseConfig = {
      context: Object.create(null),
      scope: Object.assign(Object.create(null), config.scope),
      atrule: fetchParseValues(config.atrule),
      pseudo: fetchParseValues(config.pseudo),
      node: fetchParseValues(config.node)
    };
    for (const name in config.parseContext) {
      switch (typeof config.parseContext[name]) {
        case "function":
          parseConfig.context[name] = config.parseContext[name];
          break;
        case "string":
          parseConfig.context[name] = createParseContext(config.parseContext[name]);
          break;
      }
    }
    return {
      config: parseConfig,
      ...parseConfig,
      ...parseConfig.node
    };
  }
  function createParser(config) {
    let source = "";
    let filename = "<unknown>";
    let needPositions = false;
    let onParseError = NOOP;
    let onParseErrorThrow = false;
    const locationMap = new OffsetToLocation.OffsetToLocation;
    const parser = Object.assign(new TokenStream.TokenStream, processConfig(config || {}), {
      parseAtrulePrelude: true,
      parseRulePrelude: true,
      parseValue: true,
      parseCustomProperty: false,
      readSequence: sequence.readSequence,
      consumeUntilBalanceEnd: () => 0,
      consumeUntilLeftCurlyBracket(code) {
        return code === LEFTCURLYBRACKET ? 1 : 0;
      },
      consumeUntilLeftCurlyBracketOrSemicolon(code) {
        return code === LEFTCURLYBRACKET || code === SEMICOLON ? 1 : 0;
      },
      consumeUntilExclamationMarkOrSemicolon(code) {
        return code === EXCLAMATIONMARK || code === SEMICOLON ? 1 : 0;
      },
      consumeUntilSemicolonIncluded(code) {
        return code === SEMICOLON ? 2 : 0;
      },
      createList() {
        return new List.List;
      },
      createSingleNodeList(node) {
        return new List.List().appendData(node);
      },
      getFirstListNode(list) {
        return list && list.first;
      },
      getLastListNode(list) {
        return list && list.last;
      },
      parseWithFallback(consumer, fallback) {
        const startToken = this.tokenIndex;
        try {
          return consumer.call(this);
        } catch (e) {
          if (onParseErrorThrow) {
            throw e;
          }
          const fallbackNode = fallback.call(this, startToken);
          onParseErrorThrow = true;
          onParseError(e, fallbackNode);
          onParseErrorThrow = false;
          return fallbackNode;
        }
      },
      lookupNonWSType(offset) {
        let type;
        do {
          type = this.lookupType(offset++);
          if (type !== types.WhiteSpace) {
            return type;
          }
        } while (type !== NULL);
        return NULL;
      },
      charCodeAt(offset) {
        return offset >= 0 && offset < source.length ? source.charCodeAt(offset) : 0;
      },
      substring(offsetStart, offsetEnd) {
        return source.substring(offsetStart, offsetEnd);
      },
      substrToCursor(start) {
        return this.source.substring(start, this.tokenStart);
      },
      cmpChar(offset, charCode) {
        return utils.cmpChar(source, offset, charCode);
      },
      cmpStr(offsetStart, offsetEnd, str) {
        return utils.cmpStr(source, offsetStart, offsetEnd, str);
      },
      consume(tokenType) {
        const start = this.tokenStart;
        this.eat(tokenType);
        return this.substrToCursor(start);
      },
      consumeFunctionName() {
        const name = source.substring(this.tokenStart, this.tokenEnd - 1);
        this.eat(types.Function);
        return name;
      },
      consumeNumber(type) {
        const number = source.substring(this.tokenStart, utils.consumeNumber(source, this.tokenStart));
        this.eat(type);
        return number;
      },
      eat(tokenType) {
        if (this.tokenType !== tokenType) {
          const tokenName = names[tokenType].slice(0, -6).replace(/-/g, " ").replace(/^./, (m) => m.toUpperCase());
          let message = `${/[[\](){}]/.test(tokenName) ? `"${tokenName}"` : tokenName} is expected`;
          let offset = this.tokenStart;
          switch (tokenType) {
            case types.Ident:
              if (this.tokenType === types.Function || this.tokenType === types.Url) {
                offset = this.tokenEnd - 1;
                message = "Identifier is expected but function found";
              } else {
                message = "Identifier is expected";
              }
              break;
            case types.Hash:
              if (this.isDelim(NUMBERSIGN)) {
                this.next();
                offset++;
                message = "Name is expected";
              }
              break;
            case types.Percentage:
              if (this.tokenType === types.Number) {
                offset = this.tokenEnd;
                message = "Percent sign is expected";
              }
              break;
          }
          this.error(message, offset);
        }
        this.next();
      },
      eatIdent(name) {
        if (this.tokenType !== types.Ident || this.lookupValue(0, name) === false) {
          this.error(`Identifier "${name}" is expected`);
        }
        this.next();
      },
      eatDelim(code) {
        if (!this.isDelim(code)) {
          this.error(`Delim "${String.fromCharCode(code)}" is expected`);
        }
        this.next();
      },
      getLocation(start, end) {
        if (needPositions) {
          return locationMap.getLocationRange(start, end, filename);
        }
        return null;
      },
      getLocationFromList(list) {
        if (needPositions) {
          const head = this.getFirstListNode(list);
          const tail = this.getLastListNode(list);
          return locationMap.getLocationRange(head !== null ? head.loc.start.offset - locationMap.startOffset : this.tokenStart, tail !== null ? tail.loc.end.offset - locationMap.startOffset : this.tokenStart, filename);
        }
        return null;
      },
      error(message, offset) {
        const location = typeof offset !== "undefined" && offset < source.length ? locationMap.getLocation(offset) : this.eof ? locationMap.getLocation(utils.findWhiteSpaceStart(source, source.length - 1)) : locationMap.getLocation(this.tokenStart);
        throw new SyntaxError2.SyntaxError(message || "Unexpected input", source, location.offset, location.line, location.column);
      }
    });
    const parse = function(source_, options) {
      source = source_;
      options = options || {};
      parser.setSource(source, index.tokenize);
      locationMap.setSource(source, options.offset, options.line, options.column);
      filename = options.filename || "<unknown>";
      needPositions = Boolean(options.positions);
      onParseError = typeof options.onParseError === "function" ? options.onParseError : NOOP;
      onParseErrorThrow = false;
      parser.parseAtrulePrelude = "parseAtrulePrelude" in options ? Boolean(options.parseAtrulePrelude) : true;
      parser.parseRulePrelude = "parseRulePrelude" in options ? Boolean(options.parseRulePrelude) : true;
      parser.parseValue = "parseValue" in options ? Boolean(options.parseValue) : true;
      parser.parseCustomProperty = "parseCustomProperty" in options ? Boolean(options.parseCustomProperty) : false;
      const { context = "default", onComment } = options;
      if (context in parser.context === false) {
        throw new Error("Unknown context `" + context + "`");
      }
      if (typeof onComment === "function") {
        parser.forEachToken((type, start, end) => {
          if (type === types.Comment) {
            const loc = parser.getLocation(start, end);
            const value = utils.cmpStr(source, end - 2, end, "*/") ? source.slice(start + 2, end - 2) : source.slice(start + 2, end);
            onComment(value, loc);
          }
        });
      }
      const ast = parser.context[context].call(parser, options);
      if (!parser.eof) {
        parser.error();
      }
      return ast;
    };
    return Object.assign(parse, {
      SyntaxError: SyntaxError2.SyntaxError,
      config: parser.config
    });
  }
  exports.createParser = createParser;
});

// ../../../../node_modules/.bun/css-tree@2.2.1/node_modules/css-tree/cjs/generator/sourceMap.cjs
var require_sourceMap2 = __commonJS((exports) => {
  var sourceMapGenerator_js = require_source_map_generator();
  var trackNodes = new Set(["Atrule", "Selector", "Declaration"]);
  function generateSourceMap(handlers) {
    const map = new sourceMapGenerator_js.SourceMapGenerator;
    const generated = {
      line: 1,
      column: 0
    };
    const original = {
      line: 0,
      column: 0
    };
    const activatedGenerated = {
      line: 1,
      column: 0
    };
    const activatedMapping = {
      generated: activatedGenerated
    };
    let line = 1;
    let column = 0;
    let sourceMappingActive = false;
    const origHandlersNode = handlers.node;
    handlers.node = function(node) {
      if (node.loc && node.loc.start && trackNodes.has(node.type)) {
        const nodeLine = node.loc.start.line;
        const nodeColumn = node.loc.start.column - 1;
        if (original.line !== nodeLine || original.column !== nodeColumn) {
          original.line = nodeLine;
          original.column = nodeColumn;
          generated.line = line;
          generated.column = column;
          if (sourceMappingActive) {
            sourceMappingActive = false;
            if (generated.line !== activatedGenerated.line || generated.column !== activatedGenerated.column) {
              map.addMapping(activatedMapping);
            }
          }
          sourceMappingActive = true;
          map.addMapping({
            source: node.loc.source,
            original,
            generated
          });
        }
      }
      origHandlersNode.call(this, node);
      if (sourceMappingActive && trackNodes.has(node.type)) {
        activatedGenerated.line = line;
        activatedGenerated.column = column;
      }
    };
    const origHandlersEmit = handlers.emit;
    handlers.emit = function(value, type, auto) {
      for (let i = 0;i < value.length; i++) {
        if (value.charCodeAt(i) === 10) {
          line++;
          column = 0;
        } else {
          column++;
        }
      }
      origHandlersEmit(value, type, auto);
    };
    const origHandlersResult = handlers.result;
    handlers.result = function() {
      if (sourceMappingActive) {
        map.addMapping(activatedMapping);
      }
      return {
        css: origHandlersResult(),
        map
      };
    };
    return handlers;
  }
  exports.generateSourceMap = generateSourceMap;
});

// ../../../../node_modules/.bun/css-tree@2.2.1/node_modules/css-tree/cjs/generator/token-before.cjs
var require_token_before2 = __commonJS((exports) => {
  var types = require_types3();
  var PLUSSIGN = 43;
  var HYPHENMINUS = 45;
  var code = (type, value) => {
    if (type === types.Delim) {
      type = value;
    }
    if (typeof type === "string") {
      const charCode = type.charCodeAt(0);
      return charCode > 127 ? 32768 : charCode << 8;
    }
    return type;
  };
  var specPairs = [
    [types.Ident, types.Ident],
    [types.Ident, types.Function],
    [types.Ident, types.Url],
    [types.Ident, types.BadUrl],
    [types.Ident, "-"],
    [types.Ident, types.Number],
    [types.Ident, types.Percentage],
    [types.Ident, types.Dimension],
    [types.Ident, types.CDC],
    [types.Ident, types.LeftParenthesis],
    [types.AtKeyword, types.Ident],
    [types.AtKeyword, types.Function],
    [types.AtKeyword, types.Url],
    [types.AtKeyword, types.BadUrl],
    [types.AtKeyword, "-"],
    [types.AtKeyword, types.Number],
    [types.AtKeyword, types.Percentage],
    [types.AtKeyword, types.Dimension],
    [types.AtKeyword, types.CDC],
    [types.Hash, types.Ident],
    [types.Hash, types.Function],
    [types.Hash, types.Url],
    [types.Hash, types.BadUrl],
    [types.Hash, "-"],
    [types.Hash, types.Number],
    [types.Hash, types.Percentage],
    [types.Hash, types.Dimension],
    [types.Hash, types.CDC],
    [types.Dimension, types.Ident],
    [types.Dimension, types.Function],
    [types.Dimension, types.Url],
    [types.Dimension, types.BadUrl],
    [types.Dimension, "-"],
    [types.Dimension, types.Number],
    [types.Dimension, types.Percentage],
    [types.Dimension, types.Dimension],
    [types.Dimension, types.CDC],
    ["#", types.Ident],
    ["#", types.Function],
    ["#", types.Url],
    ["#", types.BadUrl],
    ["#", "-"],
    ["#", types.Number],
    ["#", types.Percentage],
    ["#", types.Dimension],
    ["#", types.CDC],
    ["-", types.Ident],
    ["-", types.Function],
    ["-", types.Url],
    ["-", types.BadUrl],
    ["-", "-"],
    ["-", types.Number],
    ["-", types.Percentage],
    ["-", types.Dimension],
    ["-", types.CDC],
    [types.Number, types.Ident],
    [types.Number, types.Function],
    [types.Number, types.Url],
    [types.Number, types.BadUrl],
    [types.Number, types.Number],
    [types.Number, types.Percentage],
    [types.Number, types.Dimension],
    [types.Number, "%"],
    [types.Number, types.CDC],
    ["@", types.Ident],
    ["@", types.Function],
    ["@", types.Url],
    ["@", types.BadUrl],
    ["@", "-"],
    ["@", types.CDC],
    [".", types.Number],
    [".", types.Percentage],
    [".", types.Dimension],
    ["+", types.Number],
    ["+", types.Percentage],
    ["+", types.Dimension],
    ["/", "*"]
  ];
  var safePairs = specPairs.concat([
    [types.Ident, types.Hash],
    [types.Dimension, types.Hash],
    [types.Hash, types.Hash],
    [types.AtKeyword, types.LeftParenthesis],
    [types.AtKeyword, types.String],
    [types.AtKeyword, types.Colon],
    [types.Percentage, types.Percentage],
    [types.Percentage, types.Dimension],
    [types.Percentage, types.Function],
    [types.Percentage, "-"],
    [types.RightParenthesis, types.Ident],
    [types.RightParenthesis, types.Function],
    [types.RightParenthesis, types.Percentage],
    [types.RightParenthesis, types.Dimension],
    [types.RightParenthesis, types.Hash],
    [types.RightParenthesis, "-"]
  ]);
  function createMap(pairs) {
    const isWhiteSpaceRequired = new Set(pairs.map(([prev, next]) => code(prev) << 16 | code(next)));
    return function(prevCode, type, value) {
      const nextCode = code(type, value);
      const nextCharCode = value.charCodeAt(0);
      const emitWs = nextCharCode === HYPHENMINUS && type !== types.Ident && type !== types.Function && type !== types.CDC || nextCharCode === PLUSSIGN ? isWhiteSpaceRequired.has(prevCode << 16 | nextCharCode << 8) : isWhiteSpaceRequired.has(prevCode << 16 | nextCode);
      if (emitWs) {
        this.emit(" ", types.WhiteSpace, true);
      }
      return nextCode;
    };
  }
  var spec = createMap(specPairs);
  var safe = createMap(safePairs);
  exports.safe = safe;
  exports.spec = spec;
});

// ../../../../node_modules/.bun/css-tree@2.2.1/node_modules/css-tree/cjs/generator/create.cjs
var require_create7 = __commonJS((exports) => {
  var index = require_tokenizer3();
  var sourceMap = require_sourceMap2();
  var tokenBefore = require_token_before2();
  var types = require_types3();
  var REVERSESOLIDUS = 92;
  function processChildren(node, delimeter) {
    if (typeof delimeter === "function") {
      let prev = null;
      node.children.forEach((node2) => {
        if (prev !== null) {
          delimeter.call(this, prev);
        }
        this.node(node2);
        prev = node2;
      });
      return;
    }
    node.children.forEach(this.node, this);
  }
  function processChunk(chunk) {
    index.tokenize(chunk, (type, start, end) => {
      this.token(type, chunk.slice(start, end));
    });
  }
  function createGenerator(config) {
    const types$1 = new Map;
    for (let name in config.node) {
      const item = config.node[name];
      const fn = item.generate || item;
      if (typeof fn === "function") {
        types$1.set(name, item.generate || item);
      }
    }
    return function(node, options) {
      let buffer = "";
      let prevCode = 0;
      let handlers = {
        node(node2) {
          if (types$1.has(node2.type)) {
            types$1.get(node2.type).call(publicApi, node2);
          } else {
            throw new Error("Unknown node type: " + node2.type);
          }
        },
        tokenBefore: tokenBefore.safe,
        token(type, value) {
          prevCode = this.tokenBefore(prevCode, type, value);
          this.emit(value, type, false);
          if (type === types.Delim && value.charCodeAt(0) === REVERSESOLIDUS) {
            this.emit(`
`, types.WhiteSpace, true);
          }
        },
        emit(value) {
          buffer += value;
        },
        result() {
          return buffer;
        }
      };
      if (options) {
        if (typeof options.decorator === "function") {
          handlers = options.decorator(handlers);
        }
        if (options.sourceMap) {
          handlers = sourceMap.generateSourceMap(handlers);
        }
        if (options.mode in tokenBefore) {
          handlers.tokenBefore = tokenBefore[options.mode];
        }
      }
      const publicApi = {
        node: (node2) => handlers.node(node2),
        children: processChildren,
        token: (type, value) => handlers.token(type, value),
        tokenize: processChunk
      };
      handlers.node(node);
      return handlers.result();
    };
  }
  exports.createGenerator = createGenerator;
});

// ../../../../node_modules/.bun/css-tree@2.2.1/node_modules/css-tree/cjs/convertor/create.cjs
var require_create8 = __commonJS((exports) => {
  var List = require_List2();
  function createConvertor(walk) {
    return {
      fromPlainObject(ast) {
        walk(ast, {
          enter(node) {
            if (node.children && node.children instanceof List.List === false) {
              node.children = new List.List().fromArray(node.children);
            }
          }
        });
        return ast;
      },
      toPlainObject(ast) {
        walk(ast, {
          leave(node) {
            if (node.children && node.children instanceof List.List) {
              node.children = node.children.toArray();
            }
          }
        });
        return ast;
      }
    };
  }
  exports.createConvertor = createConvertor;
});

// ../../../../node_modules/.bun/css-tree@2.2.1/node_modules/css-tree/cjs/walker/create.cjs
var require_create9 = __commonJS((exports) => {
  var { hasOwnProperty: hasOwnProperty2 } = Object.prototype;
  var noop = function() {};
  function ensureFunction(value) {
    return typeof value === "function" ? value : noop;
  }
  function invokeForType(fn, type) {
    return function(node, item, list) {
      if (node.type === type) {
        fn.call(this, node, item, list);
      }
    };
  }
  function getWalkersFromStructure(name, nodeType) {
    const structure = nodeType.structure;
    const walkers = [];
    for (const key in structure) {
      if (hasOwnProperty2.call(structure, key) === false) {
        continue;
      }
      let fieldTypes = structure[key];
      const walker = {
        name: key,
        type: false,
        nullable: false
      };
      if (!Array.isArray(fieldTypes)) {
        fieldTypes = [fieldTypes];
      }
      for (const fieldType of fieldTypes) {
        if (fieldType === null) {
          walker.nullable = true;
        } else if (typeof fieldType === "string") {
          walker.type = "node";
        } else if (Array.isArray(fieldType)) {
          walker.type = "list";
        }
      }
      if (walker.type) {
        walkers.push(walker);
      }
    }
    if (walkers.length) {
      return {
        context: nodeType.walkContext,
        fields: walkers
      };
    }
    return null;
  }
  function getTypesFromConfig(config) {
    const types = {};
    for (const name in config.node) {
      if (hasOwnProperty2.call(config.node, name)) {
        const nodeType = config.node[name];
        if (!nodeType.structure) {
          throw new Error("Missed `structure` field in `" + name + "` node type definition");
        }
        types[name] = getWalkersFromStructure(name, nodeType);
      }
    }
    return types;
  }
  function createTypeIterator(config, reverse) {
    const fields = config.fields.slice();
    const contextName = config.context;
    const useContext = typeof contextName === "string";
    if (reverse) {
      fields.reverse();
    }
    return function(node, context, walk, walkReducer) {
      let prevContextValue;
      if (useContext) {
        prevContextValue = context[contextName];
        context[contextName] = node;
      }
      for (const field of fields) {
        const ref = node[field.name];
        if (!field.nullable || ref) {
          if (field.type === "list") {
            const breakWalk = reverse ? ref.reduceRight(walkReducer, false) : ref.reduce(walkReducer, false);
            if (breakWalk) {
              return true;
            }
          } else if (walk(ref)) {
            return true;
          }
        }
      }
      if (useContext) {
        context[contextName] = prevContextValue;
      }
    };
  }
  function createFastTraveralMap({
    StyleSheet,
    Atrule,
    Rule,
    Block,
    DeclarationList
  }) {
    return {
      Atrule: {
        StyleSheet,
        Atrule,
        Rule,
        Block
      },
      Rule: {
        StyleSheet,
        Atrule,
        Rule,
        Block
      },
      Declaration: {
        StyleSheet,
        Atrule,
        Rule,
        Block,
        DeclarationList
      }
    };
  }
  function createWalker(config) {
    const types = getTypesFromConfig(config);
    const iteratorsNatural = {};
    const iteratorsReverse = {};
    const breakWalk = Symbol("break-walk");
    const skipNode = Symbol("skip-node");
    for (const name in types) {
      if (hasOwnProperty2.call(types, name) && types[name] !== null) {
        iteratorsNatural[name] = createTypeIterator(types[name], false);
        iteratorsReverse[name] = createTypeIterator(types[name], true);
      }
    }
    const fastTraversalIteratorsNatural = createFastTraveralMap(iteratorsNatural);
    const fastTraversalIteratorsReverse = createFastTraveralMap(iteratorsReverse);
    const walk = function(root, options) {
      function walkNode(node, item, list) {
        const enterRet = enter.call(context, node, item, list);
        if (enterRet === breakWalk) {
          return true;
        }
        if (enterRet === skipNode) {
          return false;
        }
        if (iterators.hasOwnProperty(node.type)) {
          if (iterators[node.type](node, context, walkNode, walkReducer)) {
            return true;
          }
        }
        if (leave.call(context, node, item, list) === breakWalk) {
          return true;
        }
        return false;
      }
      let enter = noop;
      let leave = noop;
      let iterators = iteratorsNatural;
      let walkReducer = (ret, data, item, list) => ret || walkNode(data, item, list);
      const context = {
        break: breakWalk,
        skip: skipNode,
        root,
        stylesheet: null,
        atrule: null,
        atrulePrelude: null,
        rule: null,
        selector: null,
        block: null,
        declaration: null,
        function: null
      };
      if (typeof options === "function") {
        enter = options;
      } else if (options) {
        enter = ensureFunction(options.enter);
        leave = ensureFunction(options.leave);
        if (options.reverse) {
          iterators = iteratorsReverse;
        }
        if (options.visit) {
          if (fastTraversalIteratorsNatural.hasOwnProperty(options.visit)) {
            iterators = options.reverse ? fastTraversalIteratorsReverse[options.visit] : fastTraversalIteratorsNatural[options.visit];
          } else if (!types.hasOwnProperty(options.visit)) {
            throw new Error("Bad value `" + options.visit + "` for `visit` option (should be: " + Object.keys(types).sort().join(", ") + ")");
          }
          enter = invokeForType(enter, options.visit);
          leave = invokeForType(leave, options.visit);
        }
      }
      if (enter === noop && leave === noop) {
        throw new Error("Neither `enter` nor `leave` walker handler is set or both aren't a function");
      }
      walkNode(root);
    };
    walk.break = breakWalk;
    walk.skip = skipNode;
    walk.find = function(ast, fn) {
      let found = null;
      walk(ast, function(node, item, list) {
        if (fn.call(this, node, item, list)) {
          found = node;
          return breakWalk;
        }
      });
      return found;
    };
    walk.findLast = function(ast, fn) {
      let found = null;
      walk(ast, {
        reverse: true,
        enter(node, item, list) {
          if (fn.call(this, node, item, list)) {
            found = node;
            return breakWalk;
          }
        }
      });
      return found;
    };
    walk.findAll = function(ast, fn) {
      const found = [];
      walk(ast, function(node, item, list) {
        if (fn.call(this, node, item, list)) {
          found.push(node);
        }
      });
      return found;
    };
    return walk;
  }
  exports.createWalker = createWalker;
});

// ../../../../node_modules/.bun/css-tree@2.2.1/node_modules/css-tree/cjs/definition-syntax/generate.cjs
var require_generate2 = __commonJS((exports) => {
  function noop(value) {
    return value;
  }
  function generateMultiplier(multiplier) {
    const { min, max, comma } = multiplier;
    if (min === 0 && max === 0) {
      return comma ? "#?" : "*";
    }
    if (min === 0 && max === 1) {
      return "?";
    }
    if (min === 1 && max === 0) {
      return comma ? "#" : "+";
    }
    if (min === 1 && max === 1) {
      return "";
    }
    return (comma ? "#" : "") + (min === max ? "{" + min + "}" : "{" + min + "," + (max !== 0 ? max : "") + "}");
  }
  function generateTypeOpts(node) {
    switch (node.type) {
      case "Range":
        return " [" + (node.min === null ? "-" : node.min) + "," + (node.max === null ? "" : node.max) + "]";
      default:
        throw new Error("Unknown node type `" + node.type + "`");
    }
  }
  function generateSequence(node, decorate, forceBraces, compact) {
    const combinator = node.combinator === " " || compact ? node.combinator : " " + node.combinator + " ";
    const result = node.terms.map((term) => internalGenerate(term, decorate, forceBraces, compact)).join(combinator);
    if (node.explicit || forceBraces) {
      return (compact || result[0] === "," ? "[" : "[ ") + result + (compact ? "]" : " ]");
    }
    return result;
  }
  function internalGenerate(node, decorate, forceBraces, compact) {
    let result;
    switch (node.type) {
      case "Group":
        result = generateSequence(node, decorate, forceBraces, compact) + (node.disallowEmpty ? "!" : "");
        break;
      case "Multiplier":
        return internalGenerate(node.term, decorate, forceBraces, compact) + decorate(generateMultiplier(node), node);
      case "Type":
        result = "<" + node.name + (node.opts ? decorate(generateTypeOpts(node.opts), node.opts) : "") + ">";
        break;
      case "Property":
        result = "<'" + node.name + "'>";
        break;
      case "Keyword":
        result = node.name;
        break;
      case "AtKeyword":
        result = "@" + node.name;
        break;
      case "Function":
        result = node.name + "(";
        break;
      case "String":
      case "Token":
        result = node.value;
        break;
      case "Comma":
        result = ",";
        break;
      default:
        throw new Error("Unknown node type `" + node.type + "`");
    }
    return decorate(result, node);
  }
  function generate(node, options) {
    let decorate = noop;
    let forceBraces = false;
    let compact = false;
    if (typeof options === "function") {
      decorate = options;
    } else if (options) {
      forceBraces = Boolean(options.forceBraces);
      compact = Boolean(options.compact);
      if (typeof options.decorate === "function") {
        decorate = options.decorate;
      }
    }
    return internalGenerate(node, decorate, forceBraces, compact);
  }
  exports.generate = generate;
});

// ../../../../node_modules/.bun/css-tree@2.2.1/node_modules/css-tree/cjs/lexer/error.cjs
var require_error2 = __commonJS((exports) => {
  var createCustomError = require_create_custom_error2();
  var generate = require_generate2();
  var defaultLoc = { offset: 0, line: 1, column: 1 };
  function locateMismatch(matchResult, node) {
    const tokens = matchResult.tokens;
    const longestMatch = matchResult.longestMatch;
    const mismatchNode = longestMatch < tokens.length ? tokens[longestMatch].node || null : null;
    const badNode = mismatchNode !== node ? mismatchNode : null;
    let mismatchOffset = 0;
    let mismatchLength = 0;
    let entries = 0;
    let css = "";
    let start;
    let end;
    for (let i = 0;i < tokens.length; i++) {
      const token = tokens[i].value;
      if (i === longestMatch) {
        mismatchLength = token.length;
        mismatchOffset = css.length;
      }
      if (badNode !== null && tokens[i].node === badNode) {
        if (i <= longestMatch) {
          entries++;
        } else {
          entries = 0;
        }
      }
      css += token;
    }
    if (longestMatch === tokens.length || entries > 1) {
      start = fromLoc(badNode || node, "end") || buildLoc(defaultLoc, css);
      end = buildLoc(start);
    } else {
      start = fromLoc(badNode, "start") || buildLoc(fromLoc(node, "start") || defaultLoc, css.slice(0, mismatchOffset));
      end = fromLoc(badNode, "end") || buildLoc(start, css.substr(mismatchOffset, mismatchLength));
    }
    return {
      css,
      mismatchOffset,
      mismatchLength,
      start,
      end
    };
  }
  function fromLoc(node, point) {
    const value = node && node.loc && node.loc[point];
    if (value) {
      return "line" in value ? buildLoc(value) : value;
    }
    return null;
  }
  function buildLoc({ offset, line, column }, extra) {
    const loc = {
      offset,
      line,
      column
    };
    if (extra) {
      const lines = extra.split(/\n|\r\n?|\f/);
      loc.offset += extra.length;
      loc.line += lines.length - 1;
      loc.column = lines.length === 1 ? loc.column + extra.length : lines.pop().length + 1;
    }
    return loc;
  }
  var SyntaxReferenceError = function(type, referenceName) {
    const error = createCustomError.createCustomError("SyntaxReferenceError", type + (referenceName ? " `" + referenceName + "`" : ""));
    error.reference = referenceName;
    return error;
  };
  var SyntaxMatchError = function(message, syntax, node, matchResult) {
    const error = createCustomError.createCustomError("SyntaxMatchError", message);
    const {
      css,
      mismatchOffset,
      mismatchLength,
      start,
      end
    } = locateMismatch(matchResult, node);
    error.rawMessage = message;
    error.syntax = syntax ? generate.generate(syntax) : "<generic>";
    error.css = css;
    error.mismatchOffset = mismatchOffset;
    error.mismatchLength = mismatchLength;
    error.message = message + `
` + "  syntax: " + error.syntax + `
` + "   value: " + (css || "<empty string>") + `
` + "  --------" + new Array(error.mismatchOffset + 1).join("-") + "^";
    Object.assign(error, start);
    error.loc = {
      source: node && node.loc && node.loc.source || "<unknown>",
      start,
      end
    };
    return error;
  };
  exports.SyntaxMatchError = SyntaxMatchError;
  exports.SyntaxReferenceError = SyntaxReferenceError;
});

// ../../../../node_modules/.bun/css-tree@2.2.1/node_modules/css-tree/cjs/utils/names.cjs
var require_names4 = __commonJS((exports) => {
  var keywords = new Map;
  var properties = new Map;
  var HYPHENMINUS = 45;
  var keyword = getKeywordDescriptor;
  var property = getPropertyDescriptor;
  var vendorPrefix = getVendorPrefix;
  function isCustomProperty(str, offset) {
    offset = offset || 0;
    return str.length - offset >= 2 && str.charCodeAt(offset) === HYPHENMINUS && str.charCodeAt(offset + 1) === HYPHENMINUS;
  }
  function getVendorPrefix(str, offset) {
    offset = offset || 0;
    if (str.length - offset >= 3) {
      if (str.charCodeAt(offset) === HYPHENMINUS && str.charCodeAt(offset + 1) !== HYPHENMINUS) {
        const secondDashIndex = str.indexOf("-", offset + 2);
        if (secondDashIndex !== -1) {
          return str.substring(offset, secondDashIndex + 1);
        }
      }
    }
    return "";
  }
  function getKeywordDescriptor(keyword2) {
    if (keywords.has(keyword2)) {
      return keywords.get(keyword2);
    }
    const name = keyword2.toLowerCase();
    let descriptor = keywords.get(name);
    if (descriptor === undefined) {
      const custom = isCustomProperty(name, 0);
      const vendor = !custom ? getVendorPrefix(name, 0) : "";
      descriptor = Object.freeze({
        basename: name.substr(vendor.length),
        name,
        prefix: vendor,
        vendor,
        custom
      });
    }
    keywords.set(keyword2, descriptor);
    return descriptor;
  }
  function getPropertyDescriptor(property2) {
    if (properties.has(property2)) {
      return properties.get(property2);
    }
    let name = property2;
    let hack = property2[0];
    if (hack === "/") {
      hack = property2[1] === "/" ? "//" : "/";
    } else if (hack !== "_" && hack !== "*" && hack !== "$" && hack !== "#" && hack !== "+" && hack !== "&") {
      hack = "";
    }
    const custom = isCustomProperty(name, hack.length);
    if (!custom) {
      name = name.toLowerCase();
      if (properties.has(name)) {
        const descriptor2 = properties.get(name);
        properties.set(property2, descriptor2);
        return descriptor2;
      }
    }
    const vendor = !custom ? getVendorPrefix(name, hack.length) : "";
    const prefix = name.substr(0, hack.length + vendor.length);
    const descriptor = Object.freeze({
      basename: name.substr(prefix.length),
      name: name.substr(hack.length),
      hack,
      vendor,
      prefix,
      custom
    });
    properties.set(property2, descriptor);
    return descriptor;
  }
  exports.isCustomProperty = isCustomProperty;
  exports.keyword = keyword;
  exports.property = property;
  exports.vendorPrefix = vendorPrefix;
});

// ../../../../node_modules/.bun/css-tree@2.2.1/node_modules/css-tree/cjs/lexer/generic-const.cjs
var require_generic_const2 = __commonJS((exports) => {
  var cssWideKeywords = [
    "initial",
    "inherit",
    "unset",
    "revert",
    "revert-layer"
  ];
  exports.cssWideKeywords = cssWideKeywords;
});

// ../../../../node_modules/.bun/css-tree@2.2.1/node_modules/css-tree/cjs/lexer/generic-an-plus-b.cjs
var require_generic_an_plus_b2 = __commonJS((exports, module) => {
  var charCodeDefinitions = require_char_code_definitions2();
  var types = require_types3();
  var utils = require_utils2();
  var PLUSSIGN = 43;
  var HYPHENMINUS = 45;
  var N = 110;
  var DISALLOW_SIGN = true;
  var ALLOW_SIGN = false;
  function isDelim(token, code) {
    return token !== null && token.type === types.Delim && token.value.charCodeAt(0) === code;
  }
  function skipSC(token, offset, getNextToken) {
    while (token !== null && (token.type === types.WhiteSpace || token.type === types.Comment)) {
      token = getNextToken(++offset);
    }
    return offset;
  }
  function checkInteger(token, valueOffset, disallowSign, offset) {
    if (!token) {
      return 0;
    }
    const code = token.value.charCodeAt(valueOffset);
    if (code === PLUSSIGN || code === HYPHENMINUS) {
      if (disallowSign) {
        return 0;
      }
      valueOffset++;
    }
    for (;valueOffset < token.value.length; valueOffset++) {
      if (!charCodeDefinitions.isDigit(token.value.charCodeAt(valueOffset))) {
        return 0;
      }
    }
    return offset + 1;
  }
  function consumeB(token, offset_, getNextToken) {
    let sign = false;
    let offset = skipSC(token, offset_, getNextToken);
    token = getNextToken(offset);
    if (token === null) {
      return offset_;
    }
    if (token.type !== types.Number) {
      if (isDelim(token, PLUSSIGN) || isDelim(token, HYPHENMINUS)) {
        sign = true;
        offset = skipSC(getNextToken(++offset), offset, getNextToken);
        token = getNextToken(offset);
        if (token === null || token.type !== types.Number) {
          return 0;
        }
      } else {
        return offset_;
      }
    }
    if (!sign) {
      const code = token.value.charCodeAt(0);
      if (code !== PLUSSIGN && code !== HYPHENMINUS) {
        return 0;
      }
    }
    return checkInteger(token, sign ? 0 : 1, sign, offset);
  }
  function anPlusB(token, getNextToken) {
    let offset = 0;
    if (!token) {
      return 0;
    }
    if (token.type === types.Number) {
      return checkInteger(token, 0, ALLOW_SIGN, offset);
    } else if (token.type === types.Ident && token.value.charCodeAt(0) === HYPHENMINUS) {
      if (!utils.cmpChar(token.value, 1, N)) {
        return 0;
      }
      switch (token.value.length) {
        case 2:
          return consumeB(getNextToken(++offset), offset, getNextToken);
        case 3:
          if (token.value.charCodeAt(2) !== HYPHENMINUS) {
            return 0;
          }
          offset = skipSC(getNextToken(++offset), offset, getNextToken);
          token = getNextToken(offset);
          return checkInteger(token, 0, DISALLOW_SIGN, offset);
        default:
          if (token.value.charCodeAt(2) !== HYPHENMINUS) {
            return 0;
          }
          return checkInteger(token, 3, DISALLOW_SIGN, offset);
      }
    } else if (token.type === types.Ident || isDelim(token, PLUSSIGN) && getNextToken(offset + 1).type === types.Ident) {
      if (token.type !== types.Ident) {
        token = getNextToken(++offset);
      }
      if (token === null || !utils.cmpChar(token.value, 0, N)) {
        return 0;
      }
      switch (token.value.length) {
        case 1:
          return consumeB(getNextToken(++offset), offset, getNextToken);
        case 2:
          if (token.value.charCodeAt(1) !== HYPHENMINUS) {
            return 0;
          }
          offset = skipSC(getNextToken(++offset), offset, getNextToken);
          token = getNextToken(offset);
          return checkInteger(token, 0, DISALLOW_SIGN, offset);
        default:
          if (token.value.charCodeAt(1) !== HYPHENMINUS) {
            return 0;
          }
          return checkInteger(token, 2, DISALLOW_SIGN, offset);
      }
    } else if (token.type === types.Dimension) {
      let code = token.value.charCodeAt(0);
      let sign = code === PLUSSIGN || code === HYPHENMINUS ? 1 : 0;
      let i = sign;
      for (;i < token.value.length; i++) {
        if (!charCodeDefinitions.isDigit(token.value.charCodeAt(i))) {
          break;
        }
      }
      if (i === sign) {
        return 0;
      }
      if (!utils.cmpChar(token.value, i, N)) {
        return 0;
      }
      if (i + 1 === token.value.length) {
        return consumeB(getNextToken(++offset), offset, getNextToken);
      } else {
        if (token.value.charCodeAt(i + 1) !== HYPHENMINUS) {
          return 0;
        }
        if (i + 2 === token.value.length) {
          offset = skipSC(getNextToken(++offset), offset, getNextToken);
          token = getNextToken(offset);
          return checkInteger(token, 0, DISALLOW_SIGN, offset);
        } else {
          return checkInteger(token, i + 2, DISALLOW_SIGN, offset);
        }
      }
    }
    return 0;
  }
  module.exports = anPlusB;
});

// ../../../../node_modules/.bun/css-tree@2.2.1/node_modules/css-tree/cjs/lexer/generic-urange.cjs
var require_generic_urange2 = __commonJS((exports, module) => {
  var charCodeDefinitions = require_char_code_definitions2();
  var types = require_types3();
  var utils = require_utils2();
  var PLUSSIGN = 43;
  var HYPHENMINUS = 45;
  var QUESTIONMARK = 63;
  var U = 117;
  function isDelim(token, code) {
    return token !== null && token.type === types.Delim && token.value.charCodeAt(0) === code;
  }
  function startsWith(token, code) {
    return token.value.charCodeAt(0) === code;
  }
  function hexSequence(token, offset, allowDash) {
    let hexlen = 0;
    for (let pos = offset;pos < token.value.length; pos++) {
      const code = token.value.charCodeAt(pos);
      if (code === HYPHENMINUS && allowDash && hexlen !== 0) {
        hexSequence(token, offset + hexlen + 1, false);
        return 6;
      }
      if (!charCodeDefinitions.isHexDigit(code)) {
        return 0;
      }
      if (++hexlen > 6) {
        return 0;
      }
    }
    return hexlen;
  }
  function withQuestionMarkSequence(consumed, length, getNextToken) {
    if (!consumed) {
      return 0;
    }
    while (isDelim(getNextToken(length), QUESTIONMARK)) {
      if (++consumed > 6) {
        return 0;
      }
      length++;
    }
    return length;
  }
  function urange(token, getNextToken) {
    let length = 0;
    if (token === null || token.type !== types.Ident || !utils.cmpChar(token.value, 0, U)) {
      return 0;
    }
    token = getNextToken(++length);
    if (token === null) {
      return 0;
    }
    if (isDelim(token, PLUSSIGN)) {
      token = getNextToken(++length);
      if (token === null) {
        return 0;
      }
      if (token.type === types.Ident) {
        return withQuestionMarkSequence(hexSequence(token, 0, true), ++length, getNextToken);
      }
      if (isDelim(token, QUESTIONMARK)) {
        return withQuestionMarkSequence(1, ++length, getNextToken);
      }
      return 0;
    }
    if (token.type === types.Number) {
      const consumedHexLength = hexSequence(token, 1, true);
      if (consumedHexLength === 0) {
        return 0;
      }
      token = getNextToken(++length);
      if (token === null) {
        return length;
      }
      if (token.type === types.Dimension || token.type === types.Number) {
        if (!startsWith(token, HYPHENMINUS) || !hexSequence(token, 1, false)) {
          return 0;
        }
        return length + 1;
      }
      return withQuestionMarkSequence(consumedHexLength, length, getNextToken);
    }
    if (token.type === types.Dimension) {
      return withQuestionMarkSequence(hexSequence(token, 1, true), ++length, getNextToken);
    }
    return 0;
  }
  module.exports = urange;
});

// ../../../../node_modules/.bun/css-tree@2.2.1/node_modules/css-tree/cjs/lexer/generic.cjs
var require_generic2 = __commonJS((exports, module) => {
  var genericConst = require_generic_const2();
  var genericAnPlusB = require_generic_an_plus_b2();
  var genericUrange = require_generic_urange2();
  var types = require_types3();
  var charCodeDefinitions = require_char_code_definitions2();
  var utils = require_utils2();
  var calcFunctionNames = ["calc(", "-moz-calc(", "-webkit-calc("];
  var balancePair = new Map([
    [types.Function, types.RightParenthesis],
    [types.LeftParenthesis, types.RightParenthesis],
    [types.LeftSquareBracket, types.RightSquareBracket],
    [types.LeftCurlyBracket, types.RightCurlyBracket]
  ]);
  var LENGTH = [
    "cm",
    "mm",
    "q",
    "in",
    "pt",
    "pc",
    "px",
    "em",
    "rem",
    "ex",
    "rex",
    "cap",
    "rcap",
    "ch",
    "rch",
    "ic",
    "ric",
    "lh",
    "rlh",
    "vw",
    "svw",
    "lvw",
    "dvw",
    "vh",
    "svh",
    "lvh",
    "dvh",
    "vi",
    "svi",
    "lvi",
    "dvi",
    "vb",
    "svb",
    "lvb",
    "dvb",
    "vmin",
    "svmin",
    "lvmin",
    "dvmin",
    "vmax",
    "svmax",
    "lvmax",
    "dvmax",
    "cqw",
    "cqh",
    "cqi",
    "cqb",
    "cqmin",
    "cqmax"
  ];
  var ANGLE = ["deg", "grad", "rad", "turn"];
  var TIME = ["s", "ms"];
  var FREQUENCY = ["hz", "khz"];
  var RESOLUTION = ["dpi", "dpcm", "dppx", "x"];
  var FLEX = ["fr"];
  var DECIBEL = ["db"];
  var SEMITONES = ["st"];
  function charCodeAt(str, index) {
    return index < str.length ? str.charCodeAt(index) : 0;
  }
  function eqStr(actual, expected) {
    return utils.cmpStr(actual, 0, actual.length, expected);
  }
  function eqStrAny(actual, expected) {
    for (let i = 0;i < expected.length; i++) {
      if (eqStr(actual, expected[i])) {
        return true;
      }
    }
    return false;
  }
  function isPostfixIeHack(str, offset) {
    if (offset !== str.length - 2) {
      return false;
    }
    return charCodeAt(str, offset) === 92 && charCodeDefinitions.isDigit(charCodeAt(str, offset + 1));
  }
  function outOfRange(opts, value, numEnd) {
    if (opts && opts.type === "Range") {
      const num = Number(numEnd !== undefined && numEnd !== value.length ? value.substr(0, numEnd) : value);
      if (isNaN(num)) {
        return true;
      }
      if (opts.min !== null && num < opts.min && typeof opts.min !== "string") {
        return true;
      }
      if (opts.max !== null && num > opts.max && typeof opts.max !== "string") {
        return true;
      }
    }
    return false;
  }
  function consumeFunction(token, getNextToken) {
    let balanceCloseType = 0;
    let balanceStash = [];
    let length = 0;
    scan:
      do {
        switch (token.type) {
          case types.RightCurlyBracket:
          case types.RightParenthesis:
          case types.RightSquareBracket:
            if (token.type !== balanceCloseType) {
              break scan;
            }
            balanceCloseType = balanceStash.pop();
            if (balanceStash.length === 0) {
              length++;
              break scan;
            }
            break;
          case types.Function:
          case types.LeftParenthesis:
          case types.LeftSquareBracket:
          case types.LeftCurlyBracket:
            balanceStash.push(balanceCloseType);
            balanceCloseType = balancePair.get(token.type);
            break;
        }
        length++;
      } while (token = getNextToken(length));
    return length;
  }
  function calc(next) {
    return function(token, getNextToken, opts) {
      if (token === null) {
        return 0;
      }
      if (token.type === types.Function && eqStrAny(token.value, calcFunctionNames)) {
        return consumeFunction(token, getNextToken);
      }
      return next(token, getNextToken, opts);
    };
  }
  function tokenType(expectedTokenType) {
    return function(token) {
      if (token === null || token.type !== expectedTokenType) {
        return 0;
      }
      return 1;
    };
  }
  function customIdent(token) {
    if (token === null || token.type !== types.Ident) {
      return 0;
    }
    const name = token.value.toLowerCase();
    if (eqStrAny(name, genericConst.cssWideKeywords)) {
      return 0;
    }
    if (eqStr(name, "default")) {
      return 0;
    }
    return 1;
  }
  function customPropertyName(token) {
    if (token === null || token.type !== types.Ident) {
      return 0;
    }
    if (charCodeAt(token.value, 0) !== 45 || charCodeAt(token.value, 1) !== 45) {
      return 0;
    }
    return 1;
  }
  function hexColor(token) {
    if (token === null || token.type !== types.Hash) {
      return 0;
    }
    const length = token.value.length;
    if (length !== 4 && length !== 5 && length !== 7 && length !== 9) {
      return 0;
    }
    for (let i = 1;i < length; i++) {
      if (!charCodeDefinitions.isHexDigit(charCodeAt(token.value, i))) {
        return 0;
      }
    }
    return 1;
  }
  function idSelector(token) {
    if (token === null || token.type !== types.Hash) {
      return 0;
    }
    if (!charCodeDefinitions.isIdentifierStart(charCodeAt(token.value, 1), charCodeAt(token.value, 2), charCodeAt(token.value, 3))) {
      return 0;
    }
    return 1;
  }
  function declarationValue(token, getNextToken) {
    if (!token) {
      return 0;
    }
    let balanceCloseType = 0;
    let balanceStash = [];
    let length = 0;
    scan:
      do {
        switch (token.type) {
          case types.BadString:
          case types.BadUrl:
            break scan;
          case types.RightCurlyBracket:
          case types.RightParenthesis:
          case types.RightSquareBracket:
            if (token.type !== balanceCloseType) {
              break scan;
            }
            balanceCloseType = balanceStash.pop();
            break;
          case types.Semicolon:
            if (balanceCloseType === 0) {
              break scan;
            }
            break;
          case types.Delim:
            if (balanceCloseType === 0 && token.value === "!") {
              break scan;
            }
            break;
          case types.Function:
          case types.LeftParenthesis:
          case types.LeftSquareBracket:
          case types.LeftCurlyBracket:
            balanceStash.push(balanceCloseType);
            balanceCloseType = balancePair.get(token.type);
            break;
        }
        length++;
      } while (token = getNextToken(length));
    return length;
  }
  function anyValue(token, getNextToken) {
    if (!token) {
      return 0;
    }
    let balanceCloseType = 0;
    let balanceStash = [];
    let length = 0;
    scan:
      do {
        switch (token.type) {
          case types.BadString:
          case types.BadUrl:
            break scan;
          case types.RightCurlyBracket:
          case types.RightParenthesis:
          case types.RightSquareBracket:
            if (token.type !== balanceCloseType) {
              break scan;
            }
            balanceCloseType = balanceStash.pop();
            break;
          case types.Function:
          case types.LeftParenthesis:
          case types.LeftSquareBracket:
          case types.LeftCurlyBracket:
            balanceStash.push(balanceCloseType);
            balanceCloseType = balancePair.get(token.type);
            break;
        }
        length++;
      } while (token = getNextToken(length));
    return length;
  }
  function dimension(type) {
    if (type) {
      type = new Set(type);
    }
    return function(token, getNextToken, opts) {
      if (token === null || token.type !== types.Dimension) {
        return 0;
      }
      const numberEnd = utils.consumeNumber(token.value, 0);
      if (type !== null) {
        const reverseSolidusOffset = token.value.indexOf("\\", numberEnd);
        const unit = reverseSolidusOffset === -1 || !isPostfixIeHack(token.value, reverseSolidusOffset) ? token.value.substr(numberEnd) : token.value.substring(numberEnd, reverseSolidusOffset);
        if (type.has(unit.toLowerCase()) === false) {
          return 0;
        }
      }
      if (outOfRange(opts, token.value, numberEnd)) {
        return 0;
      }
      return 1;
    };
  }
  function percentage(token, getNextToken, opts) {
    if (token === null || token.type !== types.Percentage) {
      return 0;
    }
    if (outOfRange(opts, token.value, token.value.length - 1)) {
      return 0;
    }
    return 1;
  }
  function zero(next) {
    if (typeof next !== "function") {
      next = function() {
        return 0;
      };
    }
    return function(token, getNextToken, opts) {
      if (token !== null && token.type === types.Number) {
        if (Number(token.value) === 0) {
          return 1;
        }
      }
      return next(token, getNextToken, opts);
    };
  }
  function number(token, getNextToken, opts) {
    if (token === null) {
      return 0;
    }
    const numberEnd = utils.consumeNumber(token.value, 0);
    const isNumber = numberEnd === token.value.length;
    if (!isNumber && !isPostfixIeHack(token.value, numberEnd)) {
      return 0;
    }
    if (outOfRange(opts, token.value, numberEnd)) {
      return 0;
    }
    return 1;
  }
  function integer(token, getNextToken, opts) {
    if (token === null || token.type !== types.Number) {
      return 0;
    }
    let i = charCodeAt(token.value, 0) === 43 || charCodeAt(token.value, 0) === 45 ? 1 : 0;
    for (;i < token.value.length; i++) {
      if (!charCodeDefinitions.isDigit(charCodeAt(token.value, i))) {
        return 0;
      }
    }
    if (outOfRange(opts, token.value, i)) {
      return 0;
    }
    return 1;
  }
  var genericSyntaxes = {
    "ident-token": tokenType(types.Ident),
    "function-token": tokenType(types.Function),
    "at-keyword-token": tokenType(types.AtKeyword),
    "hash-token": tokenType(types.Hash),
    "string-token": tokenType(types.String),
    "bad-string-token": tokenType(types.BadString),
    "url-token": tokenType(types.Url),
    "bad-url-token": tokenType(types.BadUrl),
    "delim-token": tokenType(types.Delim),
    "number-token": tokenType(types.Number),
    "percentage-token": tokenType(types.Percentage),
    "dimension-token": tokenType(types.Dimension),
    "whitespace-token": tokenType(types.WhiteSpace),
    "CDO-token": tokenType(types.CDO),
    "CDC-token": tokenType(types.CDC),
    "colon-token": tokenType(types.Colon),
    "semicolon-token": tokenType(types.Semicolon),
    "comma-token": tokenType(types.Comma),
    "[-token": tokenType(types.LeftSquareBracket),
    "]-token": tokenType(types.RightSquareBracket),
    "(-token": tokenType(types.LeftParenthesis),
    ")-token": tokenType(types.RightParenthesis),
    "{-token": tokenType(types.LeftCurlyBracket),
    "}-token": tokenType(types.RightCurlyBracket),
    string: tokenType(types.String),
    ident: tokenType(types.Ident),
    "custom-ident": customIdent,
    "custom-property-name": customPropertyName,
    "hex-color": hexColor,
    "id-selector": idSelector,
    "an-plus-b": genericAnPlusB,
    urange: genericUrange,
    "declaration-value": declarationValue,
    "any-value": anyValue,
    dimension: calc(dimension(null)),
    angle: calc(dimension(ANGLE)),
    decibel: calc(dimension(DECIBEL)),
    frequency: calc(dimension(FREQUENCY)),
    flex: calc(dimension(FLEX)),
    length: calc(zero(dimension(LENGTH))),
    resolution: calc(dimension(RESOLUTION)),
    semitones: calc(dimension(SEMITONES)),
    time: calc(dimension(TIME)),
    percentage: calc(percentage),
    zero: zero(),
    number: calc(number),
    integer: calc(integer)
  };
  module.exports = genericSyntaxes;
});

// ../../../../node_modules/.bun/css-tree@2.2.1/node_modules/css-tree/cjs/lexer/prepare-tokens.cjs
var require_prepare_tokens2 = __commonJS((exports, module) => {
  var index = require_tokenizer3();
  var astToTokens = {
    decorator(handlers) {
      const tokens = [];
      let curNode = null;
      return {
        ...handlers,
        node(node) {
          const tmp = curNode;
          curNode = node;
          handlers.node.call(this, node);
          curNode = tmp;
        },
        emit(value, type, auto) {
          tokens.push({
            type,
            value,
            node: auto ? null : curNode
          });
        },
        result() {
          return tokens;
        }
      };
    }
  };
  function stringToTokens(str) {
    const tokens = [];
    index.tokenize(str, (type, start, end) => tokens.push({
      type,
      value: str.slice(start, end),
      node: null
    }));
    return tokens;
  }
  function prepareTokens(value, syntax) {
    if (typeof value === "string") {
      return stringToTokens(value);
    }
    return syntax.generate(value, astToTokens);
  }
  module.exports = prepareTokens;
});

// ../../../../node_modules/.bun/css-tree@2.2.1/node_modules/css-tree/cjs/definition-syntax/SyntaxError.cjs
var require_SyntaxError4 = __commonJS((exports) => {
  var createCustomError = require_create_custom_error2();
  function SyntaxError2(message, input, offset) {
    return Object.assign(createCustomError.createCustomError("SyntaxError", message), {
      input,
      offset,
      rawMessage: message,
      message: message + `
` + "  " + input + `
` + "--" + new Array((offset || input.length) + 1).join("-") + "^"
    });
  }
  exports.SyntaxError = SyntaxError2;
});

// ../../../../node_modules/.bun/css-tree@2.2.1/node_modules/css-tree/cjs/definition-syntax/tokenizer.cjs
var require_tokenizer4 = __commonJS((exports) => {
  var SyntaxError2 = require_SyntaxError4();
  var TAB = 9;
  var N = 10;
  var F = 12;
  var R = 13;
  var SPACE = 32;

  class Tokenizer {
    constructor(str) {
      this.str = str;
      this.pos = 0;
    }
    charCodeAt(pos) {
      return pos < this.str.length ? this.str.charCodeAt(pos) : 0;
    }
    charCode() {
      return this.charCodeAt(this.pos);
    }
    nextCharCode() {
      return this.charCodeAt(this.pos + 1);
    }
    nextNonWsCode(pos) {
      return this.charCodeAt(this.findWsEnd(pos));
    }
    findWsEnd(pos) {
      for (;pos < this.str.length; pos++) {
        const code = this.str.charCodeAt(pos);
        if (code !== R && code !== N && code !== F && code !== SPACE && code !== TAB) {
          break;
        }
      }
      return pos;
    }
    substringToPos(end) {
      return this.str.substring(this.pos, this.pos = end);
    }
    eat(code) {
      if (this.charCode() !== code) {
        this.error("Expect `" + String.fromCharCode(code) + "`");
      }
      this.pos++;
    }
    peek() {
      return this.pos < this.str.length ? this.str.charAt(this.pos++) : "";
    }
    error(message) {
      throw new SyntaxError2.SyntaxError(message, this.str, this.pos);
    }
  }
  exports.Tokenizer = Tokenizer;
});

// ../../../../node_modules/.bun/css-tree@2.2.1/node_modules/css-tree/cjs/definition-syntax/parse.cjs
var require_parse4 = __commonJS((exports) => {
  var tokenizer = require_tokenizer4();
  var TAB = 9;
  var N = 10;
  var F = 12;
  var R = 13;
  var SPACE = 32;
  var EXCLAMATIONMARK = 33;
  var NUMBERSIGN = 35;
  var AMPERSAND = 38;
  var APOSTROPHE = 39;
  var LEFTPARENTHESIS = 40;
  var RIGHTPARENTHESIS = 41;
  var ASTERISK = 42;
  var PLUSSIGN = 43;
  var COMMA = 44;
  var HYPERMINUS = 45;
  var LESSTHANSIGN = 60;
  var GREATERTHANSIGN = 62;
  var QUESTIONMARK = 63;
  var COMMERCIALAT = 64;
  var LEFTSQUAREBRACKET = 91;
  var RIGHTSQUAREBRACKET = 93;
  var LEFTCURLYBRACKET = 123;
  var VERTICALLINE = 124;
  var RIGHTCURLYBRACKET = 125;
  var INFINITY = 8734;
  var NAME_CHAR = new Uint8Array(128).map((_, idx) => /[a-zA-Z0-9\-]/.test(String.fromCharCode(idx)) ? 1 : 0);
  var COMBINATOR_PRECEDENCE = {
    " ": 1,
    "&&": 2,
    "||": 3,
    "|": 4
  };
  function scanSpaces(tokenizer2) {
    return tokenizer2.substringToPos(tokenizer2.findWsEnd(tokenizer2.pos));
  }
  function scanWord(tokenizer2) {
    let end = tokenizer2.pos;
    for (;end < tokenizer2.str.length; end++) {
      const code = tokenizer2.str.charCodeAt(end);
      if (code >= 128 || NAME_CHAR[code] === 0) {
        break;
      }
    }
    if (tokenizer2.pos === end) {
      tokenizer2.error("Expect a keyword");
    }
    return tokenizer2.substringToPos(end);
  }
  function scanNumber(tokenizer2) {
    let end = tokenizer2.pos;
    for (;end < tokenizer2.str.length; end++) {
      const code = tokenizer2.str.charCodeAt(end);
      if (code < 48 || code > 57) {
        break;
      }
    }
    if (tokenizer2.pos === end) {
      tokenizer2.error("Expect a number");
    }
    return tokenizer2.substringToPos(end);
  }
  function scanString(tokenizer2) {
    const end = tokenizer2.str.indexOf("'", tokenizer2.pos + 1);
    if (end === -1) {
      tokenizer2.pos = tokenizer2.str.length;
      tokenizer2.error("Expect an apostrophe");
    }
    return tokenizer2.substringToPos(end + 1);
  }
  function readMultiplierRange(tokenizer2) {
    let min = null;
    let max = null;
    tokenizer2.eat(LEFTCURLYBRACKET);
    min = scanNumber(tokenizer2);
    if (tokenizer2.charCode() === COMMA) {
      tokenizer2.pos++;
      if (tokenizer2.charCode() !== RIGHTCURLYBRACKET) {
        max = scanNumber(tokenizer2);
      }
    } else {
      max = min;
    }
    tokenizer2.eat(RIGHTCURLYBRACKET);
    return {
      min: Number(min),
      max: max ? Number(max) : 0
    };
  }
  function readMultiplier(tokenizer2) {
    let range = null;
    let comma = false;
    switch (tokenizer2.charCode()) {
      case ASTERISK:
        tokenizer2.pos++;
        range = {
          min: 0,
          max: 0
        };
        break;
      case PLUSSIGN:
        tokenizer2.pos++;
        range = {
          min: 1,
          max: 0
        };
        break;
      case QUESTIONMARK:
        tokenizer2.pos++;
        range = {
          min: 0,
          max: 1
        };
        break;
      case NUMBERSIGN:
        tokenizer2.pos++;
        comma = true;
        if (tokenizer2.charCode() === LEFTCURLYBRACKET) {
          range = readMultiplierRange(tokenizer2);
        } else if (tokenizer2.charCode() === QUESTIONMARK) {
          tokenizer2.pos++;
          range = {
            min: 0,
            max: 0
          };
        } else {
          range = {
            min: 1,
            max: 0
          };
        }
        break;
      case LEFTCURLYBRACKET:
        range = readMultiplierRange(tokenizer2);
        break;
      default:
        return null;
    }
    return {
      type: "Multiplier",
      comma,
      min: range.min,
      max: range.max,
      term: null
    };
  }
  function maybeMultiplied(tokenizer2, node) {
    const multiplier = readMultiplier(tokenizer2);
    if (multiplier !== null) {
      multiplier.term = node;
      if (tokenizer2.charCode() === NUMBERSIGN && tokenizer2.charCodeAt(tokenizer2.pos - 1) === PLUSSIGN) {
        return maybeMultiplied(tokenizer2, multiplier);
      }
      return multiplier;
    }
    return node;
  }
  function maybeToken(tokenizer2) {
    const ch = tokenizer2.peek();
    if (ch === "") {
      return null;
    }
    return {
      type: "Token",
      value: ch
    };
  }
  function readProperty(tokenizer2) {
    let name;
    tokenizer2.eat(LESSTHANSIGN);
    tokenizer2.eat(APOSTROPHE);
    name = scanWord(tokenizer2);
    tokenizer2.eat(APOSTROPHE);
    tokenizer2.eat(GREATERTHANSIGN);
    return maybeMultiplied(tokenizer2, {
      type: "Property",
      name
    });
  }
  function readTypeRange(tokenizer2) {
    let min = null;
    let max = null;
    let sign = 1;
    tokenizer2.eat(LEFTSQUAREBRACKET);
    if (tokenizer2.charCode() === HYPERMINUS) {
      tokenizer2.peek();
      sign = -1;
    }
    if (sign == -1 && tokenizer2.charCode() === INFINITY) {
      tokenizer2.peek();
    } else {
      min = sign * Number(scanNumber(tokenizer2));
      if (NAME_CHAR[tokenizer2.charCode()] !== 0) {
        min += scanWord(tokenizer2);
      }
    }
    scanSpaces(tokenizer2);
    tokenizer2.eat(COMMA);
    scanSpaces(tokenizer2);
    if (tokenizer2.charCode() === INFINITY) {
      tokenizer2.peek();
    } else {
      sign = 1;
      if (tokenizer2.charCode() === HYPERMINUS) {
        tokenizer2.peek();
        sign = -1;
      }
      max = sign * Number(scanNumber(tokenizer2));
      if (NAME_CHAR[tokenizer2.charCode()] !== 0) {
        max += scanWord(tokenizer2);
      }
    }
    tokenizer2.eat(RIGHTSQUAREBRACKET);
    return {
      type: "Range",
      min,
      max
    };
  }
  function readType(tokenizer2) {
    let name;
    let opts = null;
    tokenizer2.eat(LESSTHANSIGN);
    name = scanWord(tokenizer2);
    if (tokenizer2.charCode() === LEFTPARENTHESIS && tokenizer2.nextCharCode() === RIGHTPARENTHESIS) {
      tokenizer2.pos += 2;
      name += "()";
    }
    if (tokenizer2.charCodeAt(tokenizer2.findWsEnd(tokenizer2.pos)) === LEFTSQUAREBRACKET) {
      scanSpaces(tokenizer2);
      opts = readTypeRange(tokenizer2);
    }
    tokenizer2.eat(GREATERTHANSIGN);
    return maybeMultiplied(tokenizer2, {
      type: "Type",
      name,
      opts
    });
  }
  function readKeywordOrFunction(tokenizer2) {
    const name = scanWord(tokenizer2);
    if (tokenizer2.charCode() === LEFTPARENTHESIS) {
      tokenizer2.pos++;
      return {
        type: "Function",
        name
      };
    }
    return maybeMultiplied(tokenizer2, {
      type: "Keyword",
      name
    });
  }
  function regroupTerms(terms, combinators) {
    function createGroup(terms2, combinator2) {
      return {
        type: "Group",
        terms: terms2,
        combinator: combinator2,
        disallowEmpty: false,
        explicit: false
      };
    }
    let combinator;
    combinators = Object.keys(combinators).sort((a, b) => COMBINATOR_PRECEDENCE[a] - COMBINATOR_PRECEDENCE[b]);
    while (combinators.length > 0) {
      combinator = combinators.shift();
      let i = 0;
      let subgroupStart = 0;
      for (;i < terms.length; i++) {
        const term = terms[i];
        if (term.type === "Combinator") {
          if (term.value === combinator) {
            if (subgroupStart === -1) {
              subgroupStart = i - 1;
            }
            terms.splice(i, 1);
            i--;
          } else {
            if (subgroupStart !== -1 && i - subgroupStart > 1) {
              terms.splice(subgroupStart, i - subgroupStart, createGroup(terms.slice(subgroupStart, i), combinator));
              i = subgroupStart + 1;
            }
            subgroupStart = -1;
          }
        }
      }
      if (subgroupStart !== -1 && combinators.length) {
        terms.splice(subgroupStart, i - subgroupStart, createGroup(terms.slice(subgroupStart, i), combinator));
      }
    }
    return combinator;
  }
  function readImplicitGroup(tokenizer2) {
    const terms = [];
    const combinators = {};
    let token;
    let prevToken = null;
    let prevTokenPos = tokenizer2.pos;
    while (token = peek(tokenizer2)) {
      if (token.type !== "Spaces") {
        if (token.type === "Combinator") {
          if (prevToken === null || prevToken.type === "Combinator") {
            tokenizer2.pos = prevTokenPos;
            tokenizer2.error("Unexpected combinator");
          }
          combinators[token.value] = true;
        } else if (prevToken !== null && prevToken.type !== "Combinator") {
          combinators[" "] = true;
          terms.push({
            type: "Combinator",
            value: " "
          });
        }
        terms.push(token);
        prevToken = token;
        prevTokenPos = tokenizer2.pos;
      }
    }
    if (prevToken !== null && prevToken.type === "Combinator") {
      tokenizer2.pos -= prevTokenPos;
      tokenizer2.error("Unexpected combinator");
    }
    return {
      type: "Group",
      terms,
      combinator: regroupTerms(terms, combinators) || " ",
      disallowEmpty: false,
      explicit: false
    };
  }
  function readGroup(tokenizer2) {
    let result;
    tokenizer2.eat(LEFTSQUAREBRACKET);
    result = readImplicitGroup(tokenizer2);
    tokenizer2.eat(RIGHTSQUAREBRACKET);
    result.explicit = true;
    if (tokenizer2.charCode() === EXCLAMATIONMARK) {
      tokenizer2.pos++;
      result.disallowEmpty = true;
    }
    return result;
  }
  function peek(tokenizer2) {
    let code = tokenizer2.charCode();
    if (code < 128 && NAME_CHAR[code] === 1) {
      return readKeywordOrFunction(tokenizer2);
    }
    switch (code) {
      case RIGHTSQUAREBRACKET:
        break;
      case LEFTSQUAREBRACKET:
        return maybeMultiplied(tokenizer2, readGroup(tokenizer2));
      case LESSTHANSIGN:
        return tokenizer2.nextCharCode() === APOSTROPHE ? readProperty(tokenizer2) : readType(tokenizer2);
      case VERTICALLINE:
        return {
          type: "Combinator",
          value: tokenizer2.substringToPos(tokenizer2.pos + (tokenizer2.nextCharCode() === VERTICALLINE ? 2 : 1))
        };
      case AMPERSAND:
        tokenizer2.pos++;
        tokenizer2.eat(AMPERSAND);
        return {
          type: "Combinator",
          value: "&&"
        };
      case COMMA:
        tokenizer2.pos++;
        return {
          type: "Comma"
        };
      case APOSTROPHE:
        return maybeMultiplied(tokenizer2, {
          type: "String",
          value: scanString(tokenizer2)
        });
      case SPACE:
      case TAB:
      case N:
      case R:
      case F:
        return {
          type: "Spaces",
          value: scanSpaces(tokenizer2)
        };
      case COMMERCIALAT:
        code = tokenizer2.nextCharCode();
        if (code < 128 && NAME_CHAR[code] === 1) {
          tokenizer2.pos++;
          return {
            type: "AtKeyword",
            name: scanWord(tokenizer2)
          };
        }
        return maybeToken(tokenizer2);
      case ASTERISK:
      case PLUSSIGN:
      case QUESTIONMARK:
      case NUMBERSIGN:
      case EXCLAMATIONMARK:
        break;
      case LEFTCURLYBRACKET:
        code = tokenizer2.nextCharCode();
        if (code < 48 || code > 57) {
          return maybeToken(tokenizer2);
        }
        break;
      default:
        return maybeToken(tokenizer2);
    }
  }
  function parse(source) {
    const tokenizer$1 = new tokenizer.Tokenizer(source);
    const result = readImplicitGroup(tokenizer$1);
    if (tokenizer$1.pos !== source.length) {
      tokenizer$1.error("Unexpected input");
    }
    if (result.terms.length === 1 && result.terms[0].type === "Group") {
      return result.terms[0];
    }
    return result;
  }
  exports.parse = parse;
});

// ../../../../node_modules/.bun/css-tree@2.2.1/node_modules/css-tree/cjs/lexer/match-graph.cjs
var require_match_graph2 = __commonJS((exports) => {
  var parse = require_parse4();
  var MATCH = { type: "Match" };
  var MISMATCH = { type: "Mismatch" };
  var DISALLOW_EMPTY = { type: "DisallowEmpty" };
  var LEFTPARENTHESIS = 40;
  var RIGHTPARENTHESIS = 41;
  function createCondition(match, thenBranch, elseBranch) {
    if (thenBranch === MATCH && elseBranch === MISMATCH) {
      return match;
    }
    if (match === MATCH && thenBranch === MATCH && elseBranch === MATCH) {
      return match;
    }
    if (match.type === "If" && match.else === MISMATCH && thenBranch === MATCH) {
      thenBranch = match.then;
      match = match.match;
    }
    return {
      type: "If",
      match,
      then: thenBranch,
      else: elseBranch
    };
  }
  function isFunctionType(name) {
    return name.length > 2 && name.charCodeAt(name.length - 2) === LEFTPARENTHESIS && name.charCodeAt(name.length - 1) === RIGHTPARENTHESIS;
  }
  function isEnumCapatible(term) {
    return term.type === "Keyword" || term.type === "AtKeyword" || term.type === "Function" || term.type === "Type" && isFunctionType(term.name);
  }
  function buildGroupMatchGraph(combinator, terms, atLeastOneTermMatched) {
    switch (combinator) {
      case " ": {
        let result = MATCH;
        for (let i = terms.length - 1;i >= 0; i--) {
          const term = terms[i];
          result = createCondition(term, result, MISMATCH);
        }
        return result;
      }
      case "|": {
        let result = MISMATCH;
        let map = null;
        for (let i = terms.length - 1;i >= 0; i--) {
          let term = terms[i];
          if (isEnumCapatible(term)) {
            if (map === null && i > 0 && isEnumCapatible(terms[i - 1])) {
              map = Object.create(null);
              result = createCondition({
                type: "Enum",
                map
              }, MATCH, result);
            }
            if (map !== null) {
              const key = (isFunctionType(term.name) ? term.name.slice(0, -1) : term.name).toLowerCase();
              if (key in map === false) {
                map[key] = term;
                continue;
              }
            }
          }
          map = null;
          result = createCondition(term, MATCH, result);
        }
        return result;
      }
      case "&&": {
        if (terms.length > 5) {
          return {
            type: "MatchOnce",
            terms,
            all: true
          };
        }
        let result = MISMATCH;
        for (let i = terms.length - 1;i >= 0; i--) {
          const term = terms[i];
          let thenClause;
          if (terms.length > 1) {
            thenClause = buildGroupMatchGraph(combinator, terms.filter(function(newGroupTerm) {
              return newGroupTerm !== term;
            }), false);
          } else {
            thenClause = MATCH;
          }
          result = createCondition(term, thenClause, result);
        }
        return result;
      }
      case "||": {
        if (terms.length > 5) {
          return {
            type: "MatchOnce",
            terms,
            all: false
          };
        }
        let result = atLeastOneTermMatched ? MATCH : MISMATCH;
        for (let i = terms.length - 1;i >= 0; i--) {
          const term = terms[i];
          let thenClause;
          if (terms.length > 1) {
            thenClause = buildGroupMatchGraph(combinator, terms.filter(function(newGroupTerm) {
              return newGroupTerm !== term;
            }), true);
          } else {
            thenClause = MATCH;
          }
          result = createCondition(term, thenClause, result);
        }
        return result;
      }
    }
  }
  function buildMultiplierMatchGraph(node) {
    let result = MATCH;
    let matchTerm = buildMatchGraphInternal(node.term);
    if (node.max === 0) {
      matchTerm = createCondition(matchTerm, DISALLOW_EMPTY, MISMATCH);
      result = createCondition(matchTerm, null, MISMATCH);
      result.then = createCondition(MATCH, MATCH, result);
      if (node.comma) {
        result.then.else = createCondition({ type: "Comma", syntax: node }, result, MISMATCH);
      }
    } else {
      for (let i = node.min || 1;i <= node.max; i++) {
        if (node.comma && result !== MATCH) {
          result = createCondition({ type: "Comma", syntax: node }, result, MISMATCH);
        }
        result = createCondition(matchTerm, createCondition(MATCH, MATCH, result), MISMATCH);
      }
    }
    if (node.min === 0) {
      result = createCondition(MATCH, MATCH, result);
    } else {
      for (let i = 0;i < node.min - 1; i++) {
        if (node.comma && result !== MATCH) {
          result = createCondition({ type: "Comma", syntax: node }, result, MISMATCH);
        }
        result = createCondition(matchTerm, result, MISMATCH);
      }
    }
    return result;
  }
  function buildMatchGraphInternal(node) {
    if (typeof node === "function") {
      return {
        type: "Generic",
        fn: node
      };
    }
    switch (node.type) {
      case "Group": {
        let result = buildGroupMatchGraph(node.combinator, node.terms.map(buildMatchGraphInternal), false);
        if (node.disallowEmpty) {
          result = createCondition(result, DISALLOW_EMPTY, MISMATCH);
        }
        return result;
      }
      case "Multiplier":
        return buildMultiplierMatchGraph(node);
      case "Type":
      case "Property":
        return {
          type: node.type,
          name: node.name,
          syntax: node
        };
      case "Keyword":
        return {
          type: node.type,
          name: node.name.toLowerCase(),
          syntax: node
        };
      case "AtKeyword":
        return {
          type: node.type,
          name: "@" + node.name.toLowerCase(),
          syntax: node
        };
      case "Function":
        return {
          type: node.type,
          name: node.name.toLowerCase() + "(",
          syntax: node
        };
      case "String":
        if (node.value.length === 3) {
          return {
            type: "Token",
            value: node.value.charAt(1),
            syntax: node
          };
        }
        return {
          type: node.type,
          value: node.value.substr(1, node.value.length - 2).replace(/\\'/g, "'"),
          syntax: node
        };
      case "Token":
        return {
          type: node.type,
          value: node.value,
          syntax: node
        };
      case "Comma":
        return {
          type: node.type,
          syntax: node
        };
      default:
        throw new Error("Unknown node type:", node.type);
    }
  }
  function buildMatchGraph(syntaxTree, ref) {
    if (typeof syntaxTree === "string") {
      syntaxTree = parse.parse(syntaxTree);
    }
    return {
      type: "MatchGraph",
      match: buildMatchGraphInternal(syntaxTree),
      syntax: ref || null,
      source: syntaxTree
    };
  }
  exports.DISALLOW_EMPTY = DISALLOW_EMPTY;
  exports.MATCH = MATCH;
  exports.MISMATCH = MISMATCH;
  exports.buildMatchGraph = buildMatchGraph;
});

// ../../../../node_modules/.bun/css-tree@2.2.1/node_modules/css-tree/cjs/lexer/match.cjs
var require_match2 = __commonJS((exports) => {
  var matchGraph = require_match_graph2();
  var types = require_types3();
  var { hasOwnProperty: hasOwnProperty2 } = Object.prototype;
  var STUB = 0;
  var TOKEN = 1;
  var OPEN_SYNTAX = 2;
  var CLOSE_SYNTAX = 3;
  var EXIT_REASON_MATCH = "Match";
  var EXIT_REASON_MISMATCH = "Mismatch";
  var EXIT_REASON_ITERATION_LIMIT = "Maximum iteration number exceeded (please fill an issue on https://github.com/csstree/csstree/issues)";
  var ITERATION_LIMIT = 15000;
  function reverseList(list) {
    let prev = null;
    let next = null;
    let item = list;
    while (item !== null) {
      next = item.prev;
      item.prev = prev;
      prev = item;
      item = next;
    }
    return prev;
  }
  function areStringsEqualCaseInsensitive(testStr, referenceStr) {
    if (testStr.length !== referenceStr.length) {
      return false;
    }
    for (let i = 0;i < testStr.length; i++) {
      const referenceCode = referenceStr.charCodeAt(i);
      let testCode = testStr.charCodeAt(i);
      if (testCode >= 65 && testCode <= 90) {
        testCode = testCode | 32;
      }
      if (testCode !== referenceCode) {
        return false;
      }
    }
    return true;
  }
  function isContextEdgeDelim(token) {
    if (token.type !== types.Delim) {
      return false;
    }
    return token.value !== "?";
  }
  function isCommaContextStart(token) {
    if (token === null) {
      return true;
    }
    return token.type === types.Comma || token.type === types.Function || token.type === types.LeftParenthesis || token.type === types.LeftSquareBracket || token.type === types.LeftCurlyBracket || isContextEdgeDelim(token);
  }
  function isCommaContextEnd(token) {
    if (token === null) {
      return true;
    }
    return token.type === types.RightParenthesis || token.type === types.RightSquareBracket || token.type === types.RightCurlyBracket || token.type === types.Delim && token.value === "/";
  }
  function internalMatch(tokens, state, syntaxes) {
    function moveToNextToken() {
      do {
        tokenIndex++;
        token = tokenIndex < tokens.length ? tokens[tokenIndex] : null;
      } while (token !== null && (token.type === types.WhiteSpace || token.type === types.Comment));
    }
    function getNextToken(offset) {
      const nextIndex = tokenIndex + offset;
      return nextIndex < tokens.length ? tokens[nextIndex] : null;
    }
    function stateSnapshotFromSyntax(nextState, prev) {
      return {
        nextState,
        matchStack,
        syntaxStack,
        thenStack,
        tokenIndex,
        prev
      };
    }
    function pushThenStack(nextState) {
      thenStack = {
        nextState,
        matchStack,
        syntaxStack,
        prev: thenStack
      };
    }
    function pushElseStack(nextState) {
      elseStack = stateSnapshotFromSyntax(nextState, elseStack);
    }
    function addTokenToMatch() {
      matchStack = {
        type: TOKEN,
        syntax: state.syntax,
        token,
        prev: matchStack
      };
      moveToNextToken();
      syntaxStash = null;
      if (tokenIndex > longestMatch) {
        longestMatch = tokenIndex;
      }
    }
    function openSyntax() {
      syntaxStack = {
        syntax: state.syntax,
        opts: state.syntax.opts || syntaxStack !== null && syntaxStack.opts || null,
        prev: syntaxStack
      };
      matchStack = {
        type: OPEN_SYNTAX,
        syntax: state.syntax,
        token: matchStack.token,
        prev: matchStack
      };
    }
    function closeSyntax() {
      if (matchStack.type === OPEN_SYNTAX) {
        matchStack = matchStack.prev;
      } else {
        matchStack = {
          type: CLOSE_SYNTAX,
          syntax: syntaxStack.syntax,
          token: matchStack.token,
          prev: matchStack
        };
      }
      syntaxStack = syntaxStack.prev;
    }
    let syntaxStack = null;
    let thenStack = null;
    let elseStack = null;
    let syntaxStash = null;
    let iterationCount = 0;
    let exitReason = null;
    let token = null;
    let tokenIndex = -1;
    let longestMatch = 0;
    let matchStack = {
      type: STUB,
      syntax: null,
      token: null,
      prev: null
    };
    moveToNextToken();
    while (exitReason === null && ++iterationCount < ITERATION_LIMIT) {
      switch (state.type) {
        case "Match":
          if (thenStack === null) {
            if (token !== null) {
              if (tokenIndex !== tokens.length - 1 || token.value !== "\\0" && token.value !== "\\9") {
                state = matchGraph.MISMATCH;
                break;
              }
            }
            exitReason = EXIT_REASON_MATCH;
            break;
          }
          state = thenStack.nextState;
          if (state === matchGraph.DISALLOW_EMPTY) {
            if (thenStack.matchStack === matchStack) {
              state = matchGraph.MISMATCH;
              break;
            } else {
              state = matchGraph.MATCH;
            }
          }
          while (thenStack.syntaxStack !== syntaxStack) {
            closeSyntax();
          }
          thenStack = thenStack.prev;
          break;
        case "Mismatch":
          if (syntaxStash !== null && syntaxStash !== false) {
            if (elseStack === null || tokenIndex > elseStack.tokenIndex) {
              elseStack = syntaxStash;
              syntaxStash = false;
            }
          } else if (elseStack === null) {
            exitReason = EXIT_REASON_MISMATCH;
            break;
          }
          state = elseStack.nextState;
          thenStack = elseStack.thenStack;
          syntaxStack = elseStack.syntaxStack;
          matchStack = elseStack.matchStack;
          tokenIndex = elseStack.tokenIndex;
          token = tokenIndex < tokens.length ? tokens[tokenIndex] : null;
          elseStack = elseStack.prev;
          break;
        case "MatchGraph":
          state = state.match;
          break;
        case "If":
          if (state.else !== matchGraph.MISMATCH) {
            pushElseStack(state.else);
          }
          if (state.then !== matchGraph.MATCH) {
            pushThenStack(state.then);
          }
          state = state.match;
          break;
        case "MatchOnce":
          state = {
            type: "MatchOnceBuffer",
            syntax: state,
            index: 0,
            mask: 0
          };
          break;
        case "MatchOnceBuffer": {
          const terms = state.syntax.terms;
          if (state.index === terms.length) {
            if (state.mask === 0 || state.syntax.all) {
              state = matchGraph.MISMATCH;
              break;
            }
            state = matchGraph.MATCH;
            break;
          }
          if (state.mask === (1 << terms.length) - 1) {
            state = matchGraph.MATCH;
            break;
          }
          for (;state.index < terms.length; state.index++) {
            const matchFlag = 1 << state.index;
            if ((state.mask & matchFlag) === 0) {
              pushElseStack(state);
              pushThenStack({
                type: "AddMatchOnce",
                syntax: state.syntax,
                mask: state.mask | matchFlag
              });
              state = terms[state.index++];
              break;
            }
          }
          break;
        }
        case "AddMatchOnce":
          state = {
            type: "MatchOnceBuffer",
            syntax: state.syntax,
            index: 0,
            mask: state.mask
          };
          break;
        case "Enum":
          if (token !== null) {
            let name = token.value.toLowerCase();
            if (name.indexOf("\\") !== -1) {
              name = name.replace(/\\[09].*$/, "");
            }
            if (hasOwnProperty2.call(state.map, name)) {
              state = state.map[name];
              break;
            }
          }
          state = matchGraph.MISMATCH;
          break;
        case "Generic": {
          const opts = syntaxStack !== null ? syntaxStack.opts : null;
          const lastTokenIndex2 = tokenIndex + Math.floor(state.fn(token, getNextToken, opts));
          if (!isNaN(lastTokenIndex2) && lastTokenIndex2 > tokenIndex) {
            while (tokenIndex < lastTokenIndex2) {
              addTokenToMatch();
            }
            state = matchGraph.MATCH;
          } else {
            state = matchGraph.MISMATCH;
          }
          break;
        }
        case "Type":
        case "Property": {
          const syntaxDict = state.type === "Type" ? "types" : "properties";
          const dictSyntax = hasOwnProperty2.call(syntaxes, syntaxDict) ? syntaxes[syntaxDict][state.name] : null;
          if (!dictSyntax || !dictSyntax.match) {
            throw new Error("Bad syntax reference: " + (state.type === "Type" ? "<" + state.name + ">" : "<'" + state.name + "'>"));
          }
          if (syntaxStash !== false && token !== null && state.type === "Type") {
            const lowPriorityMatching = state.name === "custom-ident" && token.type === types.Ident || state.name === "length" && token.value === "0";
            if (lowPriorityMatching) {
              if (syntaxStash === null) {
                syntaxStash = stateSnapshotFromSyntax(state, elseStack);
              }
              state = matchGraph.MISMATCH;
              break;
            }
          }
          openSyntax();
          state = dictSyntax.match;
          break;
        }
        case "Keyword": {
          const name = state.name;
          if (token !== null) {
            let keywordName = token.value;
            if (keywordName.indexOf("\\") !== -1) {
              keywordName = keywordName.replace(/\\[09].*$/, "");
            }
            if (areStringsEqualCaseInsensitive(keywordName, name)) {
              addTokenToMatch();
              state = matchGraph.MATCH;
              break;
            }
          }
          state = matchGraph.MISMATCH;
          break;
        }
        case "AtKeyword":
        case "Function":
          if (token !== null && areStringsEqualCaseInsensitive(token.value, state.name)) {
            addTokenToMatch();
            state = matchGraph.MATCH;
            break;
          }
          state = matchGraph.MISMATCH;
          break;
        case "Token":
          if (token !== null && token.value === state.value) {
            addTokenToMatch();
            state = matchGraph.MATCH;
            break;
          }
          state = matchGraph.MISMATCH;
          break;
        case "Comma":
          if (token !== null && token.type === types.Comma) {
            if (isCommaContextStart(matchStack.token)) {
              state = matchGraph.MISMATCH;
            } else {
              addTokenToMatch();
              state = isCommaContextEnd(token) ? matchGraph.MISMATCH : matchGraph.MATCH;
            }
          } else {
            state = isCommaContextStart(matchStack.token) || isCommaContextEnd(token) ? matchGraph.MATCH : matchGraph.MISMATCH;
          }
          break;
        case "String":
          let string = "";
          let lastTokenIndex = tokenIndex;
          for (;lastTokenIndex < tokens.length && string.length < state.value.length; lastTokenIndex++) {
            string += tokens[lastTokenIndex].value;
          }
          if (areStringsEqualCaseInsensitive(string, state.value)) {
            while (tokenIndex < lastTokenIndex) {
              addTokenToMatch();
            }
            state = matchGraph.MATCH;
          } else {
            state = matchGraph.MISMATCH;
          }
          break;
        default:
          throw new Error("Unknown node type: " + state.type);
      }
    }
    switch (exitReason) {
      case null:
        console.warn("[csstree-match] BREAK after " + ITERATION_LIMIT + " iterations");
        exitReason = EXIT_REASON_ITERATION_LIMIT;
        matchStack = null;
        break;
      case EXIT_REASON_MATCH:
        while (syntaxStack !== null) {
          closeSyntax();
        }
        break;
      default:
        matchStack = null;
    }
    return {
      tokens,
      reason: exitReason,
      iterations: iterationCount,
      match: matchStack,
      longestMatch
    };
  }
  function matchAsList(tokens, matchGraph2, syntaxes) {
    const matchResult = internalMatch(tokens, matchGraph2, syntaxes || {});
    if (matchResult.match !== null) {
      let item = reverseList(matchResult.match).prev;
      matchResult.match = [];
      while (item !== null) {
        switch (item.type) {
          case OPEN_SYNTAX:
          case CLOSE_SYNTAX:
            matchResult.match.push({
              type: item.type,
              syntax: item.syntax
            });
            break;
          default:
            matchResult.match.push({
              token: item.token.value,
              node: item.token.node
            });
            break;
        }
        item = item.prev;
      }
    }
    return matchResult;
  }
  function matchAsTree(tokens, matchGraph2, syntaxes) {
    const matchResult = internalMatch(tokens, matchGraph2, syntaxes || {});
    if (matchResult.match === null) {
      return matchResult;
    }
    let item = matchResult.match;
    let host = matchResult.match = {
      syntax: matchGraph2.syntax || null,
      match: []
    };
    const hostStack = [host];
    item = reverseList(item).prev;
    while (item !== null) {
      switch (item.type) {
        case OPEN_SYNTAX:
          host.match.push(host = {
            syntax: item.syntax,
            match: []
          });
          hostStack.push(host);
          break;
        case CLOSE_SYNTAX:
          hostStack.pop();
          host = hostStack[hostStack.length - 1];
          break;
        default:
          host.match.push({
            syntax: item.syntax || null,
            token: item.token.value,
            node: item.token.node
          });
      }
      item = item.prev;
    }
    return matchResult;
  }
  exports.matchAsList = matchAsList;
  exports.matchAsTree = matchAsTree;
});

// ../../../../node_modules/.bun/css-tree@2.2.1/node_modules/css-tree/cjs/lexer/trace.cjs
var require_trace2 = __commonJS((exports) => {
  function getTrace(node) {
    function shouldPutToTrace(syntax) {
      if (syntax === null) {
        return false;
      }
      return syntax.type === "Type" || syntax.type === "Property" || syntax.type === "Keyword";
    }
    function hasMatch(matchNode) {
      if (Array.isArray(matchNode.match)) {
        for (let i = 0;i < matchNode.match.length; i++) {
          if (hasMatch(matchNode.match[i])) {
            if (shouldPutToTrace(matchNode.syntax)) {
              result.unshift(matchNode.syntax);
            }
            return true;
          }
        }
      } else if (matchNode.node === node) {
        result = shouldPutToTrace(matchNode.syntax) ? [matchNode.syntax] : [];
        return true;
      }
      return false;
    }
    let result = null;
    if (this.matched !== null) {
      hasMatch(this.matched);
    }
    return result;
  }
  function isType(node, type) {
    return testNode(this, node, (match) => match.type === "Type" && match.name === type);
  }
  function isProperty(node, property) {
    return testNode(this, node, (match) => match.type === "Property" && match.name === property);
  }
  function isKeyword(node) {
    return testNode(this, node, (match) => match.type === "Keyword");
  }
  function testNode(match, node, fn) {
    const trace = getTrace.call(match, node);
    if (trace === null) {
      return false;
    }
    return trace.some(fn);
  }
  exports.getTrace = getTrace;
  exports.isKeyword = isKeyword;
  exports.isProperty = isProperty;
  exports.isType = isType;
});

// ../../../../node_modules/.bun/css-tree@2.2.1/node_modules/css-tree/cjs/lexer/search.cjs
var require_search2 = __commonJS((exports) => {
  var List = require_List2();
  function getFirstMatchNode(matchNode) {
    if ("node" in matchNode) {
      return matchNode.node;
    }
    return getFirstMatchNode(matchNode.match[0]);
  }
  function getLastMatchNode(matchNode) {
    if ("node" in matchNode) {
      return matchNode.node;
    }
    return getLastMatchNode(matchNode.match[matchNode.match.length - 1]);
  }
  function matchFragments(lexer, ast, match, type, name) {
    function findFragments(matchNode) {
      if (matchNode.syntax !== null && matchNode.syntax.type === type && matchNode.syntax.name === name) {
        const start = getFirstMatchNode(matchNode);
        const end = getLastMatchNode(matchNode);
        lexer.syntax.walk(ast, function(node, item, list) {
          if (node === start) {
            const nodes = new List.List;
            do {
              nodes.appendData(item.data);
              if (item.data === end) {
                break;
              }
              item = item.next;
            } while (item !== null);
            fragments.push({
              parent: list,
              nodes
            });
          }
        });
      }
      if (Array.isArray(matchNode.match)) {
        matchNode.match.forEach(findFragments);
      }
    }
    const fragments = [];
    if (match.matched !== null) {
      findFragments(match.matched);
    }
    return fragments;
  }
  exports.matchFragments = matchFragments;
});

// ../../../../node_modules/.bun/css-tree@2.2.1/node_modules/css-tree/cjs/lexer/structure.cjs
var require_structure2 = __commonJS((exports) => {
  var List = require_List2();
  var { hasOwnProperty: hasOwnProperty2 } = Object.prototype;
  function isValidNumber(value) {
    return typeof value === "number" && isFinite(value) && Math.floor(value) === value && value >= 0;
  }
  function isValidLocation(loc) {
    return Boolean(loc) && isValidNumber(loc.offset) && isValidNumber(loc.line) && isValidNumber(loc.column);
  }
  function createNodeStructureChecker(type, fields) {
    return function checkNode(node, warn) {
      if (!node || node.constructor !== Object) {
        return warn(node, "Type of node should be an Object");
      }
      for (let key in node) {
        let valid = true;
        if (hasOwnProperty2.call(node, key) === false) {
          continue;
        }
        if (key === "type") {
          if (node.type !== type) {
            warn(node, "Wrong node type `" + node.type + "`, expected `" + type + "`");
          }
        } else if (key === "loc") {
          if (node.loc === null) {
            continue;
          } else if (node.loc && node.loc.constructor === Object) {
            if (typeof node.loc.source !== "string") {
              key += ".source";
            } else if (!isValidLocation(node.loc.start)) {
              key += ".start";
            } else if (!isValidLocation(node.loc.end)) {
              key += ".end";
            } else {
              continue;
            }
          }
          valid = false;
        } else if (fields.hasOwnProperty(key)) {
          valid = false;
          for (let i = 0;!valid && i < fields[key].length; i++) {
            const fieldType = fields[key][i];
            switch (fieldType) {
              case String:
                valid = typeof node[key] === "string";
                break;
              case Boolean:
                valid = typeof node[key] === "boolean";
                break;
              case null:
                valid = node[key] === null;
                break;
              default:
                if (typeof fieldType === "string") {
                  valid = node[key] && node[key].type === fieldType;
                } else if (Array.isArray(fieldType)) {
                  valid = node[key] instanceof List.List;
                }
            }
          }
        } else {
          warn(node, "Unknown field `" + key + "` for " + type + " node type");
        }
        if (!valid) {
          warn(node, "Bad value for `" + type + "." + key + "`");
        }
      }
      for (const key in fields) {
        if (hasOwnProperty2.call(fields, key) && hasOwnProperty2.call(node, key) === false) {
          warn(node, "Field `" + type + "." + key + "` is missed");
        }
      }
    };
  }
  function processStructure(name, nodeType) {
    const structure = nodeType.structure;
    const fields = {
      type: String,
      loc: true
    };
    const docs = {
      type: '"' + name + '"'
    };
    for (const key in structure) {
      if (hasOwnProperty2.call(structure, key) === false) {
        continue;
      }
      const docsTypes = [];
      const fieldTypes = fields[key] = Array.isArray(structure[key]) ? structure[key].slice() : [structure[key]];
      for (let i = 0;i < fieldTypes.length; i++) {
        const fieldType = fieldTypes[i];
        if (fieldType === String || fieldType === Boolean) {
          docsTypes.push(fieldType.name);
        } else if (fieldType === null) {
          docsTypes.push("null");
        } else if (typeof fieldType === "string") {
          docsTypes.push("<" + fieldType + ">");
        } else if (Array.isArray(fieldType)) {
          docsTypes.push("List");
        } else {
          throw new Error("Wrong value `" + fieldType + "` in `" + name + "." + key + "` structure definition");
        }
      }
      docs[key] = docsTypes.join(" | ");
    }
    return {
      docs,
      check: createNodeStructureChecker(name, fields)
    };
  }
  function getStructureFromConfig(config) {
    const structure = {};
    if (config.node) {
      for (const name in config.node) {
        if (hasOwnProperty2.call(config.node, name)) {
          const nodeType = config.node[name];
          if (nodeType.structure) {
            structure[name] = processStructure(name, nodeType);
          } else {
            throw new Error("Missed `structure` field in `" + name + "` node type definition");
          }
        }
      }
    }
    return structure;
  }
  exports.getStructureFromConfig = getStructureFromConfig;
});

// ../../../../node_modules/.bun/css-tree@2.2.1/node_modules/css-tree/cjs/definition-syntax/walk.cjs
var require_walk2 = __commonJS((exports) => {
  var noop = function() {};
  function ensureFunction(value) {
    return typeof value === "function" ? value : noop;
  }
  function walk(node, options, context) {
    function walk2(node2) {
      enter.call(context, node2);
      switch (node2.type) {
        case "Group":
          node2.terms.forEach(walk2);
          break;
        case "Multiplier":
          walk2(node2.term);
          break;
        case "Type":
        case "Property":
        case "Keyword":
        case "AtKeyword":
        case "Function":
        case "String":
        case "Token":
        case "Comma":
          break;
        default:
          throw new Error("Unknown type: " + node2.type);
      }
      leave.call(context, node2);
    }
    let enter = noop;
    let leave = noop;
    if (typeof options === "function") {
      enter = options;
    } else if (options) {
      enter = ensureFunction(options.enter);
      leave = ensureFunction(options.leave);
    }
    if (enter === noop && leave === noop) {
      throw new Error("Neither `enter` nor `leave` walker handler is set or both aren't a function");
    }
    walk2(node);
  }
  exports.walk = walk;
});

// ../../../../node_modules/.bun/css-tree@2.2.1/node_modules/css-tree/cjs/lexer/Lexer.cjs
var require_Lexer2 = __commonJS((exports) => {
  var error = require_error2();
  var names = require_names4();
  var genericConst = require_generic_const2();
  var generic = require_generic2();
  var prepareTokens = require_prepare_tokens2();
  var matchGraph = require_match_graph2();
  var match = require_match2();
  var trace = require_trace2();
  var search = require_search2();
  var structure = require_structure2();
  var parse = require_parse4();
  var generate = require_generate2();
  var walk = require_walk2();
  var cssWideKeywordsSyntax = matchGraph.buildMatchGraph(genericConst.cssWideKeywords.join(" | "));
  function dumpMapSyntax(map, compact, syntaxAsAst) {
    const result = {};
    for (const name in map) {
      if (map[name].syntax) {
        result[name] = syntaxAsAst ? map[name].syntax : generate.generate(map[name].syntax, { compact });
      }
    }
    return result;
  }
  function dumpAtruleMapSyntax(map, compact, syntaxAsAst) {
    const result = {};
    for (const [name, atrule] of Object.entries(map)) {
      result[name] = {
        prelude: atrule.prelude && (syntaxAsAst ? atrule.prelude.syntax : generate.generate(atrule.prelude.syntax, { compact })),
        descriptors: atrule.descriptors && dumpMapSyntax(atrule.descriptors, compact, syntaxAsAst)
      };
    }
    return result;
  }
  function valueHasVar(tokens) {
    for (let i = 0;i < tokens.length; i++) {
      if (tokens[i].value.toLowerCase() === "var(") {
        return true;
      }
    }
    return false;
  }
  function buildMatchResult(matched, error2, iterations) {
    return {
      matched,
      iterations,
      error: error2,
      ...trace
    };
  }
  function matchSyntax(lexer, syntax, value, useCssWideKeywords) {
    const tokens = prepareTokens(value, lexer.syntax);
    let result;
    if (valueHasVar(tokens)) {
      return buildMatchResult(null, new Error("Matching for a tree with var() is not supported"));
    }
    if (useCssWideKeywords) {
      result = match.matchAsTree(tokens, lexer.cssWideKeywordsSyntax, lexer);
    }
    if (!useCssWideKeywords || !result.match) {
      result = match.matchAsTree(tokens, syntax.match, lexer);
      if (!result.match) {
        return buildMatchResult(null, new error.SyntaxMatchError(result.reason, syntax.syntax, value, result), result.iterations);
      }
    }
    return buildMatchResult(result.match, null, result.iterations);
  }

  class Lexer {
    constructor(config, syntax, structure$1) {
      this.cssWideKeywordsSyntax = cssWideKeywordsSyntax;
      this.syntax = syntax;
      this.generic = false;
      this.atrules = Object.create(null);
      this.properties = Object.create(null);
      this.types = Object.create(null);
      this.structure = structure$1 || structure.getStructureFromConfig(config);
      if (config) {
        if (config.types) {
          for (const name in config.types) {
            this.addType_(name, config.types[name]);
          }
        }
        if (config.generic) {
          this.generic = true;
          for (const name in generic) {
            this.addType_(name, generic[name]);
          }
        }
        if (config.atrules) {
          for (const name in config.atrules) {
            this.addAtrule_(name, config.atrules[name]);
          }
        }
        if (config.properties) {
          for (const name in config.properties) {
            this.addProperty_(name, config.properties[name]);
          }
        }
      }
    }
    checkStructure(ast) {
      function collectWarning(node, message) {
        warns.push({ node, message });
      }
      const structure2 = this.structure;
      const warns = [];
      this.syntax.walk(ast, function(node) {
        if (structure2.hasOwnProperty(node.type)) {
          structure2[node.type].check(node, collectWarning);
        } else {
          collectWarning(node, "Unknown node type `" + node.type + "`");
        }
      });
      return warns.length ? warns : false;
    }
    createDescriptor(syntax, type, name, parent = null) {
      const ref = {
        type,
        name
      };
      const descriptor = {
        type,
        name,
        parent,
        serializable: typeof syntax === "string" || syntax && typeof syntax.type === "string",
        syntax: null,
        match: null
      };
      if (typeof syntax === "function") {
        descriptor.match = matchGraph.buildMatchGraph(syntax, ref);
      } else {
        if (typeof syntax === "string") {
          Object.defineProperty(descriptor, "syntax", {
            get() {
              Object.defineProperty(descriptor, "syntax", {
                value: parse.parse(syntax)
              });
              return descriptor.syntax;
            }
          });
        } else {
          descriptor.syntax = syntax;
        }
        Object.defineProperty(descriptor, "match", {
          get() {
            Object.defineProperty(descriptor, "match", {
              value: matchGraph.buildMatchGraph(descriptor.syntax, ref)
            });
            return descriptor.match;
          }
        });
      }
      return descriptor;
    }
    addAtrule_(name, syntax) {
      if (!syntax) {
        return;
      }
      this.atrules[name] = {
        type: "Atrule",
        name,
        prelude: syntax.prelude ? this.createDescriptor(syntax.prelude, "AtrulePrelude", name) : null,
        descriptors: syntax.descriptors ? Object.keys(syntax.descriptors).reduce((map, descName) => {
          map[descName] = this.createDescriptor(syntax.descriptors[descName], "AtruleDescriptor", descName, name);
          return map;
        }, Object.create(null)) : null
      };
    }
    addProperty_(name, syntax) {
      if (!syntax) {
        return;
      }
      this.properties[name] = this.createDescriptor(syntax, "Property", name);
    }
    addType_(name, syntax) {
      if (!syntax) {
        return;
      }
      this.types[name] = this.createDescriptor(syntax, "Type", name);
    }
    checkAtruleName(atruleName) {
      if (!this.getAtrule(atruleName)) {
        return new error.SyntaxReferenceError("Unknown at-rule", "@" + atruleName);
      }
    }
    checkAtrulePrelude(atruleName, prelude) {
      const error2 = this.checkAtruleName(atruleName);
      if (error2) {
        return error2;
      }
      const atrule = this.getAtrule(atruleName);
      if (!atrule.prelude && prelude) {
        return new SyntaxError("At-rule `@" + atruleName + "` should not contain a prelude");
      }
      if (atrule.prelude && !prelude) {
        if (!matchSyntax(this, atrule.prelude, "", false).matched) {
          return new SyntaxError("At-rule `@" + atruleName + "` should contain a prelude");
        }
      }
    }
    checkAtruleDescriptorName(atruleName, descriptorName) {
      const error$1 = this.checkAtruleName(atruleName);
      if (error$1) {
        return error$1;
      }
      const atrule = this.getAtrule(atruleName);
      const descriptor = names.keyword(descriptorName);
      if (!atrule.descriptors) {
        return new SyntaxError("At-rule `@" + atruleName + "` has no known descriptors");
      }
      if (!atrule.descriptors[descriptor.name] && !atrule.descriptors[descriptor.basename]) {
        return new error.SyntaxReferenceError("Unknown at-rule descriptor", descriptorName);
      }
    }
    checkPropertyName(propertyName) {
      if (!this.getProperty(propertyName)) {
        return new error.SyntaxReferenceError("Unknown property", propertyName);
      }
    }
    matchAtrulePrelude(atruleName, prelude) {
      const error2 = this.checkAtrulePrelude(atruleName, prelude);
      if (error2) {
        return buildMatchResult(null, error2);
      }
      const atrule = this.getAtrule(atruleName);
      if (!atrule.prelude) {
        return buildMatchResult(null, null);
      }
      return matchSyntax(this, atrule.prelude, prelude || "", false);
    }
    matchAtruleDescriptor(atruleName, descriptorName, value) {
      const error2 = this.checkAtruleDescriptorName(atruleName, descriptorName);
      if (error2) {
        return buildMatchResult(null, error2);
      }
      const atrule = this.getAtrule(atruleName);
      const descriptor = names.keyword(descriptorName);
      return matchSyntax(this, atrule.descriptors[descriptor.name] || atrule.descriptors[descriptor.basename], value, false);
    }
    matchDeclaration(node) {
      if (node.type !== "Declaration") {
        return buildMatchResult(null, new Error("Not a Declaration node"));
      }
      return this.matchProperty(node.property, node.value);
    }
    matchProperty(propertyName, value) {
      if (names.property(propertyName).custom) {
        return buildMatchResult(null, new Error("Lexer matching doesn't applicable for custom properties"));
      }
      const error2 = this.checkPropertyName(propertyName);
      if (error2) {
        return buildMatchResult(null, error2);
      }
      return matchSyntax(this, this.getProperty(propertyName), value, true);
    }
    matchType(typeName, value) {
      const typeSyntax = this.getType(typeName);
      if (!typeSyntax) {
        return buildMatchResult(null, new error.SyntaxReferenceError("Unknown type", typeName));
      }
      return matchSyntax(this, typeSyntax, value, false);
    }
    match(syntax, value) {
      if (typeof syntax !== "string" && (!syntax || !syntax.type)) {
        return buildMatchResult(null, new error.SyntaxReferenceError("Bad syntax"));
      }
      if (typeof syntax === "string" || !syntax.match) {
        syntax = this.createDescriptor(syntax, "Type", "anonymous");
      }
      return matchSyntax(this, syntax, value, false);
    }
    findValueFragments(propertyName, value, type, name) {
      return search.matchFragments(this, value, this.matchProperty(propertyName, value), type, name);
    }
    findDeclarationValueFragments(declaration, type, name) {
      return search.matchFragments(this, declaration.value, this.matchDeclaration(declaration), type, name);
    }
    findAllFragments(ast, type, name) {
      const result = [];
      this.syntax.walk(ast, {
        visit: "Declaration",
        enter: (declaration) => {
          result.push.apply(result, this.findDeclarationValueFragments(declaration, type, name));
        }
      });
      return result;
    }
    getAtrule(atruleName, fallbackBasename = true) {
      const atrule = names.keyword(atruleName);
      const atruleEntry = atrule.vendor && fallbackBasename ? this.atrules[atrule.name] || this.atrules[atrule.basename] : this.atrules[atrule.name];
      return atruleEntry || null;
    }
    getAtrulePrelude(atruleName, fallbackBasename = true) {
      const atrule = this.getAtrule(atruleName, fallbackBasename);
      return atrule && atrule.prelude || null;
    }
    getAtruleDescriptor(atruleName, name) {
      return this.atrules.hasOwnProperty(atruleName) && this.atrules.declarators ? this.atrules[atruleName].declarators[name] || null : null;
    }
    getProperty(propertyName, fallbackBasename = true) {
      const property = names.property(propertyName);
      const propertyEntry = property.vendor && fallbackBasename ? this.properties[property.name] || this.properties[property.basename] : this.properties[property.name];
      return propertyEntry || null;
    }
    getType(name) {
      return hasOwnProperty.call(this.types, name) ? this.types[name] : null;
    }
    validate() {
      function validate(syntax, name, broken, descriptor) {
        if (broken.has(name)) {
          return broken.get(name);
        }
        broken.set(name, false);
        if (descriptor.syntax !== null) {
          walk.walk(descriptor.syntax, function(node) {
            if (node.type !== "Type" && node.type !== "Property") {
              return;
            }
            const map = node.type === "Type" ? syntax.types : syntax.properties;
            const brokenMap = node.type === "Type" ? brokenTypes : brokenProperties;
            if (!hasOwnProperty.call(map, node.name) || validate(syntax, node.name, brokenMap, map[node.name])) {
              broken.set(name, true);
            }
          }, this);
        }
      }
      let brokenTypes = new Map;
      let brokenProperties = new Map;
      for (const key in this.types) {
        validate(this, key, brokenTypes, this.types[key]);
      }
      for (const key in this.properties) {
        validate(this, key, brokenProperties, this.properties[key]);
      }
      brokenTypes = [...brokenTypes.keys()].filter((name) => brokenTypes.get(name));
      brokenProperties = [...brokenProperties.keys()].filter((name) => brokenProperties.get(name));
      if (brokenTypes.length || brokenProperties.length) {
        return {
          types: brokenTypes,
          properties: brokenProperties
        };
      }
      return null;
    }
    dump(syntaxAsAst, pretty) {
      return {
        generic: this.generic,
        types: dumpMapSyntax(this.types, !pretty, syntaxAsAst),
        properties: dumpMapSyntax(this.properties, !pretty, syntaxAsAst),
        atrules: dumpAtruleMapSyntax(this.atrules, !pretty, syntaxAsAst)
      };
    }
    toString() {
      return JSON.stringify(this.dump());
    }
  }
  exports.Lexer = Lexer;
});

// ../../../../node_modules/.bun/css-tree@2.2.1/node_modules/css-tree/cjs/syntax/config/mix.cjs
var require_mix2 = __commonJS((exports, module) => {
  var { hasOwnProperty: hasOwnProperty2 } = Object.prototype;
  var shape = {
    generic: true,
    types: appendOrAssign,
    atrules: {
      prelude: appendOrAssignOrNull,
      descriptors: appendOrAssignOrNull
    },
    properties: appendOrAssign,
    parseContext: assign,
    scope: deepAssign,
    atrule: ["parse"],
    pseudo: ["parse"],
    node: ["name", "structure", "parse", "generate", "walkContext"]
  };
  function isObject(value) {
    return value && value.constructor === Object;
  }
  function copy(value) {
    return isObject(value) ? { ...value } : value;
  }
  function assign(dest, src) {
    return Object.assign(dest, src);
  }
  function deepAssign(dest, src) {
    for (const key in src) {
      if (hasOwnProperty2.call(src, key)) {
        if (isObject(dest[key])) {
          deepAssign(dest[key], src[key]);
        } else {
          dest[key] = copy(src[key]);
        }
      }
    }
    return dest;
  }
  function append(a, b) {
    if (typeof b === "string" && /^\s*\|/.test(b)) {
      return typeof a === "string" ? a + b : b.replace(/^\s*\|\s*/, "");
    }
    return b || null;
  }
  function appendOrAssign(a, b) {
    if (typeof b === "string") {
      return append(a, b);
    }
    const result = { ...a };
    for (let key in b) {
      if (hasOwnProperty2.call(b, key)) {
        result[key] = append(hasOwnProperty2.call(a, key) ? a[key] : undefined, b[key]);
      }
    }
    return result;
  }
  function appendOrAssignOrNull(a, b) {
    const result = appendOrAssign(a, b);
    return !isObject(result) || Object.keys(result).length ? result : null;
  }
  function mix(dest, src, shape2) {
    for (const key in shape2) {
      if (hasOwnProperty2.call(shape2, key) === false) {
        continue;
      }
      if (shape2[key] === true) {
        if (hasOwnProperty2.call(src, key)) {
          dest[key] = copy(src[key]);
        }
      } else if (shape2[key]) {
        if (typeof shape2[key] === "function") {
          const fn = shape2[key];
          dest[key] = fn({}, dest[key]);
          dest[key] = fn(dest[key] || {}, src[key]);
        } else if (isObject(shape2[key])) {
          const result = {};
          for (let name in dest[key]) {
            result[name] = mix({}, dest[key][name], shape2[key]);
          }
          for (let name in src[key]) {
            result[name] = mix(result[name] || {}, src[key][name], shape2[key]);
          }
          dest[key] = result;
        } else if (Array.isArray(shape2[key])) {
          const res = {};
          const innerShape = shape2[key].reduce(function(s, k) {
            s[k] = true;
            return s;
          }, {});
          for (const [name, value] of Object.entries(dest[key] || {})) {
            res[name] = {};
            if (value) {
              mix(res[name], value, innerShape);
            }
          }
          for (const name in src[key]) {
            if (hasOwnProperty2.call(src[key], name)) {
              if (!res[name]) {
                res[name] = {};
              }
              if (src[key] && src[key][name]) {
                mix(res[name], src[key][name], innerShape);
              }
            }
          }
          dest[key] = res;
        }
      }
    }
    return dest;
  }
  var mix$1 = (dest, src) => mix(dest, src, shape);
  module.exports = mix$1;
});

// ../../../../node_modules/.bun/css-tree@2.2.1/node_modules/css-tree/cjs/syntax/create.cjs
var require_create10 = __commonJS((exports, module) => {
  var index = require_tokenizer3();
  var create = require_create6();
  var create$2 = require_create7();
  var create$3 = require_create8();
  var create$1 = require_create9();
  var Lexer = require_Lexer2();
  var mix = require_mix2();
  function createSyntax(config) {
    const parse = create.createParser(config);
    const walk = create$1.createWalker(config);
    const generate = create$2.createGenerator(config);
    const { fromPlainObject, toPlainObject } = create$3.createConvertor(walk);
    const syntax = {
      lexer: null,
      createLexer: (config2) => new Lexer.Lexer(config2, syntax, syntax.lexer.structure),
      tokenize: index.tokenize,
      parse,
      generate,
      walk,
      find: walk.find,
      findLast: walk.findLast,
      findAll: walk.findAll,
      fromPlainObject,
      toPlainObject,
      fork(extension) {
        const base = mix({}, config);
        return createSyntax(typeof extension === "function" ? extension(base, Object.assign) : mix(base, extension));
      }
    };
    syntax.lexer = new Lexer.Lexer({
      generic: true,
      types: config.types,
      atrules: config.atrules,
      properties: config.properties,
      node: config.node
    }, syntax);
    return syntax;
  }
  var createSyntax$1 = (config) => createSyntax(mix({}, config));
  module.exports = createSyntax$1;
});

// ../../../../node_modules/.bun/css-tree@2.2.1/node_modules/css-tree/data/patch.json
var require_patch2 = __commonJS((exports, module) => {
  module.exports = {
    atrules: {
      charset: {
        prelude: "<string>"
      },
      "font-face": {
        descriptors: {
          "unicode-range": {
            comment: "replaces <unicode-range>, an old production name",
            syntax: "<urange>#"
          }
        }
      }
    },
    properties: {
      "-moz-background-clip": {
        comment: "deprecated syntax in old Firefox, https://developer.mozilla.org/en/docs/Web/CSS/background-clip",
        syntax: "padding | border"
      },
      "-moz-border-radius-bottomleft": {
        comment: "https://developer.mozilla.org/en-US/docs/Web/CSS/border-bottom-left-radius",
        syntax: "<'border-bottom-left-radius'>"
      },
      "-moz-border-radius-bottomright": {
        comment: "https://developer.mozilla.org/en-US/docs/Web/CSS/border-bottom-right-radius",
        syntax: "<'border-bottom-right-radius'>"
      },
      "-moz-border-radius-topleft": {
        comment: "https://developer.mozilla.org/en-US/docs/Web/CSS/border-top-left-radius",
        syntax: "<'border-top-left-radius'>"
      },
      "-moz-border-radius-topright": {
        comment: "https://developer.mozilla.org/en-US/docs/Web/CSS/border-bottom-right-radius",
        syntax: "<'border-bottom-right-radius'>"
      },
      "-moz-control-character-visibility": {
        comment: "firefox specific keywords, https://bugzilla.mozilla.org/show_bug.cgi?id=947588",
        syntax: "visible | hidden"
      },
      "-moz-osx-font-smoothing": {
        comment: "misssed old syntax https://developer.mozilla.org/en-US/docs/Web/CSS/font-smooth",
        syntax: "auto | grayscale"
      },
      "-moz-user-select": {
        comment: "https://developer.mozilla.org/en-US/docs/Web/CSS/user-select",
        syntax: "none | text | all | -moz-none"
      },
      "-ms-flex-align": {
        comment: "misssed old syntax implemented in IE, https://www.w3.org/TR/2012/WD-css3-flexbox-20120322/#flex-align",
        syntax: "start | end | center | baseline | stretch"
      },
      "-ms-flex-item-align": {
        comment: "misssed old syntax implemented in IE, https://www.w3.org/TR/2012/WD-css3-flexbox-20120322/#flex-align",
        syntax: "auto | start | end | center | baseline | stretch"
      },
      "-ms-flex-line-pack": {
        comment: "misssed old syntax implemented in IE, https://www.w3.org/TR/2012/WD-css3-flexbox-20120322/#flex-line-pack",
        syntax: "start | end | center | justify | distribute | stretch"
      },
      "-ms-flex-negative": {
        comment: "misssed old syntax implemented in IE; TODO: find references for comfirmation",
        syntax: "<'flex-shrink'>"
      },
      "-ms-flex-pack": {
        comment: "misssed old syntax implemented in IE, https://www.w3.org/TR/2012/WD-css3-flexbox-20120322/#flex-pack",
        syntax: "start | end | center | justify | distribute"
      },
      "-ms-flex-order": {
        comment: "misssed old syntax implemented in IE; https://msdn.microsoft.com/en-us/library/jj127303(v=vs.85).aspx",
        syntax: "<integer>"
      },
      "-ms-flex-positive": {
        comment: "misssed old syntax implemented in IE; TODO: find references for comfirmation",
        syntax: "<'flex-grow'>"
      },
      "-ms-flex-preferred-size": {
        comment: "misssed old syntax implemented in IE; TODO: find references for comfirmation",
        syntax: "<'flex-basis'>"
      },
      "-ms-interpolation-mode": {
        comment: "https://msdn.microsoft.com/en-us/library/ff521095(v=vs.85).aspx",
        syntax: "nearest-neighbor | bicubic"
      },
      "-ms-grid-column-align": {
        comment: "add this property first since it uses as fallback for flexbox, https://msdn.microsoft.com/en-us/library/windows/apps/hh466338.aspx",
        syntax: "start | end | center | stretch"
      },
      "-ms-grid-row-align": {
        comment: "add this property first since it uses as fallback for flexbox, https://msdn.microsoft.com/en-us/library/windows/apps/hh466348.aspx",
        syntax: "start | end | center | stretch"
      },
      "-ms-hyphenate-limit-last": {
        comment: "misssed old syntax implemented in IE; https://www.w3.org/TR/css-text-4/#hyphenate-line-limits",
        syntax: "none | always | column | page | spread"
      },
      "-webkit-appearance": {
        comment: "webkit specific keywords",
        references: [
          "http://css-infos.net/property/-webkit-appearance"
        ],
        syntax: "none | button | button-bevel | caps-lock-indicator | caret | checkbox | default-button | inner-spin-button | listbox | listitem | media-controls-background | media-controls-fullscreen-background | media-current-time-display | media-enter-fullscreen-button | media-exit-fullscreen-button | media-fullscreen-button | media-mute-button | media-overlay-play-button | media-play-button | media-seek-back-button | media-seek-forward-button | media-slider | media-sliderthumb | media-time-remaining-display | media-toggle-closed-captions-button | media-volume-slider | media-volume-slider-container | media-volume-sliderthumb | menulist | menulist-button | menulist-text | menulist-textfield | meter | progress-bar | progress-bar-value | push-button | radio | scrollbarbutton-down | scrollbarbutton-left | scrollbarbutton-right | scrollbarbutton-up | scrollbargripper-horizontal | scrollbargripper-vertical | scrollbarthumb-horizontal | scrollbarthumb-vertical | scrollbartrack-horizontal | scrollbartrack-vertical | searchfield | searchfield-cancel-button | searchfield-decoration | searchfield-results-button | searchfield-results-decoration | slider-horizontal | slider-vertical | sliderthumb-horizontal | sliderthumb-vertical | square-button | textarea | textfield | -apple-pay-button"
      },
      "-webkit-background-clip": {
        comment: "https://developer.mozilla.org/en/docs/Web/CSS/background-clip",
        syntax: "[ <box> | border | padding | content | text ]#"
      },
      "-webkit-column-break-after": {
        comment: "added, http://help.dottoro.com/lcrthhhv.php",
        syntax: "always | auto | avoid"
      },
      "-webkit-column-break-before": {
        comment: "added, http://help.dottoro.com/lcxquvkf.php",
        syntax: "always | auto | avoid"
      },
      "-webkit-column-break-inside": {
        comment: "added, http://help.dottoro.com/lclhnthl.php",
        syntax: "always | auto | avoid"
      },
      "-webkit-font-smoothing": {
        comment: "https://developer.mozilla.org/en-US/docs/Web/CSS/font-smooth",
        syntax: "auto | none | antialiased | subpixel-antialiased"
      },
      "-webkit-mask-box-image": {
        comment: "missed; https://developer.mozilla.org/en-US/docs/Web/CSS/-webkit-mask-box-image",
        syntax: "[ <url> | <gradient> | none ] [ <length-percentage>{4} <-webkit-mask-box-repeat>{2} ]?"
      },
      "-webkit-print-color-adjust": {
        comment: "missed",
        references: [
          "https://developer.mozilla.org/en/docs/Web/CSS/-webkit-print-color-adjust"
        ],
        syntax: "economy | exact"
      },
      "-webkit-text-security": {
        comment: "missed; http://help.dottoro.com/lcbkewgt.php",
        syntax: "none | circle | disc | square"
      },
      "-webkit-user-drag": {
        comment: "missed; http://help.dottoro.com/lcbixvwm.php",
        syntax: "none | element | auto"
      },
      "-webkit-user-select": {
        comment: "auto is supported by old webkit, https://developer.mozilla.org/en-US/docs/Web/CSS/user-select",
        syntax: "auto | none | text | all"
      },
      "alignment-baseline": {
        comment: "added SVG property",
        references: [
          "https://www.w3.org/TR/SVG/text.html#AlignmentBaselineProperty"
        ],
        syntax: "auto | baseline | before-edge | text-before-edge | middle | central | after-edge | text-after-edge | ideographic | alphabetic | hanging | mathematical"
      },
      "background-clip": {
        comment: "used <bg-clip> from CSS Backgrounds and Borders 4 since it adds new values",
        references: [
          "https://github.com/csstree/csstree/issues/190"
        ],
        syntax: "<bg-clip>#"
      },
      "baseline-shift": {
        comment: "added SVG property",
        references: [
          "https://www.w3.org/TR/SVG/text.html#BaselineShiftProperty"
        ],
        syntax: "baseline | sub | super | <svg-length>"
      },
      behavior: {
        comment: "added old IE property https://msdn.microsoft.com/en-us/library/ms530723(v=vs.85).aspx",
        syntax: "<url>+"
      },
      "clip-rule": {
        comment: "added SVG property",
        references: [
          "https://www.w3.org/TR/SVG/masking.html#ClipRuleProperty"
        ],
        syntax: "nonzero | evenodd"
      },
      cue: {
        comment: "https://www.w3.org/TR/css3-speech/#property-index",
        syntax: "<'cue-before'> <'cue-after'>?"
      },
      "cue-after": {
        comment: "https://www.w3.org/TR/css3-speech/#property-index",
        syntax: "<url> <decibel>? | none"
      },
      "cue-before": {
        comment: "https://www.w3.org/TR/css3-speech/#property-index",
        syntax: "<url> <decibel>? | none"
      },
      cursor: {
        comment: "added legacy keywords: hand, -webkit-grab. -webkit-grabbing, -webkit-zoom-in, -webkit-zoom-out, -moz-grab, -moz-grabbing, -moz-zoom-in, -moz-zoom-out",
        references: [
          "https://www.sitepoint.com/css3-cursor-styles/"
        ],
        syntax: "[ [ <url> [ <x> <y> ]? , ]* [ auto | default | none | context-menu | help | pointer | progress | wait | cell | crosshair | text | vertical-text | alias | copy | move | no-drop | not-allowed | e-resize | n-resize | ne-resize | nw-resize | s-resize | se-resize | sw-resize | w-resize | ew-resize | ns-resize | nesw-resize | nwse-resize | col-resize | row-resize | all-scroll | zoom-in | zoom-out | grab | grabbing | hand | -webkit-grab | -webkit-grabbing | -webkit-zoom-in | -webkit-zoom-out | -moz-grab | -moz-grabbing | -moz-zoom-in | -moz-zoom-out ] ]"
      },
      display: {
        comment: "extended with -ms-flexbox",
        syntax: "| <-non-standard-display>"
      },
      position: {
        comment: "extended with -webkit-sticky",
        syntax: "| -webkit-sticky"
      },
      "dominant-baseline": {
        comment: "added SVG property",
        references: [
          "https://www.w3.org/TR/SVG/text.html#DominantBaselineProperty"
        ],
        syntax: "auto | use-script | no-change | reset-size | ideographic | alphabetic | hanging | mathematical | central | middle | text-after-edge | text-before-edge"
      },
      "image-rendering": {
        comment: "extended with <-non-standard-image-rendering>, added SVG keywords optimizeSpeed and optimizeQuality",
        references: [
          "https://developer.mozilla.org/en/docs/Web/CSS/image-rendering",
          "https://www.w3.org/TR/SVG/painting.html#ImageRenderingProperty"
        ],
        syntax: "| optimizeSpeed | optimizeQuality | <-non-standard-image-rendering>"
      },
      fill: {
        comment: "added SVG property",
        references: [
          "https://www.w3.org/TR/SVG/painting.html#FillProperty"
        ],
        syntax: "<paint>"
      },
      "fill-opacity": {
        comment: "added SVG property",
        references: [
          "https://www.w3.org/TR/SVG/painting.html#FillProperty"
        ],
        syntax: "<number-zero-one>"
      },
      "fill-rule": {
        comment: "added SVG property",
        references: [
          "https://www.w3.org/TR/SVG/painting.html#FillProperty"
        ],
        syntax: "nonzero | evenodd"
      },
      filter: {
        comment: "extend with IE legacy syntaxes",
        syntax: "| <-ms-filter-function-list>"
      },
      "glyph-orientation-horizontal": {
        comment: "added SVG property",
        references: [
          "https://www.w3.org/TR/SVG/text.html#GlyphOrientationHorizontalProperty"
        ],
        syntax: "<angle>"
      },
      "glyph-orientation-vertical": {
        comment: "added SVG property",
        references: [
          "https://www.w3.org/TR/SVG/text.html#GlyphOrientationVerticalProperty"
        ],
        syntax: "<angle>"
      },
      kerning: {
        comment: "added SVG property",
        references: [
          "https://www.w3.org/TR/SVG/text.html#KerningProperty"
        ],
        syntax: "auto | <svg-length>"
      },
      "letter-spacing": {
        comment: "fix syntax <length> -> <length-percentage>",
        references: [
          "https://developer.mozilla.org/en-US/docs/Web/SVG/Attribute/letter-spacing"
        ],
        syntax: "normal | <length-percentage>"
      },
      marker: {
        comment: "added SVG property",
        references: [
          "https://www.w3.org/TR/SVG/painting.html#MarkerProperties"
        ],
        syntax: "none | <url>"
      },
      "marker-end": {
        comment: "added SVG property",
        references: [
          "https://www.w3.org/TR/SVG/painting.html#MarkerProperties"
        ],
        syntax: "none | <url>"
      },
      "marker-mid": {
        comment: "added SVG property",
        references: [
          "https://www.w3.org/TR/SVG/painting.html#MarkerProperties"
        ],
        syntax: "none | <url>"
      },
      "marker-start": {
        comment: "added SVG property",
        references: [
          "https://www.w3.org/TR/SVG/painting.html#MarkerProperties"
        ],
        syntax: "none | <url>"
      },
      "max-width": {
        comment: "extend by non-standard width keywords https://developer.mozilla.org/en-US/docs/Web/CSS/max-width",
        syntax: "| <-non-standard-width>"
      },
      width: {
        references: [
          "https://developer.mozilla.org/en-US/docs/Web/CSS/width",
          "https://github.com/csstree/stylelint-validator/issues/29"
        ],
        syntax: "| fill | stretch | intrinsic | -moz-max-content | -webkit-max-content | -moz-fit-content | -webkit-fit-content"
      },
      "min-width": {
        comment: "extend by non-standard width keywords https://developer.mozilla.org/en-US/docs/Web/CSS/width",
        syntax: "| <-non-standard-width>"
      },
      overflow: {
        comment: "extend by vendor keywords https://developer.mozilla.org/en-US/docs/Web/CSS/overflow",
        syntax: "| <-non-standard-overflow>"
      },
      pause: {
        comment: "https://www.w3.org/TR/css3-speech/#property-index",
        syntax: "<'pause-before'> <'pause-after'>?"
      },
      "pause-after": {
        comment: "https://www.w3.org/TR/css3-speech/#property-index",
        syntax: "<time> | none | x-weak | weak | medium | strong | x-strong"
      },
      "pause-before": {
        comment: "https://www.w3.org/TR/css3-speech/#property-index",
        syntax: "<time> | none | x-weak | weak | medium | strong | x-strong"
      },
      rest: {
        comment: "https://www.w3.org/TR/css3-speech/#property-index",
        syntax: "<'rest-before'> <'rest-after'>?"
      },
      "rest-after": {
        comment: "https://www.w3.org/TR/css3-speech/#property-index",
        syntax: "<time> | none | x-weak | weak | medium | strong | x-strong"
      },
      "rest-before": {
        comment: "https://www.w3.org/TR/css3-speech/#property-index",
        syntax: "<time> | none | x-weak | weak | medium | strong | x-strong"
      },
      "shape-rendering": {
        comment: "added SVG property",
        references: [
          "https://www.w3.org/TR/SVG/painting.html#ShapeRenderingPropert"
        ],
        syntax: "auto | optimizeSpeed | crispEdges | geometricPrecision"
      },
      src: {
        comment: "added @font-face's src property https://developer.mozilla.org/en-US/docs/Web/CSS/@font-face/src",
        syntax: "[ <url> [ format( <string># ) ]? | local( <family-name> ) ]#"
      },
      speak: {
        comment: "https://www.w3.org/TR/css3-speech/#property-index",
        syntax: "auto | none | normal"
      },
      "speak-as": {
        comment: "https://www.w3.org/TR/css3-speech/#property-index",
        syntax: "normal | spell-out || digits || [ literal-punctuation | no-punctuation ]"
      },
      stroke: {
        comment: "added SVG property",
        references: [
          "https://www.w3.org/TR/SVG/painting.html#StrokeProperties"
        ],
        syntax: "<paint>"
      },
      "stroke-dasharray": {
        comment: "added SVG property; a list of comma and/or white space separated <length>s and <percentage>s",
        references: [
          "https://www.w3.org/TR/SVG/painting.html#StrokeProperties"
        ],
        syntax: "none | [ <svg-length>+ ]#"
      },
      "stroke-dashoffset": {
        comment: "added SVG property",
        references: [
          "https://www.w3.org/TR/SVG/painting.html#StrokeProperties"
        ],
        syntax: "<svg-length>"
      },
      "stroke-linecap": {
        comment: "added SVG property",
        references: [
          "https://www.w3.org/TR/SVG/painting.html#StrokeProperties"
        ],
        syntax: "butt | round | square"
      },
      "stroke-linejoin": {
        comment: "added SVG property",
        references: [
          "https://www.w3.org/TR/SVG/painting.html#StrokeProperties"
        ],
        syntax: "miter | round | bevel"
      },
      "stroke-miterlimit": {
        comment: "added SVG property (<miterlimit> = <number-one-or-greater>) ",
        references: [
          "https://www.w3.org/TR/SVG/painting.html#StrokeProperties"
        ],
        syntax: "<number-one-or-greater>"
      },
      "stroke-opacity": {
        comment: "added SVG property",
        references: [
          "https://www.w3.org/TR/SVG/painting.html#StrokeProperties"
        ],
        syntax: "<number-zero-one>"
      },
      "stroke-width": {
        comment: "added SVG property",
        references: [
          "https://www.w3.org/TR/SVG/painting.html#StrokeProperties"
        ],
        syntax: "<svg-length>"
      },
      "text-anchor": {
        comment: "added SVG property",
        references: [
          "https://www.w3.org/TR/SVG/text.html#TextAlignmentProperties"
        ],
        syntax: "start | middle | end"
      },
      "unicode-bidi": {
        comment: "added prefixed keywords https://developer.mozilla.org/en-US/docs/Web/CSS/unicode-bidi",
        syntax: "| -moz-isolate | -moz-isolate-override | -moz-plaintext | -webkit-isolate | -webkit-isolate-override | -webkit-plaintext"
      },
      "unicode-range": {
        comment: "added missed property https://developer.mozilla.org/en-US/docs/Web/CSS/%40font-face/unicode-range",
        syntax: "<urange>#"
      },
      "voice-balance": {
        comment: "https://www.w3.org/TR/css3-speech/#property-index",
        syntax: "<number> | left | center | right | leftwards | rightwards"
      },
      "voice-duration": {
        comment: "https://www.w3.org/TR/css3-speech/#property-index",
        syntax: "auto | <time>"
      },
      "voice-family": {
        comment: "<name> -> <family-name>, https://www.w3.org/TR/css3-speech/#property-index",
        syntax: "[ [ <family-name> | <generic-voice> ] , ]* [ <family-name> | <generic-voice> ] | preserve"
      },
      "voice-pitch": {
        comment: "https://www.w3.org/TR/css3-speech/#property-index",
        syntax: "<frequency> && absolute | [ [ x-low | low | medium | high | x-high ] || [ <frequency> | <semitones> | <percentage> ] ]"
      },
      "voice-range": {
        comment: "https://www.w3.org/TR/css3-speech/#property-index",
        syntax: "<frequency> && absolute | [ [ x-low | low | medium | high | x-high ] || [ <frequency> | <semitones> | <percentage> ] ]"
      },
      "voice-rate": {
        comment: "https://www.w3.org/TR/css3-speech/#property-index",
        syntax: "[ normal | x-slow | slow | medium | fast | x-fast ] || <percentage>"
      },
      "voice-stress": {
        comment: "https://www.w3.org/TR/css3-speech/#property-index",
        syntax: "normal | strong | moderate | none | reduced"
      },
      "voice-volume": {
        comment: "https://www.w3.org/TR/css3-speech/#property-index",
        syntax: "silent | [ [ x-soft | soft | medium | loud | x-loud ] || <decibel> ]"
      },
      "writing-mode": {
        comment: "extend with SVG keywords",
        syntax: "| <svg-writing-mode>"
      }
    },
    types: {
      "-legacy-gradient": {
        comment: "added collection of legacy gradient syntaxes",
        syntax: "<-webkit-gradient()> | <-legacy-linear-gradient> | <-legacy-repeating-linear-gradient> | <-legacy-radial-gradient> | <-legacy-repeating-radial-gradient>"
      },
      "-legacy-linear-gradient": {
        comment: "like standard syntax but w/o `to` keyword https://developer.mozilla.org/en-US/docs/Web/CSS/linear-gradient",
        syntax: "-moz-linear-gradient( <-legacy-linear-gradient-arguments> ) | -webkit-linear-gradient( <-legacy-linear-gradient-arguments> ) | -o-linear-gradient( <-legacy-linear-gradient-arguments> )"
      },
      "-legacy-repeating-linear-gradient": {
        comment: "like standard syntax but w/o `to` keyword https://developer.mozilla.org/en-US/docs/Web/CSS/linear-gradient",
        syntax: "-moz-repeating-linear-gradient( <-legacy-linear-gradient-arguments> ) | -webkit-repeating-linear-gradient( <-legacy-linear-gradient-arguments> ) | -o-repeating-linear-gradient( <-legacy-linear-gradient-arguments> )"
      },
      "-legacy-linear-gradient-arguments": {
        comment: "like standard syntax but w/o `to` keyword https://developer.mozilla.org/en-US/docs/Web/CSS/linear-gradient",
        syntax: "[ <angle> | <side-or-corner> ]? , <color-stop-list>"
      },
      "-legacy-radial-gradient": {
        comment: "deprecated syntax that implemented by some browsers https://www.w3.org/TR/2011/WD-css3-images-20110908/#radial-gradients",
        syntax: "-moz-radial-gradient( <-legacy-radial-gradient-arguments> ) | -webkit-radial-gradient( <-legacy-radial-gradient-arguments> ) | -o-radial-gradient( <-legacy-radial-gradient-arguments> )"
      },
      "-legacy-repeating-radial-gradient": {
        comment: "deprecated syntax that implemented by some browsers https://www.w3.org/TR/2011/WD-css3-images-20110908/#radial-gradients",
        syntax: "-moz-repeating-radial-gradient( <-legacy-radial-gradient-arguments> ) | -webkit-repeating-radial-gradient( <-legacy-radial-gradient-arguments> ) | -o-repeating-radial-gradient( <-legacy-radial-gradient-arguments> )"
      },
      "-legacy-radial-gradient-arguments": {
        comment: "deprecated syntax that implemented by some browsers https://www.w3.org/TR/2011/WD-css3-images-20110908/#radial-gradients",
        syntax: "[ <position> , ]? [ [ [ <-legacy-radial-gradient-shape> || <-legacy-radial-gradient-size> ] | [ <length> | <percentage> ]{2} ] , ]? <color-stop-list>"
      },
      "-legacy-radial-gradient-size": {
        comment: "before a standard it contains 2 extra keywords (`contain` and `cover`) https://www.w3.org/TR/2011/WD-css3-images-20110908/#ltsize",
        syntax: "closest-side | closest-corner | farthest-side | farthest-corner | contain | cover"
      },
      "-legacy-radial-gradient-shape": {
        comment: "define to double sure it doesn't extends in future https://www.w3.org/TR/2011/WD-css3-images-20110908/#ltshape",
        syntax: "circle | ellipse"
      },
      "-non-standard-font": {
        comment: "non standard fonts",
        references: [
          "https://webkit.org/blog/3709/using-the-system-font-in-web-content/"
        ],
        syntax: "-apple-system-body | -apple-system-headline | -apple-system-subheadline | -apple-system-caption1 | -apple-system-caption2 | -apple-system-footnote | -apple-system-short-body | -apple-system-short-headline | -apple-system-short-subheadline | -apple-system-short-caption1 | -apple-system-short-footnote | -apple-system-tall-body"
      },
      "-non-standard-color": {
        comment: "non standard colors",
        references: [
          "http://cssdot.ru/%D0%A1%D0%BF%D1%80%D0%B0%D0%B2%D0%BE%D1%87%D0%BD%D0%B8%D0%BA_CSS/color-i305.html",
          "https://developer.mozilla.org/en-US/docs/Web/CSS/color_value#Mozilla_Color_Preference_Extensions"
        ],
        syntax: "-moz-ButtonDefault | -moz-ButtonHoverFace | -moz-ButtonHoverText | -moz-CellHighlight | -moz-CellHighlightText | -moz-Combobox | -moz-ComboboxText | -moz-Dialog | -moz-DialogText | -moz-dragtargetzone | -moz-EvenTreeRow | -moz-Field | -moz-FieldText | -moz-html-CellHighlight | -moz-html-CellHighlightText | -moz-mac-accentdarkestshadow | -moz-mac-accentdarkshadow | -moz-mac-accentface | -moz-mac-accentlightesthighlight | -moz-mac-accentlightshadow | -moz-mac-accentregularhighlight | -moz-mac-accentregularshadow | -moz-mac-chrome-active | -moz-mac-chrome-inactive | -moz-mac-focusring | -moz-mac-menuselect | -moz-mac-menushadow | -moz-mac-menutextselect | -moz-MenuHover | -moz-MenuHoverText | -moz-MenuBarText | -moz-MenuBarHoverText | -moz-nativehyperlinktext | -moz-OddTreeRow | -moz-win-communicationstext | -moz-win-mediatext | -moz-activehyperlinktext | -moz-default-background-color | -moz-default-color | -moz-hyperlinktext | -moz-visitedhyperlinktext | -webkit-activelink | -webkit-focus-ring-color | -webkit-link | -webkit-text"
      },
      "-non-standard-image-rendering": {
        comment: "non-standard keywords http://phrogz.net/tmp/canvas_image_zoom.html",
        syntax: "optimize-contrast | -moz-crisp-edges | -o-crisp-edges | -webkit-optimize-contrast"
      },
      "-non-standard-overflow": {
        comment: "non-standard keywords https://developer.mozilla.org/en-US/docs/Web/CSS/overflow",
        syntax: "-moz-scrollbars-none | -moz-scrollbars-horizontal | -moz-scrollbars-vertical | -moz-hidden-unscrollable"
      },
      "-non-standard-width": {
        comment: "non-standard keywords https://developer.mozilla.org/en-US/docs/Web/CSS/width",
        syntax: "fill-available | min-intrinsic | intrinsic | -moz-available | -moz-fit-content | -moz-min-content | -moz-max-content | -webkit-min-content | -webkit-max-content"
      },
      "-webkit-gradient()": {
        comment: "first Apple proposal gradient syntax https://webkit.org/blog/175/introducing-css-gradients/ - TODO: simplify when after match algorithm improvement ( [, point, radius | , point] -> [, radius]? , point )",
        syntax: "-webkit-gradient( <-webkit-gradient-type>, <-webkit-gradient-point> [, <-webkit-gradient-point> | , <-webkit-gradient-radius>, <-webkit-gradient-point> ] [, <-webkit-gradient-radius>]? [, <-webkit-gradient-color-stop>]* )"
      },
      "-webkit-gradient-color-stop": {
        comment: "first Apple proposal gradient syntax https://webkit.org/blog/175/introducing-css-gradients/",
        syntax: "from( <color> ) | color-stop( [ <number-zero-one> | <percentage> ] , <color> ) | to( <color> )"
      },
      "-webkit-gradient-point": {
        comment: "first Apple proposal gradient syntax https://webkit.org/blog/175/introducing-css-gradients/",
        syntax: "[ left | center | right | <length-percentage> ] [ top | center | bottom | <length-percentage> ]"
      },
      "-webkit-gradient-radius": {
        comment: "first Apple proposal gradient syntax https://webkit.org/blog/175/introducing-css-gradients/",
        syntax: "<length> | <percentage>"
      },
      "-webkit-gradient-type": {
        comment: "first Apple proposal gradient syntax https://webkit.org/blog/175/introducing-css-gradients/",
        syntax: "linear | radial"
      },
      "-webkit-mask-box-repeat": {
        comment: "missed; https://developer.mozilla.org/en-US/docs/Web/CSS/-webkit-mask-box-image",
        syntax: "repeat | stretch | round"
      },
      "-webkit-mask-clip-style": {
        comment: "missed; there is no enough information about `-webkit-mask-clip` property, but looks like all those keywords are working",
        syntax: "border | border-box | padding | padding-box | content | content-box | text"
      },
      "-ms-filter-function-list": {
        comment: "https://developer.mozilla.org/en-US/docs/Web/CSS/-ms-filter",
        syntax: "<-ms-filter-function>+"
      },
      "-ms-filter-function": {
        comment: "https://developer.mozilla.org/en-US/docs/Web/CSS/-ms-filter",
        syntax: "<-ms-filter-function-progid> | <-ms-filter-function-legacy>"
      },
      "-ms-filter-function-progid": {
        comment: "https://developer.mozilla.org/en-US/docs/Web/CSS/-ms-filter",
        syntax: "'progid:' [ <ident-token> '.' ]* [ <ident-token> | <function-token> <any-value>? ) ]"
      },
      "-ms-filter-function-legacy": {
        comment: "https://developer.mozilla.org/en-US/docs/Web/CSS/-ms-filter",
        syntax: "<ident-token> | <function-token> <any-value>? )"
      },
      "-ms-filter": {
        syntax: "<string>"
      },
      age: {
        comment: "https://www.w3.org/TR/css3-speech/#voice-family",
        syntax: "child | young | old"
      },
      "attr-name": {
        syntax: "<wq-name>"
      },
      "attr-fallback": {
        syntax: "<any-value>"
      },
      "bg-clip": {
        comment: "missed, https://drafts.csswg.org/css-backgrounds-4/#typedef-bg-clip",
        syntax: "<box> | border | text"
      },
      "border-radius": {
        comment: "missed, https://drafts.csswg.org/css-backgrounds-3/#the-border-radius",
        syntax: "<length-percentage>{1,2}"
      },
      bottom: {
        comment: "missed; not sure we should add it, but no others except `shape` is using it so it's ok for now; https://drafts.fxtf.org/css-masking-1/#funcdef-clip-rect",
        syntax: "<length> | auto"
      },
      "content-list": {
        comment: "added attr(), see https://github.com/csstree/csstree/issues/201",
        syntax: "[ <string> | contents | <image> | <counter> | <quote> | <target> | <leader()> | <attr()> ]+"
      },
      "element()": {
        comment: "https://drafts.csswg.org/css-gcpm/#element-syntax & https://drafts.csswg.org/css-images-4/#element-notation",
        syntax: "element( <custom-ident> , [ first | start | last | first-except ]? ) | element( <id-selector> )"
      },
      "generic-voice": {
        comment: "https://www.w3.org/TR/css3-speech/#voice-family",
        syntax: "[ <age>? <gender> <integer>? ]"
      },
      gender: {
        comment: "https://www.w3.org/TR/css3-speech/#voice-family",
        syntax: "male | female | neutral"
      },
      "generic-family": {
        comment: "added -apple-system",
        references: [
          "https://webkit.org/blog/3709/using-the-system-font-in-web-content/"
        ],
        syntax: "| -apple-system"
      },
      gradient: {
        comment: "added legacy syntaxes support",
        syntax: "| <-legacy-gradient>"
      },
      "lab()": {
        comment: "missed; https://www.w3.org/TR/css-color-4/#specifying-lab-lch",
        syntax: "lab( [<percentage> | <number> | none] [ <percentage> | <number> | none] [ <percentage> | <number> | none] [ / [<alpha-value> | none] ]? )"
      },
      "lch()": {
        comment: "missed; https://www.w3.org/TR/css-color-4/#specifying-lab-lch",
        syntax: "lch( [<percentage> | <number> | none] [ <percentage> | <number> | none] [ <hue> | none] [ / [<alpha-value> | none] ]? )"
      },
      left: {
        comment: "missed; not sure we should add it, but no others except `shape` is using it so it's ok for now; https://drafts.fxtf.org/css-masking-1/#funcdef-clip-rect",
        syntax: "<length> | auto"
      },
      "mask-image": {
        comment: "missed; https://drafts.fxtf.org/css-masking-1/#the-mask-image",
        syntax: "<mask-reference>#"
      },
      "named-color": {
        comment: "added non standard color names",
        syntax: "| <-non-standard-color>"
      },
      paint: {
        comment: "used by SVG https://www.w3.org/TR/SVG/painting.html#SpecifyingPaint",
        syntax: "none | <color> | <url> [ none | <color> ]? | context-fill | context-stroke"
      },
      ratio: {
        comment: "missed, https://drafts.csswg.org/css-values-4/#ratio-value",
        syntax: "<number [0,]> [ / <number [0,]> ]?"
      },
      "reversed-counter-name": {
        comment: "missed; https://drafts.csswg.org/css-lists/#typedef-reversed-counter-name",
        syntax: "reversed( <counter-name> )"
      },
      right: {
        comment: "missed; not sure we should add it, but no others except `shape` is using it so it's ok for now; https://drafts.fxtf.org/css-masking-1/#funcdef-clip-rect",
        syntax: "<length> | auto"
      },
      shape: {
        comment: "missed spaces in function body and add backwards compatible syntax",
        syntax: "rect( <top>, <right>, <bottom>, <left> ) | rect( <top> <right> <bottom> <left> )"
      },
      "svg-length": {
        comment: "All coordinates and lengths in SVG can be specified with or without a unit identifier",
        references: [
          "https://www.w3.org/TR/SVG11/coords.html#Units"
        ],
        syntax: "<percentage> | <length> | <number>"
      },
      "svg-writing-mode": {
        comment: "SVG specific keywords (deprecated for CSS)",
        references: [
          "https://developer.mozilla.org/en/docs/Web/CSS/writing-mode",
          "https://www.w3.org/TR/SVG/text.html#WritingModeProperty"
        ],
        syntax: "lr-tb | rl-tb | tb-rl | lr | rl | tb"
      },
      top: {
        comment: "missed; not sure we should add it, but no others except `shape` is using it so it's ok for now; https://drafts.fxtf.org/css-masking-1/#funcdef-clip-rect",
        syntax: "<length> | auto"
      },
      "track-group": {
        comment: "used by old grid-columns and grid-rows syntax v0",
        syntax: "'(' [ <string>* <track-minmax> <string>* ]+ ')' [ '[' <positive-integer> ']' ]? | <track-minmax>"
      },
      "track-list-v0": {
        comment: "used by old grid-columns and grid-rows syntax v0",
        syntax: "[ <string>* <track-group> <string>* ]+ | none"
      },
      "track-minmax": {
        comment: "used by old grid-columns and grid-rows syntax v0",
        syntax: "minmax( <track-breadth> , <track-breadth> ) | auto | <track-breadth> | fit-content"
      },
      x: {
        comment: "missed; not sure we should add it, but no others except `cursor` is using it so it's ok for now; https://drafts.csswg.org/css-ui-3/#cursor",
        syntax: "<number>"
      },
      y: {
        comment: "missed; not sure we should add it, but no others except `cursor` is using so it's ok for now; https://drafts.csswg.org/css-ui-3/#cursor",
        syntax: "<number>"
      },
      declaration: {
        comment: "missed, restored by https://drafts.csswg.org/css-syntax",
        syntax: "<ident-token> : <declaration-value>? [ '!' important ]?"
      },
      "declaration-list": {
        comment: "missed, restored by https://drafts.csswg.org/css-syntax",
        syntax: "[ <declaration>? ';' ]* <declaration>?"
      },
      url: {
        comment: "https://drafts.csswg.org/css-values-4/#urls",
        syntax: "url( <string> <url-modifier>* ) | <url-token>"
      },
      "url-modifier": {
        comment: "https://drafts.csswg.org/css-values-4/#typedef-url-modifier",
        syntax: "<ident> | <function-token> <any-value> )"
      },
      "number-zero-one": {
        syntax: "<number [0,1]>"
      },
      "number-one-or-greater": {
        syntax: "<number [1,]>"
      },
      "positive-integer": {
        syntax: "<integer [0,]>"
      },
      "-non-standard-display": {
        syntax: "-ms-inline-flexbox | -ms-grid | -ms-inline-grid | -webkit-flex | -webkit-inline-flex | -webkit-box | -webkit-inline-box | -moz-inline-stack | -moz-box | -moz-inline-box"
      }
    }
  };
});

// ../../../../node_modules/.bun/css-tree@2.2.1/node_modules/css-tree/cjs/data-patch.cjs
var require_data_patch2 = __commonJS((exports, module) => {
  var patch = require_patch2();
  var patch$1 = patch;
  module.exports = patch$1;
});

// ../../../../node_modules/.bun/mdn-data@2.0.28/node_modules/mdn-data/css/at-rules.json
var require_at_rules2 = __commonJS((exports, module) => {
  module.exports = {
    "@charset": {
      syntax: '@charset "<charset>";',
      groups: [
        "CSS Charsets"
      ],
      status: "standard",
      mdn_url: "https://developer.mozilla.org/docs/Web/CSS/@charset"
    },
    "@counter-style": {
      syntax: `@counter-style <counter-style-name> {
  [ system: <counter-system>; ] ||
  [ symbols: <counter-symbols>; ] ||
  [ additive-symbols: <additive-symbols>; ] ||
  [ negative: <negative-symbol>; ] ||
  [ prefix: <prefix>; ] ||
  [ suffix: <suffix>; ] ||
  [ range: <range>; ] ||
  [ pad: <padding>; ] ||
  [ speak-as: <speak-as>; ] ||
  [ fallback: <counter-style-name>; ]
}`,
      interfaces: [
        "CSSCounterStyleRule"
      ],
      groups: [
        "CSS Counter Styles"
      ],
      descriptors: {
        "additive-symbols": {
          syntax: "[ <integer> && <symbol> ]#",
          media: "all",
          initial: "n/a (required)",
          percentages: "no",
          computed: "asSpecified",
          order: "orderOfAppearance",
          status: "standard"
        },
        fallback: {
          syntax: "<counter-style-name>",
          media: "all",
          initial: "decimal",
          percentages: "no",
          computed: "asSpecified",
          order: "uniqueOrder",
          status: "standard"
        },
        negative: {
          syntax: "<symbol> <symbol>?",
          media: "all",
          initial: '"-" hyphen-minus',
          percentages: "no",
          computed: "asSpecified",
          order: "orderOfAppearance",
          status: "standard"
        },
        pad: {
          syntax: "<integer> && <symbol>",
          media: "all",
          initial: '0 ""',
          percentages: "no",
          computed: "asSpecified",
          order: "uniqueOrder",
          status: "standard"
        },
        prefix: {
          syntax: "<symbol>",
          media: "all",
          initial: '""',
          percentages: "no",
          computed: "asSpecified",
          order: "uniqueOrder",
          status: "standard"
        },
        range: {
          syntax: "[ [ <integer> | infinite ]{2} ]# | auto",
          media: "all",
          initial: "auto",
          percentages: "no",
          computed: "asSpecified",
          order: "orderOfAppearance",
          status: "standard"
        },
        "speak-as": {
          syntax: "auto | bullets | numbers | words | spell-out | <counter-style-name>",
          media: "all",
          initial: "auto",
          percentages: "no",
          computed: "asSpecified",
          order: "uniqueOrder",
          status: "standard"
        },
        suffix: {
          syntax: "<symbol>",
          media: "all",
          initial: '". "',
          percentages: "no",
          computed: "asSpecified",
          order: "uniqueOrder",
          status: "standard"
        },
        symbols: {
          syntax: "<symbol>+",
          media: "all",
          initial: "n/a (required)",
          percentages: "no",
          computed: "asSpecified",
          order: "orderOfAppearance",
          status: "standard"
        },
        system: {
          syntax: "cyclic | numeric | alphabetic | symbolic | additive | [ fixed <integer>? ] | [ extends <counter-style-name> ]",
          media: "all",
          initial: "symbolic",
          percentages: "no",
          computed: "asSpecified",
          order: "uniqueOrder",
          status: "standard"
        }
      },
      status: "standard",
      mdn_url: "https://developer.mozilla.org/docs/Web/CSS/@counter-style"
    },
    "@document": {
      syntax: `@document [ <url> | url-prefix(<string>) | domain(<string>) | media-document(<string>) | regexp(<string>) ]# {
  <group-rule-body>
}`,
      interfaces: [
        "CSSGroupingRule",
        "CSSConditionRule"
      ],
      groups: [
        "CSS Conditional Rules"
      ],
      status: "nonstandard",
      mdn_url: "https://developer.mozilla.org/docs/Web/CSS/@document"
    },
    "@font-face": {
      syntax: `@font-face {
  [ font-family: <family-name>; ] ||
  [ src: <src>; ] ||
  [ unicode-range: <unicode-range>; ] ||
  [ font-variant: <font-variant>; ] ||
  [ font-feature-settings: <font-feature-settings>; ] ||
  [ font-variation-settings: <font-variation-settings>; ] ||
  [ font-stretch: <font-stretch>; ] ||
  [ font-weight: <font-weight>; ] ||
  [ font-style: <font-style>; ] ||
  [ size-adjust: <size-adjust>; ] ||
  [ ascent-override: <ascent-override>; ] ||
  [ descent-override: <descent-override>; ] ||
  [ line-gap-override: <line-gap-override>; ]
}`,
      interfaces: [
        "CSSFontFaceRule"
      ],
      groups: [
        "CSS Fonts"
      ],
      descriptors: {
        "ascent-override": {
          syntax: "normal | <percentage>",
          media: "all",
          initial: "normal",
          percentages: "asSpecified",
          computed: "asSpecified",
          order: "orderOfAppearance",
          status: "experimental"
        },
        "descent-override": {
          syntax: "normal | <percentage>",
          media: "all",
          initial: "normal",
          percentages: "asSpecified",
          computed: "asSpecified",
          order: "orderOfAppearance",
          status: "experimental"
        },
        "font-display": {
          syntax: "[ auto | block | swap | fallback | optional ]",
          media: "visual",
          percentages: "no",
          initial: "auto",
          computed: "asSpecified",
          order: "uniqueOrder",
          status: "experimental"
        },
        "font-family": {
          syntax: "<family-name>",
          media: "all",
          initial: "n/a (required)",
          percentages: "no",
          computed: "asSpecified",
          order: "uniqueOrder",
          status: "standard"
        },
        "font-feature-settings": {
          syntax: "normal | <feature-tag-value>#",
          media: "all",
          initial: "normal",
          percentages: "no",
          computed: "asSpecified",
          order: "orderOfAppearance",
          status: "standard"
        },
        "font-variation-settings": {
          syntax: "normal | [ <string> <number> ]#",
          media: "all",
          initial: "normal",
          percentages: "no",
          computed: "asSpecified",
          order: "orderOfAppearance",
          status: "standard"
        },
        "font-stretch": {
          syntax: "<font-stretch-absolute>{1,2}",
          media: "all",
          initial: "normal",
          percentages: "no",
          computed: "asSpecified",
          order: "uniqueOrder",
          status: "standard"
        },
        "font-style": {
          syntax: "normal | italic | oblique <angle>{0,2}",
          media: "all",
          initial: "normal",
          percentages: "no",
          computed: "asSpecified",
          order: "uniqueOrder",
          status: "standard"
        },
        "font-weight": {
          syntax: "<font-weight-absolute>{1,2}",
          media: "all",
          initial: "normal",
          percentages: "no",
          computed: "asSpecified",
          order: "uniqueOrder",
          status: "standard"
        },
        "font-variant": {
          syntax: "normal | none | [ <common-lig-values> || <discretionary-lig-values> || <historical-lig-values> || <contextual-alt-values> || stylistic(<feature-value-name>) || historical-forms || styleset(<feature-value-name>#) || character-variant(<feature-value-name>#) || swash(<feature-value-name>) || ornaments(<feature-value-name>) || annotation(<feature-value-name>) || [ small-caps | all-small-caps | petite-caps | all-petite-caps | unicase | titling-caps ] || <numeric-figure-values> || <numeric-spacing-values> || <numeric-fraction-values> || ordinal || slashed-zero || <east-asian-variant-values> || <east-asian-width-values> || ruby ]",
          media: "all",
          initial: "normal",
          percentages: "no",
          computed: "asSpecified",
          order: "orderOfAppearance",
          status: "standard"
        },
        "line-gap-override": {
          syntax: "normal | <percentage>",
          media: "all",
          initial: "normal",
          percentages: "asSpecified",
          computed: "asSpecified",
          order: "orderOfAppearance",
          status: "experimental"
        },
        "size-adjust": {
          syntax: "<percentage>",
          media: "all",
          initial: "100%",
          percentages: "asSpecified",
          computed: "asSpecified",
          order: "orderOfAppearance",
          status: "experimental"
        },
        src: {
          syntax: "[ <url> [ format( <string># ) ]? | local( <family-name> ) ]#",
          media: "all",
          initial: "n/a (required)",
          percentages: "no",
          computed: "asSpecified",
          order: "orderOfAppearance",
          status: "standard"
        },
        "unicode-range": {
          syntax: "<unicode-range>#",
          media: "all",
          initial: "U+0-10FFFF",
          percentages: "no",
          computed: "asSpecified",
          order: "orderOfAppearance",
          status: "standard"
        }
      },
      status: "standard",
      mdn_url: "https://developer.mozilla.org/docs/Web/CSS/@font-face"
    },
    "@font-feature-values": {
      syntax: `@font-feature-values <family-name># {
  <feature-value-block-list>
}`,
      interfaces: [
        "CSSFontFeatureValuesRule"
      ],
      groups: [
        "CSS Fonts"
      ],
      status: "standard",
      mdn_url: "https://developer.mozilla.org/docs/Web/CSS/@font-feature-values"
    },
    "@import": {
      syntax: `@import [ <string> | <url> ]
        [ layer | layer(<layer-name>) ]?
        [ supports( [ <supports-condition> | <declaration> ] ) ]?
        <media-query-list>? ;`,
      groups: [
        "CSS Conditional Rules",
        "Media Queries"
      ],
      status: "standard",
      mdn_url: "https://developer.mozilla.org/docs/Web/CSS/@import"
    },
    "@keyframes": {
      syntax: `@keyframes <keyframes-name> {
  <keyframe-block-list>
}`,
      interfaces: [
        "CSSKeyframeRule",
        "CSSKeyframesRule"
      ],
      groups: [
        "CSS Animations"
      ],
      status: "standard",
      mdn_url: "https://developer.mozilla.org/docs/Web/CSS/@keyframes"
    },
    "@layer": {
      syntax: `@layer [ <layer-name># | <layer-name>?  {
  <stylesheet>
} ]`,
      interfaces: [
        "CSSLayerBlockRule",
        "CSSLayerStatementRule"
      ],
      groups: [
        "CSS Cascading and Inheritance"
      ],
      status: "standard",
      mdn_url: "https://developer.mozilla.org/docs/Web/CSS/@layer"
    },
    "@media": {
      syntax: `@media <media-query-list> {
  <group-rule-body>
}`,
      interfaces: [
        "CSSGroupingRule",
        "CSSConditionRule",
        "CSSMediaRule",
        "CSSCustomMediaRule"
      ],
      groups: [
        "CSS Conditional Rules",
        "Media Queries"
      ],
      status: "standard",
      mdn_url: "https://developer.mozilla.org/docs/Web/CSS/@media"
    },
    "@namespace": {
      syntax: "@namespace <namespace-prefix>? [ <string> | <url> ];",
      groups: [
        "CSS Namespaces"
      ],
      status: "standard",
      mdn_url: "https://developer.mozilla.org/docs/Web/CSS/@namespace"
    },
    "@page": {
      syntax: `@page <page-selector-list> {
  <page-body>
}`,
      interfaces: [
        "CSSPageRule"
      ],
      groups: [
        "CSS Pages"
      ],
      descriptors: {
        bleed: {
          syntax: "auto | <length>",
          media: [
            "visual",
            "paged"
          ],
          initial: "auto",
          percentages: "no",
          computed: "asSpecified",
          order: "uniqueOrder",
          status: "standard"
        },
        marks: {
          syntax: "none | [ crop || cross ]",
          media: [
            "visual",
            "paged"
          ],
          initial: "none",
          percentages: "no",
          computed: "asSpecified",
          order: "orderOfAppearance",
          status: "standard"
        },
        size: {
          syntax: "<length>{1,2} | auto | [ <page-size> || [ portrait | landscape ] ]",
          media: [
            "visual",
            "paged"
          ],
          initial: "auto",
          percentages: "no",
          computed: "asSpecifiedRelativeToAbsoluteLengths",
          order: "orderOfAppearance",
          status: "standard"
        }
      },
      status: "standard",
      mdn_url: "https://developer.mozilla.org/docs/Web/CSS/@page"
    },
    "@property": {
      syntax: `@property <custom-property-name> {
  <declaration-list>
}`,
      interfaces: [
        "CSS",
        "CSSPropertyRule"
      ],
      groups: [
        "CSS Houdini"
      ],
      descriptors: {
        syntax: {
          syntax: "<string>",
          media: "all",
          percentages: "no",
          initial: "n/a (required)",
          computed: "asSpecified",
          order: "uniqueOrder",
          status: "experimental"
        },
        inherits: {
          syntax: "true | false",
          media: "all",
          percentages: "no",
          initial: "auto",
          computed: "asSpecified",
          order: "uniqueOrder",
          status: "experimental"
        },
        "initial-value": {
          syntax: "<string>",
          media: "all",
          initial: "n/a (required)",
          percentages: "no",
          computed: "asSpecified",
          order: "uniqueOrder",
          status: "experimental"
        }
      },
      status: "experimental",
      mdn_url: "https://developer.mozilla.org/docs/Web/CSS/@property"
    },
    "@scroll-timeline": {
      syntax: "@scroll-timeline <timeline-name> { <declaration-list> }",
      interfaces: [
        "ScrollTimeline"
      ],
      groups: [
        "CSS Animations"
      ],
      status: "standard",
      mdn_url: "https://developer.mozilla.org/docs/Web/CSS/@scroll-timeline"
    },
    "@supports": {
      syntax: `@supports <supports-condition> {
  <group-rule-body>
}`,
      interfaces: [
        "CSSGroupingRule",
        "CSSConditionRule",
        "CSSSupportsRule"
      ],
      groups: [
        "CSS Conditional Rules"
      ],
      status: "standard",
      mdn_url: "https://developer.mozilla.org/docs/Web/CSS/@supports"
    },
    "@viewport": {
      syntax: `@viewport {
  <group-rule-body>
}`,
      interfaces: [
        "CSSViewportRule"
      ],
      groups: [
        "CSS Device Adaptation"
      ],
      descriptors: {
        height: {
          syntax: "<viewport-length>{1,2}",
          media: [
            "visual",
            "continuous"
          ],
          initial: [
            "min-height",
            "max-height"
          ],
          percentages: [
            "min-height",
            "max-height"
          ],
          computed: [
            "min-height",
            "max-height"
          ],
          order: "orderOfAppearance",
          status: "standard"
        },
        "max-height": {
          syntax: "<viewport-length>",
          media: [
            "visual",
            "continuous"
          ],
          initial: "auto",
          percentages: "referToHeightOfInitialViewport",
          computed: "lengthAbsolutePercentageAsSpecifiedOtherwiseAuto",
          order: "uniqueOrder",
          status: "standard"
        },
        "max-width": {
          syntax: "<viewport-length>",
          media: [
            "visual",
            "continuous"
          ],
          initial: "auto",
          percentages: "referToWidthOfInitialViewport",
          computed: "lengthAbsolutePercentageAsSpecifiedOtherwiseAuto",
          order: "uniqueOrder",
          status: "standard"
        },
        "max-zoom": {
          syntax: "auto | <number> | <percentage>",
          media: [
            "visual",
            "continuous"
          ],
          initial: "auto",
          percentages: "the zoom factor itself",
          computed: "autoNonNegativeOrPercentage",
          order: "uniqueOrder",
          status: "standard"
        },
        "min-height": {
          syntax: "<viewport-length>",
          media: [
            "visual",
            "continuous"
          ],
          initial: "auto",
          percentages: "referToHeightOfInitialViewport",
          computed: "lengthAbsolutePercentageAsSpecifiedOtherwiseAuto",
          order: "uniqueOrder",
          status: "standard"
        },
        "min-width": {
          syntax: "<viewport-length>",
          media: [
            "visual",
            "continuous"
          ],
          initial: "auto",
          percentages: "referToWidthOfInitialViewport",
          computed: "lengthAbsolutePercentageAsSpecifiedOtherwiseAuto",
          order: "uniqueOrder",
          status: "standard"
        },
        "min-zoom": {
          syntax: "auto | <number> | <percentage>",
          media: [
            "visual",
            "continuous"
          ],
          initial: "auto",
          percentages: "the zoom factor itself",
          computed: "autoNonNegativeOrPercentage",
          order: "uniqueOrder",
          status: "standard"
        },
        orientation: {
          syntax: "auto | portrait | landscape",
          media: [
            "visual",
            "continuous"
          ],
          initial: "auto",
          percentages: "referToSizeOfBoundingBox",
          computed: "asSpecified",
          order: "uniqueOrder",
          status: "standard"
        },
        "user-zoom": {
          syntax: "zoom | fixed",
          media: [
            "visual",
            "continuous"
          ],
          initial: "zoom",
          percentages: "referToSizeOfBoundingBox",
          computed: "asSpecified",
          order: "uniqueOrder",
          status: "standard"
        },
        "viewport-fit": {
          syntax: "auto | contain | cover",
          media: [
            "visual",
            "continuous"
          ],
          initial: "auto",
          percentages: "no",
          computed: "asSpecified",
          order: "uniqueOrder",
          status: "standard"
        },
        width: {
          syntax: "<viewport-length>{1,2}",
          media: [
            "visual",
            "continuous"
          ],
          initial: [
            "min-width",
            "max-width"
          ],
          percentages: [
            "min-width",
            "max-width"
          ],
          computed: [
            "min-width",
            "max-width"
          ],
          order: "orderOfAppearance",
          status: "standard"
        },
        zoom: {
          syntax: "auto | <number> | <percentage>",
          media: [
            "visual",
            "continuous"
          ],
          initial: "auto",
          percentages: "the zoom factor itself",
          computed: "autoNonNegativeOrPercentage",
          order: "uniqueOrder",
          status: "standard"
        }
      },
      status: "standard",
      mdn_url: "https://developer.mozilla.org/docs/Web/CSS/@viewport"
    }
  };
});

// ../../../../node_modules/.bun/mdn-data@2.0.28/node_modules/mdn-data/css/properties.json
var require_properties2 = __commonJS((exports, module) => {
  module.exports = {
    "--*": {
      syntax: "<declaration-value>",
      media: "all",
      inherited: true,
      animationType: "discrete",
      percentages: "no",
      groups: [
        "CSS Variables"
      ],
      initial: "seeProse",
      appliesto: "allElements",
      computed: "asSpecifiedWithVarsSubstituted",
      order: "perGrammar",
      status: "experimental",
      mdn_url: "https://developer.mozilla.org/docs/Web/CSS/--*"
    },
    "-ms-accelerator": {
      syntax: "false | true",
      media: "visual",
      inherited: false,
      animationType: "discrete",
      percentages: "no",
      groups: [
        "Microsoft Extensions"
      ],
      initial: "false",
      appliesto: "allElements",
      computed: "asSpecified",
      order: "uniqueOrder",
      status: "nonstandard",
      mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-accelerator"
    },
    "-ms-block-progression": {
      syntax: "tb | rl | bt | lr",
      media: "visual",
      inherited: false,
      animationType: "discrete",
      percentages: "no",
      groups: [
        "Microsoft Extensions"
      ],
      initial: "tb",
      appliesto: "allElements",
      computed: "asSpecified",
      order: "uniqueOrder",
      status: "nonstandard",
      mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-block-progression"
    },
    "-ms-content-zoom-chaining": {
      syntax: "none | chained",
      media: "interactive",
      inherited: false,
      animationType: "discrete",
      percentages: "no",
      groups: [
        "Microsoft Extensions"
      ],
      initial: "none",
      appliesto: "nonReplacedBlockAndInlineBlockElements",
      computed: "asSpecified",
      order: "uniqueOrder",
      status: "nonstandard",
      mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-content-zoom-chaining"
    },
    "-ms-content-zooming": {
      syntax: "none | zoom",
      media: "interactive",
      inherited: false,
      animationType: "discrete",
      percentages: "no",
      groups: [
        "Microsoft Extensions"
      ],
      initial: "zoomForTheTopLevelNoneForTheRest",
      appliesto: "nonReplacedBlockAndInlineBlockElements",
      computed: "asSpecified",
      order: "uniqueOrder",
      status: "nonstandard",
      mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-content-zooming"
    },
    "-ms-content-zoom-limit": {
      syntax: "<'-ms-content-zoom-limit-min'> <'-ms-content-zoom-limit-max'>",
      media: "interactive",
      inherited: false,
      animationType: "discrete",
      percentages: [
        "-ms-content-zoom-limit-max",
        "-ms-content-zoom-limit-min"
      ],
      groups: [
        "Microsoft Extensions"
      ],
      initial: [
        "-ms-content-zoom-limit-max",
        "-ms-content-zoom-limit-min"
      ],
      appliesto: "nonReplacedBlockAndInlineBlockElements",
      computed: [
        "-ms-content-zoom-limit-max",
        "-ms-content-zoom-limit-min"
      ],
      order: "uniqueOrder",
      status: "nonstandard",
      mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-content-zoom-limit"
    },
    "-ms-content-zoom-limit-max": {
      syntax: "<percentage>",
      media: "interactive",
      inherited: false,
      animationType: "discrete",
      percentages: "maxZoomFactor",
      groups: [
        "Microsoft Extensions"
      ],
      initial: "400%",
      appliesto: "nonReplacedBlockAndInlineBlockElements",
      computed: "asSpecified",
      order: "uniqueOrder",
      status: "nonstandard",
      mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-content-zoom-limit-max"
    },
    "-ms-content-zoom-limit-min": {
      syntax: "<percentage>",
      media: "interactive",
      inherited: false,
      animationType: "discrete",
      percentages: "minZoomFactor",
      groups: [
        "Microsoft Extensions"
      ],
      initial: "100%",
      appliesto: "nonReplacedBlockAndInlineBlockElements",
      computed: "asSpecified",
      order: "uniqueOrder",
      status: "nonstandard",
      mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-content-zoom-limit-min"
    },
    "-ms-content-zoom-snap": {
      syntax: "<'-ms-content-zoom-snap-type'> || <'-ms-content-zoom-snap-points'>",
      media: "interactive",
      inherited: false,
      animationType: "discrete",
      percentages: "no",
      groups: [
        "Microsoft Extensions"
      ],
      initial: [
        "-ms-content-zoom-snap-type",
        "-ms-content-zoom-snap-points"
      ],
      appliesto: "nonReplacedBlockAndInlineBlockElements",
      computed: [
        "-ms-content-zoom-snap-type",
        "-ms-content-zoom-snap-points"
      ],
      order: "uniqueOrder",
      status: "nonstandard",
      mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-content-zoom-snap"
    },
    "-ms-content-zoom-snap-points": {
      syntax: "snapInterval( <percentage>, <percentage> ) | snapList( <percentage># )",
      media: "interactive",
      inherited: false,
      animationType: "discrete",
      percentages: "no",
      groups: [
        "Microsoft Extensions"
      ],
      initial: "snapInterval(0%, 100%)",
      appliesto: "nonReplacedBlockAndInlineBlockElements",
      computed: "asSpecified",
      order: "uniqueOrder",
      status: "nonstandard",
      mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-content-zoom-snap-points"
    },
    "-ms-content-zoom-snap-type": {
      syntax: "none | proximity | mandatory",
      media: "interactive",
      inherited: false,
      animationType: "discrete",
      percentages: "no",
      groups: [
        "Microsoft Extensions"
      ],
      initial: "none",
      appliesto: "nonReplacedBlockAndInlineBlockElements",
      computed: "asSpecified",
      order: "uniqueOrder",
      status: "nonstandard",
      mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-content-zoom-snap-type"
    },
    "-ms-filter": {
      syntax: "<string>",
      media: "visual",
      inherited: false,
      animationType: "discrete",
      percentages: "no",
      groups: [
        "Microsoft Extensions"
      ],
      initial: '""',
      appliesto: "allElements",
      computed: "asSpecified",
      order: "uniqueOrder",
      status: "nonstandard",
      mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-filter"
    },
    "-ms-flow-from": {
      syntax: "[ none | <custom-ident> ]#",
      media: "visual",
      inherited: false,
      animationType: "discrete",
      percentages: "no",
      groups: [
        "Microsoft Extensions"
      ],
      initial: "none",
      appliesto: "nonReplacedElements",
      computed: "asSpecified",
      order: "uniqueOrder",
      status: "nonstandard",
      mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-flow-from"
    },
    "-ms-flow-into": {
      syntax: "[ none | <custom-ident> ]#",
      media: "visual",
      inherited: false,
      animationType: "discrete",
      percentages: "no",
      groups: [
        "Microsoft Extensions"
      ],
      initial: "none",
      appliesto: "iframeElements",
      computed: "asSpecified",
      order: "uniqueOrder",
      status: "nonstandard",
      mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-flow-into"
    },
    "-ms-grid-columns": {
      syntax: "none | <track-list> | <auto-track-list>",
      media: "visual",
      inherited: false,
      animationType: "simpleListOfLpcDifferenceLpc",
      percentages: "referToDimensionOfContentArea",
      groups: [
        "CSS Grid Layout"
      ],
      initial: "none",
      appliesto: "gridContainers",
      computed: "asSpecifiedRelativeToAbsoluteLengths",
      order: "uniqueOrder",
      status: "nonstandard",
      mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-grid-columns"
    },
    "-ms-grid-rows": {
      syntax: "none | <track-list> | <auto-track-list>",
      media: "visual",
      inherited: false,
      animationType: "simpleListOfLpcDifferenceLpc",
      percentages: "referToDimensionOfContentArea",
      groups: [
        "CSS Grid Layout"
      ],
      initial: "none",
      appliesto: "gridContainers",
      computed: "asSpecifiedRelativeToAbsoluteLengths",
      order: "uniqueOrder",
      status: "nonstandard",
      mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-grid-rows"
    },
    "-ms-high-contrast-adjust": {
      syntax: "auto | none",
      media: "visual",
      inherited: true,
      animationType: "discrete",
      percentages: "no",
      groups: [
        "Microsoft Extensions"
      ],
      initial: "auto",
      appliesto: "allElements",
      computed: "asSpecified",
      order: "uniqueOrder",
      status: "nonstandard",
      mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-high-contrast-adjust"
    },
    "-ms-hyphenate-limit-chars": {
      syntax: "auto | <integer>{1,3}",
      media: "visual",
      inherited: true,
      animationType: "discrete",
      percentages: "no",
      groups: [
        "Microsoft Extensions"
      ],
      initial: "auto",
      appliesto: "allElements",
      computed: "asSpecified",
      order: "uniqueOrder",
      status: "nonstandard",
      mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-hyphenate-limit-chars"
    },
    "-ms-hyphenate-limit-lines": {
      syntax: "no-limit | <integer>",
      media: "visual",
      inherited: true,
      animationType: "discrete",
      percentages: "no",
      groups: [
        "Microsoft Extensions"
      ],
      initial: "no-limit",
      appliesto: "blockContainerElements",
      computed: "asSpecified",
      order: "uniqueOrder",
      status: "nonstandard",
      mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-hyphenate-limit-lines"
    },
    "-ms-hyphenate-limit-zone": {
      syntax: "<percentage> | <length>",
      media: "visual",
      inherited: true,
      animationType: "discrete",
      percentages: "referToLineBoxWidth",
      groups: [
        "Microsoft Extensions"
      ],
      initial: "0",
      appliesto: "blockContainerElements",
      computed: "asSpecified",
      order: "uniqueOrder",
      status: "nonstandard",
      mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-hyphenate-limit-zone"
    },
    "-ms-ime-align": {
      syntax: "auto | after",
      media: "visual",
      inherited: false,
      animationType: "discrete",
      percentages: "no",
      groups: [
        "Microsoft Extensions"
      ],
      initial: "auto",
      appliesto: "allElements",
      computed: "asSpecified",
      order: "uniqueOrder",
      status: "nonstandard",
      mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-ime-align"
    },
    "-ms-overflow-style": {
      syntax: "auto | none | scrollbar | -ms-autohiding-scrollbar",
      media: "interactive",
      inherited: true,
      animationType: "discrete",
      percentages: "no",
      groups: [
        "Microsoft Extensions"
      ],
      initial: "auto",
      appliesto: "nonReplacedBlockAndInlineBlockElements",
      computed: "asSpecified",
      order: "uniqueOrder",
      status: "nonstandard",
      mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-overflow-style"
    },
    "-ms-scrollbar-3dlight-color": {
      syntax: "<color>",
      media: "visual",
      inherited: true,
      animationType: "discrete",
      percentages: "no",
      groups: [
        "Microsoft Extensions"
      ],
      initial: "dependsOnUserAgent",
      appliesto: "allElements",
      computed: "asSpecified",
      order: "uniqueOrder",
      status: "nonstandard",
      mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scrollbar-3dlight-color"
    },
    "-ms-scrollbar-arrow-color": {
      syntax: "<color>",
      media: "visual",
      inherited: true,
      animationType: "discrete",
      percentages: "no",
      groups: [
        "Microsoft Extensions"
      ],
      initial: "ButtonText",
      appliesto: "allElements",
      computed: "asSpecified",
      order: "uniqueOrder",
      status: "nonstandard",
      mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scrollbar-arrow-color"
    },
    "-ms-scrollbar-base-color": {
      syntax: "<color>",
      media: "visual",
      inherited: true,
      animationType: "discrete",
      percentages: "no",
      groups: [
        "Microsoft Extensions"
      ],
      initial: "dependsOnUserAgent",
      appliesto: "allElements",
      computed: "asSpecified",
      order: "uniqueOrder",
      status: "nonstandard",
      mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scrollbar-base-color"
    },
    "-ms-scrollbar-darkshadow-color": {
      syntax: "<color>",
      media: "visual",
      inherited: true,
      animationType: "discrete",
      percentages: "no",
      groups: [
        "Microsoft Extensions"
      ],
      initial: "ThreeDDarkShadow",
      appliesto: "allElements",
      computed: "asSpecified",
      order: "uniqueOrder",
      status: "nonstandard",
      mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scrollbar-darkshadow-color"
    },
    "-ms-scrollbar-face-color": {
      syntax: "<color>",
      media: "visual",
      inherited: true,
      animationType: "discrete",
      percentages: "no",
      groups: [
        "Microsoft Extensions"
      ],
      initial: "ThreeDFace",
      appliesto: "allElements",
      computed: "asSpecified",
      order: "uniqueOrder",
      status: "nonstandard",
      mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scrollbar-face-color"
    },
    "-ms-scrollbar-highlight-color": {
      syntax: "<color>",
      media: "visual",
      inherited: true,
      animationType: "discrete",
      percentages: "no",
      groups: [
        "Microsoft Extensions"
      ],
      initial: "ThreeDHighlight",
      appliesto: "allElements",
      computed: "asSpecified",
      order: "uniqueOrder",
      status: "nonstandard",
      mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scrollbar-highlight-color"
    },
    "-ms-scrollbar-shadow-color": {
      syntax: "<color>",
      media: "visual",
      inherited: true,
      animationType: "discrete",
      percentages: "no",
      groups: [
        "Microsoft Extensions"
      ],
      initial: "ThreeDDarkShadow",
      appliesto: "allElements",
      computed: "asSpecified",
      order: "uniqueOrder",
      status: "nonstandard",
      mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scrollbar-shadow-color"
    },
    "-ms-scrollbar-track-color": {
      syntax: "<color>",
      media: "visual",
      inherited: true,
      animationType: "discrete",
      percentages: "no",
      groups: [
        "Microsoft Extensions"
      ],
      initial: "Scrollbar",
      appliesto: "allElements",
      computed: "asSpecified",
      order: "uniqueOrder",
      status: "nonstandard",
      mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scrollbar-track-color"
    },
    "-ms-scroll-chaining": {
      syntax: "chained | none",
      media: "interactive",
      inherited: false,
      animationType: "discrete",
      percentages: "no",
      groups: [
        "Microsoft Extensions"
      ],
      initial: "chained",
      appliesto: "nonReplacedBlockAndInlineBlockElements",
      computed: "asSpecified",
      order: "uniqueOrder",
      status: "nonstandard",
      mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scroll-chaining"
    },
    "-ms-scroll-limit": {
      syntax: "<'-ms-scroll-limit-x-min'> <'-ms-scroll-limit-y-min'> <'-ms-scroll-limit-x-max'> <'-ms-scroll-limit-y-max'>",
      media: "interactive",
      inherited: false,
      animationType: "discrete",
      percentages: "no",
      groups: [
        "Microsoft Extensions"
      ],
      initial: [
        "-ms-scroll-limit-x-min",
        "-ms-scroll-limit-y-min",
        "-ms-scroll-limit-x-max",
        "-ms-scroll-limit-y-max"
      ],
      appliesto: "nonReplacedBlockAndInlineBlockElements",
      computed: [
        "-ms-scroll-limit-x-min",
        "-ms-scroll-limit-y-min",
        "-ms-scroll-limit-x-max",
        "-ms-scroll-limit-y-max"
      ],
      order: "uniqueOrder",
      status: "nonstandard",
      mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scroll-limit"
    },
    "-ms-scroll-limit-x-max": {
      syntax: "auto | <length>",
      media: "interactive",
      inherited: false,
      animationType: "discrete",
      percentages: "no",
      groups: [
        "Microsoft Extensions"
      ],
      initial: "auto",
      appliesto: "nonReplacedBlockAndInlineBlockElements",
      computed: "asSpecified",
      order: "uniqueOrder",
      status: "nonstandard",
      mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scroll-limit-x-max"
    },
    "-ms-scroll-limit-x-min": {
      syntax: "<length>",
      media: "interactive",
      inherited: false,
      animationType: "discrete",
      percentages: "no",
      groups: [
        "Microsoft Extensions"
      ],
      initial: "0",
      appliesto: "nonReplacedBlockAndInlineBlockElements",
      computed: "asSpecified",
      order: "uniqueOrder",
      status: "nonstandard",
      mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scroll-limit-x-min"
    },
    "-ms-scroll-limit-y-max": {
      syntax: "auto | <length>",
      media: "interactive",
      inherited: false,
      animationType: "discrete",
      percentages: "no",
      groups: [
        "Microsoft Extensions"
      ],
      initial: "auto",
      appliesto: "nonReplacedBlockAndInlineBlockElements",
      computed: "asSpecified",
      order: "uniqueOrder",
      status: "nonstandard",
      mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scroll-limit-y-max"
    },
    "-ms-scroll-limit-y-min": {
      syntax: "<length>",
      media: "interactive",
      inherited: false,
      animationType: "discrete",
      percentages: "no",
      groups: [
        "Microsoft Extensions"
      ],
      initial: "0",
      appliesto: "nonReplacedBlockAndInlineBlockElements",
      computed: "asSpecified",
      order: "uniqueOrder",
      status: "nonstandard",
      mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scroll-limit-y-min"
    },
    "-ms-scroll-rails": {
      syntax: "none | railed",
      media: "interactive",
      inherited: false,
      animationType: "discrete",
      percentages: "no",
      groups: [
        "Microsoft Extensions"
      ],
      initial: "railed",
      appliesto: "nonReplacedBlockAndInlineBlockElements",
      computed: "asSpecified",
      order: "uniqueOrder",
      status: "nonstandard",
      mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scroll-rails"
    },
    "-ms-scroll-snap-points-x": {
      syntax: "snapInterval( <length-percentage>, <length-percentage> ) | snapList( <length-percentage># )",
      media: "interactive",
      inherited: false,
      animationType: "discrete",
      percentages: "no",
      groups: [
        "Microsoft Extensions"
      ],
      initial: "snapInterval(0px, 100%)",
      appliesto: "nonReplacedBlockAndInlineBlockElements",
      computed: "asSpecified",
      order: "uniqueOrder",
      status: "nonstandard",
      mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scroll-snap-points-x"
    },
    "-ms-scroll-snap-points-y": {
      syntax: "snapInterval( <length-percentage>, <length-percentage> ) | snapList( <length-percentage># )",
      media: "interactive",
      inherited: false,
      animationType: "discrete",
      percentages: "no",
      groups: [
        "Microsoft Extensions"
      ],
      initial: "snapInterval(0px, 100%)",
      appliesto: "nonReplacedBlockAndInlineBlockElements",
      computed: "asSpecified",
      order: "uniqueOrder",
      status: "nonstandard",
      mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scroll-snap-points-y"
    },
    "-ms-scroll-snap-type": {
      syntax: "none | proximity | mandatory",
      media: "interactive",
      inherited: false,
      animationType: "discrete",
      percentages: "no",
      groups: [
        "Microsoft Extensions"
      ],
      initial: "none",
      appliesto: "nonReplacedBlockAndInlineBlockElements",
      computed: "asSpecified",
      order: "uniqueOrder",
      status: "nonstandard",
      mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scroll-snap-type"
    },
    "-ms-scroll-snap-x": {
      syntax: "<'-ms-scroll-snap-type'> <'-ms-scroll-snap-points-x'>",
      media: "interactive",
      inherited: false,
      animationType: "discrete",
      percentages: "no",
      groups: [
        "Microsoft Extensions"
      ],
      initial: [
        "-ms-scroll-snap-type",
        "-ms-scroll-snap-points-x"
      ],
      appliesto: "nonReplacedBlockAndInlineBlockElements",
      computed: [
        "-ms-scroll-snap-type",
        "-ms-scroll-snap-points-x"
      ],
      order: "uniqueOrder",
      status: "nonstandard",
      mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scroll-snap-x"
    },
    "-ms-scroll-snap-y": {
      syntax: "<'-ms-scroll-snap-type'> <'-ms-scroll-snap-points-y'>",
      media: "interactive",
      inherited: false,
      animationType: "discrete",
      percentages: "no",
      groups: [
        "Microsoft Extensions"
      ],
      initial: [
        "-ms-scroll-snap-type",
        "-ms-scroll-snap-points-y"
      ],
      appliesto: "nonReplacedBlockAndInlineBlockElements",
      computed: [
        "-ms-scroll-snap-type",
        "-ms-scroll-snap-points-y"
      ],
      order: "uniqueOrder",
      status: "nonstandard",
      mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scroll-snap-y"
    },
    "-ms-scroll-translation": {
      syntax: "none | vertical-to-horizontal",
      media: "interactive",
      inherited: true,
      animationType: "discrete",
      percentages: "no",
      groups: [
        "Microsoft Extensions"
      ],
      initial: "none",
      appliesto: "allElements",
      computed: "asSpecified",
      order: "uniqueOrder",
      status: "nonstandard",
      mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scroll-translation"
    },
    "-ms-text-autospace": {
      syntax: "none | ideograph-alpha | ideograph-numeric | ideograph-parenthesis | ideograph-space",
      media: "visual",
      inherited: false,
      animationType: "discrete",
      percentages: "no",
      groups: [
        "Microsoft Extensions"
      ],
      initial: "none",
      appliesto: "allElements",
      computed: "asSpecified",
      order: "uniqueOrder",
      status: "nonstandard",
      mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-text-autospace"
    },
    "-ms-touch-select": {
      syntax: "grippers | none",
      media: "interactive",
      inherited: true,
      animationType: "discrete",
      percentages: "no",
      groups: [
        "Microsoft Extensions"
      ],
      initial: "grippers",
      appliesto: "allElements",
      computed: "asSpecified",
      order: "uniqueOrder",
      status: "nonstandard",
      mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-touch-select"
    },
    "-ms-user-select": {
      syntax: "none | element | text",
      media: "interactive",
      inherited: false,
      animationType: "discrete",
      percentages: "no",
      groups: [
        "Microsoft Extensions"
      ],
      initial: "text",
      appliesto: "nonReplacedElements",
      computed: "asSpecified",
      order: "uniqueOrder",
      status: "nonstandard",
      mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-user-select"
    },
    "-ms-wrap-flow": {
      syntax: "auto | both | start | end | maximum | clear",
      media: "visual",
      inherited: false,
      animationType: "discrete",
      percentages: "no",
      groups: [
        "Microsoft Extensions"
      ],
      initial: "auto",
      appliesto: "blockLevelElements",
      computed: "asSpecified",
      order: "uniqueOrder",
      status: "nonstandard",
      mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-wrap-flow"
    },
    "-ms-wrap-margin": {
      syntax: "<length>",
      media: "visual",
      inherited: false,
      animationType: "discrete",
      percentages: "no",
      groups: [
        "Microsoft Extensions"
      ],
      initial: "0",
      appliesto: "exclusionElements",
      computed: "asSpecified",
      order: "uniqueOrder",
      status: "nonstandard",
      mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-wrap-margin"
    },
    "-ms-wrap-through": {
      syntax: "wrap | none",
      media: "visual",
      inherited: false,
      animationType: "discrete",
      percentages: "no",
      groups: [
        "Microsoft Extensions"
      ],
      initial: "wrap",
      appliesto: "blockLevelElements",
      computed: "asSpecified",
      order: "uniqueOrder",
      status: "nonstandard",
      mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-wrap-through"
    },
    "-moz-appearance": {
      syntax: "none | button | button-arrow-down | button-arrow-next | button-arrow-previous | button-arrow-up | button-bevel | button-focus | caret | checkbox | checkbox-container | checkbox-label | checkmenuitem | dualbutton | groupbox | listbox | listitem | menuarrow | menubar | menucheckbox | menuimage | menuitem | menuitemtext | menulist | menulist-button | menulist-text | menulist-textfield | menupopup | menuradio | menuseparator | meterbar | meterchunk | progressbar | progressbar-vertical | progresschunk | progresschunk-vertical | radio | radio-container | radio-label | radiomenuitem | range | range-thumb | resizer | resizerpanel | scale-horizontal | scalethumbend | scalethumb-horizontal | scalethumbstart | scalethumbtick | scalethumb-vertical | scale-vertical | scrollbarbutton-down | scrollbarbutton-left | scrollbarbutton-right | scrollbarbutton-up | scrollbarthumb-horizontal | scrollbarthumb-vertical | scrollbartrack-horizontal | scrollbartrack-vertical | searchfield | separator | sheet | spinner | spinner-downbutton | spinner-textfield | spinner-upbutton | splitter | statusbar | statusbarpanel | tab | tabpanel | tabpanels | tab-scroll-arrow-back | tab-scroll-arrow-forward | textfield | textfield-multiline | toolbar | toolbarbutton | toolbarbutton-dropdown | toolbargripper | toolbox | tooltip | treeheader | treeheadercell | treeheadersortarrow | treeitem | treeline | treetwisty | treetwistyopen | treeview | -moz-mac-unified-toolbar | -moz-win-borderless-glass | -moz-win-browsertabbar-toolbox | -moz-win-communicationstext | -moz-win-communications-toolbox | -moz-win-exclude-glass | -moz-win-glass | -moz-win-mediatext | -moz-win-media-toolbox | -moz-window-button-box | -moz-window-button-box-maximized | -moz-window-button-close | -moz-window-button-maximize | -moz-window-button-minimize | -moz-window-button-restore | -moz-window-frame-bottom | -moz-window-frame-left | -moz-window-frame-right | -moz-window-titlebar | -moz-window-titlebar-maximized",
      media: "visual",
      inherited: false,
      animationType: "discrete",
      percentages: "no",
      groups: [
        "Mozilla Extensions",
        "WebKit Extensions"
      ],
      initial: "noneButOverriddenInUserAgentCSS",
      appliesto: "allElements",
      computed: "asSpecified",
      order: "uniqueOrder",
      status: "nonstandard",
      mdn_url: "https://developer.mozilla.org/docs/Web/CSS/appearance"
    },
    "-moz-binding": {
      syntax: "<url> | none",
      media: "visual",
      inherited: false,
      animationType: "discrete",
      percentages: "no",
      groups: [
        "Mozilla Extensions"
      ],
      initial: "none",
      appliesto: "allElementsExceptGeneratedContentOrPseudoElements",
      computed: "asSpecified",
      order: "uniqueOrder",
      status: "nonstandard",
      mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-binding"
    },
    "-moz-border-bottom-colors": {
      syntax: "<color>+ | none",
      media: "visual",
      inherited: false,
      animationType: "discrete",
      percentages: "no",
      groups: [
        "Mozilla Extensions"
      ],
      initial: "none",
      appliesto: "allElements",
      computed: "asSpecified",
      order: "uniqueOrder",
      status: "nonstandard",
      mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-border-bottom-colors"
    },
    "-moz-border-left-colors": {
      syntax: "<color>+ | none",
      media: "visual",
      inherited: false,
      animationType: "discrete",
      percentages: "no",
      groups: [
        "Mozilla Extensions"
      ],
      initial: "none",
      appliesto: "allElements",
      computed: "asSpecified",
      order: "uniqueOrder",
      status: "nonstandard",
      mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-border-left-colors"
    },
    "-moz-border-right-colors": {
      syntax: "<color>+ | none",
      media: "visual",
      inherited: false,
      animationType: "discrete",
      percentages: "no",
      groups: [
        "Mozilla Extensions"
      ],
      initial: "none",
      appliesto: "allElements",
      computed: "asSpecified",
      order: "uniqueOrder",
      status: "nonstandard",
      mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-border-right-colors"
    },
    "-moz-border-top-colors": {
      syntax: "<color>+ | none",
      media: "visual",
      inherited: false,
      animationType: "discrete",
      percentages: "no",
      groups: [
        "Mozilla Extensions"
      ],
      initial: "none",
      appliesto: "allElements",
      computed: "asSpecified",
      order: "uniqueOrder",
      status: "nonstandard",
      mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-border-top-colors"
    },
    "-moz-context-properties": {
      syntax: "none | [ fill | fill-opacity | stroke | stroke-opacity ]#",
      media: "visual",
      inherited: true,
      animationType: "discrete",
      percentages: "no",
      groups: [
        "Mozilla Extensions"
      ],
      initial: "none",
      appliesto: "allElementsThatCanReferenceImages",
      computed: "asSpecified",
      order: "uniqueOrder",
      status: "nonstandard",
      mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-context-properties"
    },
    "-moz-float-edge": {
      syntax: "border-box | content-box | margin-box | padding-box",
      media: "visual",
      inherited: false,
      animationType: "discrete",
      percentages: "no",
      groups: [
        "Mozilla Extensions"
      ],
      initial: "content-box",
      appliesto: "allElements",
      computed: "asSpecified",
      order: "uniqueOrder",
      status: "nonstandard",
      mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-float-edge"
    },
    "-moz-force-broken-image-icon": {
      syntax: "0 | 1",
      media: "visual",
      inherited: false,
      animationType: "discrete",
      percentages: "no",
      groups: [
        "Mozilla Extensions"
      ],
      initial: "0",
      appliesto: "images",
      computed: "asSpecified",
      order: "uniqueOrder",
      status: "nonstandard",
      mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-force-broken-image-icon"
    },
    "-moz-image-region": {
      syntax: "<shape> | auto",
      media: "visual",
      inherited: true,
      animationType: "discrete",
      percentages: "no",
      groups: [
        "Mozilla Extensions"
      ],
      initial: "auto",
      appliesto: "xulImageElements",
      computed: "asSpecified",
      order: "uniqueOrder",
      status: "nonstandard",
      mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-image-region"
    },
    "-moz-orient": {
      syntax: "inline | block | horizontal | vertical",
      media: "visual",
      inherited: false,
      animationType: "discrete",
      percentages: "no",
      groups: [
        "Mozilla Extensions"
      ],
      initial: "inline",
      appliesto: "anyElementEffectOnProgressAndMeter",
      computed: "asSpecified",
      order: "uniqueOrder",
      status: "nonstandard",
      mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-orient"
    },
    "-moz-outline-radius": {
      syntax: "<outline-radius>{1,4} [ / <outline-radius>{1,4} ]?",
      media: "visual",
      inherited: false,
      animationType: [
        "-moz-outline-radius-topleft",
        "-moz-outline-radius-topright",
        "-moz-outline-radius-bottomright",
        "-moz-outline-radius-bottomleft"
      ],
      percentages: [
        "-moz-outline-radius-topleft",
        "-moz-outline-radius-topright",
        "-moz-outline-radius-bottomright",
        "-moz-outline-radius-bottomleft"
      ],
      groups: [
        "Mozilla Extensions"
      ],
      initial: [
        "-moz-outline-radius-topleft",
        "-moz-outline-radius-topright",
        "-moz-outline-radius-bottomright",
        "-moz-outline-radius-bottomleft"
      ],
      appliesto: "allElements",
      computed: [
        "-moz-outline-radius-topleft",
        "-moz-outline-radius-topright",
        "-moz-outline-radius-bottomright",
        "-moz-outline-radius-bottomleft"
      ],
      order: "uniqueOrder",
      status: "nonstandard",
      mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-outline-radius"
    },
    "-moz-outline-radius-bottomleft": {
      syntax: "<outline-radius>",
      media: "visual",
      inherited: false,
      animationType: "lpc",
      percentages: "referToDimensionOfBorderBox",
      groups: [
        "Mozilla Extensions"
      ],
      initial: "0",
      appliesto: "allElements",
      computed: "asSpecified",
      order: "uniqueOrder",
      status: "nonstandard",
      mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-outline-radius-bottomleft"
    },
    "-moz-outline-radius-bottomright": {
      syntax: "<outline-radius>",
      media: "visual",
      inherited: false,
      animationType: "lpc",
      percentages: "referToDimensionOfBorderBox",
      groups: [
        "Mozilla Extensions"
      ],
      initial: "0",
      appliesto: "allElements",
      computed: "asSpecified",
      order: "uniqueOrder",
      status: "nonstandard",
      mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-outline-radius-bottomright"
    },
    "-moz-outline-radius-topleft": {
      syntax: "<outline-radius>",
      media: "visual",
      inherited: false,
      animationType: "lpc",
      percentages: "referToDimensionOfBorderBox",
      groups: [
        "Mozilla Extensions"
      ],
      initial: "0",
      appliesto: "allElements",
      computed: "asSpecified",
      order: "uniqueOrder",
      status: "nonstandard",
      mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-outline-radius-topleft"
    },
    "-moz-outline-radius-topright": {
      syntax: "<outline-radius>",
      media: "visual",
      inherited: false,
      animationType: "lpc",
      percentages: "referToDimensionOfBorderBox",
      groups: [
        "Mozilla Extensions"
      ],
      initial: "0",
      appliesto: "allElements",
      computed: "asSpecified",
      order: "uniqueOrder",
      status: "nonstandard",
      mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-outline-radius-topright"
    },
    "-moz-stack-sizing": {
      syntax: "ignore | stretch-to-fit",
      media: "visual",
      inherited: true,
      animationType: "discrete",
      percentages: "no",
      groups: [
        "Mozilla Extensions"
      ],
      initial: "stretch-to-fit",
      appliesto: "allElements",
      computed: "asSpecified",
      order: "uniqueOrder",
      status: "nonstandard",
      mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-stack-sizing"
    },
    "-moz-text-blink": {
      syntax: "none | blink",
      media: "visual",
      inherited: false,
      animationType: "discrete",
      percentages: "no",
      groups: [
        "Mozilla Extensions"
      ],
      initial: "none",
      appliesto: "allElements",
      computed: "asSpecified",
      order: "uniqueOrder",
      status: "nonstandard",
      mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-text-blink"
    },
    "-moz-user-focus": {
      syntax: "ignore | normal | select-after | select-before | select-menu | select-same | select-all | none",
      media: "interactive",
      inherited: false,
      animationType: "discrete",
      percentages: "no",
      groups: [
        "Mozilla Extensions"
      ],
      initial: "none",
      appliesto: "allElements",
      computed: "asSpecified",
      order: "uniqueOrder",
      status: "nonstandard",
      mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-user-focus"
    },
    "-moz-user-input": {
      syntax: "auto | none | enabled | disabled",
      media: "visual",
      inherited: true,
      animationType: "discrete",
      percentages: "no",
      groups: [
        "Mozilla Extensions"
      ],
      initial: "auto",
      appliesto: "allElements",
      computed: "asSpecified",
      order: "uniqueOrder",
      status: "nonstandard",
      mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-user-input"
    },
    "-moz-user-modify": {
      syntax: "read-only | read-write | write-only",
      media: "interactive",
      inherited: true,
      animationType: "discrete",
      percentages: "no",
      groups: [
        "Mozilla Extensions"
      ],
      initial: "read-only",
      appliesto: "allElements",
      computed: "asSpecified",
      order: "uniqueOrder",
      status: "nonstandard",
      mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-user-modify"
    },
    "-moz-window-dragging": {
      syntax: "drag | no-drag",
      media: "visual",
      inherited: false,
      animationType: "discrete",
      percentages: "no",
      groups: [
        "Mozilla Extensions"
      ],
      initial: "drag",
      appliesto: "allElementsCreatingNativeWindows",
      computed: "asSpecified",
      order: "uniqueOrder",
      status: "nonstandard",
      mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-window-dragging"
    },
    "-moz-window-shadow": {
      syntax: "default | menu | tooltip | sheet | none",
      media: "visual",
      inherited: false,
      animationType: "discrete",
      percentages: "no",
      groups: [
        "Mozilla Extensions"
      ],
      initial: "default",
      appliesto: "allElementsCreatingNativeWindows",
      computed: "asSpecified",
      order: "uniqueOrder",
      status: "nonstandard",
      mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-window-shadow"
    },
    "-webkit-appearance": {
      syntax: "none | button | button-bevel | caret | checkbox | default-button | inner-spin-button | listbox | listitem | media-controls-background | media-controls-fullscreen-background | media-current-time-display | media-enter-fullscreen-button | media-exit-fullscreen-button | media-fullscreen-button | media-mute-button | media-overlay-play-button | media-play-button | media-seek-back-button | media-seek-forward-button | media-slider | media-sliderthumb | media-time-remaining-display | media-toggle-closed-captions-button | media-volume-slider | media-volume-slider-container | media-volume-sliderthumb | menulist | menulist-button | menulist-text | menulist-textfield | meter | progress-bar | progress-bar-value | push-button | radio | searchfield | searchfield-cancel-button | searchfield-decoration | searchfield-results-button | searchfield-results-decoration | slider-horizontal | slider-vertical | sliderthumb-horizontal | sliderthumb-vertical | square-button | textarea | textfield | -apple-pay-button",
      media: "visual",
      inherited: false,
      animationType: "discrete",
      percentages: "no",
      groups: [
        "WebKit Extensions"
      ],
      initial: "noneButOverriddenInUserAgentCSS",
      appliesto: "allElements",
      computed: "asSpecified",
      order: "uniqueOrder",
      status: "nonstandard",
      mdn_url: "https://developer.mozilla.org/docs/Web/CSS/appearance"
    },
    "-webkit-border-before": {
      syntax: "<'border-width'> || <'border-style'> || <color>",
      media: "visual",
      inherited: true,
      animationType: "discrete",
      percentages: [
        "-webkit-border-before-width"
      ],
      groups: [
        "WebKit Extensions"
      ],
      initial: [
        "border-width",
        "border-style",
        "color"
      ],
      appliesto: "allElements",
      computed: [
        "border-width",
        "border-style",
        "color"
      ],
      order: "uniqueOrder",
      status: "nonstandard",
      mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-webkit-border-before"
    },
    "-webkit-border-before-color": {
      syntax: "<color>",
      media: "visual",
      inherited: true,
      animationType: "discrete",
      percentages: "no",
      groups: [
        "WebKit Extensions"
      ],
      initial: "currentcolor",
      appliesto: "allElements",
      computed: "computedColor",
      order: "uniqueOrder",
      status: "nonstandard"
    },
    "-webkit-border-before-style": {
      syntax: "<'border-style'>",
      media: "visual",
      inherited: true,
      animationType: "discrete",
      percentages: "no",
      groups: [
        "WebKit Extensions"
      ],
      initial: "none",
      appliesto: "allElements",
      computed: "asSpecified",
      order: "uniqueOrder",
      status: "nonstandard"
    },
    "-webkit-border-before-width": {
      syntax: "<'border-width'>",
      media: "visual",
      inherited: true,
      animationType: "discrete",
      percentages: "logicalWidthOfContainingBlock",
      groups: [
        "WebKit Extensions"
      ],
      initial: "medium",
      appliesto: "allElements",
      computed: "absoluteLengthZeroIfBorderStyleNoneOrHidden",
      order: "uniqueOrder",
      status: "nonstandard"
    },
    "-webkit-box-reflect": {
      syntax: "[ above | below | right | left ]? <length>? <image>?",
      media: "visual",
      inherited: false,
      animationType: "discrete",
      percentages: "no",
      groups: [
        "WebKit Extensions"
      ],
      initial: "none",
      appliesto: "allElements",
      computed: "asSpecified",
      order: "uniqueOrder",
      status: "nonstandard",
      mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-webkit-box-reflect"
    },
    "-webkit-line-clamp": {
      syntax: "none | <integer>",
      media: "visual",
      inherited: false,
      animationType: "byComputedValueType",
      percentages: "no",
      groups: [
        "WebKit Extensions",
        "CSS Overflow"
      ],
      initial: "none",
      appliesto: "allElements",
      computed: "asSpecified",
      order: "uniqueOrder",
      status: "standard",
      mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-webkit-line-clamp"
    },
    "-webkit-mask": {
      syntax: "[ <mask-reference> || <position> [ / <bg-size> ]? || <repeat-style> || [ <box> | border | padding | content | text ] || [ <box> | border | padding | content ] ]#",
      media: "visual",
      inherited: false,
      animationType: "discrete",
      percentages: "no",
      groups: [
        "WebKit Extensions"
      ],
      initial: [
        "-webkit-mask-image",
        "-webkit-mask-repeat",
        "-webkit-mask-attachment",
        "-webkit-mask-position",
        "-webkit-mask-origin",
        "-webkit-mask-clip"
      ],
      appliesto: "allElements",
      computed: [
        "-webkit-mask-image",
        "-webkit-mask-repeat",
        "-webkit-mask-attachment",
        "-webkit-mask-position",
        "-webkit-mask-origin",
        "-webkit-mask-clip"
      ],
      order: "uniqueOrder",
      status: "nonstandard",
      mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask"
    },
    "-webkit-mask-attachment": {
      syntax: "<attachment>#",
      media: "visual",
      inherited: false,
      animationType: "discrete",
      percentages: "no",
      groups: [
        "WebKit Extensions"
      ],
      initial: "scroll",
      appliesto: "allElements",
      computed: "asSpecified",
      order: "orderOfAppearance",
      status: "nonstandard",
      mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-webkit-mask-attachment"
    },
    "-webkit-mask-clip": {
      syntax: "[ <box> | border | padding | content | text ]#",
      media: "visual",
      inherited: false,
      animationType: "discrete",
      percentages: "no",
      groups: [
        "WebKit Extensions"
      ],
      initial: "border",
      appliesto: "allElements",
      computed: "asSpecified",
      order: "orderOfAppearance",
      status: "nonstandard",
      mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-clip"
    },
    "-webkit-mask-composite": {
      syntax: "<composite-style>#",
      media: "visual",
      inherited: false,
      animationType: "discrete",
      percentages: "no",
      groups: [
        "WebKit Extensions"
      ],
      initial: "source-over",
      appliesto: "allElements",
      computed: "asSpecified",
      order: "orderOfAppearance",
      status: "nonstandard",
      mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-webkit-mask-composite"
    },
    "-webkit-mask-image": {
      syntax: "<mask-reference>#",
      media: "visual",
      inherited: false,
      animationType: "discrete",
      percentages: "no",
      groups: [
        "WebKit Extensions"
      ],
      initial: "none",
      appliesto: "allElements",
      computed: "absoluteURIOrNone",
      order: "orderOfAppearance",
      status: "nonstandard",
      mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-image"
    },
    "-webkit-mask-origin": {
      syntax: "[ <box> | border | padding | content ]#",
      media: "visual",
      inherited: false,
      animationType: "discrete",
      percentages: "no",
      groups: [
        "WebKit Extensions"
      ],
      initial: "padding",
      appliesto: "allElements",
      computed: "asSpecified",
      order: "orderOfAppearance",
      status: "nonstandard",
      mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-origin"
    },
    "-webkit-mask-position": {
      syntax: "<position>#",
      media: "visual",
      inherited: false,
      animationType: "discrete",
      percentages: "referToSizeOfElement",
      groups: [
        "WebKit Extensions"
      ],
      initial: "0% 0%",
      appliesto: "allElements",
      computed: "absoluteLengthOrPercentage",
      order: "orderOfAppearance",
      status: "nonstandard",
      mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-position"
    },
    "-webkit-mask-position-x": {
      syntax: "[ <length-percentage> | left | center | right ]#",
      media: "visual",
      inherited: false,
      animationType: "discrete",
      percentages: "referToSizeOfElement",
      groups: [
        "WebKit Extensions"
      ],
      initial: "0%",
      appliesto: "allElements",
      computed: "absoluteLengthOrPercentage",
      order: "orderOfAppearance",
      status: "nonstandard",
      mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-webkit-mask-position-x"
    },
    "-webkit-mask-position-y": {
      syntax: "[ <length-percentage> | top | center | bottom ]#",
      media: "visual",
      inherited: false,
      animationType: "discrete",
      percentages: "referToSizeOfElement",
      groups: [
        "WebKit Extensions"
      ],
      initial: "0%",
      appliesto: "allElements",
      computed: "absoluteLengthOrPercentage",
      order: "orderOfAppearance",
      status: "nonstandard",
      mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-webkit-mask-position-y"
    },
    "-webkit-mask-repeat": {
      syntax: "<repeat-style>#",
      media: "visual",
      inherited: false,
      animationType: "discrete",
      percentages: "no",
      groups: [
        "WebKit Extensions"
      ],
      initial: "repeat",
      appliesto: "allElements",
      computed: "asSpecified",
      order: "orderOfAppearance",
      status: "nonstandard",
      mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-repeat"
    },
    "-webkit-mask-repeat-x": {
      syntax: "repeat | no-repeat | space | round",
      media: "visual",
      inherited: false,
      animationType: "discrete",
      percentages: "no",
      groups: [
        "WebKit Extensions"
      ],
      initial: "repeat",
      appliesto: "allElements",
      computed: "asSpecified",
      order: "orderOfAppearance",
      status: "nonstandard",
      mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-webkit-mask-repeat-x"
    },
    "-webkit-mask-repeat-y": {
      syntax: "repeat | no-repeat | space | round",
      media: "visual",
      inherited: false,
      animationType: "discrete",
      percentages: "no",
      groups: [
        "WebKit Extensions"
      ],
      initial: "repeat",
      appliesto: "allElements",
      computed: "absoluteLengthOrPercentage",
      order: "orderOfAppearance",
      status: "nonstandard",
      mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-webkit-mask-repeat-y"
    },
    "-webkit-mask-size": {
      syntax: "<bg-size>#",
      media: "visual",
      inherited: false,
      animationType: "discrete",
      percentages: "relativeToBackgroundPositioningArea",
      groups: [
        "WebKit Extensions"
      ],
      initial: "auto auto",
      appliesto: "allElements",
      computed: "asSpecified",
      order: "orderOfAppearance",
      status: "nonstandard",
      mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-size"
    },
    "-webkit-overflow-scrolling": {
      syntax: "auto | touch",
      media: "visual",
      inherited: true,
      animationType: "discrete",
      percentages: "no",
      groups: [
        "WebKit Extensions"
      ],
      initial: "auto",
      appliesto: "scrollingBoxes",
      computed: "asSpecified",
      order: "orderOfAppearance",
      status: "nonstandard",
      mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-webkit-overflow-scrolling"
    },
    "-webkit-tap-highlight-color": {
      syntax: "<color>",
      media: "visual",
      inherited: true,
      animationType: "discrete",
      percentages: "no",
      groups: [
        "WebKit Extensions"
      ],
      initial: "black",
      appliesto: "allElements",
      computed: "asSpecified",
      order: "uniqueOrder",
      status: "nonstandard",
      mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-webkit-tap-highlight-color"
    },
    "-webkit-text-fill-color": {
      syntax: "<color>",
      media: "visual",
      inherited: true,
      animationType: "color",
      percentages: "no",
      groups: [
        "WebKit Extensions"
      ],
      initial: "currentcolor",
      appliesto: "allElements",
      computed: "computedColor",
      order: "uniqueOrder",
      status: "nonstandard",
      mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-webkit-text-fill-color"
    },
    "-webkit-text-stroke": {
      syntax: "<length> || <color>",
      media: "visual",
      inherited: true,
      animationType: [
        "-webkit-text-stroke-width",
        "-webkit-text-stroke-color"
      ],
      percentages: "no",
      groups: [
        "WebKit Extensions"
      ],
      initial: [
        "-webkit-text-stroke-width",
        "-webkit-text-stroke-color"
      ],
      appliesto: "allElements",
      computed: [
        "-webkit-text-stroke-width",
        "-webkit-text-stroke-color"
      ],
      order: "canonicalOrder",
      status: "nonstandard",
      mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-webkit-text-stroke"
    },
    "-webkit-text-stroke-color": {
      syntax: "<color>",
      media: "visual",
      inherited: true,
      animationType: "color",
      percentages: "no",
      groups: [
        "WebKit Extensions"
      ],
      initial: "currentcolor",
      appliesto: "allElements",
      computed: "computedColor",
      order: "uniqueOrder",
      status: "nonstandard",
      mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-webkit-text-stroke-color"
    },
    "-webkit-text-stroke-width": {
      syntax: "<length>",
      media: "visual",
      inherited: true,
      animationType: "discrete",
      percentages: "no",
      groups: [
        "WebKit Extensions"
      ],
      initial: "0",
      appliesto: "allElements",
      computed: "absoluteLength",
      order: "uniqueOrder",
      status: "nonstandard",
      mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-webkit-text-stroke-width"
    },
    "-webkit-touch-callout": {
      syntax: "default | none",
      media: "visual",
      inherited: true,
      animationType: "discrete",
      percentages: "no",
      groups: [
        "WebKit Extensions"
      ],
      initial: "default",
      appliesto: "allElements",
      computed: "asSpecified",
      order: "uniqueOrder",
      status: "nonstandard",
      mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-webkit-touch-callout"
    },
    "-webkit-user-modify": {
      syntax: "read-only | read-write | read-write-plaintext-only",
      media: "interactive",
      inherited: true,
      animationType: "discrete",
      percentages: "no",
      groups: [
        "WebKit Extensions"
      ],
      initial: "read-only",
      appliesto: "allElements",
      computed: "asSpecified",
      order: "uniqueOrder",
      status: "nonstandard"
    },
    "accent-color": {
      syntax: "auto | <color>",
      media: "interactive",
      inherited: true,
      animationType: "byComputedValueType",
      percentages: "no",
      groups: [
        "CSS Basic User Interface"
      ],
      initial: "auto",
      appliesto: "allElements",
      computed: "asAutoOrColor",
      order: "perGrammar",
      status: "standard",
      mdn_url: "https://developer.mozilla.org/docs/Web/CSS/accent-color"
    },
    "align-content": {
      syntax: "normal | <baseline-position> | <content-distribution> | <overflow-position>? <content-position>",
      media: "visual",
      inherited: false,
      animationType: "discrete",
      percentages: "no",
      groups: [
        "CSS Box Alignment"
      ],
      initial: "normal",
      appliesto: "multilineFlexContainers",
      computed: "asSpecified",
      order: "uniqueOrder",
      status: "standard",
      mdn_url: "https://developer.mozilla.org/docs/Web/CSS/align-content"
    },
    "align-items": {
      syntax: "normal | stretch | <baseline-position> | [ <overflow-position>? <self-position> ]",
      media: "visual",
      inherited: false,
      animationType: "discrete",
      percentages: "no",
      groups: [
        "CSS Box Alignment"
      ],
      initial: "normal",
      appliesto: "allElements",
      computed: "asSpecified",
      order: "uniqueOrder",
      status: "standard",
      mdn_url: "https://developer.mozilla.org/docs/Web/CSS/align-items"
    },
    "align-self": {
      syntax: "auto | normal | stretch | <baseline-position> | <overflow-position>? <self-position>",
      media: "visual",
      inherited: false,
      animationType: "discrete",
      percentages: "no",
      groups: [
        "CSS Box Alignment"
      ],
      initial: "auto",
      appliesto: "flexItemsGridItemsAndAbsolutelyPositionedBoxes",
      computed: "autoOnAbsolutelyPositionedElementsValueOfAlignItemsOnParent",
      order: "uniqueOrder",
      status: "standard",
      mdn_url: "https://developer.mozilla.org/docs/Web/CSS/align-self"
    },
    "align-tracks": {
      syntax: "[ normal | <baseline-position> | <content-distribution> | <overflow-position>? <content-position> ]#",
      media: "visual",
      inherited: false,
      animationType: "discrete",
      percentages: "no",
      groups: [
        "CSS Grid Layout"
      ],
      initial: "normal",
      appliesto: "gridContainersWithMasonryLayoutInTheirBlockAxis",
      computed: "asSpecified",
      order: "uniqueOrder",
      status: "experimental",
      mdn_url: "https://developer.mozilla.org/docs/Web/CSS/align-tracks"
    },
    all: {
      syntax: "initial | inherit | unset | revert | revert-layer",
      media: "noPracticalMedia",
      inherited: false,
      animationType: "eachOfShorthandPropertiesExceptUnicodeBiDiAndDirection",
      percentages: "no",
      groups: [
        "CSS Miscellaneous"
      ],
      initial: "noPracticalInitialValue",
      appliesto: "allElements",
      computed: "asSpecifiedAppliesToEachProperty",
      order: "uniqueOrder",
      status: "standard",
      mdn_url: "https://developer.mozilla.org/docs/Web/CSS/all"
    },
    animation: {
      syntax: "<single-animation>#",
      media: "visual",
      inherited: false,
      animationType: "notAnimatable",
      percentages: "no",
      groups: [
        "CSS Animations"
      ],
      initial: [
        "animation-name",
        "animation-duration",
        "animation-timing-function",
        "animation-delay",
        "animation-iteration-count",
        "animation-direction",
        "animation-fill-mode",
        "animation-play-state",
        "animation-timeline"
      ],
      appliesto: "allElementsAndPseudos",
      computed: [
        "animation-name",
        "animation-duration",
        "animation-timing-function",
        "animation-delay",
        "animation-direction",
        "animation-iteration-count",
        "animation-fill-mode",
        "animation-play-state",
        "animation-timeline"
      ],
      order: "orderOfAppearance",
      status: "standard",
      mdn_url: "https://developer.mozilla.org/docs/Web/CSS/animation"
    },
    "animation-delay": {
      syntax: "<time>#",
      media: "visual",
      inherited: false,
      animationType: "notAnimatable",
      percentages: "no",
      groups: [
        "CSS Animations"
      ],
      initial: "0s",
      appliesto: "allElementsAndPseudos",
      computed: "asSpecified",
      order: "uniqueOrder",
      status: "standard",
      mdn_url: "https://developer.mozilla.org/docs/Web/CSS/animation-delay"
    },
    "animation-direction": {
      syntax: "<single-animation-direction>#",
      media: "visual",
      inherited: false,
      animationType: "notAnimatable",
      percentages: "no",
      groups: [
        "CSS Animations"
      ],
      initial: "normal",
      appliesto: "allElementsAndPseudos",
      computed: "asSpecified",
      order: "uniqueOrder",
      status: "standard",
      mdn_url: "https://developer.mozilla.org/docs/Web/CSS/animation-direction"
    },
    "animation-duration": {
      syntax: "<time>#",
      media: "visual",
      inherited: false,
      animationType: "notAnimatable",
      percentages: "no",
      groups: [
        "CSS Animations"
      ],
      initial: "0s",
      appliesto: "allElementsAndPseudos",
      computed: "asSpecified",
      order: "uniqueOrder",
      status: "standard",
      mdn_url: "https://developer.mozilla.org/docs/Web/CSS/animation-duration"
    },
    "animation-fill-mode": {
      syntax: "<single-animation-fill-mode>#",
      media: "visual",
      inherited: false,
      animationType: "notAnimatable",
      percentages: "no",
      groups: [
        "CSS Animations"
      ],
      initial: "none",
      appliesto: "allElementsAndPseudos",
      computed: "asSpecified",
      order: "uniqueOrder",
      status: "standard",
      mdn_url: "https://developer.mozilla.org/docs/Web/CSS/animation-fill-mode"
    },
    "animation-iteration-count": {
      syntax: "<single-animation-iteration-count>#",
      media: "visual",
      inherited: false,
      animationType: "notAnimatable",
      percentages: "no",
      groups: [
        "CSS Animations"
      ],
      initial: "1",
      appliesto: "allElementsAndPseudos",
      computed: "asSpecified",
      order: "uniqueOrder",
      status: "standard",
      mdn_url: "https://developer.mozilla.org/docs/Web/CSS/animation-iteration-count"
    },
    "animation-name": {
      syntax: "[ none | <keyframes-name> ]#",
      media: "visual",
      inherited: false,
      animationType: "notAnimatable",
      percentages: "no",
      groups: [
        "CSS Animations"
      ],
      initial: "none",
      appliesto: "allElementsAndPseudos",
      computed: "asSpecified",
      order: "uniqueOrder",
      status: "standard",
      mdn_url: "https://developer.mozilla.org/docs/Web/CSS/animation-name"
    },
    "animation-play-state": {
      syntax: "<single-animation-play-state>#",
      media: "visual",
      inherited: false,
      animationType: "notAnimatable",
      percentages: "no",
      groups: [
        "CSS Animations"
      ],
      initial: "running",
      appliesto: "allElementsAndPseudos",
      computed: "asSpecified",
      order: "uniqueOrder",
      status: "standard",
      mdn_url: "https://developer.mozilla.org/docs/Web/CSS/animation-play-state"
    },
    "animation-timing-function": {
      syntax: "<easing-function>#",
      media: "visual",
      inherited: false,
      animationType: "notAnimatable",
      percentages: "no",
      groups: [
        "CSS Animations"
      ],
      initial: "ease",
      appliesto: "allElementsAndPseudos",
      computed: "asSpecified",
      order: "uniqueOrder",
      status: "standard",
      mdn_url: "https://developer.mozilla.org/docs/Web/CSS/animation-timing-function"
    },
    "animation-timeline": {
      syntax: "<single-animation-timeline>#",
      media: "visual",
      inherited: false,
      animationType: "notAnimatable",
      percentages: "no",
      groups: [
        "CSS Animations"
      ],
      initial: "auto",
      appliesto: "allElements",
      computed: "listEachItemIdentifyerOrNoneAuto",
      order: "uniqueOrder",
      status: "standard",
      mdn_url: "https://developer.mozilla.org/docs/Web/CSS/animation-timeline"
    },
    appearance: {
      syntax: "none | auto | textfield | menulist-button | <compat-auto>",
      media: "all",
      inherited: false,
      animationType: "discrete",
      percentages: "no",
      groups: [
        "CSS Basic User Interface"
      ],
      initial: "none",
      appliesto: "allElements",
      computed: "asSpecified",
      order: "perGrammar",
      status: "experimental",
      mdn_url: "https://developer.mozilla.org/docs/Web/CSS/appearance"
    },
    "aspect-ratio": {
      syntax: "auto | <ratio>",
      media: "all",
      inherited: false,
      animationType: "discrete",
      percentages: "no",
      groups: [
        "CSS Basic User Interface"
      ],
      initial: "auto",
      appliesto: "allElementsExceptInlineBoxesAndInternalRubyOrTableBoxes",
      computed: "asSpecified",
      order: "perGrammar",
      status: "experimental",
      mdn_url: "https://developer.mozilla.org/docs/Web/CSS/aspect-ratio"
    },
    azimuth: {
      syntax: "<angle> | [ [ left-side | far-left | left | center-left | center | center-right | right | far-right | right-side ] || behind ] | leftwards | rightwards",
      media: "aural",
      inherited: true,
      animationType: "discrete",
      percentages: "no",
      groups: [
        "CSS Speech"
      ],
      initial: "center",
      appliesto: "allElements",
      computed: "normalizedAngle",
      order: "orderOfAppearance",
      status: "obsolete",
      mdn_url: "https://developer.mozilla.org/docs/Web/CSS/azimuth"
    },
    "backdrop-filter": {
      syntax: "none | <filter-function-list>",
      media: "visual",
      inherited: false,
      animationType: "filterList",
      percentages: "no",
      groups: [
        "Filter Effects"
      ],
      initial: "none",
      appliesto: "allElementsSVGContainerElements",
      computed: "asSpecified",
      order: "uniqueOrder",
      status: "standard",
      mdn_url: "https://developer.mozilla.org/docs/Web/CSS/backdrop-filter"
    },
    "backface-visibility": {
      syntax: "visible | hidden",
      media: "visual",
      inherited: false,
      animationType: "discrete",
      percentages: "no",
      groups: [
        "CSS Transforms"
      ],
      initial: "visible",
      appliesto: "transformableElements",
      computed: "asSpecified",
      order: "uniqueOrder",
      status: "standard",
      mdn_url: "https://developer.mozilla.org/docs/Web/CSS/backface-visibility"
    },
    background: {
      syntax: "[ <bg-layer> , ]* <final-bg-layer>",
      media: "visual",
      inherited: false,
      animationType: [
        "background-color",
        "background-image",
        "background-clip",
        "background-position",
        "background-size",
        "background-repeat",
        "background-attachment"
      ],
      percentages: [
        "background-position",
        "background-size"
      ],
      groups: [
        "CSS Backgrounds and Borders"
      ],
      initial: [
        "background-image",
        "background-position",
        "background-size",
        "background-repeat",
        "background-origin",
        "background-clip",
        "background-attachment",
        "background-color"
      ],
      appliesto: "allElements",
      computed: [
        "background-image",
        "background-position",
        "background-size",
        "background-repeat",
        "background-origin",
        "background-clip",
        "background-attachment",
        "background-color"
      ],
      order: "orderOfAppearance",
      alsoAppliesTo: [
        "::first-letter",
        "::first-line",
        "::placeholder"
      ],
      status: "standard",
      mdn_url: "https://developer.mozilla.org/docs/Web/CSS/background"
    },
    "background-attachment": {
      syntax: "<attachment>#",
      media: "visual",
      inherited: false,
      animationType: "discrete",
      percentages: "no",
      groups: [
        "CSS Backgrounds and Borders"
      ],
      initial: "scroll",
      appliesto: "allElements",
      computed: "asSpecified",
      order: "uniqueOrder",
      alsoAppliesTo: [
        "::first-letter",
        "::first-line",
        "::placeholder"
      ],
      status: "standard",
      mdn_url: "https://developer.mozilla.org/docs/Web/CSS/background-attachment"
    },
    "background-blend-mode": {
      syntax: "<blend-mode>#",
      media: "none",
      inherited: false,
      animationType: "discrete",
      percentages: "no",
      groups: [
        "Compositing and Blending"
      ],
      initial: "normal",
      appliesto: "allElementsSVGContainerGraphicsAndGraphicsReferencingElements",
      computed: "asSpecified",
      order: "uniqueOrder",
      alsoAppliesTo: [
        "::first-letter",
        "::first-line",
        "::placeholder"
      ],
      status: "standard",
      mdn_url: "https://developer.mozilla.org/docs/Web/CSS/background-blend-mode"
    },
    "background-clip": {
      syntax: "<box>#",
      media: "visual",
      inherited: false,
      animationType: "discrete",
      percentages: "no",
      groups: [
        "CSS Backgrounds and Borders"
      ],
      initial: "border-box",
      appliesto: "allElements",
      computed: "asSpecified",
      order: "uniqueOrder",
      alsoAppliesTo: [
        "::first-letter",
        "::first-line",
        "::placeholder"
      ],
      status: "standard",
      mdn_url: "https://developer.mozilla.org/docs/Web/CSS/background-clip"
    },
    "background-color": {
      syntax: "<color>",
      media: "visual",
      inherited: false,
      animationType: "color",
      percentages: "no",
      groups: [
        "CSS Backgrounds and Borders"
      ],
      initial: "transparent",
      appliesto: "allElements",
      computed: "computedColor",
      order: "uniqueOrder",
      alsoAppliesTo: [
        "::first-letter",
        "::first-line",
        "::placeholder"
      ],
      status: "standard",
      mdn_url: "https://developer.mozilla.org/docs/Web/CSS/background-color"
    },
    "background-image": {
      syntax: "<bg-image>#",
      media: "visual",
      inherited: false,
      animationType: "discrete",
      percentages: "no",
      groups: [
        "CSS Backgrounds and Borders"
      ],
      initial: "none",
      appliesto: "allElements",
      computed: "asSpecifiedURLsAbsolute",
      order: "uniqueOrder",
      alsoAppliesTo: [
        "::first-letter",
        "::first-line",
        "::placeholder"
      ],
      status: "standard",
      mdn_url: "https://developer.mozilla.org/docs/Web/CSS/background-image"
    },
    "background-origin": {
      syntax: "<box>#",
      media: "visual",
      inherited: false,
      animationType: "discrete",
      percentages: "no",
      groups: [
        "CSS Backgrounds and Borders"
      ],
      initial: "padding-box",
      appliesto: "allElements",
      computed: "asSpecified",
      order: "uniqueOrder",
      alsoAppliesTo: [
        "::first-letter",
        "::first-line",
        "::placeholder"
      ],
      status: "standard",
      mdn_url: "https://developer.mozilla.org/docs/Web/CSS/background-origin"
    },
    "background-position": {
      syntax: "<bg-position>#",
      media: "visual",
      inherited: false,
      animationType: "repeatableListOfSimpleListOfLpc",
      percentages: "referToSizeOfBackgroundPositioningAreaMinusBackgroundImageSize",
      groups: [
        "CSS Backgrounds and Borders"
      ],
      initial: "0% 0%",
      appliesto: "allElements",
      computed: [
        "background-position-x",
        "background-position-y"
      ],
      order: "uniqueOrder",
      alsoAppliesTo: [
        "::first-letter",
        "::first-line",
        "::placeholder"
      ],
      status: "standard",
      mdn_url: "https://developer.mozilla.org/docs/Web/CSS/background-position"
    },
    "background-position-x": {
      syntax: "[ center | [ [ left | right | x-start | x-end ]? <length-percentage>? ]! ]#",
      media: "visual",
      inherited: false,
      animationType: "discrete",
      percentages: "referToWidthOfBackgroundPositioningAreaMinusBackgroundImageHeight",
      groups: [
        "CSS Backgrounds and Borders"
      ],
      initial: "0%",
      appliesto: "allElements",
      computed: "listEachItemConsistingOfAbsoluteLengthPercentageAndOrigin",
      order: "uniqueOrder",
      status: "experimental",
      mdn_url: "https://developer.mozilla.org/docs/Web/CSS/background-position-x"
    },
    "background-position-y": {
      syntax: "[ center | [ [ top | bottom | y-start | y-end ]? <length-percentage>? ]! ]#",
      media: "visual",
      inherited: false,
      animationType: "discrete",
      percentages: "referToHeightOfBackgroundPositioningAreaMinusBackgroundImageHeight",
      groups: [
        "CSS Backgrounds and Borders"
      ],
      initial: "0%",
      appliesto: "allElements",
      computed: "listEachItemConsistingOfAbsoluteLengthPercentageAndOrigin",
      order: "uniqueOrder",
      status: "experimental",
      mdn_url: "https://developer.mozilla.org/docs/Web/CSS/background-position-y"
    },
    "background-repeat": {
      syntax: "<repeat-style>#",
      media: "visual",
      inherited: false,
      animationType: "discrete",
      percentages: "no",
      groups: [
        "CSS Backgrounds and Borders"
      ],
      initial: "repeat",
      appliesto: "allElements",
      computed: "listEachItemHasTwoKeywordsOnePerDimension",
      order: "uniqueOrder",
      alsoAppliesTo: [
        "::first-letter",
        "::first-line",
        "::placeholder"
      ],
      status: "standard",
      mdn_url: "https://developer.mozilla.org/docs/Web/CSS/background-repeat"
    },
    "background-size": {
      syntax: "<bg-size>#",
      media: "visual",
      inherited: false,
      animationType: "repeatableListOfSimpleListOfLpc",
      percentages: "relativeToBackgroundPositioningArea",
      groups: [
        "CSS Backgrounds and Borders"
      ],
      initial: "auto auto",
      appliesto: "allElements",
      computed: "asSpecifiedRelativeToAbsoluteLengths",
      order: "uniqueOrder",
      alsoAppliesTo: [
        "::first-letter",
        "::first-line",
        "::placeholder"
      ],
      status: "standard",
      mdn_url: "https://developer.mozilla.org/docs/Web/CSS/background-size"
    },
    "block-overflow": {
      syntax: "clip | ellipsis | <string>",
      media: "visual",
      inherited: true,
      animationType: "discrete",
      percentages: "no",
      groups: [
        "CSS Overflow"
      ],
      initial: "clip",
      appliesto: "blockContainers",
      computed: "asSpecified",
      order: "perGrammar",
      status: "experimental"
    },
    "block-size": {
      syntax: "<'width'>",
      media: "visual",
      inherited: false,
      animationType: "lpc",
      percentages: "blockSizeOfContainingBlock",
      groups: [
        "CSS Logical Properties"
      ],
      initial: "auto",
      appliesto: "sameAsWidthAndHeight",
      computed: "sameAsWidthAndHeight",
      order: "uniqueOrder",
      status: "standard",
      mdn_url: "https://developer.mozilla.org/docs/Web/CSS/block-size"
    },
    border: {
      syntax: "<line-width> || <line-style> || <color>",
      media: "visual",
      inherited: false,
      animationType: [
        "border-color",
        "border-style",
        "border-width"
      ],
      percentages: "no",
      groups: [
        "CSS Backgrounds and Borders"
      ],
      initial: [
        "border-width",
        "border-style",
        "border-color"
      ],
      appliesto: "allElements",
      computed: [
        "border-width",
        "border-style",
        "border-color"
      ],
      order: "orderOfAppearance",
      alsoAppliesTo: [
        "::first-letter"
      ],
      status: "standard",
      mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border"
    },
    "border-block": {
      syntax: "<'border-top-width'> || <'border-top-style'> || <color>",
      media: "visual",
      inherited: false,
      animationType: "discrete",
      percentages: "no",
      groups: [
        "CSS Logical Properties"
      ],
      initial: [
        "border-top-width",
        "border-top-style",
        "border-top-color"
      ],
      appliesto: "allElements",
      computed: [
        "border-top-width",
        "border-top-style",
        "border-top-color"
      ],
      order: "uniqueOrder",
      status: "standard",
      mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-block"
    },
    "border-block-color": {
      syntax: "<'border-top-color'>{1,2}",
      media: "visual",
      inherited: false,
      animationType: "discrete",
      percentages: "no",
      groups: [
        "CSS Logical Properties"
      ],
      initial: "currentcolor",
      appliesto: "allElements",
      computed: "computedColor",
      order: "uniqueOrder",
      status: "standard",
      mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-block-color"
    },
    "border-block-style": {
      syntax: "<'border-top-style'>",
      media: "visual",
      inherited: false,
      animationType: "discrete",
      percentages: "no",
      groups: [
        "CSS Logical Properties"
      ],
      initial: "none",
      appliesto: "allElements",
      computed: "asSpecified",
      order: "uniqueOrder",
      status: "standard",
      mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-block-style"
    },
    "border-block-width": {
      syntax: "<'border-top-width'>",
      media: "visual",
      inherited: false,
      animationType: "discrete",
      percentages: "logicalWidthOfContainingBlock",
      groups: [
        "CSS Logical Properties"
      ],
      initial: "medium",
      appliesto: "allElements",
      computed: "absoluteLengthZeroIfBorderStyleNoneOrHidden",
      order: "uniqueOrder",
      status: "standard",
      mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-block-width"
    },
    "border-block-end": {
      syntax: "<'border-top-width'> || <'border-top-style'> || <color>",
      media: "visual",
      inherited: false,
      animationType: [
        "border-block-end-color",
        "border-block-end-style",
        "border-block-end-width"
      ],
      percentages: "no",
      groups: [
        "CSS Logical Properties"
      ],
      initial: [
        "border-top-width",
        "border-top-style",
        "border-top-color"
      ],
      appliesto: "allElements",
      computed: [
        "border-top-width",
        "border-top-style",
        "border-top-color"
      ],
      order: "uniqueOrder",
      status: "standard",
      mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-block-end"
    },
    "border-block-end-color": {
      syntax: "<'border-top-color'>",
      media: "visual",
      inherited: false,
      animationType: "color",
      percentages: "no",
      groups: [
        "CSS Logical Properties"
      ],
      initial: "currentcolor",
      appliesto: "allElements",
      computed: "computedColor",
      order: "uniqueOrder",
      status: "standard",
      mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-block-end-color"
    },
    "border-block-end-style": {
      syntax: "<'border-top-style'>",
      media: "visual",
      inherited: false,
      animationType: "discrete",
      percentages: "no",
      groups: [
        "CSS Logical Properties"
      ],
      initial: "none",
      appliesto: "allElements",
      computed: "asSpecified",
      order: "uniqueOrder",
      status: "standard",
      mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-block-end-style"
    },
    "border-block-end-width": {
      syntax: "<'border-top-width'>",
      media: "visual",
      inherited: false,
      animationType: "length",
      percentages: "logicalWidthOfContainingBlock",
      groups: [
        "CSS Logical Properties"
      ],
      initial: "medium",
      appliesto: "allElements",
      computed: "absoluteLengthZeroIfBorderStyleNoneOrHidden",
      order: "uniqueOrder",
      status: "standard",
      mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-block-end-width"
    },
    "border-block-start": {
      syntax: "<'border-top-width'> || <'border-top-style'> || <color>",
      media: "visual",
      inherited: false,
      animationType: [
        "border-block-start-color",
        "border-block-start-style",
        "border-block-start-width"
      ],
      percentages: "no",
      groups: [
        "CSS Logical Properties"
      ],
      initial: [
        "border-width",
        "border-style",
        "color"
      ],
      appliesto: "allElements",
      computed: [
        "border-width",
        "border-style",
        "border-block-start-color"
      ],
      order: "uniqueOrder",
      status: "standard",
      mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-block-start"
    },
    "border-block-start-color": {
      syntax: "<'border-top-color'>",
      media: "visual",
      inherited: false,
      animationType: "color",
      percentages: "no",
      groups: [
        "CSS Logical Properties"
      ],
      initial: "currentcolor",
      appliesto: "allElements",
      computed: "computedColor",
      order: "uniqueOrder",
      status: "standard",
      mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-block-start-color"
    },
    "border-block-start-style": {
      syntax: "<'border-top-style'>",
      media: "visual",
      inherited: false,
      animationType: "discrete",
      percentages: "no",
      groups: [
        "CSS Logical Properties"
      ],
      initial: "none",
      appliesto: "allElements",
      computed: "asSpecified",
      order: "uniqueOrder",
      status: "standard",
      mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-block-start-style"
    },
    "border-block-start-width": {
      syntax: "<'border-top-width'>",
      media: "visual",
      inherited: false,
      animationType: "length",
      percentages: "logicalWidthOfContainingBlock",
      groups: [
        "CSS Logical Properties"
      ],
      initial: "medium",
      appliesto: "allElements",
      computed: "absoluteLengthZeroIfBorderStyleNoneOrHidden",
      order: "uniqueOrder",
      status: "standard",
      mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-block-start-width"
    },
    "border-bottom": {
      syntax: "<line-width> || <line-style> || <color>",
      media: "visual",
      inherited: false,
      animationType: [
        "border-bottom-color",
        "border-bottom-style",
        "border-bottom-width"
      ],
      percentages: "no",
      groups: [
        "CSS Backgrounds and Borders"
      ],
      initial: [
        "border-bottom-width",
        "border-bottom-style",
        "border-bottom-color"
      ],
      appliesto: "allElements",
      computed: [
        "border-bottom-width",
        "border-bottom-style",
        "border-bottom-color"
      ],
      order: "orderOfAppearance",
      alsoAppliesTo: [
        "::first-letter"
      ],
      status: "standard",
      mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-bottom"
    },
    "border-bottom-color": {
      syntax: "<'border-top-color'>",
      media: "visual",
      inherited: false,
      animationType: "color",
      percentages: "no",
      groups: [
        "CSS Backgrounds and Borders"
      ],
      initial: "currentcolor",
      appliesto: "allElements",
      computed: "computedColor",
      order: "uniqueOrder",
      alsoAppliesTo: [
        "::first-letter"
      ],
      status: "standard",
      mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-bottom-color"
    },
    "border-bottom-left-radius": {
      syntax: "<length-percentage>{1,2}",
      media: "visual",
      inherited: false,
      animationType: "lpc",
      percentages: "referToDimensionOfBorderBox",
      groups: [
        "CSS Backgrounds and Borders"
      ],
      initial: "0",
      appliesto: "allElementsUAsNotRequiredWhenCollapse",
      computed: "twoAbsoluteLengthOrPercentages",
      order: "uniqueOrder",
      alsoAppliesTo: [
        "::first-letter"
      ],
      status: "standard",
      mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-bottom-left-radius"
    },
    "border-bottom-right-radius": {
      syntax: "<length-percentage>{1,2}",
      media: "visual",
      inherited: false,
      animationType: "lpc",
      percentages: "referToDimensionOfBorderBox",
      groups: [
        "CSS Backgrounds and Borders"
      ],
      initial: "0",
      appliesto: "allElementsUAsNotRequiredWhenCollapse",
      computed: "twoAbsoluteLengthOrPercentages",
      order: "uniqueOrder",
      alsoAppliesTo: [
        "::first-letter"
      ],
      status: "standard",
      mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-bottom-right-radius"
    },
    "border-bottom-style": {
      syntax: "<line-style>",
      media: "visual",
      inherited: false,
      animationType: "discrete",
      percentages: "no",
      groups: [
        "CSS Backgrounds and Borders"
      ],
      initial: "none",
      appliesto: "allElements",
      computed: "asSpecified",
      order: "uniqueOrder",
      alsoAppliesTo: [
        "::first-letter"
      ],
      status: "standard",
      mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-bottom-style"
    },
    "border-bottom-width": {
      syntax: "<line-width>",
      media: "visual",
      inherited: false,
      animationType: "length",
      percentages: "no",
      groups: [
        "CSS Backgrounds and Borders"
      ],
      initial: "medium",
      appliesto: "allElements",
      computed: "absoluteLengthOr0IfBorderBottomStyleNoneOrHidden",
      order: "uniqueOrder",
      alsoAppliesTo: [
        "::first-letter"
      ],
      status: "standard",
      mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-bottom-width"
    },
    "border-collapse": {
      syntax: "collapse | separate",
      media: "visual",
      inherited: true,
      animationType: "discrete",
      percentages: "no",
      groups: [
        "CSS Table"
      ],
      initial: "separate",
      appliesto: "tableElements",
      computed: "asSpecified",
      order: "uniqueOrder",
      status: "standard",
      mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-collapse"
    },
    "border-color": {
      syntax: "<color>{1,4}",
      media: "visual",
      inherited: false,
      animationType: [
        "border-bottom-color",
        "border-left-color",
        "border-right-color",
        "border-top-color"
      ],
      percentages: "no",
      groups: [
        "CSS Backgrounds and Borders"
      ],
      initial: [
        "border-top-color",
        "border-right-color",
        "border-bottom-color",
        "border-left-color"
      ],
      appliesto: "allElements",
      computed: [
        "border-bottom-color",
        "border-left-color",
        "border-right-color",
        "border-top-color"
      ],
      order: "uniqueOrder",
      alsoAppliesTo: [
        "::first-letter"
      ],
      status: "standard",
      mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-color"
    },
    "border-end-end-radius": {
      syntax: "<length-percentage>{1,2}",
      media: "visual",
      inherited: false,
      animationType: "lpc",
      percentages: "referToDimensionOfBorderBox",
      groups: [
        "CSS Logical Properties"
      ],
      initial: "0",
      appliesto: "allElementsUAsNotRequiredWhenCollapse",
      computed: "twoAbsoluteLengthOrPercentages",
      order: "uniqueOrder",
      alsoAppliesTo: [
        "::first-letter"
      ],
      status: "standard",
      mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-end-end-radius"
    },
    "border-end-start-radius": {
      syntax: "<length-percentage>{1,2}",
      media: "visual",
      inherited: false,
      animationType: "lpc",
      percentages: "referToDimensionOfBorderBox",
      groups: [
        "CSS Logical Properties"
      ],
      initial: "0",
      appliesto: "allElementsUAsNotRequiredWhenCollapse",
      computed: "twoAbsoluteLengthOrPercentages",
      order: "uniqueOrder",
      alsoAppliesTo: [
        "::first-letter"
      ],
      status: "standard",
      mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-end-start-radius"
    },
    "border-image": {
      syntax: "<'border-image-source'> || <'border-image-slice'> [ / <'border-image-width'> | / <'border-image-width'>? / <'border-image-outset'> ]? || <'border-image-repeat'>",
      media: "visual",
      inherited: false,
      animationType: "discrete",
      percentages: [
        "border-image-slice",
        "border-image-width"
      ],
      groups: [
        "CSS Backgrounds and Borders"
      ],
      initial: [
        "border-image-source",
        "border-image-slice",
        "border-image-width",
        "border-image-outset",
        "border-image-repeat"
      ],
      appliesto: "allElementsExceptTableElementsWhenCollapse",
      computed: [
        "border-image-outset",
        "border-image-repeat",
        "border-image-slice",
        "border-image-source",
        "border-image-width"
      ],
      order: "uniqueOrder",
      alsoAppliesTo: [
        "::first-letter"
      ],
      status: "standard",
      mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-image"
    },
    "border-image-outset": {
      syntax: "[ <length> | <number> ]{1,4}",
      media: "visual",
      inherited: false,
      animationType: "byComputedValueType",
      percentages: "no",
      groups: [
        "CSS Backgrounds and Borders"
      ],
      initial: "0",
      appliesto: "allElementsExceptTableElementsWhenCollapse",
      computed: "asSpecifiedRelativeToAbsoluteLengths",
      order: "uniqueOrder",
      alsoAppliesTo: [
        "::first-letter"
      ],
      status: "standard",
      mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-image-outset"
    },
    "border-image-repeat": {
      syntax: "[ stretch | repeat | round | space ]{1,2}",
      media: "visual",
      inherited: false,
      animationType: "discrete",
      percentages: "no",
      groups: [
        "CSS Backgrounds and Borders"
      ],
      initial: "stretch",
      appliesto: "allElementsExceptTableElementsWhenCollapse",
      computed: "asSpecified",
      order: "uniqueOrder",
      alsoAppliesTo: [
        "::first-letter"
      ],
      status: "standard",
      mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-image-repeat"
    },
    "border-image-slice": {
      syntax: "<number-percentage>{1,4} && fill?",
      media: "visual",
      inherited: false,
      animationType: "byComputedValueType",
      percentages: "referToSizeOfBorderImage",
      groups: [
        "CSS Backgrounds and Borders"
      ],
      initial: "100%",
      appliesto: "allElementsExceptTableElementsWhenCollapse",
      computed: "oneToFourPercentagesOrAbsoluteLengthsPlusFill",
      order: "percentagesOrLengthsFollowedByFill",
      alsoAppliesTo: [
        "::first-letter"
      ],
      status: "standard",
      mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-image-slice"
    },
    "border-image-source": {
      syntax: "none | <image>",
      media: "visual",
      inherited: false,
      animationType: "discrete",
      percentages: "no",
      groups: [
        "CSS Backgrounds and Borders"
      ],
      initial: "none",
      appliesto: "allElementsExceptTableElementsWhenCollapse",
      computed: "noneOrImageWithAbsoluteURI",
      order: "uniqueOrder",
      alsoAppliesTo: [
        "::first-letter"
      ],
      status: "standard",
      mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-image-source"
    },
    "border-image-width": {
      syntax: "[ <length-percentage> | <number> | auto ]{1,4}",
      media: "visual",
      inherited: false,
      animationType: "byComputedValueType",
      percentages: "referToWidthOrHeightOfBorderImageArea",
      groups: [
        "CSS Backgrounds and Borders"
      ],
      initial: "1",
      appliesto: "allElementsExceptTableElementsWhenCollapse",
      computed: "asSpecifiedRelativeToAbsoluteLengths",
      order: "uniqueOrder",
      alsoAppliesTo: [
        "::first-letter"
      ],
      status: "standard",
      mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-image-width"
    },
    "border-inline": {
      syntax: "<'border-top-width'> || <'border-top-style'> || <color>",
      media: "visual",
      inherited: false,
      animationType: "discrete",
      percentages: "no",
      groups: [
        "CSS Logical Properties"
      ],
      initial: [
        "border-top-width",
        "border-top-style",
        "border-top-color"
      ],
      appliesto: "allElements",
      computed: [
        "border-top-width",
        "border-top-style",
        "border-top-color"
      ],
      order: "uniqueOrder",
      status: "standard",
      mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-inline"
    },
    "border-inline-end": {
      syntax: "<'border-top-width'> || <'border-top-style'> || <color>",
      media: "visual",
      inherited: false,
      animationType: [
        "border-inline-end-color",
        "border-inline-end-style",
        "border-inline-end-width"
      ],
      percentages: "no",
      groups: [
        "CSS Logical Properties"
      ],
      initial: [
        "border-width",
        "border-style",
        "color"
      ],
      appliesto: "allElements",
      computed: [
        "border-width",
        "border-style",
        "border-inline-end-color"
      ],
      order: "uniqueOrder",
      status: "standard",
      mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-inline-end"
    },
    "border-inline-color": {
      syntax: "<'border-top-color'>{1,2}",
      media: "visual",
      inherited: false,
      animationType: "discrete",
      percentages: "no",
      groups: [
        "CSS Logical Properties"
      ],
      initial: "currentcolor",
      appliesto: "allElements",
      computed: "computedColor",
      order: "uniqueOrder",
      status: "standard",
      mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-inline-color"
    },
    "border-inline-style": {
      syntax: "<'border-top-style'>",
      media: "visual",
      inherited: false,
      animationType: "discrete",
      percentages: "no",
      groups: [
        "CSS Logical Properties"
      ],
      initial: "none",
      appliesto: "allElements",
      computed: "asSpecified",
      order: "uniqueOrder",
      status: "standard",
      mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-inline-style"
    },
    "border-inline-width": {
      syntax: "<'border-top-width'>",
      media: "visual",
      inherited: false,
      animationType: "discrete",
      percentages: "logicalWidthOfContainingBlock",
      groups: [
        "CSS Logical Properties"
      ],
      initial: "medium",
      appliesto: "allElements",
      computed: "absoluteLengthZeroIfBorderStyleNoneOrHidden",
      order: "uniqueOrder",
      status: "standard",
      mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-inline-width"
    },
    "border-inline-end-color": {
      syntax: "<'border-top-color'>",
      media: "visual",
      inherited: false,
      animationType: "color",
      percentages: "no",
      groups: [
        "CSS Logical Properties"
      ],
      initial: "currentcolor",
      appliesto: "allElements",
      computed: "computedColor",
      order: "uniqueOrder",
      status: "standard",
      mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-inline-end-color"
    },
    "border-inline-end-style": {
      syntax: "<'border-top-style'>",
      media: "visual",
      inherited: false,
      animationType: "discrete",
      percentages: "no",
      groups: [
        "CSS Logical Properties"
      ],
      initial: "none",
      appliesto: "allElements",
      computed: "asSpecified",
      order: "uniqueOrder",
      status: "standard",
      mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-inline-end-style"
    },
    "border-inline-end-width": {
      syntax: "<'border-top-width'>",
      media: "visual",
      inherited: false,
      animationType: "length",
      percentages: "logicalWidthOfContainingBlock",
      groups: [
        "CSS Logical Properties"
      ],
      initial: "medium",
      appliesto: "allElements",
      computed: "absoluteLengthZeroIfBorderStyleNoneOrHidden",
      order: "uniqueOrder",
      status: "standard",
      mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-inline-end-width"
    },
    "border-inline-start": {
      syntax: "<'border-top-width'> || <'border-top-style'> || <color>",
      media: "visual",
      inherited: false,
      animationType: [
        "border-inline-start-color",
        "border-inline-start-style",
        "border-inline-start-width"
      ],
      percentages: "no",
      groups: [
        "CSS Logical Properties"
      ],
      initial: [
        "border-width",
        "border-style",
        "color"
      ],
      appliesto: "allElements",
      computed: [
        "border-width",
        "border-style",
        "border-inline-start-color"
      ],
      order: "uniqueOrder",
      status: "standard",
      mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-inline-start"
    },
    "border-inline-start-color": {
      syntax: "<'border-top-color'>",
      media: "visual",
      inherited: false,
      animationType: "color",
      percentages: "no",
      groups: [
        "CSS Logical Properties"
      ],
      initial: "currentcolor",
      appliesto: "allElements",
      computed: "computedColor",
      order: "uniqueOrder",
      status: "standard",
      mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-inline-start-color"
    },
    "border-inline-start-style": {
      syntax: "<'border-top-style'>",
      media: "visual",
      inherited: false,
      animationType: "discrete",
      percentages: "no",
      groups: [
        "CSS Logical Properties"
      ],
      initial: "none",
      appliesto: "allElements",
      computed: "asSpecified",
      order: "uniqueOrder",
      status: "standard",
      mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-inline-start-style"
    },
    "border-inline-start-width": {
      syntax: "<'border-top-width'>",
      media: "visual",
      inherited: false,
      animationType: "length",
      percentages: "logicalWidthOfContainingBlock",
      groups: [
        "CSS Logical Properties"
      ],
      initial: "medium",
      appliesto: "allElements",
      computed: "absoluteLengthZeroIfBorderStyleNoneOrHidden",
      order: "uniqueOrder",
      status: "standard",
      mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-inline-start-width"
    },
    "border-left": {
      syntax: "<line-width> || <line-style> || <color>",
      media: "visual",
      inherited: false,
      animationType: [
        "border-left-color",
        "border-left-style",
        "border-left-width"
      ],
      percentages: "no",
      groups: [
        "CSS Backgrounds and Borders"
      ],
      initial: [
        "border-left-width",
        "border-left-style",
        "border-left-color"
      ],
      appliesto: "allElements",
      computed: [
        "border-left-width",
        "border-left-style",
        "border-left-color"
      ],
      order: "orderOfAppearance",
      alsoAppliesTo: [
        "::first-letter"
      ],
      status: "standard",
      mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-left"
    },
    "border-left-color": {
      syntax: "<color>",
      media: "visual",
      inherited: false,
      animationType: "color",
      percentages: "no",
      groups: [
        "CSS Backgrounds and Borders"
      ],
      initial: "currentcolor",
      appliesto: "allElements",
      computed: "computedColor",
      order: "uniqueOrder",
      alsoAppliesTo: [
        "::first-letter"
      ],
      status: "standard",
      mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-left-color"
    },
    "border-left-style": {
      syntax: "<line-style>",
      media: "visual",
      inherited: false,
      animationType: "discrete",
      percentages: "no",
      groups: [
        "CSS Backgrounds and Borders"
      ],
      initial: "none",
      appliesto: "allElements",
      computed: "asSpecified",
      order: "uniqueOrder",
      alsoAppliesTo: [
        "::first-letter"
      ],
      status: "standard",
      mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-left-style"
    },
    "border-left-width": {
      syntax: "<line-width>",
      media: "visual",
      inherited: false,
      animationType: "length",
      percentages: "no",
      groups: [
        "CSS Backgrounds and Borders"
      ],
      initial: "medium",
      appliesto: "allElements",
      computed: "absoluteLengthOr0IfBorderLeftStyleNoneOrHidden",
      order: "uniqueOrder",
      alsoAppliesTo: [
        "::first-letter"
      ],
      status: "standard",
      mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-left-width"
    },
    "border-radius": {
      syntax: "<length-percentage>{1,4} [ / <length-percentage>{1,4} ]?",
      media: "visual",
      inherited: false,
      animationType: [
        "border-top-left-radius",
        "border-top-right-radius",
        "border-bottom-right-radius",
        "border-bottom-left-radius"
      ],
      percentages: "referToDimensionOfBorderBox",
      groups: [
        "CSS Backgrounds and Borders"
      ],
      initial: [
        "border-top-left-radius",
        "border-top-right-radius",
        "border-bottom-right-radius",
        "border-bottom-left-radius"
      ],
      appliesto: "allElementsUAsNotRequiredWhenCollapse",
      computed: [
        "border-bottom-left-radius",
        "border-bottom-right-radius",
        "border-top-left-radius",
        "border-top-right-radius"
      ],
      order: "uniqueOrder",
      alsoAppliesTo: [
        "::first-letter"
      ],
      status: "standard",
      mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-radius"
    },
    "border-right": {
      syntax: "<line-width> || <line-style> || <color>",
      media: "visual",
      inherited: false,
      animationType: [
        "border-right-color",
        "border-right-style",
        "border-right-width"
      ],
      percentages: "no",
      groups: [
        "CSS Backgrounds and Borders"
      ],
      initial: [
        "border-right-width",
        "border-right-style",
        "border-right-color"
      ],
      appliesto: "allElements",
      computed: [
        "border-right-width",
        "border-right-style",
        "border-right-color"
      ],
      order: "orderOfAppearance",
      alsoAppliesTo: [
        "::first-letter"
      ],
      status: "standard",
      mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-right"
    },
    "border-right-color": {
      syntax: "<color>",
      media: "visual",
      inherited: false,
      animationType: "color",
      percentages: "no",
      groups: [
        "CSS Backgrounds and Borders"
      ],
      initial: "currentcolor",
      appliesto: "allElements",
      computed: "computedColor",
      order: "uniqueOrder",
      alsoAppliesTo: [
        "::first-letter"
      ],
      status: "standard",
      mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-right-color"
    },
    "border-right-style": {
      syntax: "<line-style>",
      media: "visual",
      inherited: false,
      animationType: "discrete",
      percentages: "no",
      groups: [
        "CSS Backgrounds and Borders"
      ],
      initial: "none",
      appliesto: "allElements",
      computed: "asSpecified",
      order: "uniqueOrder",
      alsoAppliesTo: [
        "::first-letter"
      ],
      status: "standard",
      mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-right-style"
    },
    "border-right-width": {
      syntax: "<line-width>",
      media: "visual",
      inherited: false,
      animationType: "length",
      percentages: "no",
      groups: [
        "CSS Backgrounds and Borders"
      ],
      initial: "medium",
      appliesto: "allElements",
      computed: "absoluteLengthOr0IfBorderRightStyleNoneOrHidden",
      order: "uniqueOrder",
      alsoAppliesTo: [
        "::first-letter"
      ],
      status: "standard",
      mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-right-width"
    },
    "border-spacing": {
      syntax: "<length> <length>?",
      media: "visual",
      inherited: true,
      animationType: "discrete",
      percentages: "no",
      groups: [
        "CSS Table"
      ],
      initial: "0",
      appliesto: "tableElements",
      computed: "twoAbsoluteLengths",
      order: "uniqueOrder",
      status: "standard",
      mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-spacing"
    },
    "border-start-end-radius": {
      syntax: "<length-percentage>{1,2}",
      media: "visual",
      inherited: false,
      animationType: "lpc",
      percentages: "referToDimensionOfBorderBox",
      groups: [
        "CSS Logical Properties"
      ],
      initial: "0",
      appliesto: "allElementsUAsNotRequiredWhenCollapse",
      computed: "twoAbsoluteLengthOrPercentages",
      order: "uniqueOrder",
      alsoAppliesTo: [
        "::first-letter"
      ],
      status: "standard",
      mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-start-end-radius"
    },
    "border-start-start-radius": {
      syntax: "<length-percentage>{1,2}",
      media: "visual",
      inherited: false,
      animationType: "lpc",
      percentages: "referToDimensionOfBorderBox",
      groups: [
        "CSS Logical Properties"
      ],
      initial: "0",
      appliesto: "allElementsUAsNotRequiredWhenCollapse",
      computed: "twoAbsoluteLengthOrPercentages",
      order: "uniqueOrder",
      alsoAppliesTo: [
        "::first-letter"
      ],
      status: "standard",
      mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-start-start-radius"
    },
    "border-style": {
      syntax: "<line-style>{1,4}",
      media: "visual",
      inherited: false,
      animationType: "discrete",
      percentages: "no",
      groups: [
        "CSS Backgrounds and Borders"
      ],
      initial: [
        "border-top-style",
        "border-right-style",
        "border-bottom-style",
        "border-left-style"
      ],
      appliesto: "allElements",
      computed: [
        "border-bottom-style",
        "border-left-style",
        "border-right-style",
        "border-top-style"
      ],
      order: "uniqueOrder",
      alsoAppliesTo: [
        "::first-letter"
      ],
      status: "standard",
      mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-style"
    },
    "border-top": {
      syntax: "<line-width> || <line-style> || <color>",
      media: "visual",
      inherited: false,
      animationType: [
        "border-top-color",
        "border-top-style",
        "border-top-width"
      ],
      percentages: "no",
      groups: [
        "CSS Backgrounds and Borders"
      ],
      initial: [
        "border-top-width",
        "border-top-style",
        "border-top-color"
      ],
      appliesto: "allElements",
      computed: [
        "border-top-width",
        "border-top-style",
        "border-top-color"
      ],
      order: "orderOfAppearance",
      alsoAppliesTo: [
        "::first-letter"
      ],
      status: "standard",
      mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-top"
    },
    "border-top-color": {
      syntax: "<color>",
      media: "visual",
      inherited: false,
      animationType: "color",
      percentages: "no",
      groups: [
        "CSS Backgrounds and Borders"
      ],
      initial: "currentcolor",
      appliesto: "allElements",
      computed: "computedColor",
      order: "uniqueOrder",
      alsoAppliesTo: [
        "::first-letter"
      ],
      status: "standard",
      mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-top-color"
    },
    "border-top-left-radius": {
      syntax: "<length-percentage>{1,2}",
      media: "visual",
      inherited: false,
      animationType: "lpc",
      percentages: "referToDimensionOfBorderBox",
      groups: [
        "CSS Backgrounds and Borders"
      ],
      initial: "0",
      appliesto: "allElementsUAsNotRequiredWhenCollapse",
      computed: "twoAbsoluteLengthOrPercentages",
      order: "uniqueOrder",
      alsoAppliesTo: [
        "::first-letter"
      ],
      status: "standard",
      mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-top-left-radius"
    },
    "border-top-right-radius": {
      syntax: "<length-percentage>{1,2}",
      media: "visual",
      inherited: false,
      animationType: "lpc",
      percentages: "referToDimensionOfBorderBox",
      groups: [
        "CSS Backgrounds and Borders"
      ],
      initial: "0",
      appliesto: "allElementsUAsNotRequiredWhenCollapse",
      computed: "twoAbsoluteLengthOrPercentages",
      order: "uniqueOrder",
      alsoAppliesTo: [
        "::first-letter"
      ],
      status: "standard",
      mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-top-right-radius"
    },
    "border-top-style": {
      syntax: "<line-style>",
      media: "visual",
      inherited: false,
      animationType: "discrete",
      percentages: "no",
      groups: [
        "CSS Backgrounds and Borders"
      ],
      initial: "none",
      appliesto: "allElements",
      computed: "asSpecified",
      order: "uniqueOrder",
      alsoAppliesTo: [
        "::first-letter"
      ],
      status: "standard",
      mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-top-style"
    },
    "border-top-width": {
      syntax: "<line-width>",
      media: "visual",
      inherited: false,
      animationType: "length",
      percentages: "no",
      groups: [
        "CSS Backgrounds and Borders"
      ],
      initial: "medium",
      appliesto: "allElements",
      computed: "absoluteLengthOr0IfBorderTopStyleNoneOrHidden",
      order: "uniqueOrder",
      alsoAppliesTo: [
        "::first-letter"
      ],
      status: "standard",
      mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-top-width"
    },
    "border-width": {
      syntax: "<line-width>{1,4}",
      media: "visual",
      inherited: false,
      animationType: [
        "border-bottom-width",
        "border-left-width",
        "border-right-width",
        "border-top-width"
      ],
      percentages: "no",
      groups: [
        "CSS Backgrounds and Borders"
      ],
      initial: [
        "border-top-width",
        "border-right-width",
        "border-bottom-width",
        "border-left-width"
      ],
      appliesto: "allElements",
      computed: [
        "border-bottom-width",
        "border-left-width",
        "border-right-width",
        "border-top-width"
      ],
      order: "uniqueOrder",
      alsoAppliesTo: [
        "::first-letter"
      ],
      status: "standard",
      mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-width"
    },
    bottom: {
      syntax: "<length> | <percentage> | auto",
      media: "visual",
      inherited: false,
      animationType: "lpc",
      percentages: "referToContainingBlockHeight",
      groups: [
        "CSS Positioning"
      ],
      initial: "auto",
      appliesto: "positionedElements",
      computed: "lengthAbsolutePercentageAsSpecifiedOtherwiseAuto",
      order: "uniqueOrder",
      status: "standard",
      mdn_url: "https://developer.mozilla.org/docs/Web/CSS/bottom"
    },
    "box-align": {
      syntax: "start | center | end | baseline | stretch",
      media: "visual",
      inherited: false,
      animationType: "discrete",
      percentages: "no",
      groups: [
        "Mozilla Extensions",
        "WebKit Extensions"
      ],
      initial: "stretch",
      appliesto: "elementsWithDisplayBoxOrInlineBox",
      computed: "asSpecified",
      order: "uniqueOrder",
      status: "nonstandard",
      mdn_url: "https://developer.mozilla.org/docs/Web/CSS/box-align"
    },
    "box-decoration-break": {
      syntax: "slice | clone",
      media: "visual",
      inherited: false,
      animationType: "discrete",
      percentages: "no",
      groups: [
        "CSS Fragmentation"
      ],
      initial: "slice",
      appliesto: "allElements",
      computed: "asSpecified",
      order: "uniqueOrder",
      status: "standard",
      mdn_url: "https://developer.mozilla.org/docs/Web/CSS/box-decoration-break"
    },
    "box-direction": {
      syntax: "normal | reverse | inherit",
      media: "visual",
      inherited: false,
      animationType: "discrete",
      percentages: "no",
      groups: [
        "Mozilla Extensions",
        "WebKit Extensions"
      ],
      initial: "normal",
      appliesto: "elementsWithDisplayBoxOrInlineBox",
      computed: "asSpecified",
      order: "uniqueOrder",
      status: "nonstandard",
      mdn_url: "https://developer.mozilla.org/docs/Web/CSS/box-direction"
    },
    "box-flex": {
      syntax: "<number>",
      media: "visual",
      inherited: false,
      animationType: "discrete",
      percentages: "no",
      groups: [
        "Mozilla Extensions",
        "WebKit Extensions"
      ],
      initial: "0",
      appliesto: "directChildrenOfElementsWithDisplayMozBoxMozInlineBox",
      computed: "asSpecified",
      order: "uniqueOrder",
      status: "nonstandard",
      mdn_url: "https://developer.mozilla.org/docs/Web/CSS/box-flex"
    },
    "box-flex-group": {
      syntax: "<integer>",
      media: "visual",
      inherited: false,
      animationType: "discrete",
      percentages: "no",
      groups: [
        "Mozilla Extensions",
        "WebKit Extensions"
      ],
      initial: "1",
      appliesto: "inFlowChildrenOfBoxElements",
      computed: "asSpecified",
      order: "uniqueOrder",
      status: "nonstandard",
      mdn_url: "https://developer.mozilla.org/docs/Web/CSS/box-flex-group"
    },
    "box-lines": {
      syntax: "single | multiple",
      media: "visual",
      inherited: false,
      animationType: "discrete",
      percentages: "no",
      groups: [
        "Mozilla Extensions",
        "WebKit Extensions"
      ],
      initial: "single",
      appliesto: "boxElements",
      computed: "asSpecified",
      order: "uniqueOrder",
      status: "nonstandard",
      mdn_url: "https://developer.mozilla.org/docs/Web/CSS/box-lines"
    },
    "box-ordinal-group": {
      syntax: "<integer>",
      media: "visual",
      inherited: false,
      animationType: "discrete",
      percentages: "no",
      groups: [
        "Mozilla Extensions",
        "WebKit Extensions"
      ],
      initial: "1",
      appliesto: "childrenOfBoxElements",
      computed: "asSpecified",
      order: "uniqueOrder",
      status: "nonstandard",
      mdn_url: "https://developer.mozilla.org/docs/Web/CSS/box-ordinal-group"
    },
    "box-orient": {
      syntax: "horizontal | vertical | inline-axis | block-axis | inherit",
      media: "visual",
      inherited: false,
      animationType: "discrete",
      percentages: "no",
      groups: [
        "Mozilla Extensions",
        "WebKit Extensions"
      ],
      initial: "inlineAxisHorizontalInXUL",
      appliesto: "elementsWithDisplayBoxOrInlineBox",
      computed: "asSpecified",
      order: "uniqueOrder",
      status: "nonstandard",
      mdn_url: "https://developer.mozilla.org/docs/Web/CSS/box-orient"
    },
    "box-pack": {
      syntax: "start | center | end | justify",
      media: "visual",
      inherited: false,
      animationType: "discrete",
      percentages: "no",
      groups: [
        "Mozilla Extensions",
        "WebKit Extensions"
      ],
      initial: "start",
      appliesto: "elementsWithDisplayMozBoxMozInlineBox",
      computed: "asSpecified",
      order: "uniqueOrder",
      status: "nonstandard",
      mdn_url: "https://developer.mozilla.org/docs/Web/CSS/box-pack"
    },
    "box-shadow": {
      syntax: "none | <shadow>#",
      media: "visual",
      inherited: false,
      animationType: "shadowList",
      percentages: "no",
      groups: [
        "CSS Backgrounds and Borders"
      ],
      initial: "none",
      appliesto: "allElements",
      computed: "absoluteLengthsSpecifiedColorAsSpecified",
      order: "uniqueOrder",
      alsoAppliesTo: [
        "::first-letter"
      ],
      status: "standard",
      mdn_url: "https://developer.mozilla.org/docs/Web/CSS/box-shadow"
    },
    "box-sizing": {
      syntax: "content-box | border-box",
      media: "visual",
      inherited: false,
      animationType: "discrete",
      percentages: "no",
      groups: [
        "CSS Box Model"
      ],
      initial: "content-box",
      appliesto: "allElementsAcceptingWidthOrHeight",
      computed: "asSpecified",
      order: "uniqueOrder",
      status: "standard",
      mdn_url: "https://developer.mozilla.org/docs/Web/CSS/box-sizing"
    },
    "break-after": {
      syntax: "auto | avoid | always | all | avoid-page | page | left | right | recto | verso | avoid-column | column | avoid-region | region",
      media: "visual",
      inherited: false,
      animationType: "discrete",
      percentages: "no",
      groups: [
        "CSS Fragmentation"
      ],
      initial: "auto",
      appliesto: "blockLevelElements",
      computed: "asSpecified",
      order: "uniqueOrder",
      status: "standard",
      mdn_url: "https://developer.mozilla.org/docs/Web/CSS/break-after"
    },
    "break-before": {
      syntax: "auto | avoid | always | all | avoid-page | page | left | right | recto | verso | avoid-column | column | avoid-region | region",
      media: "visual",
      inherited: false,
      animationType: "discrete",
      percentages: "no",
      groups: [
        "CSS Fragmentation"
      ],
      initial: "auto",
      appliesto: "blockLevelElements",
      computed: "asSpecified",
      order: "uniqueOrder",
      status: "standard",
      mdn_url: "https://developer.mozilla.org/docs/Web/CSS/break-before"
    },
    "break-inside": {
      syntax: "auto | avoid | avoid-page | avoid-column | avoid-region",
      media: "visual",
      inherited: false,
      animationType: "discrete",
      percentages: "no",
      groups: [
        "CSS Fragmentation"
      ],
      initial: "auto",
      appliesto: "blockLevelElements",
      computed: "asSpecified",
      order: "uniqueOrder",
      status: "standard",
      mdn_url: "https://developer.mozilla.org/docs/Web/CSS/break-inside"
    },
    "caption-side": {
      syntax: "top | bottom | block-start | block-end | inline-start | inline-end",
      media: "visual",
      inherited: true,
      animationType: "discrete",
      percentages: "no",
      groups: [
        "CSS Table"
      ],
      initial: "top",
      appliesto: "tableCaptionElements",
      computed: "asSpecified",
      order: "uniqueOrder",
      status: "standard",
      mdn_url: "https://developer.mozilla.org/docs/Web/CSS/caption-side"
    },
    "caret-color": {
      syntax: "auto | <color>",
      media: "interactive",
      inherited: true,
      animationType: "color",
      percentages: "no",
      groups: [
        "CSS Basic User Interface"
      ],
      initial: "auto",
      appliesto: "allElements",
      computed: "asAutoOrColor",
      order: "perGrammar",
      status: "standard",
      mdn_url: "https://developer.mozilla.org/docs/Web/CSS/caret-color"
    },
    clear: {
      syntax: "none | left | right | both | inline-start | inline-end",
      media: "visual",
      inherited: false,
      animationType: "discrete",
      percentages: "no",
      groups: [
        "CSS Positioning"
      ],
      initial: "none",
      appliesto: "blockLevelElements",
      computed: "asSpecified",
      order: "uniqueOrder",
      status: "standard",
      mdn_url: "https://developer.mozilla.org/docs/Web/CSS/clear"
    },
    clip: {
      syntax: "<shape> | auto",
      media: "visual",
      inherited: false,
      animationType: "rectangle",
      percentages: "no",
      groups: [
        "CSS Masking"
      ],
      initial: "auto",
      appliesto: "absolutelyPositionedElements",
      computed: "autoOrRectangle",
      order: "uniqueOrder",
      status: "standard",
      mdn_url: "https://developer.mozilla.org/docs/Web/CSS/clip"
    },
    "clip-path": {
      syntax: "<clip-source> | [ <basic-shape> || <geometry-box> ] | none",
      media: "visual",
      inherited: false,
      animationType: "basicShapeOtherwiseNo",
      percentages: "referToReferenceBoxWhenSpecifiedOtherwiseBorderBox",
      groups: [
        "CSS Masking"
      ],
      initial: "none",
      appliesto: "allElementsSVGContainerElements",
      computed: "asSpecifiedURLsAbsolute",
      order: "uniqueOrder",
      status: "standard",
      mdn_url: "https://developer.mozilla.org/docs/Web/CSS/clip-path"
    },
    color: {
      syntax: "<color>",
      media: "visual",
      inherited: true,
      animationType: "byComputedValueType",
      percentages: "no",
      groups: [
        "CSS Color"
      ],
      initial: "canvastext",
      appliesto: "allElementsAndText",
      computed: "computedColor",
      order: "perGrammar",
      alsoAppliesTo: [
        "::first-letter",
        "::first-line",
        "::placeholder"
      ],
      status: "standard",
      mdn_url: "https://developer.mozilla.org/docs/Web/CSS/color"
    },
    "print-color-adjust": {
      syntax: "economy | exact",
      media: "visual",
      inherited: true,
      animationType: "discrete",
      percentages: "no",
      groups: [
        "CSS Color"
      ],
      initial: "economy",
      appliesto: "allElements",
      computed: "asSpecified",
      order: "perGrammar",
      status: "standard",
      mdn_url: "https://developer.mozilla.org/docs/Web/CSS/print-color-adjust"
    },
    "color-scheme": {
      syntax: "normal | [ light | dark | <custom-ident> ]+ && only?",
      media: "visual",
      inherited: true,
      animationType: "discrete",
      percentages: "no",
      groups: [
        "CSS Color"
      ],
      initial: "normal",
      appliesto: "allElementsAndText",
      computed: "asSpecified",
      order: "perGrammar",
      status: "standard",
      mdn_url: "https://developer.mozilla.org/docs/Web/CSS/color-scheme"
    },
    "column-count": {
      syntax: "<integer> | auto",
      media: "visual",
      inherited: false,
      animationType: "integer",
      percentages: "no",
      groups: [
        "CSS Columns"
      ],
      initial: "auto",
      appliesto: "blockContainersExceptTableWrappers",
      computed: "asSpecified",
      order: "perGrammar",
      status: "standard",
      mdn_url: "https://developer.mozilla.org/docs/Web/CSS/column-count"
    },
    "column-fill": {
      syntax: "auto | balance | balance-all",
      media: "visualInContinuousMediaNoEffectInOverflowColumns",
      inherited: false,
      animationType: "discrete",
      percentages: "no",
      groups: [
        "CSS Columns"
      ],
      initial: "balance",
      appliesto: "multicolElements",
      computed: "asSpecified",
      order: "perGrammar",
      status: "standard",
      mdn_url: "https://developer.mozilla.org/docs/Web/CSS/column-fill"
    },
    "column-gap": {
      syntax: "normal | <length-percentage>",
      media: "visual",
      inherited: false,
      animationType: "lpc",
      percentages: "referToDimensionOfContentArea",
      groups: [
        "CSS Box Alignment"
      ],
      initial: "normal",
      appliesto: "multiColumnElementsFlexContainersGridContainers",
      computed: "asSpecifiedWithLengthsAbsoluteAndNormalComputingToZeroExceptMultiColumn",
      order: "perGrammar",
      status: "standard",
      mdn_url: "https://developer.mozilla.org/docs/Web/CSS/column-gap"
    },
    "column-rule": {
      syntax: "<'column-rule-width'> || <'column-rule-style'> || <'column-rule-color'>",
      media: "visual",
      inherited: false,
      animationType: [
        "column-rule-color",
        "column-rule-style",
        "column-rule-width"
      ],
      percentages: "no",
      groups: [
        "CSS Columns"
      ],
      initial: [
        "column-rule-width",
        "column-rule-style",
        "column-rule-color"
      ],
      appliesto: "multicolElements",
      computed: [
        "column-rule-color",
        "column-rule-style",
        "column-rule-width"
      ],
      order: "perGrammar",
      status: "standard",
      mdn_url: "https://developer.mozilla.org/docs/Web/CSS/column-rule"
    },
    "column-rule-color": {
      syntax: "<color>",
      media: "visual",
      inherited: false,
      animationType: "color",
      percentages: "no",
      groups: [
        "CSS Columns"
      ],
      initial: "currentcolor",
      appliesto: "multicolElements",
      computed: "computedColor",
      order: "perGrammar",
      status: "standard",
      mdn_url: "https://developer.mozilla.org/docs/Web/CSS/column-rule-color"
    },
    "column-rule-style": {
      syntax: "<'border-style'>",
      media: "visual",
      inherited: false,
      animationType: "discrete",
      percentages: "no",
      groups: [
        "CSS Columns"
      ],
      initial: "none",
      appliesto: "multicolElements",
      computed: "asSpecified",
      order: "perGrammar",
      status: "standard",
      mdn_url: "https://developer.mozilla.org/docs/Web/CSS/column-rule-style"
    },
    "column-rule-width": {
      syntax: "<'border-width'>",
      media: "visual",
      inherited: false,
      animationType: "length",
      percentages: "no",
      groups: [
        "CSS Columns"
      ],
      initial: "medium",
      appliesto: "multicolElements",
      computed: "absoluteLength0IfColumnRuleStyleNoneOrHidden",
      order: "perGrammar",
      status: "standard",
      mdn_url: "https://developer.mozilla.org/docs/Web/CSS/column-rule-width"
    },
    "column-span": {
      syntax: "none | all",
      media: "visual",
      inherited: false,
      animationType: "discrete",
      percentages: "no",
      groups: [
        "CSS Columns"
      ],
      initial: "none",
      appliesto: "inFlowBlockLevelElements",
      computed: "asSpecified",
      order: "perGrammar",
      status: "standard",
      mdn_url: "https://developer.mozilla.org/docs/Web/CSS/column-span"
    },
    "column-width": {
      syntax: "<length> | auto",
      media: "visual",
      inherited: false,
      animationType: "length",
      percentages: "no",
      groups: [
        "CSS Columns"
      ],
      initial: "auto",
      appliesto: "blockContainersExceptTableWrappers",
      computed: "absoluteLengthZeroOrLarger",
      order: "perGrammar",
      status: "standard",
      mdn_url: "https://developer.mozilla.org/docs/Web/CSS/column-width"
    },
    columns: {
      syntax: "<'column-width'> || <'column-count'>",
      media: "visual",
      inherited: false,
      animationType: [
        "column-width",
        "column-count"
      ],
      percentages: "no",
      groups: [
        "CSS Columns"
      ],
      initial: [
        "column-width",
        "column-count"
      ],
      appliesto: "blockContainersExceptTableWrappers",
      computed: [
        "column-width",
        "column-count"
      ],
      order: "perGrammar",
      status: "standard",
      mdn_url: "https://developer.mozilla.org/docs/Web/CSS/columns"
    },
    contain: {
      syntax: "none | strict | content | [ size || layout || style || paint ]",
      media: "all",
      inherited: false,
      animationType: "discrete",
      percentages: "no",
      groups: [
        "CSS Containment"
      ],
      initial: "none",
      appliesto: "allElements",
      computed: "asSpecified",
      order: "perGrammar",
      status: "standard",
      mdn_url: "https://developer.mozilla.org/docs/Web/CSS/contain"
    },
    content: {
      syntax: "normal | none | [ <content-replacement> | <content-list> ] [/ [ <string> | <counter> ]+ ]?",
      media: "all",
      inherited: false,
      animationType: "discrete",
      percentages: "no",
      groups: [
        "CSS Generated Content"
      ],
      initial: "normal",
      appliesto: "allElementsTreeAbidingPseudoElementsPageMarginBoxes",
      computed: "normalOnElementsForPseudosNoneAbsoluteURIStringOrAsSpecified",
      order: "uniqueOrder",
      status: "standard",
      mdn_url: "https://developer.mozilla.org/docs/Web/CSS/content"
    },
    "content-visibility": {
      syntax: "visible | auto | hidden",
      media: "all",
      inherited: false,
      animationType: "discrete",
      percentages: "no",
      groups: [
        "CSS Containment"
      ],
      initial: "visible",
      appliesto: "elementsForWhichLayoutContainmentCanApply",
      computed: "asSpecified",
      order: "perGrammar",
      status: "standard",
      mdn_url: "https://developer.mozilla.org/docs/Web/CSS/content-visibility"
    },
    "counter-increment": {
      syntax: "[ <counter-name> <integer>? ]+ | none",
      media: "all",
      inherited: false,
      animationType: "discrete",
      percentages: "no",
      groups: [
        "CSS Counter Styles"
      ],
      initial: "none",
      appliesto: "allElements",
      computed: "asSpecified",
      order: "uniqueOrder",
      status: "standard",
      mdn_url: "https://developer.mozilla.org/docs/Web/CSS/counter-increment"
    },
    "counter-reset": {
      syntax: "[ <counter-name> <integer>? | <reversed-counter-name> <integer>? ]+ | none",
      media: "all",
      inherited: false,
      animationType: "discrete",
      percentages: "no",
      groups: [
        "CSS Counter Styles"
      ],
      initial: "none",
      appliesto: "allElements",
      computed: "asSpecified",
      order: "uniqueOrder",
      status: "standard",
      mdn_url: "https://developer.mozilla.org/docs/Web/CSS/counter-reset"
    },
    "counter-set": {
      syntax: "[ <counter-name> <integer>? ]+ | none",
      media: "all",
      inherited: false,
      animationType: "discrete",
      percentages: "no",
      groups: [
        "CSS Counter Styles"
      ],
      initial: "none",
      appliesto: "allElements",
      computed: "asSpecified",
      order: "uniqueOrder",
      status: "standard",
      mdn_url: "https://developer.mozilla.org/docs/Web/CSS/counter-set"
    },
    cursor: {
      syntax: "[ [ <url> [ <x> <y> ]? , ]* [ auto | default | none | context-menu | help | pointer | progress | wait | cell | crosshair | text | vertical-text | alias | copy | move | no-drop | not-allowed | e-resize | n-resize | ne-resize | nw-resize | s-resize | se-resize | sw-resize | w-resize | ew-resize | ns-resize | nesw-resize | nwse-resize | col-resize | row-resize | all-scroll | zoom-in | zoom-out | grab | grabbing ] ]",
      media: [
        "visual",
        "interactive"
      ],
      inherited: true,
      animationType: "discrete",
      percentages: "no",
      groups: [
        "CSS Basic User Interface"
      ],
      initial: "auto",
      appliesto: "allElements",
      computed: "asSpecifiedURLsAbsolute",
      order: "uniqueOrder",
      status: "standard",
      mdn_url: "https://developer.mozilla.org/docs/Web/CSS/cursor"
    },
    direction: {
      syntax: "ltr | rtl",
      media: "visual",
      inherited: true,
      animationType: "discrete",
      percentages: "no",
      groups: [
        "CSS Writing Modes"
      ],
      initial: "ltr",
      appliesto: "allElements",
      computed: "asSpecified",
      order: "uniqueOrder",
      status: "standard",
      mdn_url: "https://developer.mozilla.org/docs/Web/CSS/direction"
    },
    display: {
      syntax: "[ <display-outside> || <display-inside> ] | <display-listitem> | <display-internal> | <display-box> | <display-legacy>",
      media: "all",
      inherited: false,
      animationType: "notAnimatable",
      percentages: "no",
      groups: [
        "CSS Display"
      ],
      initial: "inline",
      appliesto: "allElements",
      computed: "asSpecifiedExceptPositionedFloatingAndRootElementsKeywordMaybeDifferent",
      order: "uniqueOrder",
      status: "standard",
      mdn_url: "https://developer.mozilla.org/docs/Web/CSS/display"
    },
    "empty-cells": {
      syntax: "show | hide",
      media: "visual",
      inherited: true,
      animationType: "discrete",
      percentages: "no",
      groups: [
        "CSS Table"
      ],
      initial: "show",
      appliesto: "tableCellElements",
      computed: "asSpecified",
      order: "uniqueOrder",
      status: "standard",
      mdn_url: "https://developer.mozilla.org/docs/Web/CSS/empty-cells"
    },
    filter: {
      syntax: "none | <filter-function-list>",
      media: "visual",
      inherited: false,
      animationType: "filterList",
      percentages: "no",
      groups: [
        "Filter Effects"
      ],
      initial: "none",
      appliesto: "allElementsSVGContainerElements",
      computed: "asSpecified",
      order: "uniqueOrder",
      status: "standard",
      mdn_url: "https://developer.mozilla.org/docs/Web/CSS/filter"
    },
    flex: {
      syntax: "none | [ <'flex-grow'> <'flex-shrink'>? || <'flex-basis'> ]",
      media: "visual",
      inherited: false,
      animationType: [
        "flex-grow",
        "flex-shrink",
        "flex-basis"
      ],
      percentages: "no",
      groups: [
        "CSS Flexible Box Layout"
      ],
      initial: [
        "flex-grow",
        "flex-shrink",
        "flex-basis"
      ],
      appliesto: "flexItemsAndInFlowPseudos",
      computed: [
        "flex-grow",
        "flex-shrink",
        "flex-basis"
      ],
      order: "orderOfAppearance",
      status: "standard",
      mdn_url: "https://developer.mozilla.org/docs/Web/CSS/flex"
    },
    "flex-basis": {
      syntax: "content | <'width'>",
      media: "visual",
      inherited: false,
      animationType: "lpc",
      percentages: "referToFlexContainersInnerMainSize",
      groups: [
        "CSS Flexible Box Layout"
      ],
      initial: "auto",
      appliesto: "flexItemsAndInFlowPseudos",
      computed: "asSpecifiedRelativeToAbsoluteLengths",
      order: "lengthOrPercentageBeforeKeywordIfBothPresent",
      status: "standard",
      mdn_url: "https://developer.mozilla.org/docs/Web/CSS/flex-basis"
    },
    "flex-direction": {
      syntax: "row | row-reverse | column | column-reverse",
      media: "visual",
      inherited: false,
      animationType: "discrete",
      percentages: "no",
      groups: [
        "CSS Flexible Box Layout"
      ],
      initial: "row",
      appliesto: "flexContainers",
      computed: "asSpecified",
      order: "uniqueOrder",
      status: "standard",
      mdn_url: "https://developer.mozilla.org/docs/Web/CSS/flex-direction"
    },
    "flex-flow": {
      syntax: "<'flex-direction'> || <'flex-wrap'>",
      media: "visual",
      inherited: false,
      animationType: "discrete",
      percentages: "no",
      groups: [
        "CSS Flexible Box Layout"
      ],
      initial: [
        "flex-direction",
        "flex-wrap"
      ],
      appliesto: "flexContainers",
      computed: [
        "flex-direction",
        "flex-wrap"
      ],
      order: "orderOfAppearance",
      status: "standard",
      mdn_url: "https://developer.mozilla.org/docs/Web/CSS/flex-flow"
    },
    "flex-grow": {
      syntax: "<number>",
      media: "visual",
      inherited: false,
      animationType: "number",
      percentages: "no",
      groups: [
        "CSS Flexible Box Layout"
      ],
      initial: "0",
      appliesto: "flexItemsAndInFlowPseudos",
      computed: "asSpecified",
      order: "uniqueOrder",
      status: "standard",
      mdn_url: "https://developer.mozilla.org/docs/Web/CSS/flex-grow"
    },
    "flex-shrink": {
      syntax: "<number>",
      media: "visual",
      inherited: false,
      animationType: "number",
      percentages: "no",
      groups: [
        "CSS Flexible Box Layout"
      ],
      initial: "1",
      appliesto: "flexItemsAndInFlowPseudos",
      computed: "asSpecified",
      order: "uniqueOrder",
      status: "standard",
      mdn_url: "https://developer.mozilla.org/docs/Web/CSS/flex-shrink"
    },
    "flex-wrap": {
      syntax: "nowrap | wrap | wrap-reverse",
      media: "visual",
      inherited: false,
      animationType: "discrete",
      percentages: "no",
      groups: [
        "CSS Flexible Box Layout"
      ],
      initial: "nowrap",
      appliesto: "flexContainers",
      computed: "asSpecified",
      order: "uniqueOrder",
      status: "standard",
      mdn_url: "https://developer.mozilla.org/docs/Web/CSS/flex-wrap"
    },
    float: {
      syntax: "left | right | none | inline-start | inline-end",
      media: "visual",
      inherited: false,
      animationType: "discrete",
      percentages: "no",
      groups: [
        "CSS Positioning"
      ],
      initial: "none",
      appliesto: "allElementsNoEffectIfDisplayNone",
      computed: "asSpecified",
      order: "uniqueOrder",
      status: "standard",
      mdn_url: "https://developer.mozilla.org/docs/Web/CSS/float"
    },
    font: {
      syntax: "[ [ <'font-style'> || <font-variant-css21> || <'font-weight'> || <'font-stretch'> ]? <'font-size'> [ / <'line-height'> ]? <'font-family'> ] | caption | icon | menu | message-box | small-caption | status-bar",
      media: "visual",
      inherited: true,
      animationType: [
        "font-style",
        "font-variant",
        "font-weight",
        "font-stretch",
        "font-size",
        "line-height",
        "font-family"
      ],
      percentages: [
        "font-size",
        "line-height"
      ],
      groups: [
        "CSS Fonts"
      ],
      initial: [
        "font-style",
        "font-variant",
        "font-weight",
        "font-stretch",
        "font-size",
        "line-height",
        "font-family"
      ],
      appliesto: "allElements",
      computed: [
        "font-style",
        "font-variant",
        "font-weight",
        "font-stretch",
        "font-size",
        "line-height",
        "font-family"
      ],
      order: "orderOfAppearance",
      alsoAppliesTo: [
        "::first-letter",
        "::first-line",
        "::placeholder"
      ],
      status: "standard",
      mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font"
    },
    "font-family": {
      syntax: "[ <family-name> | <generic-family> ]#",
      media: "visual",
      inherited: true,
      animationType: "discrete",
      percentages: "no",
      groups: [
        "CSS Fonts"
      ],
      initial: "dependsOnUserAgent",
      appliesto: "allElements",
      computed: "asSpecified",
      order: "uniqueOrder",
      alsoAppliesTo: [
        "::first-letter",
        "::first-line",
        "::placeholder"
      ],
      status: "standard",
      mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-family"
    },
    "font-feature-settings": {
      syntax: "normal | <feature-tag-value>#",
      media: "visual",
      inherited: true,
      animationType: "discrete",
      percentages: "no",
      groups: [
        "CSS Fonts"
      ],
      initial: "normal",
      appliesto: "allElements",
      computed: "asSpecified",
      order: "uniqueOrder",
      alsoAppliesTo: [
        "::first-letter",
        "::first-line",
        "::placeholder"
      ],
      status: "standard",
      mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-feature-settings"
    },
    "font-kerning": {
      syntax: "auto | normal | none",
      media: "visual",
      inherited: true,
      animationType: "discrete",
      percentages: "no",
      groups: [
        "CSS Fonts"
      ],
      initial: "auto",
      appliesto: "allElements",
      computed: "asSpecified",
      order: "uniqueOrder",
      alsoAppliesTo: [
        "::first-letter",
        "::first-line",
        "::placeholder"
      ],
      status: "standard",
      mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-kerning"
    },
    "font-language-override": {
      syntax: "normal | <string>",
      media: "visual",
      inherited: true,
      animationType: "discrete",
      percentages: "no",
      groups: [
        "CSS Fonts"
      ],
      initial: "normal",
      appliesto: "allElements",
      computed: "asSpecified",
      order: "uniqueOrder",
      alsoAppliesTo: [
        "::first-letter",
        "::first-line",
        "::placeholder"
      ],
      status: "standard",
      mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-language-override"
    },
    "font-optical-sizing": {
      syntax: "auto | none",
      media: "visual",
      inherited: true,
      animationType: "discrete",
      percentages: "no",
      groups: [
        "CSS Fonts"
      ],
      initial: "auto",
      appliesto: "allElements",
      computed: "asSpecified",
      order: "perGrammar",
      alsoAppliesTo: [
        "::first-letter",
        "::first-line",
        "::placeholder"
      ],
      status: "standard",
      mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-optical-sizing"
    },
    "font-variation-settings": {
      syntax: "normal | [ <string> <number> ]#",
      media: "visual",
      inherited: true,
      animationType: "transform",
      percentages: "no",
      groups: [
        "CSS Fonts"
      ],
      initial: "normal",
      appliesto: "allElements",
      computed: "asSpecified",
      order: "perGrammar",
      alsoAppliesTo: [
        "::first-letter",
        "::first-line",
        "::placeholder"
      ],
      status: "standard",
      mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-variation-settings"
    },
    "font-size": {
      syntax: "<absolute-size> | <relative-size> | <length-percentage>",
      media: "visual",
      inherited: true,
      animationType: "length",
      percentages: "referToParentElementsFontSize",
      groups: [
        "CSS Fonts"
      ],
      initial: "medium",
      appliesto: "allElements",
      computed: "asSpecifiedRelativeToAbsoluteLengths",
      order: "uniqueOrder",
      alsoAppliesTo: [
        "::first-letter",
        "::first-line",
        "::placeholder"
      ],
      status: "standard",
      mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-size"
    },
    "font-size-adjust": {
      syntax: "none | [ ex-height | cap-height | ch-width | ic-width | ic-height ]? [ from-font | <number> ]",
      media: "visual",
      inherited: true,
      animationType: "number",
      percentages: "no",
      groups: [
        "CSS Fonts"
      ],
      initial: "none",
      appliesto: "allElements",
      computed: "asSpecified",
      order: "uniqueOrder",
      alsoAppliesTo: [
        "::first-letter",
        "::first-line",
        "::placeholder"
      ],
      status: "standard",
      mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-size-adjust"
    },
    "font-smooth": {
      syntax: "auto | never | always | <absolute-size> | <length>",
      media: "visual",
      inherited: true,
      animationType: "discrete",
      percentages: "no",
      groups: [
        "CSS Fonts"
      ],
      initial: "auto",
      appliesto: "allElements",
      computed: "asSpecified",
      order: "uniqueOrder",
      status: "nonstandard",
      mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-smooth"
    },
    "font-stretch": {
      syntax: "<font-stretch-absolute>",
      media: "visual",
      inherited: true,
      animationType: "fontStretch",
      percentages: "no",
      groups: [
        "CSS Fonts"
      ],
      initial: "normal",
      appliesto: "allElements",
      computed: "asSpecified",
      order: "uniqueOrder",
      alsoAppliesTo: [
        "::first-letter",
        "::first-line",
        "::placeholder"
      ],
      status: "standard",
      mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-stretch"
    },
    "font-style": {
      syntax: "normal | italic | oblique <angle>?",
      media: "visual",
      inherited: true,
      animationType: "discrete",
      percentages: "no",
      groups: [
        "CSS Fonts"
      ],
      initial: "normal",
      appliesto: "allElements",
      computed: "asSpecified",
      order: "uniqueOrder",
      alsoAppliesTo: [
        "::first-letter",
        "::first-line",
        "::placeholder"
      ],
      status: "standard",
      mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-style"
    },
    "font-synthesis": {
      syntax: "none | [ weight || style || small-caps ]",
      media: "visual",
      inherited: true,
      animationType: "discrete",
      percentages: "no",
      groups: [
        "CSS Fonts"
      ],
      initial: "weight style",
      appliesto: "allElements",
      computed: "asSpecified",
      order: "orderOfAppearance",
      alsoAppliesTo: [
        "::first-letter",
        "::first-line",
        "::placeholder"
      ],
      status: "standard",
      mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-synthesis"
    },
    "font-variant": {
      syntax: "normal | none | [ <common-lig-values> || <discretionary-lig-values> || <historical-lig-values> || <contextual-alt-values> || stylistic( <feature-value-name> ) || historical-forms || styleset( <feature-value-name># ) || character-variant( <feature-value-name># ) || swash( <feature-value-name> ) || ornaments( <feature-value-name> ) || annotation( <feature-value-name> ) || [ small-caps | all-small-caps | petite-caps | all-petite-caps | unicase | titling-caps ] || <numeric-figure-values> || <numeric-spacing-values> || <numeric-fraction-values> || ordinal || slashed-zero || <east-asian-variant-values> || <east-asian-width-values> || ruby ]",
      media: "visual",
      inherited: true,
      animationType: "discrete",
      percentages: "no",
      groups: [
        "CSS Fonts"
      ],
      initial: "normal",
      appliesto: "allElements",
      computed: "asSpecified",
      order: "uniqueOrder",
      alsoAppliesTo: [
        "::first-letter",
        "::first-line",
        "::placeholder"
      ],
      status: "standard",
      mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-variant"
    },
    "font-variant-alternates": {
      syntax: "normal | [ stylistic( <feature-value-name> ) || historical-forms || styleset( <feature-value-name># ) || character-variant( <feature-value-name># ) || swash( <feature-value-name> ) || ornaments( <feature-value-name> ) || annotation( <feature-value-name> ) ]",
      media: "visual",
      inherited: true,
      animationType: "discrete",
      percentages: "no",
      groups: [
        "CSS Fonts"
      ],
      initial: "normal",
      appliesto: "allElements",
      computed: "asSpecified",
      order: "orderOfAppearance",
      alsoAppliesTo: [
        "::first-letter",
        "::first-line",
        "::placeholder"
      ],
      status: "standard",
      mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-variant-alternates"
    },
    "font-variant-caps": {
      syntax: "normal | small-caps | all-small-caps | petite-caps | all-petite-caps | unicase | titling-caps",
      media: "visual",
      inherited: true,
      animationType: "discrete",
      percentages: "no",
      groups: [
        "CSS Fonts"
      ],
      initial: "normal",
      appliesto: "allElements",
      computed: "asSpecified",
      order: "uniqueOrder",
      alsoAppliesTo: [
        "::first-letter",
        "::first-line",
        "::placeholder"
      ],
      status: "standard",
      mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-variant-caps"
    },
    "font-variant-east-asian": {
      syntax: "normal | [ <east-asian-variant-values> || <east-asian-width-values> || ruby ]",
      media: "visual",
      inherited: true,
      animationType: "discrete",
      percentages: "no",
      groups: [
        "CSS Fonts"
      ],
      initial: "normal",
      appliesto: "allElements",
      computed: "asSpecified",
      order: "orderOfAppearance",
      alsoAppliesTo: [
        "::first-letter",
        "::first-line",
        "::placeholder"
      ],
      status: "standard",
      mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-variant-east-asian"
    },
    "font-variant-ligatures": {
      syntax: "normal | none | [ <common-lig-values> || <discretionary-lig-values> || <historical-lig-values> || <contextual-alt-values> ]",
      media: "visual",
      inherited: true,
      animationType: "discrete",
      percentages: "no",
      groups: [
        "CSS Fonts"
      ],
      initial: "normal",
      appliesto: "allElements",
      computed: "asSpecified",
      order: "orderOfAppearance",
      alsoAppliesTo: [
        "::first-letter",
        "::first-line",
        "::placeholder"
      ],
      status: "standard",
      mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-variant-ligatures"
    },
    "font-variant-numeric": {
      syntax: "normal | [ <numeric-figure-values> || <numeric-spacing-values> || <numeric-fraction-values> || ordinal || slashed-zero ]",
      media: "visual",
      inherited: true,
      animationType: "discrete",
      percentages: "no",
      groups: [
        "CSS Fonts"
      ],
      initial: "normal",
      appliesto: "allElements",
      computed: "asSpecified",
      order: "orderOfAppearance",
      alsoAppliesTo: [
        "::first-letter",
        "::first-line",
        "::placeholder"
      ],
      status: "standard",
      mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-variant-numeric"
    },
    "font-variant-position": {
      syntax: "normal | sub | super",
      media: "visual",
      inherited: true,
      animationType: "discrete",
      percentages: "no",
      groups: [
        "CSS Fonts"
      ],
      initial: "normal",
      appliesto: "allElements",
      computed: "asSpecified",
      order: "uniqueOrder",
      alsoAppliesTo: [
        "::first-letter",
        "::first-line",
        "::placeholder"
      ],
      status: "standard",
      mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-variant-position"
    },
    "font-weight": {
      syntax: "<font-weight-absolute> | bolder | lighter",
      media: "visual",
      inherited: true,
      animationType: "fontWeight",
      percentages: "no",
      groups: [
        "CSS Fonts"
      ],
      initial: "normal",
      appliesto: "allElements",
      computed: "keywordOrNumericalValueBolderLighterTransformedToRealValue",
      order: "uniqueOrder",
      alsoAppliesTo: [
        "::first-letter",
        "::first-line",
        "::placeholder"
      ],
      status: "standard",
      mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-weight"
    },
    "forced-color-adjust": {
      syntax: "auto | none",
      media: "visual",
      inherited: true,
      animationType: "notAnimatable",
      percentages: "no",
      groups: [
        "CSS Color"
      ],
      initial: "auto",
      appliesto: "allElementsAndText",
      computed: "asSpecified",
      order: "perGrammar",
      status: "experimental",
      mdn_url: "https://developer.mozilla.org/docs/Web/CSS/forced-color-adjust"
    },
    gap: {
      syntax: "<'row-gap'> <'column-gap'>?",
      media: "visual",
      inherited: false,
      animationType: [
        "row-gap",
        "column-gap"
      ],
      percentages: "no",
      groups: [
        "CSS Box Alignment"
      ],
      initial: [
        "row-gap",
        "column-gap"
      ],
      appliesto: "multiColumnElementsFlexContainersGridContainers",
      computed: [
        "row-gap",
        "column-gap"
      ],
      order: "uniqueOrder",
      status: "standard",
      mdn_url: "https://developer.mozilla.org/docs/Web/CSS/gap"
    },
    grid: {
      syntax: "<'grid-template'> | <'grid-template-rows'> / [ auto-flow && dense? ] <'grid-auto-columns'>? | [ auto-flow && dense? ] <'grid-auto-rows'>? / <'grid-template-columns'>",
      media: "visual",
      inherited: false,
      animationType: "discrete",
      percentages: [
        "grid-template-rows",
        "grid-template-columns",
        "grid-auto-rows",
        "grid-auto-columns"
      ],
      groups: [
        "CSS Grid Layout"
      ],
      initial: [
        "grid-template-rows",
        "grid-template-columns",
        "grid-template-areas",
        "grid-auto-rows",
        "grid-auto-columns",
        "grid-auto-flow",
        "grid-column-gap",
        "grid-row-gap",
        "column-gap",
        "row-gap"
      ],
      appliesto: "gridContainers",
      computed: [
        "grid-template-rows",
        "grid-template-columns",
        "grid-template-areas",
        "grid-auto-rows",
        "grid-auto-columns",
        "grid-auto-flow",
        "grid-column-gap",
        "grid-row-gap",
        "column-gap",
        "row-gap"
      ],
      order: "uniqueOrder",
      status: "standard",
      mdn_url: "https://developer.mozilla.org/docs/Web/CSS/grid"
    },
    "grid-area": {
      syntax: "<grid-line> [ / <grid-line> ]{0,3}",
      media: "visual",
      inherited: false,
      animationType: "discrete",
      percentages: "no",
      groups: [
        "CSS Grid Layout"
      ],
      initial: [
        "grid-row-start",
        "grid-column-start",
        "grid-row-end",
        "grid-column-end"
      ],
      appliesto: "gridItemsAndBoxesWithinGridContainer",
      computed: [
        "grid-row-start",
        "grid-column-start",
        "grid-row-end",
        "grid-column-end"
      ],
      order: "uniqueOrder",
      status: "standard",
      mdn_url: "https://developer.mozilla.org/docs/Web/CSS/grid-area"
    },
    "grid-auto-columns": {
      syntax: "<track-size>+",
      media: "visual",
      inherited: false,
      animationType: "discrete",
      percentages: "referToDimensionOfContentArea",
      groups: [
        "CSS Grid Layout"
      ],
      initial: "auto",
      appliesto: "gridContainers",
      computed: "percentageAsSpecifiedOrAbsoluteLength",
      order: "uniqueOrder",
      status: "standard",
      mdn_url: "https://developer.mozilla.org/docs/Web/CSS/grid-auto-columns"
    },
    "grid-auto-flow": {
      syntax: "[ row | column ] || dense",
      media: "visual",
      inherited: false,
      animationType: "discrete",
      percentages: "no",
      groups: [
        "CSS Grid Layout"
      ],
      initial: "row",
      appliesto: "gridContainers",
      computed: "asSpecified",
      order: "uniqueOrder",
      status: "standard",
      mdn_url: "https://developer.mozilla.org/docs/Web/CSS/grid-auto-flow"
    },
    "grid-auto-rows": {
      syntax: "<track-size>+",
      media: "visual",
      inherited: false,
      animationType: "discrete",
      percentages: "referToDimensionOfContentArea",
      groups: [
        "CSS Grid Layout"
      ],
      initial: "auto",
      appliesto: "gridContainers",
      computed: "percentageAsSpecifiedOrAbsoluteLength",
      order: "uniqueOrder",
      status: "standard",
      mdn_url: "https://developer.mozilla.org/docs/Web/CSS/grid-auto-rows"
    },
    "grid-column": {
      syntax: "<grid-line> [ / <grid-line> ]?",
      media: "visual",
      inherited: false,
      animationType: "discrete",
      percentages: "no",
      groups: [
        "CSS Grid Layout"
      ],
      initial: [
        "grid-column-start",
        "grid-column-end"
      ],
      appliesto: "gridItemsAndBoxesWithinGridContainer",
      computed: [
        "grid-column-start",
        "grid-column-end"
      ],
      order: "uniqueOrder",
      status: "standard",
      mdn_url: "https://developer.mozilla.org/docs/Web/CSS/grid-column"
    },
    "grid-column-end": {
      syntax: "<grid-line>",
      media: "visual",
      inherited: false,
      animationType: "discrete",
      percentages: "no",
      groups: [
        "CSS Grid Layout"
      ],
      initial: "auto",
      appliesto: "gridItemsAndBoxesWithinGridContainer",
      computed: "asSpecified",
      order: "uniqueOrder",
      status: "standard",
      mdn_url: "https://developer.mozilla.org/docs/Web/CSS/grid-column-end"
    },
    "grid-column-gap": {
      syntax: "<length-percentage>",
      media: "visual",
      inherited: false,
      animationType: "length",
      percentages: "referToDimensionOfContentArea",
      groups: [
        "CSS Grid Layout"
      ],
      initial: "0",
      appliesto: "gridContainers",
      computed: "percentageAsSpecifiedOrAbsoluteLength",
      order: "uniqueOrder",
      status: "obsolete",
      mdn_url: "https://developer.mozilla.org/docs/Web/CSS/column-gap"
    },
    "grid-column-start": {
      syntax: "<grid-line>",
      media: "visual",
      inherited: false,
      animationType: "discrete",
      percentages: "no",
      groups: [
        "CSS Grid Layout"
      ],
      initial: "auto",
      appliesto: "gridItemsAndBoxesWithinGridContainer",
      computed: "asSpecified",
      order: "uniqueOrder",
      status: "standard",
      mdn_url: "https://developer.mozilla.org/docs/Web/CSS/grid-column-start"
    },
    "grid-gap": {
      syntax: "<'grid-row-gap'> <'grid-column-gap'>?",
      media: "visual",
      inherited: false,
      animationType: [
        "grid-row-gap",
        "grid-column-gap"
      ],
      percentages: "no",
      groups: [
        "CSS Grid Layout"
      ],
      initial: [
        "grid-row-gap",
        "grid-column-gap"
      ],
      appliesto: "gridContainers",
      computed: [
        "grid-row-gap",
        "grid-column-gap"
      ],
      order: "uniqueOrder",
      status: "obsolete",
      mdn_url: "https://developer.mozilla.org/docs/Web/CSS/gap"
    },
    "grid-row": {
      syntax: "<grid-line> [ / <grid-line> ]?",
      media: "visual",
      inherited: false,
      animationType: "discrete",
      percentages: "no",
      groups: [
        "CSS Grid Layout"
      ],
      initial: [
        "grid-row-start",
        "grid-row-end"
      ],
      appliesto: "gridItemsAndBoxesWithinGridContainer",
      computed: [
        "grid-row-start",
        "grid-row-end"
      ],
      order: "uniqueOrder",
      status: "standard",
      mdn_url: "https://developer.mozilla.org/docs/Web/CSS/grid-row"
    },
    "grid-row-end": {
      syntax: "<grid-line>",
      media: "visual",
      inherited: false,
      animationType: "discrete",
      percentages: "no",
      groups: [
        "CSS Grid Layout"
      ],
      initial: "auto",
      appliesto: "gridItemsAndBoxesWithinGridContainer",
      computed: "asSpecified",
      order: "uniqueOrder",
      status: "standard",
      mdn_url: "https://developer.mozilla.org/docs/Web/CSS/grid-row-end"
    },
    "grid-row-gap": {
      syntax: "<length-percentage>",
      media: "visual",
      inherited: false,
      animationType: "length",
      percentages: "referToDimensionOfContentArea",
      groups: [
        "CSS Grid Layout"
      ],
      initial: "0",
      appliesto: "gridContainers",
      computed: "percentageAsSpecifiedOrAbsoluteLength",
      order: "uniqueOrder",
      status: "obsolete",
      mdn_url: "https://developer.mozilla.org/docs/Web/CSS/row-gap"
    },
    "grid-row-start": {
      syntax: "<grid-line>",
      media: "visual",
      inherited: false,
      animationType: "discrete",
      percentages: "no",
      groups: [
        "CSS Grid Layout"
      ],
      initial: "auto",
      appliesto: "gridItemsAndBoxesWithinGridContainer",
      computed: "asSpecified",
      order: "uniqueOrder",
      status: "standard",
      mdn_url: "https://developer.mozilla.org/docs/Web/CSS/grid-row-start"
    },
    "grid-template": {
      syntax: "none | [ <'grid-template-rows'> / <'grid-template-columns'> ] | [ <line-names>? <string> <track-size>? <line-names>? ]+ [ / <explicit-track-list> ]?",
      media: "visual",
      inherited: false,
      animationType: "discrete",
      percentages: [
        "grid-template-columns",
        "grid-template-rows"
      ],
      groups: [
        "CSS Grid Layout"
      ],
      initial: [
        "grid-template-columns",
        "grid-template-rows",
        "grid-template-areas"
      ],
      appliesto: "gridContainers",
      computed: [
        "grid-template-columns",
        "grid-template-rows",
        "grid-template-areas"
      ],
      order: "uniqueOrder",
      status: "standard",
      mdn_url: "https://developer.mozilla.org/docs/Web/CSS/grid-template"
    },
    "grid-template-areas": {
      syntax: "none | <string>+",
      media: "visual",
      inherited: false,
      animationType: "discrete",
      percentages: "no",
      groups: [
        "CSS Grid Layout"
      ],
      initial: "none",
      appliesto: "gridContainers",
      computed: "asSpecified",
      order: "uniqueOrder",
      status: "standard",
      mdn_url: "https://developer.mozilla.org/docs/Web/CSS/grid-template-areas"
    },
    "grid-template-columns": {
      syntax: "none | <track-list> | <auto-track-list> | subgrid <line-name-list>?",
      media: "visual",
      inherited: false,
      animationType: "simpleListOfLpcDifferenceLpc",
      percentages: "referToDimensionOfContentArea",
      groups: [
        "CSS Grid Layout"
      ],
      initial: "none",
      appliesto: "gridContainers",
      computed: "asSpecifiedRelativeToAbsoluteLengths",
      order: "uniqueOrder",
      status: "standard",
      mdn_url: "https://developer.mozilla.org/docs/Web/CSS/grid-template-columns"
    },
    "grid-template-rows": {
      syntax: "none | <track-list> | <auto-track-list> | subgrid <line-name-list>?",
      media: "visual",
      inherited: false,
      animationType: "simpleListOfLpcDifferenceLpc",
      percentages: "referToDimensionOfContentArea",
      groups: [
        "CSS Grid Layout"
      ],
      initial: "none",
      appliesto: "gridContainers",
      computed: "asSpecifiedRelativeToAbsoluteLengths",
      order: "uniqueOrder",
      status: "standard",
      mdn_url: "https://developer.mozilla.org/docs/Web/CSS/grid-template-rows"
    },
    "hanging-punctuation": {
      syntax: "none | [ first || [ force-end | allow-end ] || last ]",
      media: "visual",
      inherited: true,
      animationType: "discrete",
      percentages: "no",
      groups: [
        "CSS Text"
      ],
      initial: "none",
      appliesto: "allElements",
      computed: "asSpecified",
      order: "uniqueOrder",
      status: "standard",
      mdn_url: "https://developer.mozilla.org/docs/Web/CSS/hanging-punctuation"
    },
    height: {
      syntax: "auto | <length> | <percentage> | min-content | max-content | fit-content | fit-content(<length-percentage>)",
      media: "visual",
      inherited: false,
      animationType: "lpc",
      percentages: "regardingHeightOfGeneratedBoxContainingBlockPercentagesRelativeToContainingBlock",
      groups: [
        "CSS Box Model"
      ],
      initial: "auto",
      appliesto: "allElementsButNonReplacedAndTableColumns",
      computed: "percentageAutoOrAbsoluteLength",
      order: "uniqueOrder",
      status: "standard",
      mdn_url: "https://developer.mozilla.org/docs/Web/CSS/height"
    },
    "hyphenate-character": {
      syntax: "auto | <string>",
      media: "visual",
      inherited: true,
      animationType: "discrete",
      percentages: "no",
      groups: [
        "CSS Text"
      ],
      initial: "auto",
      appliesto: "allElements",
      computed: "asSpecified",
      order: "perGrammar",
      status: "standard",
      mdn_url: "https://developer.mozilla.org/docs/Web/CSS/hyphenate-character"
    },
    hyphens: {
      syntax: "none | manual | auto",
      media: "visual",
      inherited: true,
      animationType: "discrete",
      percentages: "no",
      groups: [
        "CSS Text"
      ],
      initial: "manual",
      appliesto: "allElements",
      computed: "asSpecified",
      order: "uniqueOrder",
      status: "standard",
      mdn_url: "https://developer.mozilla.org/docs/Web/CSS/hyphens"
    },
    "image-orientation": {
      syntax: "from-image | <angle> | [ <angle>? flip ]",
      media: "visual",
      inherited: true,
      animationType: "discrete",
      percentages: "no",
      groups: [
        "CSS Images"
      ],
      initial: "from-image",
      appliesto: "allElements",
      computed: "angleRoundedToNextQuarter",
      order: "uniqueOrder",
      status: "standard",
      mdn_url: "https://developer.mozilla.org/docs/Web/CSS/image-orientation"
    },
    "image-rendering": {
      syntax: "auto | crisp-edges | pixelated",
      media: "visual",
      inherited: true,
      animationType: "discrete",
      percentages: "no",
      groups: [
        "CSS Images"
      ],
      initial: "auto",
      appliesto: "allElements",
      computed: "asSpecified",
      order: "uniqueOrder",
      status: "standard",
      mdn_url: "https://developer.mozilla.org/docs/Web/CSS/image-rendering"
    },
    "image-resolution": {
      syntax: "[ from-image || <resolution> ] && snap?",
      media: "visual",
      inherited: true,
      animationType: "discrete",
      percentages: "no",
      groups: [
        "CSS Images"
      ],
      initial: "1dppx",
      appliesto: "allElements",
      computed: "asSpecifiedWithExceptionOfResolution",
      order: "uniqueOrder",
      status: "experimental"
    },
    "ime-mode": {
      syntax: "auto | normal | active | inactive | disabled",
      media: "interactive",
      inherited: false,
      animationType: "discrete",
      percentages: "no",
      groups: [
        "CSS Basic User Interface"
      ],
      initial: "auto",
      appliesto: "textFields",
      computed: "asSpecified",
      order: "uniqueOrder",
      status: "obsolete",
      mdn_url: "https://developer.mozilla.org/docs/Web/CSS/ime-mode"
    },
    "initial-letter": {
      syntax: "normal | [ <number> <integer>? ]",
      media: "visual",
      inherited: false,
      animationType: "discrete",
      percentages: "no",
      groups: [
        "CSS Inline"
      ],
      initial: "normal",
      appliesto: "firstLetterPseudoElementsAndInlineLevelFirstChildren",
      computed: "asSpecified",
      order: "uniqueOrder",
      status: "experimental",
      mdn_url: "https://developer.mozilla.org/docs/Web/CSS/initial-letter"
    },
    "initial-letter-align": {
      syntax: "[ auto | alphabetic | hanging | ideographic ]",
      media: "visual",
      inherited: false,
      animationType: "discrete",
      percentages: "no",
      groups: [
        "CSS Inline"
      ],
      initial: "auto",
      appliesto: "firstLetterPseudoElementsAndInlineLevelFirstChildren",
      computed: "asSpecified",
      order: "uniqueOrder",
      status: "experimental",
      mdn_url: "https://developer.mozilla.org/docs/Web/CSS/initial-letter-align"
    },
    "inline-size": {
      syntax: "<'width'>",
      media: "visual",
      inherited: false,
      animationType: "lpc",
      percentages: "inlineSizeOfContainingBlock",
      groups: [
        "CSS Logical Properties"
      ],
      initial: "auto",
      appliesto: "sameAsWidthAndHeight",
      computed: "sameAsWidthAndHeight",
      order: "uniqueOrder",
      status: "standard",
      mdn_url: "https://developer.mozilla.org/docs/Web/CSS/inline-size"
    },
    "input-security": {
      syntax: "auto | none",
      media: "interactive",
      inherited: false,
      animationType: "byComputedValueType",
      percentages: "no",
      groups: [
        "CSS Basic User Interface"
      ],
      initial: "auto",
      appliesto: "sensitiveTextInputs",
      computed: "asSpecified",
      order: "perGrammar",
      status: "standard"
    },
    inset: {
      syntax: "<'top'>{1,4}",
      media: "visual",
      inherited: false,
      animationType: "lpc",
      percentages: "logicalHeightOrWidthOfContainingBlock",
      groups: [
        "CSS Logical Properties"
      ],
      initial: "auto",
      appliesto: "positionedElements",
      computed: "sameAsBoxOffsets",
      order: "uniqueOrder",
      status: "standard",
      mdn_url: "https://developer.mozilla.org/docs/Web/CSS/inset"
    },
    "inset-block": {
      syntax: "<'top'>{1,2}",
      media: "visual",
      inherited: false,
      animationType: "lpc",
      percentages: "logicalHeightOfContainingBlock",
      groups: [
        "CSS Logical Properties"
      ],
      initial: "auto",
      appliesto: "positionedElements",
      computed: "sameAsBoxOffsets",
      order: "uniqueOrder",
      status: "standard",
      mdn_url: "https://developer.mozilla.org/docs/Web/CSS/inset-block"
    },
    "inset-block-end": {
      syntax: "<'top'>",
      media: "visual",
      inherited: false,
      animationType: "lpc",
      percentages: "logicalHeightOfContainingBlock",
      groups: [
        "CSS Logical Properties"
      ],
      initial: "auto",
      appliesto: "positionedElements",
      computed: "sameAsBoxOffsets",
      order: "uniqueOrder",
      status: "standard",
      mdn_url: "https://developer.mozilla.org/docs/Web/CSS/inset-block-end"
    },
    "inset-block-start": {
      syntax: "<'top'>",
      media: "visual",
      inherited: false,
      animationType: "lpc",
      percentages: "logicalHeightOfContainingBlock",
      groups: [
        "CSS Logical Properties"
      ],
      initial: "auto",
      appliesto: "positionedElements",
      computed: "sameAsBoxOffsets",
      order: "uniqueOrder",
      status: "standard",
      mdn_url: "https://developer.mozilla.org/docs/Web/CSS/inset-block-start"
    },
    "inset-inline": {
      syntax: "<'top'>{1,2}",
      media: "visual",
      inherited: false,
      animationType: "lpc",
      percentages: "logicalWidthOfContainingBlock",
      groups: [
        "CSS Logical Properties"
      ],
      initial: "auto",
      appliesto: "positionedElements",
      computed: "sameAsBoxOffsets",
      order: "uniqueOrder",
      status: "standard",
      mdn_url: "https://developer.mozilla.org/docs/Web/CSS/inset-inline"
    },
    "inset-inline-end": {
      syntax: "<'top'>",
      media: "visual",
      inherited: false,
      animationType: "lpc",
      percentages: "logicalWidthOfContainingBlock",
      groups: [
        "CSS Logical Properties"
      ],
      initial: "auto",
      appliesto: "positionedElements",
      computed: "sameAsBoxOffsets",
      order: "uniqueOrder",
      status: "standard",
      mdn_url: "https://developer.mozilla.org/docs/Web/CSS/inset-inline-end"
    },
    "inset-inline-start": {
      syntax: "<'top'>",
      media: "visual",
      inherited: false,
      animationType: "lpc",
      percentages: "logicalWidthOfContainingBlock",
      groups: [
        "CSS Logical Properties"
      ],
      initial: "auto",
      appliesto: "positionedElements",
      computed: "sameAsBoxOffsets",
      order: "uniqueOrder",
      status: "standard",
      mdn_url: "https://developer.mozilla.org/docs/Web/CSS/inset-inline-start"
    },
    isolation: {
      syntax: "auto | isolate",
      media: "visual",
      inherited: false,
      animationType: "discrete",
      percentages: "no",
      groups: [
        "Compositing and Blending"
      ],
      initial: "auto",
      appliesto: "allElementsSVGContainerGraphicsAndGraphicsReferencingElements",
      computed: "asSpecified",
      order: "uniqueOrder",
      status: "standard",
      mdn_url: "https://developer.mozilla.org/docs/Web/CSS/isolation"
    },
    "justify-content": {
      syntax: "normal | <content-distribution> | <overflow-position>? [ <content-position> | left | right ]",
      media: "visual",
      inherited: false,
      animationType: "discrete",
      percentages: "no",
      groups: [
        "CSS Box Alignment"
      ],
      initial: "normal",
      appliesto: "flexContainers",
      computed: "asSpecified",
      order: "uniqueOrder",
      status: "standard",
      mdn_url: "https://developer.mozilla.org/docs/Web/CSS/justify-content"
    },
    "justify-items": {
      syntax: "normal | stretch | <baseline-position> | <overflow-position>? [ <self-position> | left | right ] | legacy | legacy && [ left | right | center ]",
      media: "visual",
      inherited: false,
      animationType: "discrete",
      percentages: "no",
      groups: [
        "CSS Box Alignment"
      ],
      initial: "legacy",
      appliesto: "allElements",
      computed: "asSpecified",
      order: "perGrammar",
      status: "standard",
      mdn_url: "https://developer.mozilla.org/docs/Web/CSS/justify-items"
    },
    "justify-self": {
      syntax: "auto | normal | stretch | <baseline-position> | <overflow-position>? [ <self-position> | left | right ]",
      media: "visual",
      inherited: false,
      animationType: "discrete",
      percentages: "no",
      groups: [
        "CSS Box Alignment"
      ],
      initial: "auto",
      appliesto: "blockLevelBoxesAndAbsolutelyPositionedBoxesAndGridItems",
      computed: "asSpecified",
      order: "uniqueOrder",
      status: "standard",
      mdn_url: "https://developer.mozilla.org/docs/Web/CSS/justify-self"
    },
    "justify-tracks": {
      syntax: "[ normal | <content-distribution> | <overflow-position>? [ <content-position> | left | right ] ]#",
      media: "visual",
      inherited: false,
      animationType: "discrete",
      percentages: "no",
      groups: [
        "CSS Grid Layout"
      ],
      initial: "normal",
      appliesto: "gridContainersWithMasonryLayoutInTheirInlineAxis",
      computed: "asSpecified",
      order: "uniqueOrder",
      status: "experimental",
      mdn_url: "https://developer.mozilla.org/docs/Web/CSS/justify-tracks"
    },
    left: {
      syntax: "<length> | <percentage> | auto",
      media: "visual",
      inherited: false,
      animationType: "lpc",
      percentages: "referToWidthOfContainingBlock",
      groups: [
        "CSS Positioning"
      ],
      initial: "auto",
      appliesto: "positionedElements",
      computed: "lengthAbsolutePercentageAsSpecifiedOtherwiseAuto",
      order: "uniqueOrder",
      status: "standard",
      mdn_url: "https://developer.mozilla.org/docs/Web/CSS/left"
    },
    "letter-spacing": {
      syntax: "normal | <length>",
      media: "visual",
      inherited: true,
      animationType: "length",
      percentages: "no",
      groups: [
        "CSS Text"
      ],
      initial: "normal",
      appliesto: "allElements",
      computed: "optimumValueOfAbsoluteLengthOrNormal",
      order: "uniqueOrder",
      alsoAppliesTo: [
        "::first-letter",
        "::first-line"
      ],
      status: "standard",
      mdn_url: "https://developer.mozilla.org/docs/Web/CSS/letter-spacing"
    },
    "line-break": {
      syntax: "auto | loose | normal | strict | anywhere",
      media: "visual",
      inherited: true,
      animationType: "discrete",
      percentages: "no",
      groups: [
        "CSS Text"
      ],
      initial: "auto",
      appliesto: "allElements",
      computed: "asSpecified",
      order: "uniqueOrder",
      status: "standard",
      mdn_url: "https://developer.mozilla.org/docs/Web/CSS/line-break"
    },
    "line-clamp": {
      syntax: "none | <integer>",
      media: "visual",
      inherited: false,
      animationType: "integer",
      percentages: "no",
      groups: [
        "CSS Overflow"
      ],
      initial: "none",
      appliesto: "blockContainersExceptMultiColumnContainers",
      computed: "asSpecified",
      order: "perGrammar",
      status: "experimental"
    },
    "line-height": {
      syntax: "normal | <number> | <length> | <percentage>",
      media: "visual",
      inherited: true,
      animationType: "numberOrLength",
      percentages: "referToElementFontSize",
      groups: [
        "CSS Fonts"
      ],
      initial: "normal",
      appliesto: "allElements",
      computed: "absoluteLengthOrAsSpecified",
      order: "uniqueOrder",
      alsoAppliesTo: [
        "::first-letter",
        "::first-line",
        "::placeholder"
      ],
      status: "standard",
      mdn_url: "https://developer.mozilla.org/docs/Web/CSS/line-height"
    },
    "line-height-step": {
      syntax: "<length>",
      media: "visual",
      inherited: true,
      animationType: "discrete",
      percentages: "no",
      groups: [
        "CSS Fonts"
      ],
      initial: "0",
      appliesto: "blockContainers",
      computed: "absoluteLength",
      order: "perGrammar",
      status: "experimental",
      mdn_url: "https://developer.mozilla.org/docs/Web/CSS/line-height-step"
    },
    "list-style": {
      syntax: "<'list-style-type'> || <'list-style-position'> || <'list-style-image'>",
      media: "visual",
      inherited: true,
      animationType: "discrete",
      percentages: "no",
      groups: [
        "CSS Lists and Counters"
      ],
      initial: [
        "list-style-type",
        "list-style-position",
        "list-style-image"
      ],
      appliesto: "listItems",
      computed: [
        "list-style-image",
        "list-style-position",
        "list-style-type"
      ],
      order: "orderOfAppearance",
      status: "standard",
      mdn_url: "https://developer.mozilla.org/docs/Web/CSS/list-style"
    },
    "list-style-image": {
      syntax: "<image> | none",
      media: "visual",
      inherited: true,
      animationType: "discrete",
      percentages: "no",
      groups: [
        "CSS Lists and Counters"
      ],
      initial: "none",
      appliesto: "listItems",
      computed: "theKeywordListStyleImageNoneOrComputedValue",
      order: "uniqueOrder",
      status: "standard",
      mdn_url: "https://developer.mozilla.org/docs/Web/CSS/list-style-image"
    },
    "list-style-position": {
      syntax: "inside | outside",
      media: "visual",
      inherited: true,
      animationType: "discrete",
      percentages: "no",
      groups: [
        "CSS Lists and Counters"
      ],
      initial: "outside",
      appliesto: "listItems",
      computed: "asSpecified",
      order: "uniqueOrder",
      status: "standard",
      mdn_url: "https://developer.mozilla.org/docs/Web/CSS/list-style-position"
    },
    "list-style-type": {
      syntax: "<counter-style> | <string> | none",
      media: "visual",
      inherited: true,
      animationType: "discrete",
      percentages: "no",
      groups: [
        "CSS Lists and Counters"
      ],
      initial: "disc",
      appliesto: "listItems",
      computed: "asSpecified",
      order: "uniqueOrder",
      status: "standard",
      mdn_url: "https://developer.mozilla.org/docs/Web/CSS/list-style-type"
    },
    margin: {
      syntax: "[ <length> | <percentage> | auto ]{1,4}",
      media: "visual",
      inherited: false,
      animationType: "length",
      percentages: "referToWidthOfContainingBlock",
      groups: [
        "CSS Box Model"
      ],
      initial: [
        "margin-bottom",
        "margin-left",
        "margin-right",
        "margin-top"
      ],
      appliesto: "allElementsExceptTableDisplayTypes",
      computed: [
        "margin-bottom",
        "margin-left",
        "margin-right",
        "margin-top"
      ],
      order: "uniqueOrder",
      alsoAppliesTo: [
        "::first-letter",
        "::first-line"
      ],
      status: "standard",
      mdn_url: "https://developer.mozilla.org/docs/Web/CSS/margin"
    },
    "margin-block": {
      syntax: "<'margin-left'>{1,2}",
      media: "visual",
      inherited: false,
      animationType: "discrete",
      percentages: "dependsOnLayoutModel",
      groups: [
        "CSS Logical Properties"
      ],
      initial: "0",
      appliesto: "sameAsMargin",
      computed: "lengthAbsolutePercentageAsSpecifiedOtherwiseAuto",
      order: "uniqueOrder",
      status: "standard",
      mdn_url: "https://developer.mozilla.org/docs/Web/CSS/margin-block"
    },
    "margin-block-end": {
      syntax: "<'margin-left'>",
      media: "visual",
      inherited: false,
      animationType: "length",
      percentages: "dependsOnLayoutModel",
      groups: [
        "CSS Logical Properties"
      ],
      initial: "0",
      appliesto: "sameAsMargin",
      computed: "lengthAbsolutePercentageAsSpecifiedOtherwiseAuto",
      order: "uniqueOrder",
      status: "standard",
      mdn_url: "https://developer.mozilla.org/docs/Web/CSS/margin-block-end"
    },
    "margin-block-start": {
      syntax: "<'margin-left'>",
      media: "visual",
      inherited: false,
      animationType: "length",
      percentages: "dependsOnLayoutModel",
      groups: [
        "CSS Logical Properties"
      ],
      initial: "0",
      appliesto: "sameAsMargin",
      computed: "lengthAbsolutePercentageAsSpecifiedOtherwiseAuto",
      order: "uniqueOrder",
      status: "standard",
      mdn_url: "https://developer.mozilla.org/docs/Web/CSS/margin-block-start"
    },
    "margin-bottom": {
      syntax: "<length> | <percentage> | auto",
      media: "visual",
      inherited: false,
      animationType: "length",
      percentages: "referToWidthOfContainingBlock",
      groups: [
        "CSS Box Model"
      ],
      initial: "0",
      appliesto: "allElementsExceptTableDisplayTypes",
      computed: "percentageAsSpecifiedOrAbsoluteLength",
      order: "uniqueOrder",
      alsoAppliesTo: [
        "::first-letter",
        "::first-line"
      ],
      status: "standard",
      mdn_url: "https://developer.mozilla.org/docs/Web/CSS/margin-bottom"
    },
    "margin-inline": {
      syntax: "<'margin-left'>{1,2}",
      media: "visual",
      inherited: false,
      animationType: "discrete",
      percentages: "dependsOnLayoutModel",
      groups: [
        "CSS Logical Properties"
      ],
      initial: "0",
      appliesto: "sameAsMargin",
      computed: "lengthAbsolutePercentageAsSpecifiedOtherwiseAuto",
      order: "uniqueOrder",
      status: "standard",
      mdn_url: "https://developer.mozilla.org/docs/Web/CSS/margin-inline"
    },
    "margin-inline-end": {
      syntax: "<'margin-left'>",
      media: "visual",
      inherited: false,
      animationType: "length",
      percentages: "dependsOnLayoutModel",
      groups: [
        "CSS Logical Properties"
      ],
      initial: "0",
      appliesto: "sameAsMargin",
      computed: "lengthAbsolutePercentageAsSpecifiedOtherwiseAuto",
      order: "uniqueOrder",
      status: "standard",
      mdn_url: "https://developer.mozilla.org/docs/Web/CSS/margin-inline-end"
    },
    "margin-inline-start": {
      syntax: "<'margin-left'>",
      media: "visual",
      inherited: false,
      animationType: "length",
      percentages: "dependsOnLayoutModel",
      groups: [
        "CSS Logical Properties"
      ],
      initial: "0",
      appliesto: "sameAsMargin",
      computed: "lengthAbsolutePercentageAsSpecifiedOtherwiseAuto",
      order: "uniqueOrder",
      status: "standard",
      mdn_url: "https://developer.mozilla.org/docs/Web/CSS/margin-inline-start"
    },
    "margin-left": {
      syntax: "<length> | <percentage> | auto",
      media: "visual",
      inherited: false,
      animationType: "length",
      percentages: "referToWidthOfContainingBlock",
      groups: [
        "CSS Box Model"
      ],
      initial: "0",
      appliesto: "allElementsExceptTableDisplayTypes",
      computed: "percentageAsSpecifiedOrAbsoluteLength",
      order: "uniqueOrder",
      alsoAppliesTo: [
        "::first-letter",
        "::first-line"
      ],
      status: "standard",
      mdn_url: "https://developer.mozilla.org/docs/Web/CSS/margin-left"
    },
    "margin-right": {
      syntax: "<length> | <percentage> | auto",
      media: "visual",
      inherited: false,
      animationType: "length",
      percentages: "referToWidthOfContainingBlock",
      groups: [
        "CSS Box Model"
      ],
      initial: "0",
      appliesto: "allElementsExceptTableDisplayTypes",
      computed: "percentageAsSpecifiedOrAbsoluteLength",
      order: "uniqueOrder",
      alsoAppliesTo: [
        "::first-letter",
        "::first-line"
      ],
      status: "standard",
      mdn_url: "https://developer.mozilla.org/docs/Web/CSS/margin-right"
    },
    "margin-top": {
      syntax: "<length> | <percentage> | auto",
      media: "visual",
      inherited: false,
      animationType: "length",
      percentages: "referToWidthOfContainingBlock",
      groups: [
        "CSS Box Model"
      ],
      initial: "0",
      appliesto: "allElementsExceptTableDisplayTypes",
      computed: "percentageAsSpecifiedOrAbsoluteLength",
      order: "uniqueOrder",
      alsoAppliesTo: [
        "::first-letter",
        "::first-line"
      ],
      status: "standard",
      mdn_url: "https://developer.mozilla.org/docs/Web/CSS/margin-top"
    },
    "margin-trim": {
      syntax: "none | in-flow | all",
      media: "visual",
      inherited: false,
      animationType: "discrete",
      percentages: "no",
      groups: [
        "CSS Box Model"
      ],
      initial: "none",
      appliesto: "blockContainersAndMultiColumnContainers",
      computed: "asSpecified",
      order: "perGrammar",
      alsoAppliesTo: [
        "::first-letter",
        "::first-line"
      ],
      status: "experimental",
      mdn_url: "https://developer.mozilla.org/docs/Web/CSS/margin-trim"
    },
    mask: {
      syntax: "<mask-layer>#",
      media: "visual",
      inherited: false,
      animationType: [
        "mask-image",
        "mask-mode",
        "mask-repeat",
        "mask-position",
        "mask-clip",
        "mask-origin",
        "mask-size",
        "mask-composite"
      ],
      percentages: [
        "mask-position"
      ],
      groups: [
        "CSS Masking"
      ],
      initial: [
        "mask-image",
        "mask-mode",
        "mask-repeat",
        "mask-position",
        "mask-clip",
        "mask-origin",
        "mask-size",
        "mask-composite"
      ],
      appliesto: "allElementsSVGContainerElements",
      computed: [
        "mask-image",
        "mask-mode",
        "mask-repeat",
        "mask-position",
        "mask-clip",
        "mask-origin",
        "mask-size",
        "mask-composite"
      ],
      order: "perGrammar",
      stacking: true,
      status: "standard",
      mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask"
    },
    "mask-border": {
      syntax: "<'mask-border-source'> || <'mask-border-slice'> [ / <'mask-border-width'>? [ / <'mask-border-outset'> ]? ]? || <'mask-border-repeat'> || <'mask-border-mode'>",
      media: "visual",
      inherited: false,
      animationType: [
        "mask-border-mode",
        "mask-border-outset",
        "mask-border-repeat",
        "mask-border-slice",
        "mask-border-source",
        "mask-border-width"
      ],
      percentages: [
        "mask-border-slice",
        "mask-border-width"
      ],
      groups: [
        "CSS Masking"
      ],
      initial: [
        "mask-border-mode",
        "mask-border-outset",
        "mask-border-repeat",
        "mask-border-slice",
        "mask-border-source",
        "mask-border-width"
      ],
      appliesto: "allElementsSVGContainerElements",
      computed: [
        "mask-border-mode",
        "mask-border-outset",
        "mask-border-repeat",
        "mask-border-slice",
        "mask-border-source",
        "mask-border-width"
      ],
      order: "perGrammar",
      stacking: true,
      status: "standard",
      mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-border"
    },
    "mask-border-mode": {
      syntax: "luminance | alpha",
      media: "visual",
      inherited: false,
      animationType: "discrete",
      percentages: "no",
      groups: [
        "CSS Masking"
      ],
      initial: "alpha",
      appliesto: "allElementsSVGContainerElements",
      computed: "asSpecified",
      order: "perGrammar",
      status: "standard",
      mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-border-mode"
    },
    "mask-border-outset": {
      syntax: "[ <length> | <number> ]{1,4}",
      media: "visual",
      inherited: false,
      animationType: "discrete",
      percentages: "no",
      groups: [
        "CSS Masking"
      ],
      initial: "0",
      appliesto: "allElementsSVGContainerElements",
      computed: "asSpecifiedRelativeToAbsoluteLengths",
      order: "perGrammar",
      status: "standard",
      mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-border-outset"
    },
    "mask-border-repeat": {
      syntax: "[ stretch | repeat | round | space ]{1,2}",
      media: "visual",
      inherited: false,
      animationType: "discrete",
      percentages: "no",
      groups: [
        "CSS Masking"
      ],
      initial: "stretch",
      appliesto: "allElementsSVGContainerElements",
      computed: "asSpecified",
      order: "perGrammar",
      status: "standard",
      mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-border-repeat"
    },
    "mask-border-slice": {
      syntax: "<number-percentage>{1,4} fill?",
      media: "visual",
      inherited: false,
      animationType: "discrete",
      percentages: "referToSizeOfMaskBorderImage",
      groups: [
        "CSS Masking"
      ],
      initial: "0",
      appliesto: "allElementsSVGContainerElements",
      computed: "asSpecified",
      order: "perGrammar",
      status: "standard",
      mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-border-slice"
    },
    "mask-border-source": {
      syntax: "none | <image>",
      media: "visual",
      inherited: false,
      animationType: "discrete",
      percentages: "no",
      groups: [
        "CSS Masking"
      ],
      initial: "none",
      appliesto: "allElementsSVGContainerElements",
      computed: "asSpecifiedURLsAbsolute",
      order: "perGrammar",
      status: "standard",
      mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-border-source"
    },
    "mask-border-width": {
      syntax: "[ <length-percentage> | <number> | auto ]{1,4}",
      media: "visual",
      inherited: false,
      animationType: "discrete",
      percentages: "relativeToMaskBorderImageArea",
      groups: [
        "CSS Masking"
      ],
      initial: "auto",
      appliesto: "allElementsSVGContainerElements",
      computed: "asSpecifiedRelativeToAbsoluteLengths",
      order: "perGrammar",
      status: "standard",
      mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-border-width"
    },
    "mask-clip": {
      syntax: "[ <geometry-box> | no-clip ]#",
      media: "visual",
      inherited: false,
      animationType: "discrete",
      percentages: "no",
      groups: [
        "CSS Masking"
      ],
      initial: "border-box",
      appliesto: "allElementsSVGContainerElements",
      computed: "asSpecified",
      order: "perGrammar",
      status: "standard",
      mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-clip"
    },
    "mask-composite": {
      syntax: "<compositing-operator>#",
      media: "visual",
      inherited: false,
      animationType: "discrete",
      percentages: "no",
      groups: [
        "CSS Masking"
      ],
      initial: "add",
      appliesto: "allElementsSVGContainerElements",
      computed: "asSpecified",
      order: "perGrammar",
      status: "standard",
      mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-composite"
    },
    "mask-image": {
      syntax: "<mask-reference>#",
      media: "visual",
      inherited: false,
      animationType: "discrete",
      percentages: "no",
      groups: [
        "CSS Masking"
      ],
      initial: "none",
      appliesto: "allElementsSVGContainerElements",
      computed: "asSpecifiedURLsAbsolute",
      order: "perGrammar",
      status: "standard",
      mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-image"
    },
    "mask-mode": {
      syntax: "<masking-mode>#",
      media: "visual",
      inherited: false,
      animationType: "discrete",
      percentages: "no",
      groups: [
        "CSS Masking"
      ],
      initial: "match-source",
      appliesto: "allElementsSVGContainerElements",
      computed: "asSpecified",
      order: "perGrammar",
      status: "standard",
      mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-mode"
    },
    "mask-origin": {
      syntax: "<geometry-box>#",
      media: "visual",
      inherited: false,
      animationType: "discrete",
      percentages: "no",
      groups: [
        "CSS Masking"
      ],
      initial: "border-box",
      appliesto: "allElementsSVGContainerElements",
      computed: "asSpecified",
      order: "perGrammar",
      status: "standard",
      mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-origin"
    },
    "mask-position": {
      syntax: "<position>#",
      media: "visual",
      inherited: false,
      animationType: "repeatableListOfSimpleListOfLpc",
      percentages: "referToSizeOfMaskPaintingArea",
      groups: [
        "CSS Masking"
      ],
      initial: "center",
      appliesto: "allElementsSVGContainerElements",
      computed: "consistsOfTwoKeywordsForOriginAndOffsets",
      order: "perGrammar",
      status: "standard",
      mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-position"
    },
    "mask-repeat": {
      syntax: "<repeat-style>#",
      media: "visual",
      inherited: false,
      animationType: "discrete",
      percentages: "no",
      groups: [
        "CSS Masking"
      ],
      initial: "no-repeat",
      appliesto: "allElementsSVGContainerElements",
      computed: "consistsOfTwoDimensionKeywords",
      order: "perGrammar",
      status: "standard",
      mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-repeat"
    },
    "mask-size": {
      syntax: "<bg-size>#",
      media: "visual",
      inherited: false,
      animationType: "repeatableListOfSimpleListOfLpc",
      percentages: "no",
      groups: [
        "CSS Masking"
      ],
      initial: "auto",
      appliesto: "allElementsSVGContainerElements",
      computed: "asSpecifiedRelativeToAbsoluteLengths",
      order: "perGrammar",
      status: "standard",
      mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-size"
    },
    "mask-type": {
      syntax: "luminance | alpha",
      media: "visual",
      inherited: false,
      animationType: "discrete",
      percentages: "no",
      groups: [
        "CSS Masking"
      ],
      initial: "luminance",
      appliesto: "maskElements",
      computed: "asSpecified",
      order: "perGrammar",
      status: "standard",
      mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-type"
    },
    "masonry-auto-flow": {
      syntax: "[ pack | next ] || [ definite-first | ordered ]",
      media: "visual",
      inherited: false,
      animationType: "discrete",
      percentages: "no",
      groups: [
        "CSS Grid Layout"
      ],
      initial: "pack",
      appliesto: "gridContainersWithMasonryLayout",
      computed: "asSpecified",
      order: "uniqueOrder",
      status: "experimental",
      mdn_url: "https://developer.mozilla.org/docs/Web/CSS/masonry-auto-flow"
    },
    "math-style": {
      syntax: "normal | compact",
      media: "visual",
      inherited: true,
      animationType: "notAnimatable",
      percentages: "no",
      groups: [
        "MathML"
      ],
      initial: "normal",
      appliesto: "allElements",
      computed: "asSpecified",
      order: "perGrammar",
      status: "standard",
      mdn_url: "https://developer.mozilla.org/docs/Web/CSS/math-style"
    },
    "max-block-size": {
      syntax: "<'max-width'>",
      media: "visual",
      inherited: false,
      animationType: "lpc",
      percentages: "blockSizeOfContainingBlock",
      groups: [
        "CSS Logical Properties"
      ],
      initial: "none",
      appliesto: "sameAsWidthAndHeight",
      computed: "sameAsMaxWidthAndMaxHeight",
      order: "uniqueOrder",
      status: "standard",
      mdn_url: "https://developer.mozilla.org/docs/Web/CSS/max-block-size"
    },
    "max-height": {
      syntax: "none | <length-percentage> | min-content | max-content | fit-content | fit-content(<length-percentage>)",
      media: "visual",
      inherited: false,
      animationType: "lpc",
      percentages: "regardingHeightOfGeneratedBoxContainingBlockPercentagesNone",
      groups: [
        "CSS Box Model"
      ],
      initial: "none",
      appliesto: "allElementsButNonReplacedAndTableColumns",
      computed: "percentageAsSpecifiedAbsoluteLengthOrNone",
      order: "uniqueOrder",
      status: "standard",
      mdn_url: "https://developer.mozilla.org/docs/Web/CSS/max-height"
    },
    "max-inline-size": {
      syntax: "<'max-width'>",
      media: "visual",
      inherited: false,
      animationType: "lpc",
      percentages: "inlineSizeOfContainingBlock",
      groups: [
        "CSS Logical Properties"
      ],
      initial: "none",
      appliesto: "sameAsWidthAndHeight",
      computed: "sameAsMaxWidthAndMaxHeight",
      order: "uniqueOrder",
      status: "standard",
      mdn_url: "https://developer.mozilla.org/docs/Web/CSS/max-inline-size"
    },
    "max-lines": {
      syntax: "none | <integer>",
      media: "visual",
      inherited: false,
      animationType: "integer",
      percentages: "no",
      groups: [
        "CSS Overflow"
      ],
      initial: "none",
      appliesto: "blockContainersExceptMultiColumnContainers",
      computed: "asSpecified",
      order: "perGrammar",
      status: "experimental"
    },
    "max-width": {
      syntax: "none | <length-percentage> | min-content | max-content | fit-content | fit-content(<length-percentage>)",
      media: "visual",
      inherited: false,
      animationType: "lpc",
      percentages: "referToWidthOfContainingBlock",
      groups: [
        "CSS Box Model"
      ],
      initial: "none",
      appliesto: "allElementsButNonReplacedAndTableRows",
      computed: "percentageAsSpecifiedAbsoluteLengthOrNone",
      order: "uniqueOrder",
      status: "standard",
      mdn_url: "https://developer.mozilla.org/docs/Web/CSS/max-width"
    },
    "min-block-size": {
      syntax: "<'min-width'>",
      media: "visual",
      inherited: false,
      animationType: "lpc",
      percentages: "blockSizeOfContainingBlock",
      groups: [
        "CSS Logical Properties"
      ],
      initial: "0",
      appliesto: "sameAsWidthAndHeight",
      computed: "sameAsMinWidthAndMinHeight",
      order: "uniqueOrder",
      status: "standard",
      mdn_url: "https://developer.mozilla.org/docs/Web/CSS/min-block-size"
    },
    "min-height": {
      syntax: "auto | <length> | <percentage> | min-content | max-content | fit-content | fit-content(<length-percentage>)",
      media: "visual",
      inherited: false,
      animationType: "lpc",
      percentages: "regardingHeightOfGeneratedBoxContainingBlockPercentages0",
      groups: [
        "CSS Box Model"
      ],
      initial: "auto",
      appliesto: "allElementsButNonReplacedAndTableColumns",
      computed: "percentageAsSpecifiedOrAbsoluteLength",
      order: "uniqueOrder",
      status: "standard",
      mdn_url: "https://developer.mozilla.org/docs/Web/CSS/min-height"
    },
    "min-inline-size": {
      syntax: "<'min-width'>",
      media: "visual",
      inherited: false,
      animationType: "lpc",
      percentages: "inlineSizeOfContainingBlock",
      groups: [
        "CSS Logical Properties"
      ],
      initial: "0",
      appliesto: "sameAsWidthAndHeight",
      computed: "sameAsMinWidthAndMinHeight",
      order: "uniqueOrder",
      status: "standard",
      mdn_url: "https://developer.mozilla.org/docs/Web/CSS/min-inline-size"
    },
    "min-width": {
      syntax: "auto | <length> | <percentage> | min-content | max-content | fit-content | fit-content(<length-percentage>)",
      media: "visual",
      inherited: false,
      animationType: "lpc",
      percentages: "referToWidthOfContainingBlock",
      groups: [
        "CSS Box Model"
      ],
      initial: "auto",
      appliesto: "allElementsButNonReplacedAndTableRows",
      computed: "percentageAsSpecifiedOrAbsoluteLength",
      order: "uniqueOrder",
      status: "standard",
      mdn_url: "https://developer.mozilla.org/docs/Web/CSS/min-width"
    },
    "mix-blend-mode": {
      syntax: "<blend-mode> | plus-lighter",
      media: "visual",
      inherited: false,
      animationType: "discrete",
      percentages: "no",
      groups: [
        "Compositing and Blending"
      ],
      initial: "normal",
      appliesto: "allElements",
      computed: "asSpecified",
      order: "uniqueOrder",
      stacking: true,
      status: "standard",
      mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mix-blend-mode"
    },
    "object-fit": {
      syntax: "fill | contain | cover | none | scale-down",
      media: "visual",
      inherited: false,
      animationType: "discrete",
      percentages: "no",
      groups: [
        "CSS Images"
      ],
      initial: "fill",
      appliesto: "replacedElements",
      computed: "asSpecified",
      order: "uniqueOrder",
      status: "standard",
      mdn_url: "https://developer.mozilla.org/docs/Web/CSS/object-fit"
    },
    "object-position": {
      syntax: "<position>",
      media: "visual",
      inherited: true,
      animationType: "repeatableListOfSimpleListOfLpc",
      percentages: "referToWidthAndHeightOfElement",
      groups: [
        "CSS Images"
      ],
      initial: "50% 50%",
      appliesto: "replacedElements",
      computed: "asSpecified",
      order: "uniqueOrder",
      status: "standard",
      mdn_url: "https://developer.mozilla.org/docs/Web/CSS/object-position"
    },
    offset: {
      syntax: "[ <'offset-position'>? [ <'offset-path'> [ <'offset-distance'> || <'offset-rotate'> ]? ]? ]! [ / <'offset-anchor'> ]?",
      media: "visual",
      inherited: false,
      animationType: [
        "offset-position",
        "offset-path",
        "offset-distance",
        "offset-anchor",
        "offset-rotate"
      ],
      percentages: [
        "offset-position",
        "offset-distance",
        "offset-anchor"
      ],
      groups: [
        "CSS Motion Path"
      ],
      initial: [
        "offset-position",
        "offset-path",
        "offset-distance",
        "offset-anchor",
        "offset-rotate"
      ],
      appliesto: "transformableElements",
      computed: [
        "offset-position",
        "offset-path",
        "offset-distance",
        "offset-anchor",
        "offset-rotate"
      ],
      order: "perGrammar",
      stacking: true,
      status: "standard",
      mdn_url: "https://developer.mozilla.org/docs/Web/CSS/offset"
    },
    "offset-anchor": {
      syntax: "auto | <position>",
      media: "visual",
      inherited: false,
      animationType: "position",
      percentages: "relativeToWidthAndHeight",
      groups: [
        "CSS Motion Path"
      ],
      initial: "auto",
      appliesto: "transformableElements",
      computed: "forLengthAbsoluteValueOtherwisePercentage",
      order: "perGrammar",
      status: "standard"
    },
    "offset-distance": {
      syntax: "<length-percentage>",
      media: "visual",
      inherited: false,
      animationType: "lpc",
      percentages: "referToTotalPathLength",
      groups: [
        "CSS Motion Path"
      ],
      initial: "0",
      appliesto: "transformableElements",
      computed: "forLengthAbsoluteValueOtherwisePercentage",
      order: "perGrammar",
      status: "standard",
      mdn_url: "https://developer.mozilla.org/docs/Web/CSS/offset-distance"
    },
    "offset-path": {
      syntax: "none | ray( [ <angle> && <size> && contain? ] ) | <path()> | <url> | [ <basic-shape> || <geometry-box> ]",
      media: "visual",
      inherited: false,
      animationType: "angleOrBasicShapeOrPath",
      percentages: "no",
      groups: [
        "CSS Motion Path"
      ],
      initial: "none",
      appliesto: "transformableElements",
      computed: "asSpecified",
      order: "perGrammar",
      stacking: true,
      status: "standard",
      mdn_url: "https://developer.mozilla.org/docs/Web/CSS/offset-path"
    },
    "offset-position": {
      syntax: "auto | <position>",
      media: "visual",
      inherited: false,
      animationType: "position",
      percentages: "referToSizeOfContainingBlock",
      groups: [
        "CSS Motion Path"
      ],
      initial: "auto",
      appliesto: "transformableElements",
      computed: "forLengthAbsoluteValueOtherwisePercentage",
      order: "perGrammar",
      status: "experimental"
    },
    "offset-rotate": {
      syntax: "[ auto | reverse ] || <angle>",
      media: "visual",
      inherited: false,
      animationType: "angleOrBasicShapeOrPath",
      percentages: "no",
      groups: [
        "CSS Motion Path"
      ],
      initial: "auto",
      appliesto: "transformableElements",
      computed: "asSpecified",
      order: "perGrammar",
      status: "standard",
      mdn_url: "https://developer.mozilla.org/docs/Web/CSS/offset-rotate"
    },
    opacity: {
      syntax: "<alpha-value>",
      media: "visual",
      inherited: false,
      animationType: "byComputedValueType",
      percentages: "mapToRange0To1",
      groups: [
        "CSS Color"
      ],
      initial: "1",
      appliesto: "allElements",
      computed: "specifiedValueNumberClipped0To1",
      order: "perGrammar",
      alsoAppliesTo: [
        "::placeholder"
      ],
      status: "standard",
      mdn_url: "https://developer.mozilla.org/docs/Web/CSS/opacity"
    },
    order: {
      syntax: "<integer>",
      media: "visual",
      inherited: false,
      animationType: "integer",
      percentages: "no",
      groups: [
        "CSS Flexible Box Layout"
      ],
      initial: "0",
      appliesto: "flexItemsGridItemsAbsolutelyPositionedContainerChildren",
      computed: "asSpecified",
      order: "uniqueOrder",
      status: "standard",
      mdn_url: "https://developer.mozilla.org/docs/Web/CSS/order"
    },
    orphans: {
      syntax: "<integer>",
      media: "visual",
      inherited: true,
      animationType: "discrete",
      percentages: "no",
      groups: [
        "CSS Fragmentation"
      ],
      initial: "2",
      appliesto: "blockContainerElements",
      computed: "asSpecified",
      order: "perGrammar",
      status: "standard",
      mdn_url: "https://developer.mozilla.org/docs/Web/CSS/orphans"
    },
    outline: {
      syntax: "[ <'outline-color'> || <'outline-style'> || <'outline-width'> ]",
      media: [
        "visual",
        "interactive"
      ],
      inherited: false,
      animationType: [
        "outline-color",
        "outline-width",
        "outline-style"
      ],
      percentages: "no",
      groups: [
        "CSS Basic User Interface"
      ],
      initial: [
        "outline-color",
        "outline-style",
        "outline-width"
      ],
      appliesto: "allElements",
      computed: [
        "outline-color",
        "outline-width",
        "outline-style"
      ],
      order: "orderOfAppearance",
      status: "standard",
      mdn_url: "https://developer.mozilla.org/docs/Web/CSS/outline"
    },
    "outline-color": {
      syntax: "<color> | invert",
      media: [
        "visual",
        "interactive"
      ],
      inherited: false,
      animationType: "color",
      percentages: "no",
      groups: [
        "CSS Basic User Interface"
      ],
      initial: "invertOrCurrentColor",
      appliesto: "allElements",
      computed: "invertForTranslucentColorRGBAOtherwiseRGB",
      order: "uniqueOrder",
      status: "standard",
      mdn_url: "https://developer.mozilla.org/docs/Web/CSS/outline-color"
    },
    "outline-offset": {
      syntax: "<length>",
      media: [
        "visual",
        "interactive"
      ],
      inherited: false,
      animationType: "length",
      percentages: "no",
      groups: [
        "CSS Basic User Interface"
      ],
      initial: "0",
      appliesto: "allElements",
      computed: "asSpecifiedRelativeToAbsoluteLengths",
      order: "uniqueOrder",
      status: "standard",
      mdn_url: "https://developer.mozilla.org/docs/Web/CSS/outline-offset"
    },
    "outline-style": {
      syntax: "auto | <'border-style'>",
      media: [
        "visual",
        "interactive"
      ],
      inherited: false,
      animationType: "discrete",
      percentages: "no",
      groups: [
        "CSS Basic User Interface"
      ],
      initial: "none",
      appliesto: "allElements",
      computed: "asSpecified",
      order: "uniqueOrder",
      status: "standard",
      mdn_url: "https://developer.mozilla.org/docs/Web/CSS/outline-style"
    },
    "outline-width": {
      syntax: "<line-width>",
      media: [
        "visual",
        "interactive"
      ],
      inherited: false,
      animationType: "length",
      percentages: "no",
      groups: [
        "CSS Basic User Interface"
      ],
      initial: "medium",
      appliesto: "allElements",
      computed: "absoluteLength0ForNone",
      order: "uniqueOrder",
      status: "standard",
      mdn_url: "https://developer.mozilla.org/docs/Web/CSS/outline-width"
    },
    overflow: {
      syntax: "[ visible | hidden | clip | scroll | auto ]{1,2}",
      media: "visual",
      inherited: false,
      animationType: "discrete",
      percentages: "no",
      groups: [
        "CSS Overflow"
      ],
      initial: "visible",
      appliesto: "blockContainersFlexContainersGridContainers",
      computed: [
        "overflow-x",
        "overflow-y"
      ],
      order: "uniqueOrder",
      status: "standard",
      mdn_url: "https://developer.mozilla.org/docs/Web/CSS/overflow"
    },
    "overflow-anchor": {
      syntax: "auto | none",
      media: "visual",
      inherited: false,
      animationType: "discrete",
      percentages: "no",
      groups: [
        "CSS Scroll Anchoring"
      ],
      initial: "auto",
      appliesto: "allElements",
      computed: "asSpecified",
      order: "perGrammar",
      status: "standard"
    },
    "overflow-block": {
      syntax: "visible | hidden | clip | scroll | auto",
      media: "visual",
      inherited: false,
      animationType: "discrete",
      percentages: "no",
      groups: [
        "CSS Overflow"
      ],
      initial: "auto",
      appliesto: "blockContainersFlexContainersGridContainers",
      computed: "asSpecifiedButVisibleOrClipReplacedToAutoOrHiddenIfOtherValueDifferent",
      order: "perGrammar",
      status: "standard"
    },
    "overflow-clip-box": {
      syntax: "padding-box | content-box",
      media: "visual",
      inherited: false,
      animationType: "discrete",
      percentages: "no",
      groups: [
        "Mozilla Extensions"
      ],
      initial: "padding-box",
      appliesto: "allElements",
      computed: "asSpecified",
      order: "uniqueOrder",
      status: "nonstandard",
      mdn_url: "https://developer.mozilla.org/docs/Mozilla/CSS/overflow-clip-box"
    },
    "overflow-clip-margin": {
      syntax: "<visual-box> || <length [0,]>",
      media: "visual",
      inherited: false,
      animationType: "discrete",
      percentages: "no",
      groups: [
        "CSS Overflow"
      ],
      initial: "0px",
      appliesto: "allElements",
      computed: "theComputedLength",
      order: "perGrammar",
      status: "standard"
    },
    "overflow-inline": {
      syntax: "visible | hidden | clip | scroll | auto",
      media: "visual",
      inherited: false,
      animationType: "discrete",
      percentages: "no",
      groups: [
        "CSS Overflow"
      ],
      initial: "auto",
      appliesto: "blockContainersFlexContainersGridContainers",
      computed: "asSpecifiedButVisibleOrClipReplacedToAutoOrHiddenIfOtherValueDifferent",
      order: "perGrammar",
      status: "standard"
    },
    "overflow-wrap": {
      syntax: "normal | break-word | anywhere",
      media: "visual",
      inherited: true,
      animationType: "discrete",
      percentages: "no",
      groups: [
        "CSS Text"
      ],
      initial: "normal",
      appliesto: "nonReplacedInlineElements",
      computed: "asSpecified",
      order: "uniqueOrder",
      status: "standard",
      mdn_url: "https://developer.mozilla.org/docs/Web/CSS/overflow-wrap"
    },
    "overflow-x": {
      syntax: "visible | hidden | clip | scroll | auto",
      media: "visual",
      inherited: false,
      animationType: "discrete",
      percentages: "no",
      groups: [
        "CSS Overflow"
      ],
      initial: "visible",
      appliesto: "blockContainersFlexContainersGridContainers",
      computed: "asSpecifiedButVisibleOrClipReplacedToAutoOrHiddenIfOtherValueDifferent",
      order: "uniqueOrder",
      status: "standard",
      mdn_url: "https://developer.mozilla.org/docs/Web/CSS/overflow-x"
    },
    "overflow-y": {
      syntax: "visible | hidden | clip | scroll | auto",
      media: "visual",
      inherited: false,
      animationType: "discrete",
      percentages: "no",
      groups: [
        "CSS Overflow"
      ],
      initial: "visible",
      appliesto: "blockContainersFlexContainersGridContainers",
      computed: "asSpecifiedButVisibleOrClipReplacedToAutoOrHiddenIfOtherValueDifferent",
      order: "uniqueOrder",
      status: "standard",
      mdn_url: "https://developer.mozilla.org/docs/Web/CSS/overflow-y"
    },
    "overscroll-behavior": {
      syntax: "[ contain | none | auto ]{1,2}",
      media: "visual",
      inherited: false,
      animationType: "discrete",
      percentages: "no",
      groups: [
        "CSS Box Model"
      ],
      initial: "auto",
      appliesto: "nonReplacedBlockAndInlineBlockElements",
      computed: [
        "overscroll-behavior-x",
        "overscroll-behavior-y"
      ],
      order: "uniqueOrder",
      status: "standard",
      mdn_url: "https://developer.mozilla.org/docs/Web/CSS/overscroll-behavior"
    },
    "overscroll-behavior-block": {
      syntax: "contain | none | auto",
      media: "visual",
      inherited: false,
      animationType: "discrete",
      percentages: "no",
      groups: [
        "CSS Box Model"
      ],
      initial: "auto",
      appliesto: "nonReplacedBlockAndInlineBlockElements",
      computed: "asSpecified",
      order: "uniqueOrder",
      status: "standard",
      mdn_url: "https://developer.mozilla.org/docs/Web/CSS/overscroll-behavior-block"
    },
    "overscroll-behavior-inline": {
      syntax: "contain | none | auto",
      media: "visual",
      inherited: false,
      animationType: "discrete",
      percentages: "no",
      groups: [
        "CSS Box Model"
      ],
      initial: "auto",
      appliesto: "nonReplacedBlockAndInlineBlockElements",
      computed: "asSpecified",
      order: "uniqueOrder",
      status: "standard",
      mdn_url: "https://developer.mozilla.org/docs/Web/CSS/overscroll-behavior-inline"
    },
    "overscroll-behavior-x": {
      syntax: "contain | none | auto",
      media: "visual",
      inherited: false,
      animationType: "discrete",
      percentages: "no",
      groups: [
        "CSS Box Model"
      ],
      initial: "auto",
      appliesto: "nonReplacedBlockAndInlineBlockElements",
      computed: "asSpecified",
      order: "uniqueOrder",
      status: "standard",
      mdn_url: "https://developer.mozilla.org/docs/Web/CSS/overscroll-behavior-x"
    },
    "overscroll-behavior-y": {
      syntax: "contain | none | auto",
      media: "visual",
      inherited: false,
      animationType: "discrete",
      percentages: "no",
      groups: [
        "CSS Box Model"
      ],
      initial: "auto",
      appliesto: "nonReplacedBlockAndInlineBlockElements",
      computed: "asSpecified",
      order: "uniqueOrder",
      status: "standard",
      mdn_url: "https://developer.mozilla.org/docs/Web/CSS/overscroll-behavior-y"
    },
    padding: {
      syntax: "[ <length> | <percentage> ]{1,4}",
      media: "visual",
      inherited: false,
      animationType: "length",
      percentages: "referToWidthOfContainingBlock",
      groups: [
        "CSS Box Model"
      ],
      initial: [
        "padding-bottom",
        "padding-left",
        "padding-right",
        "padding-top"
      ],
      appliesto: "allElementsExceptInternalTableDisplayTypes",
      computed: [
        "padding-bottom",
        "padding-left",
        "padding-right",
        "padding-top"
      ],
      order: "uniqueOrder",
      alsoAppliesTo: [
        "::first-letter",
        "::first-line"
      ],
      status: "standard",
      mdn_url: "https://developer.mozilla.org/docs/Web/CSS/padding"
    },
    "padding-block": {
      syntax: "<'padding-left'>{1,2}",
      media: "visual",
      inherited: false,
      animationType: "discrete",
      percentages: "logicalWidthOfContainingBlock",
      groups: [
        "CSS Logical Properties"
      ],
      initial: "0",
      appliesto: "allElements",
      computed: "asLength",
      order: "uniqueOrder",
      status: "standard",
      mdn_url: "https://developer.mozilla.org/docs/Web/CSS/padding-block"
    },
    "padding-block-end": {
      syntax: "<'padding-left'>",
      media: "visual",
      inherited: false,
      animationType: "length",
      percentages: "logicalWidthOfContainingBlock",
      groups: [
        "CSS Logical Properties"
      ],
      initial: "0",
      appliesto: "allElements",
      computed: "asLength",
      order: "uniqueOrder",
      status: "standard",
      mdn_url: "https://developer.mozilla.org/docs/Web/CSS/padding-block-end"
    },
    "padding-block-start": {
      syntax: "<'padding-left'>",
      media: "visual",
      inherited: false,
      animationType: "length",
      percentages: "logicalWidthOfContainingBlock",
      groups: [
        "CSS Logical Properties"
      ],
      initial: "0",
      appliesto: "allElements",
      computed: "asLength",
      order: "uniqueOrder",
      status: "standard",
      mdn_url: "https://developer.mozilla.org/docs/Web/CSS/padding-block-start"
    },
    "padding-bottom": {
      syntax: "<length> | <percentage>",
      media: "visual",
      inherited: false,
      animationType: "length",
      percentages: "referToWidthOfContainingBlock",
      groups: [
        "CSS Box Model"
      ],
      initial: "0",
      appliesto: "allElementsExceptInternalTableDisplayTypes",
      computed: "percentageAsSpecifiedOrAbsoluteLength",
      order: "uniqueOrder",
      alsoAppliesTo: [
        "::first-letter",
        "::first-line"
      ],
      status: "standard",
      mdn_url: "https://developer.mozilla.org/docs/Web/CSS/padding-bottom"
    },
    "padding-inline": {
      syntax: "<'padding-left'>{1,2}",
      media: "visual",
      inherited: false,
      animationType: "discrete",
      percentages: "logicalWidthOfContainingBlock",
      groups: [
        "CSS Logical Properties"
      ],
      initial: "0",
      appliesto: "allElements",
      computed: "asLength",
      order: "uniqueOrder",
      status: "standard",
      mdn_url: "https://developer.mozilla.org/docs/Web/CSS/padding-inline"
    },
    "padding-inline-end": {
      syntax: "<'padding-left'>",
      media: "visual",
      inherited: false,
      animationType: "length",
      percentages: "logicalWidthOfContainingBlock",
      groups: [
        "CSS Logical Properties"
      ],
      initial: "0",
      appliesto: "allElements",
      computed: "asLength",
      order: "uniqueOrder",
      status: "standard",
      mdn_url: "https://developer.mozilla.org/docs/Web/CSS/padding-inline-end"
    },
    "padding-inline-start": {
      syntax: "<'padding-left'>",
      media: "visual",
      inherited: false,
      animationType: "length",
      percentages: "logicalWidthOfContainingBlock",
      groups: [
        "CSS Logical Properties"
      ],
      initial: "0",
      appliesto: "allElements",
      computed: "asLength",
      order: "uniqueOrder",
      status: "standard",
      mdn_url: "https://developer.mozilla.org/docs/Web/CSS/padding-inline-start"
    },
    "padding-left": {
      syntax: "<length> | <percentage>",
      media: "visual",
      inherited: false,
      animationType: "length",
      percentages: "referToWidthOfContainingBlock",
      groups: [
        "CSS Box Model"
      ],
      initial: "0",
      appliesto: "allElementsExceptInternalTableDisplayTypes",
      computed: "percentageAsSpecifiedOrAbsoluteLength",
      order: "uniqueOrder",
      alsoAppliesTo: [
        "::first-letter",
        "::first-line"
      ],
      status: "standard",
      mdn_url: "https://developer.mozilla.org/docs/Web/CSS/padding-left"
    },
    "padding-right": {
      syntax: "<length> | <percentage>",
      media: "visual",
      inherited: false,
      animationType: "length",
      percentages: "referToWidthOfContainingBlock",
      groups: [
        "CSS Box Model"
      ],
      initial: "0",
      appliesto: "allElementsExceptInternalTableDisplayTypes",
      computed: "percentageAsSpecifiedOrAbsoluteLength",
      order: "uniqueOrder",
      alsoAppliesTo: [
        "::first-letter",
        "::first-line"
      ],
      status: "standard",
      mdn_url: "https://developer.mozilla.org/docs/Web/CSS/padding-right"
    },
    "padding-top": {
      syntax: "<length> | <percentage>",
      media: "visual",
      inherited: false,
      animationType: "length",
      percentages: "referToWidthOfContainingBlock",
      groups: [
        "CSS Box Model"
      ],
      initial: "0",
      appliesto: "allElementsExceptInternalTableDisplayTypes",
      computed: "percentageAsSpecifiedOrAbsoluteLength",
      order: "uniqueOrder",
      alsoAppliesTo: [
        "::first-letter",
        "::first-line"
      ],
      status: "standard",
      mdn_url: "https://developer.mozilla.org/docs/Web/CSS/padding-top"
    },
    "page-break-after": {
      syntax: "auto | always | avoid | left | right | recto | verso",
      media: [
        "visual",
        "paged"
      ],
      inherited: false,
      animationType: "discrete",
      percentages: "no",
      groups: [
        "CSS Pages"
      ],
      initial: "auto",
      appliesto: "blockElementsInNormalFlow",
      computed: "asSpecified",
      order: "uniqueOrder",
      status: "standard",
      mdn_url: "https://developer.mozilla.org/docs/Web/CSS/page-break-after"
    },
    "page-break-before": {
      syntax: "auto | always | avoid | left | right | recto | verso",
      media: [
        "visual",
        "paged"
      ],
      inherited: false,
      animationType: "discrete",
      percentages: "no",
      groups: [
        "CSS Pages"
      ],
      initial: "auto",
      appliesto: "blockElementsInNormalFlow",
      computed: "asSpecified",
      order: "uniqueOrder",
      status: "standard",
      mdn_url: "https://developer.mozilla.org/docs/Web/CSS/page-break-before"
    },
    "page-break-inside": {
      syntax: "auto | avoid",
      media: [
        "visual",
        "paged"
      ],
      inherited: false,
      animationType: "discrete",
      percentages: "no",
      groups: [
        "CSS Pages"
      ],
      initial: "auto",
      appliesto: "blockElementsInNormalFlow",
      computed: "asSpecified",
      order: "uniqueOrder",
      status: "standard",
      mdn_url: "https://developer.mozilla.org/docs/Web/CSS/page-break-inside"
    },
    "paint-order": {
      syntax: "normal | [ fill || stroke || markers ]",
      media: "visual",
      inherited: true,
      animationType: "discrete",
      percentages: "no",
      groups: [
        "CSS Text"
      ],
      initial: "normal",
      appliesto: "textElements",
      computed: "asSpecified",
      order: "uniqueOrder",
      status: "standard",
      mdn_url: "https://developer.mozilla.org/docs/Web/CSS/paint-order"
    },
    perspective: {
      syntax: "none | <length>",
      media: "visual",
      inherited: false,
      animationType: "length",
      percentages: "no",
      groups: [
        "CSS Transforms"
      ],
      initial: "none",
      appliesto: "transformableElements",
      computed: "absoluteLengthOrNone",
      order: "uniqueOrder",
      stacking: true,
      status: "standard",
      mdn_url: "https://developer.mozilla.org/docs/Web/CSS/perspective"
    },
    "perspective-origin": {
      syntax: "<position>",
      media: "visual",
      inherited: false,
      animationType: "simpleListOfLpc",
      percentages: "referToSizeOfBoundingBox",
      groups: [
        "CSS Transforms"
      ],
      initial: "50% 50%",
      appliesto: "transformableElements",
      computed: "forLengthAbsoluteValueOtherwisePercentage",
      order: "oneOrTwoValuesLengthAbsoluteKeywordsPercentages",
      status: "standard",
      mdn_url: "https://developer.mozilla.org/docs/Web/CSS/perspective-origin"
    },
    "place-content": {
      syntax: "<'align-content'> <'justify-content'>?",
      media: "visual",
      inherited: false,
      animationType: "discrete",
      percentages: "no",
      groups: [
        "CSS Box Alignment"
      ],
      initial: "normal",
      appliesto: "multilineFlexContainers",
      computed: "asSpecified",
      order: "uniqueOrder",
      status: "standard",
      mdn_url: "https://developer.mozilla.org/docs/Web/CSS/place-content"
    },
    "place-items": {
      syntax: "<'align-items'> <'justify-items'>?",
      media: "visual",
      inherited: false,
      animationType: "discrete",
      percentages: "no",
      groups: [
        "CSS Box Alignment"
      ],
      initial: [
        "align-items",
        "justify-items"
      ],
      appliesto: "allElements",
      computed: [
        "align-items",
        "justify-items"
      ],
      order: "uniqueOrder",
      status: "standard",
      mdn_url: "https://developer.mozilla.org/docs/Web/CSS/place-items"
    },
    "place-self": {
      syntax: "<'align-self'> <'justify-self'>?",
      media: "visual",
      inherited: false,
      animationType: "discrete",
      percentages: "no",
      groups: [
        "CSS Box Alignment"
      ],
      initial: [
        "align-self",
        "justify-self"
      ],
      appliesto: "blockLevelBoxesAndAbsolutelyPositionedBoxesAndGridItems",
      computed: [
        "align-self",
        "justify-self"
      ],
      order: "uniqueOrder",
      status: "standard",
      mdn_url: "https://developer.mozilla.org/docs/Web/CSS/place-self"
    },
    "pointer-events": {
      syntax: "auto | none | visiblePainted | visibleFill | visibleStroke | visible | painted | fill | stroke | all | inherit",
      media: "visual",
      inherited: true,
      animationType: "discrete",
      percentages: "no",
      groups: [
        "CSS Basic User Interface"
      ],
      initial: "auto",
      appliesto: "allElements",
      computed: "asSpecified",
      order: "uniqueOrder",
      status: "standard",
      mdn_url: "https://developer.mozilla.org/docs/Web/CSS/pointer-events"
    },
    position: {
      syntax: "static | relative | absolute | sticky | fixed",
      media: "visual",
      inherited: false,
      animationType: "discrete",
      percentages: "no",
      groups: [
        "CSS Positioning"
      ],
      initial: "static",
      appliesto: "allElements",
      computed: "asSpecified",
      order: "uniqueOrder",
      stacking: true,
      status: "standard",
      mdn_url: "https://developer.mozilla.org/docs/Web/CSS/position"
    },
    quotes: {
      syntax: "none | auto | [ <string> <string> ]+",
      media: "visual",
      inherited: true,
      animationType: "discrete",
      percentages: "no",
      groups: [
        "CSS Generated Content"
      ],
      initial: "dependsOnUserAgent",
      appliesto: "allElements",
      computed: "asSpecified",
      order: "uniqueOrder",
      status: "standard",
      mdn_url: "https://developer.mozilla.org/docs/Web/CSS/quotes"
    },
    resize: {
      syntax: "none | both | horizontal | vertical | block | inline",
      media: "visual",
      inherited: false,
      animationType: "discrete",
      percentages: "no",
      groups: [
        "CSS Basic User Interface"
      ],
      initial: "none",
      appliesto: "elementsWithOverflowNotVisibleAndReplacedElements",
      computed: "asSpecified",
      order: "uniqueOrder",
      status: "standard",
      mdn_url: "https://developer.mozilla.org/docs/Web/CSS/resize"
    },
    right: {
      syntax: "<length> | <percentage> | auto",
      media: "visual",
      inherited: false,
      animationType: "lpc",
      percentages: "referToWidthOfContainingBlock",
      groups: [
        "CSS Positioning"
      ],
      initial: "auto",
      appliesto: "positionedElements",
      computed: "lengthAbsolutePercentageAsSpecifiedOtherwiseAuto",
      order: "uniqueOrder",
      status: "standard",
      mdn_url: "https://developer.mozilla.org/docs/Web/CSS/right"
    },
    rotate: {
      syntax: "none | <angle> | [ x | y | z | <number>{3} ] && <angle>",
      media: "visual",
      inherited: false,
      animationType: "transform",
      percentages: "no",
      groups: [
        "CSS Transforms"
      ],
      initial: "none",
      appliesto: "transformableElements",
      computed: "asSpecified",
      order: "perGrammar",
      stacking: true,
      status: "standard",
      mdn_url: "https://developer.mozilla.org/docs/Web/CSS/rotate"
    },
    "row-gap": {
      syntax: "normal | <length-percentage>",
      media: "visual",
      inherited: false,
      animationType: "lpc",
      percentages: "referToDimensionOfContentArea",
      groups: [
        "CSS Box Alignment"
      ],
      initial: "normal",
      appliesto: "multiColumnElementsFlexContainersGridContainers",
      computed: "asSpecifiedWithLengthsAbsoluteAndNormalComputingToZeroExceptMultiColumn",
      order: "perGrammar",
      status: "standard",
      mdn_url: "https://developer.mozilla.org/docs/Web/CSS/row-gap"
    },
    "ruby-align": {
      syntax: "start | center | space-between | space-around",
      media: "visual",
      inherited: true,
      animationType: "discrete",
      percentages: "no",
      groups: [
        "CSS Ruby"
      ],
      initial: "space-around",
      appliesto: "rubyBasesAnnotationsBaseAnnotationContainers",
      computed: "asSpecified",
      order: "uniqueOrder",
      status: "experimental",
      mdn_url: "https://developer.mozilla.org/docs/Web/CSS/ruby-align"
    },
    "ruby-merge": {
      syntax: "separate | collapse | auto",
      media: "visual",
      inherited: true,
      animationType: "discrete",
      percentages: "no",
      groups: [
        "CSS Ruby"
      ],
      initial: "separate",
      appliesto: "rubyAnnotationsContainers",
      computed: "asSpecified",
      order: "uniqueOrder",
      status: "experimental"
    },
    "ruby-position": {
      syntax: "[ alternate || [ over | under ] ] | inter-character",
      media: "visual",
      inherited: true,
      animationType: "discrete",
      percentages: "no",
      groups: [
        "CSS Ruby"
      ],
      initial: "alternate",
      appliesto: "rubyAnnotationsContainers",
      computed: "asSpecified",
      order: "uniqueOrder",
      status: "experimental",
      mdn_url: "https://developer.mozilla.org/docs/Web/CSS/ruby-position"
    },
    scale: {
      syntax: "none | <number>{1,3}",
      media: "visual",
      inherited: false,
      animationType: "transform",
      percentages: "no",
      groups: [
        "CSS Transforms"
      ],
      initial: "none",
      appliesto: "transformableElements",
      computed: "asSpecified",
      order: "perGrammar",
      stacking: true,
      status: "standard",
      mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scale"
    },
    "scrollbar-color": {
      syntax: "auto | <color>{2}",
      media: "visual",
      inherited: true,
      animationType: "color",
      percentages: "no",
      groups: [
        "CSS Scrollbars"
      ],
      initial: "auto",
      appliesto: "scrollingBoxes",
      computed: "asSpecified",
      order: "perGrammar",
      status: "standard",
      mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scrollbar-color"
    },
    "scrollbar-gutter": {
      syntax: "auto | stable && both-edges?",
      media: "visual",
      inherited: false,
      animationType: "discrete",
      percentages: "no",
      groups: [
        "CSS Overflow"
      ],
      initial: "auto",
      appliesto: "scrollingBoxes",
      computed: "asSpecified",
      order: "perGrammar",
      status: "standard",
      mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scrollbar-gutter"
    },
    "scrollbar-width": {
      syntax: "auto | thin | none",
      media: "visual",
      inherited: false,
      animationType: "discrete",
      percentages: "no",
      groups: [
        "CSS Scrollbars"
      ],
      initial: "auto",
      appliesto: "scrollingBoxes",
      computed: "asSpecified",
      order: "perGrammar",
      status: "standard",
      mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scrollbar-width"
    },
    "scroll-behavior": {
      syntax: "auto | smooth",
      media: "visual",
      inherited: false,
      animationType: "discrete",
      percentages: "no",
      groups: [
        "CSSOM View"
      ],
      initial: "auto",
      appliesto: "scrollingBoxes",
      computed: "asSpecified",
      order: "uniqueOrder",
      status: "standard",
      mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-behavior"
    },
    "scroll-margin": {
      syntax: "<length>{1,4}",
      media: "visual",
      inherited: false,
      animationType: "byComputedValueType",
      percentages: "no",
      groups: [
        "CSS Scroll Snap"
      ],
      initial: "0",
      appliesto: "allElements",
      computed: "asSpecified",
      order: "perGrammar",
      status: "standard",
      mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-margin"
    },
    "scroll-margin-block": {
      syntax: "<length>{1,2}",
      media: "visual",
      inherited: false,
      animationType: "byComputedValueType",
      percentages: "no",
      groups: [
        "CSS Scroll Snap"
      ],
      initial: "0",
      appliesto: "allElements",
      computed: "asSpecified",
      order: "perGrammar",
      status: "standard",
      mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-margin-block"
    },
    "scroll-margin-block-start": {
      syntax: "<length>",
      media: "visual",
      inherited: false,
      animationType: "byComputedValueType",
      percentages: "no",
      groups: [
        "CSS Scroll Snap"
      ],
      initial: "0",
      appliesto: "allElements",
      computed: "asSpecified",
      order: "perGrammar",
      status: "standard",
      mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-margin-block-start"
    },
    "scroll-margin-block-end": {
      syntax: "<length>",
      media: "visual",
      inherited: false,
      animationType: "byComputedValueType",
      percentages: "no",
      groups: [
        "CSS Scroll Snap"
      ],
      initial: "0",
      appliesto: "allElements",
      computed: "asSpecified",
      order: "perGrammar",
      status: "standard",
      mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-margin-block-end"
    },
    "scroll-margin-bottom": {
      syntax: "<length>",
      media: "visual",
      inherited: false,
      animationType: "byComputedValueType",
      percentages: "no",
      groups: [
        "CSS Scroll Snap"
      ],
      initial: "0",
      appliesto: "allElements",
      computed: "asSpecified",
      order: "perGrammar",
      status: "standard",
      mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-margin-bottom"
    },
    "scroll-margin-inline": {
      syntax: "<length>{1,2}",
      media: "visual",
      inherited: false,
      animationType: "byComputedValueType",
      percentages: "no",
      groups: [
        "CSS Scroll Snap"
      ],
      initial: "0",
      appliesto: "allElements",
      computed: "asSpecified",
      order: "perGrammar",
      status: "standard",
      mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-margin-inline"
    },
    "scroll-margin-inline-start": {
      syntax: "<length>",
      media: "visual",
      inherited: false,
      animationType: "byComputedValueType",
      percentages: "no",
      groups: [
        "CSS Scroll Snap"
      ],
      initial: "0",
      appliesto: "allElements",
      computed: "asSpecified",
      order: "perGrammar",
      status: "standard",
      mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-margin-inline-start"
    },
    "scroll-margin-inline-end": {
      syntax: "<length>",
      media: "visual",
      inherited: false,
      animationType: "byComputedValueType",
      percentages: "no",
      groups: [
        "CSS Scroll Snap"
      ],
      initial: "0",
      appliesto: "allElements",
      computed: "asSpecified",
      order: "perGrammar",
      status: "standard",
      mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-margin-inline-end"
    },
    "scroll-margin-left": {
      syntax: "<length>",
      media: "visual",
      inherited: false,
      animationType: "byComputedValueType",
      percentages: "no",
      groups: [
        "CSS Scroll Snap"
      ],
      initial: "0",
      appliesto: "allElements",
      computed: "asSpecified",
      order: "perGrammar",
      status: "standard",
      mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-margin-left"
    },
    "scroll-margin-right": {
      syntax: "<length>",
      media: "visual",
      inherited: false,
      animationType: "byComputedValueType",
      percentages: "no",
      groups: [
        "CSS Scroll Snap"
      ],
      initial: "0",
      appliesto: "allElements",
      computed: "asSpecified",
      order: "perGrammar",
      status: "standard",
      mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-margin-right"
    },
    "scroll-margin-top": {
      syntax: "<length>",
      media: "visual",
      inherited: false,
      animationType: "byComputedValueType",
      percentages: "no",
      groups: [
        "CSS Scroll Snap"
      ],
      initial: "0",
      appliesto: "allElements",
      computed: "asSpecified",
      order: "perGrammar",
      status: "standard",
      mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-margin-top"
    },
    "scroll-padding": {
      syntax: "[ auto | <length-percentage> ]{1,4}",
      media: "visual",
      inherited: false,
      animationType: "byComputedValueType",
      percentages: "relativeToTheScrollContainersScrollport",
      groups: [
        "CSS Scroll Snap"
      ],
      initial: "auto",
      appliesto: "scrollContainers",
      computed: "asSpecified",
      order: "perGrammar",
      status: "standard",
      mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-padding"
    },
    "scroll-padding-block": {
      syntax: "[ auto | <length-percentage> ]{1,2}",
      media: "visual",
      inherited: false,
      animationType: "byComputedValueType",
      percentages: "relativeToTheScrollContainersScrollport",
      groups: [
        "CSS Scroll Snap"
      ],
      initial: "auto",
      appliesto: "scrollContainers",
      computed: "asSpecified",
      order: "perGrammar",
      status: "standard",
      mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-padding-block"
    },
    "scroll-padding-block-start": {
      syntax: "auto | <length-percentage>",
      media: "visual",
      inherited: false,
      animationType: "byComputedValueType",
      percentages: "relativeToTheScrollContainersScrollport",
      groups: [
        "CSS Scroll Snap"
      ],
      initial: "auto",
      appliesto: "scrollContainers",
      computed: "asSpecified",
      order: "perGrammar",
      status: "standard",
      mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-padding-block-start"
    },
    "scroll-padding-block-end": {
      syntax: "auto | <length-percentage>",
      media: "visual",
      inherited: false,
      animationType: "byComputedValueType",
      percentages: "relativeToTheScrollContainersScrollport",
      groups: [
        "CSS Scroll Snap"
      ],
      initial: "auto",
      appliesto: "scrollContainers",
      computed: "asSpecified",
      order: "perGrammar",
      status: "standard",
      mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-padding-block-end"
    },
    "scroll-padding-bottom": {
      syntax: "auto | <length-percentage>",
      media: "visual",
      inherited: false,
      animationType: "byComputedValueType",
      percentages: "relativeToTheScrollContainersScrollport",
      groups: [
        "CSS Scroll Snap"
      ],
      initial: "auto",
      appliesto: "scrollContainers",
      computed: "asSpecified",
      order: "perGrammar",
      status: "standard",
      mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-padding-bottom"
    },
    "scroll-padding-inline": {
      syntax: "[ auto | <length-percentage> ]{1,2}",
      media: "visual",
      inherited: false,
      animationType: "byComputedValueType",
      percentages: "relativeToTheScrollContainersScrollport",
      groups: [
        "CSS Scroll Snap"
      ],
      initial: "auto",
      appliesto: "scrollContainers",
      computed: "asSpecified",
      order: "perGrammar",
      status: "standard",
      mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-padding-inline"
    },
    "scroll-padding-inline-start": {
      syntax: "auto | <length-percentage>",
      media: "visual",
      inherited: false,
      animationType: "byComputedValueType",
      percentages: "relativeToTheScrollContainersScrollport",
      groups: [
        "CSS Scroll Snap"
      ],
      initial: "auto",
      appliesto: "scrollContainers",
      computed: "asSpecified",
      order: "perGrammar",
      status: "standard",
      mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-padding-inline-start"
    },
    "scroll-padding-inline-end": {
      syntax: "auto | <length-percentage>",
      media: "visual",
      inherited: false,
      animationType: "byComputedValueType",
      percentages: "relativeToTheScrollContainersScrollport",
      groups: [
        "CSS Scroll Snap"
      ],
      initial: "auto",
      appliesto: "scrollContainers",
      computed: "asSpecified",
      order: "perGrammar",
      status: "standard",
      mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-padding-inline-end"
    },
    "scroll-padding-left": {
      syntax: "auto | <length-percentage>",
      media: "visual",
      inherited: false,
      animationType: "byComputedValueType",
      percentages: "relativeToTheScrollContainersScrollport",
      groups: [
        "CSS Scroll Snap"
      ],
      initial: "auto",
      appliesto: "scrollContainers",
      computed: "asSpecified",
      order: "perGrammar",
      status: "standard",
      mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-padding-left"
    },
    "scroll-padding-right": {
      syntax: "auto | <length-percentage>",
      media: "visual",
      inherited: false,
      animationType: "byComputedValueType",
      percentages: "relativeToTheScrollContainersScrollport",
      groups: [
        "CSS Scroll Snap"
      ],
      initial: "auto",
      appliesto: "scrollContainers",
      computed: "asSpecified",
      order: "perGrammar",
      status: "standard",
      mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-padding-right"
    },
    "scroll-padding-top": {
      syntax: "auto | <length-percentage>",
      media: "visual",
      inherited: false,
      animationType: "byComputedValueType",
      percentages: "relativeToTheScrollContainersScrollport",
      groups: [
        "CSS Scroll Snap"
      ],
      initial: "auto",
      appliesto: "scrollContainers",
      computed: "asSpecified",
      order: "perGrammar",
      status: "standard",
      mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-padding-top"
    },
    "scroll-snap-align": {
      syntax: "[ none | start | end | center ]{1,2}",
      media: "visual",
      inherited: false,
      animationType: "discrete",
      percentages: "no",
      groups: [
        "CSS Scroll Snap"
      ],
      initial: "none",
      appliesto: "allElements",
      computed: "asSpecified",
      order: "perGrammar",
      status: "standard",
      mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-snap-align"
    },
    "scroll-snap-coordinate": {
      syntax: "none | <position>#",
      media: "interactive",
      inherited: false,
      animationType: "position",
      percentages: "referToBorderBox",
      groups: [
        "CSS Scroll Snap"
      ],
      initial: "none",
      appliesto: "allElements",
      computed: "asSpecifiedRelativeToAbsoluteLengths",
      order: "uniqueOrder",
      status: "obsolete",
      mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-snap-coordinate"
    },
    "scroll-snap-destination": {
      syntax: "<position>",
      media: "interactive",
      inherited: false,
      animationType: "position",
      percentages: "relativeToScrollContainerPaddingBoxAxis",
      groups: [
        "CSS Scroll Snap"
      ],
      initial: "0px 0px",
      appliesto: "scrollContainers",
      computed: "asSpecifiedRelativeToAbsoluteLengths",
      order: "uniqueOrder",
      status: "obsolete",
      mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-snap-destination"
    },
    "scroll-snap-points-x": {
      syntax: "none | repeat( <length-percentage> )",
      media: "interactive",
      inherited: false,
      animationType: "discrete",
      percentages: "relativeToScrollContainerPaddingBoxAxis",
      groups: [
        "CSS Scroll Snap"
      ],
      initial: "none",
      appliesto: "scrollContainers",
      computed: "asSpecifiedRelativeToAbsoluteLengths",
      order: "uniqueOrder",
      status: "obsolete",
      mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-snap-points-x"
    },
    "scroll-snap-points-y": {
      syntax: "none | repeat( <length-percentage> )",
      media: "interactive",
      inherited: false,
      animationType: "discrete",
      percentages: "relativeToScrollContainerPaddingBoxAxis",
      groups: [
        "CSS Scroll Snap"
      ],
      initial: "none",
      appliesto: "scrollContainers",
      computed: "asSpecifiedRelativeToAbsoluteLengths",
      order: "uniqueOrder",
      status: "obsolete",
      mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-snap-points-y"
    },
    "scroll-snap-stop": {
      syntax: "normal | always",
      media: "visual",
      inherited: false,
      animationType: "discrete",
      percentages: "no",
      groups: [
        "CSS Scroll Snap"
      ],
      initial: "normal",
      appliesto: "allElements",
      computed: "asSpecified",
      order: "perGrammar",
      status: "standard",
      mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-snap-stop"
    },
    "scroll-snap-type": {
      syntax: "none | [ x | y | block | inline | both ] [ mandatory | proximity ]?",
      media: "interactive",
      inherited: false,
      animationType: "discrete",
      percentages: "no",
      groups: [
        "CSS Scroll Snap"
      ],
      initial: "none",
      appliesto: "allElements",
      computed: "asSpecified",
      order: "uniqueOrder",
      status: "standard",
      mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-snap-type"
    },
    "scroll-snap-type-x": {
      syntax: "none | mandatory | proximity",
      media: "interactive",
      inherited: false,
      animationType: "discrete",
      percentages: "no",
      groups: [
        "CSS Scroll Snap"
      ],
      initial: "none",
      appliesto: "scrollContainers",
      computed: "asSpecified",
      order: "uniqueOrder",
      status: "obsolete",
      mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-snap-type-x"
    },
    "scroll-snap-type-y": {
      syntax: "none | mandatory | proximity",
      media: "interactive",
      inherited: false,
      animationType: "discrete",
      percentages: "no",
      groups: [
        "CSS Scroll Snap"
      ],
      initial: "none",
      appliesto: "scrollContainers",
      computed: "asSpecified",
      order: "uniqueOrder",
      status: "obsolete",
      mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-snap-type-y"
    },
    "shape-image-threshold": {
      syntax: "<alpha-value>",
      media: "visual",
      inherited: false,
      animationType: "number",
      percentages: "no",
      groups: [
        "CSS Shapes"
      ],
      initial: "0.0",
      appliesto: "floats",
      computed: "specifiedValueNumberClipped0To1",
      order: "uniqueOrder",
      status: "standard",
      mdn_url: "https://developer.mozilla.org/docs/Web/CSS/shape-image-threshold"
    },
    "shape-margin": {
      syntax: "<length-percentage>",
      media: "visual",
      inherited: false,
      animationType: "lpc",
      percentages: "referToWidthOfContainingBlock",
      groups: [
        "CSS Shapes"
      ],
      initial: "0",
      appliesto: "floats",
      computed: "asSpecifiedRelativeToAbsoluteLengths",
      order: "uniqueOrder",
      status: "standard",
      mdn_url: "https://developer.mozilla.org/docs/Web/CSS/shape-margin"
    },
    "shape-outside": {
      syntax: "none | [ <shape-box> || <basic-shape> ] | <image>",
      media: "visual",
      inherited: false,
      animationType: "basicShapeOtherwiseNo",
      percentages: "no",
      groups: [
        "CSS Shapes"
      ],
      initial: "none",
      appliesto: "floats",
      computed: "asDefinedForBasicShapeWithAbsoluteURIOtherwiseAsSpecified",
      order: "uniqueOrder",
      status: "standard",
      mdn_url: "https://developer.mozilla.org/docs/Web/CSS/shape-outside"
    },
    "tab-size": {
      syntax: "<integer> | <length>",
      media: "visual",
      inherited: true,
      animationType: "length",
      percentages: "no",
      groups: [
        "CSS Text"
      ],
      initial: "8",
      appliesto: "blockContainers",
      computed: "specifiedIntegerOrAbsoluteLength",
      order: "uniqueOrder",
      status: "standard",
      mdn_url: "https://developer.mozilla.org/docs/Web/CSS/tab-size"
    },
    "table-layout": {
      syntax: "auto | fixed",
      media: "visual",
      inherited: false,
      animationType: "discrete",
      percentages: "no",
      groups: [
        "CSS Table"
      ],
      initial: "auto",
      appliesto: "tableElements",
      computed: "asSpecified",
      order: "uniqueOrder",
      status: "standard",
      mdn_url: "https://developer.mozilla.org/docs/Web/CSS/table-layout"
    },
    "text-align": {
      syntax: "start | end | left | right | center | justify | match-parent",
      media: "visual",
      inherited: true,
      animationType: "discrete",
      percentages: "no",
      groups: [
        "CSS Text"
      ],
      initial: "startOrNamelessValueIfLTRRightIfRTL",
      appliesto: "blockContainers",
      computed: "asSpecifiedExceptMatchParent",
      order: "orderOfAppearance",
      alsoAppliesTo: [
        "::placeholder"
      ],
      status: "standard",
      mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-align"
    },
    "text-align-last": {
      syntax: "auto | start | end | left | right | center | justify",
      media: "visual",
      inherited: true,
      animationType: "discrete",
      percentages: "no",
      groups: [
        "CSS Text"
      ],
      initial: "auto",
      appliesto: "blockContainers",
      computed: "asSpecified",
      order: "uniqueOrder",
      status: "standard",
      mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-align-last"
    },
    "text-combine-upright": {
      syntax: "none | all | [ digits <integer>? ]",
      media: "visual",
      inherited: true,
      animationType: "notAnimatable",
      percentages: "no",
      groups: [
        "CSS Writing Modes"
      ],
      initial: "none",
      appliesto: "nonReplacedInlineElements",
      computed: "keywordPlusIntegerIfDigits",
      order: "uniqueOrder",
      status: "standard",
      mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-combine-upright"
    },
    "text-decoration": {
      syntax: "<'text-decoration-line'> || <'text-decoration-style'> || <'text-decoration-color'> || <'text-decoration-thickness'>",
      media: "visual",
      inherited: false,
      animationType: [
        "text-decoration-color",
        "text-decoration-style",
        "text-decoration-line",
        "text-decoration-thickness"
      ],
      percentages: "no",
      groups: [
        "CSS Text Decoration"
      ],
      initial: [
        "text-decoration-color",
        "text-decoration-style",
        "text-decoration-line"
      ],
      appliesto: "allElements",
      computed: [
        "text-decoration-line",
        "text-decoration-style",
        "text-decoration-color",
        "text-decoration-thickness"
      ],
      order: "orderOfAppearance",
      alsoAppliesTo: [
        "::first-letter",
        "::first-line",
        "::placeholder"
      ],
      status: "standard",
      mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-decoration"
    },
    "text-decoration-color": {
      syntax: "<color>",
      media: "visual",
      inherited: false,
      animationType: "color",
      percentages: "no",
      groups: [
        "CSS Text Decoration"
      ],
      initial: "currentcolor",
      appliesto: "allElements",
      computed: "computedColor",
      order: "uniqueOrder",
      alsoAppliesTo: [
        "::first-letter",
        "::first-line",
        "::placeholder"
      ],
      status: "standard",
      mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-decoration-color"
    },
    "text-decoration-line": {
      syntax: "none | [ underline || overline || line-through || blink ] | spelling-error | grammar-error",
      media: "visual",
      inherited: false,
      animationType: "discrete",
      percentages: "no",
      groups: [
        "CSS Text Decoration"
      ],
      initial: "none",
      appliesto: "allElements",
      computed: "asSpecified",
      order: "orderOfAppearance",
      alsoAppliesTo: [
        "::first-letter",
        "::first-line",
        "::placeholder"
      ],
      status: "standard",
      mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-decoration-line"
    },
    "text-decoration-skip": {
      syntax: "none | [ objects || [ spaces | [ leading-spaces || trailing-spaces ] ] || edges || box-decoration ]",
      media: "visual",
      inherited: true,
      animationType: "discrete",
      percentages: "no",
      groups: [
        "CSS Text Decoration"
      ],
      initial: "objects",
      appliesto: "allElements",
      computed: "asSpecified",
      order: "orderOfAppearance",
      status: "experimental",
      mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-decoration-skip"
    },
    "text-decoration-skip-ink": {
      syntax: "auto | all | none",
      media: "visual",
      inherited: true,
      animationType: "discrete",
      percentages: "no",
      groups: [
        "CSS Text Decoration"
      ],
      initial: "auto",
      appliesto: "allElements",
      computed: "asSpecified",
      order: "orderOfAppearance",
      status: "standard",
      mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-decoration-skip-ink"
    },
    "text-decoration-style": {
      syntax: "solid | double | dotted | dashed | wavy",
      media: "visual",
      inherited: false,
      animationType: "discrete",
      percentages: "no",
      groups: [
        "CSS Text Decoration"
      ],
      initial: "solid",
      appliesto: "allElements",
      computed: "asSpecified",
      order: "uniqueOrder",
      alsoAppliesTo: [
        "::first-letter",
        "::first-line",
        "::placeholder"
      ],
      status: "standard",
      mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-decoration-style"
    },
    "text-decoration-thickness": {
      syntax: "auto | from-font | <length> | <percentage> ",
      media: "visual",
      inherited: false,
      animationType: "byComputedValueType",
      percentages: "referToElementFontSize",
      groups: [
        "CSS Text Decoration"
      ],
      initial: "auto",
      appliesto: "allElements",
      computed: "asSpecified",
      order: "uniqueOrder",
      alsoAppliesTo: [
        "::first-letter",
        "::first-line",
        "::placeholder"
      ],
      status: "standard",
      mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-decoration-thickness"
    },
    "text-emphasis": {
      syntax: "<'text-emphasis-style'> || <'text-emphasis-color'>",
      media: "visual",
      inherited: false,
      animationType: [
        "text-emphasis-color",
        "text-emphasis-style"
      ],
      percentages: "no",
      groups: [
        "CSS Text Decoration"
      ],
      initial: [
        "text-emphasis-style",
        "text-emphasis-color"
      ],
      appliesto: "allElements",
      computed: [
        "text-emphasis-style",
        "text-emphasis-color"
      ],
      order: "orderOfAppearance",
      status: "standard",
      mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-emphasis"
    },
    "text-emphasis-color": {
      syntax: "<color>",
      media: "visual",
      inherited: false,
      animationType: "color",
      percentages: "no",
      groups: [
        "CSS Text Decoration"
      ],
      initial: "currentcolor",
      appliesto: "allElements",
      computed: "computedColor",
      order: "uniqueOrder",
      status: "standard",
      mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-emphasis-color"
    },
    "text-emphasis-position": {
      syntax: "[ over | under ] && [ right | left ]",
      media: "visual",
      inherited: false,
      animationType: "discrete",
      percentages: "no",
      groups: [
        "CSS Text Decoration"
      ],
      initial: "over right",
      appliesto: "allElements",
      computed: "asSpecified",
      order: "uniqueOrder",
      status: "standard",
      mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-emphasis-position"
    },
    "text-emphasis-style": {
      syntax: "none | [ [ filled | open ] || [ dot | circle | double-circle | triangle | sesame ] ] | <string>",
      media: "visual",
      inherited: false,
      animationType: "discrete",
      percentages: "no",
      groups: [
        "CSS Text Decoration"
      ],
      initial: "none",
      appliesto: "allElements",
      computed: "asSpecified",
      order: "uniqueOrder",
      status: "standard",
      mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-emphasis-style"
    },
    "text-indent": {
      syntax: "<length-percentage> && hanging? && each-line?",
      media: "visual",
      inherited: true,
      animationType: "lpc",
      percentages: "referToWidthOfContainingBlock",
      groups: [
        "CSS Text"
      ],
      initial: "0",
      appliesto: "blockContainers",
      computed: "percentageOrAbsoluteLengthPlusKeywords",
      order: "lengthOrPercentageBeforeKeywords",
      status: "standard",
      mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-indent"
    },
    "text-justify": {
      syntax: "auto | inter-character | inter-word | none",
      media: "visual",
      inherited: true,
      animationType: "discrete",
      percentages: "no",
      groups: [
        "CSS Text"
      ],
      initial: "auto",
      appliesto: "inlineLevelAndTableCellElements",
      computed: "asSpecified",
      order: "uniqueOrder",
      status: "standard",
      mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-justify"
    },
    "text-orientation": {
      syntax: "mixed | upright | sideways",
      media: "visual",
      inherited: true,
      animationType: "discrete",
      percentages: "no",
      groups: [
        "CSS Writing Modes"
      ],
      initial: "mixed",
      appliesto: "allElementsExceptTableRowGroupsRowsColumnGroupsAndColumns",
      computed: "asSpecified",
      order: "uniqueOrder",
      status: "standard",
      mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-orientation"
    },
    "text-overflow": {
      syntax: "[ clip | ellipsis | <string> ]{1,2}",
      media: "visual",
      inherited: false,
      animationType: "discrete",
      percentages: "no",
      groups: [
        "CSS Basic User Interface"
      ],
      initial: "clip",
      appliesto: "blockContainerElements",
      computed: "asSpecified",
      order: "uniqueOrder",
      alsoAppliesTo: [
        "::placeholder"
      ],
      status: "standard",
      mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-overflow"
    },
    "text-rendering": {
      syntax: "auto | optimizeSpeed | optimizeLegibility | geometricPrecision",
      media: "visual",
      inherited: true,
      animationType: "discrete",
      percentages: "no",
      groups: [
        "CSS Miscellaneous"
      ],
      initial: "auto",
      appliesto: "textElements",
      computed: "asSpecified",
      order: "uniqueOrder",
      status: "standard",
      mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-rendering"
    },
    "text-shadow": {
      syntax: "none | <shadow-t>#",
      media: "visual",
      inherited: true,
      animationType: "shadowList",
      percentages: "no",
      groups: [
        "CSS Text Decoration"
      ],
      initial: "none",
      appliesto: "allElements",
      computed: "colorPlusThreeAbsoluteLengths",
      order: "uniqueOrder",
      alsoAppliesTo: [
        "::first-letter",
        "::first-line",
        "::placeholder"
      ],
      status: "standard",
      mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-shadow"
    },
    "text-size-adjust": {
      syntax: "none | auto | <percentage>",
      media: "visual",
      inherited: true,
      animationType: "discrete",
      percentages: "referToSizeOfFont",
      groups: [
        "CSS Text"
      ],
      initial: "autoForSmartphoneBrowsersSupportingInflation",
      appliesto: "allElements",
      computed: "asSpecified",
      order: "uniqueOrder",
      status: "experimental",
      mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-size-adjust"
    },
    "text-transform": {
      syntax: "none | capitalize | uppercase | lowercase | full-width | full-size-kana",
      media: "visual",
      inherited: true,
      animationType: "discrete",
      percentages: "no",
      groups: [
        "CSS Text"
      ],
      initial: "none",
      appliesto: "allElements",
      computed: "asSpecified",
      order: "uniqueOrder",
      alsoAppliesTo: [
        "::first-letter",
        "::first-line",
        "::placeholder"
      ],
      status: "standard",
      mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-transform"
    },
    "text-underline-offset": {
      syntax: "auto | <length> | <percentage> ",
      media: "visual",
      inherited: true,
      animationType: "byComputedValueType",
      percentages: "referToElementFontSize",
      groups: [
        "CSS Text Decoration"
      ],
      initial: "auto",
      appliesto: "allElements",
      computed: "asSpecified",
      order: "uniqueOrder",
      alsoAppliesTo: [
        "::first-letter",
        "::first-line",
        "::placeholder"
      ],
      status: "standard",
      mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-underline-offset"
    },
    "text-underline-position": {
      syntax: "auto | from-font | [ under || [ left | right ] ]",
      media: "visual",
      inherited: true,
      animationType: "discrete",
      percentages: "no",
      groups: [
        "CSS Text Decoration"
      ],
      initial: "auto",
      appliesto: "allElements",
      computed: "asSpecified",
      order: "orderOfAppearance",
      status: "standard",
      mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-underline-position"
    },
    top: {
      syntax: "<length> | <percentage> | auto",
      media: "visual",
      inherited: false,
      animationType: "lpc",
      percentages: "referToContainingBlockHeight",
      groups: [
        "CSS Positioning"
      ],
      initial: "auto",
      appliesto: "positionedElements",
      computed: "lengthAbsolutePercentageAsSpecifiedOtherwiseAuto",
      order: "uniqueOrder",
      status: "standard",
      mdn_url: "https://developer.mozilla.org/docs/Web/CSS/top"
    },
    "touch-action": {
      syntax: "auto | none | [ [ pan-x | pan-left | pan-right ] || [ pan-y | pan-up | pan-down ] || pinch-zoom ] | manipulation",
      media: "visual",
      inherited: false,
      animationType: "discrete",
      percentages: "no",
      groups: [
        "Pointer Events"
      ],
      initial: "auto",
      appliesto: "allElementsExceptNonReplacedInlineElementsTableRowsColumnsRowColumnGroups",
      computed: "asSpecified",
      order: "uniqueOrder",
      status: "standard",
      mdn_url: "https://developer.mozilla.org/docs/Web/CSS/touch-action"
    },
    transform: {
      syntax: "none | <transform-list>",
      media: "visual",
      inherited: false,
      animationType: "transform",
      percentages: "referToSizeOfBoundingBox",
      groups: [
        "CSS Transforms"
      ],
      initial: "none",
      appliesto: "transformableElements",
      computed: "asSpecifiedRelativeToAbsoluteLengths",
      order: "uniqueOrder",
      stacking: true,
      status: "standard",
      mdn_url: "https://developer.mozilla.org/docs/Web/CSS/transform"
    },
    "transform-box": {
      syntax: "content-box | border-box | fill-box | stroke-box | view-box",
      media: "visual",
      inherited: false,
      animationType: "discrete",
      percentages: "no",
      groups: [
        "CSS Transforms"
      ],
      initial: "view-box",
      appliesto: "transformableElements",
      computed: "asSpecified",
      order: "perGrammar",
      status: "standard",
      mdn_url: "https://developer.mozilla.org/docs/Web/CSS/transform-box"
    },
    "transform-origin": {
      syntax: "[ <length-percentage> | left | center | right | top | bottom ] | [ [ <length-percentage> | left | center | right ] && [ <length-percentage> | top | center | bottom ] ] <length>?",
      media: "visual",
      inherited: false,
      animationType: "simpleListOfLpc",
      percentages: "referToSizeOfBoundingBox",
      groups: [
        "CSS Transforms"
      ],
      initial: "50% 50% 0",
      appliesto: "transformableElements",
      computed: "forLengthAbsoluteValueOtherwisePercentage",
      order: "oneOrTwoValuesLengthAbsoluteKeywordsPercentages",
      status: "standard",
      mdn_url: "https://developer.mozilla.org/docs/Web/CSS/transform-origin"
    },
    "transform-style": {
      syntax: "flat | preserve-3d",
      media: "visual",
      inherited: false,
      animationType: "discrete",
      percentages: "no",
      groups: [
        "CSS Transforms"
      ],
      initial: "flat",
      appliesto: "transformableElements",
      computed: "asSpecified",
      order: "uniqueOrder",
      stacking: true,
      status: "standard",
      mdn_url: "https://developer.mozilla.org/docs/Web/CSS/transform-style"
    },
    transition: {
      syntax: "<single-transition>#",
      media: "interactive",
      inherited: false,
      animationType: "discrete",
      percentages: "no",
      groups: [
        "CSS Transitions"
      ],
      initial: [
        "transition-delay",
        "transition-duration",
        "transition-property",
        "transition-timing-function"
      ],
      appliesto: "allElementsAndPseudos",
      computed: [
        "transition-delay",
        "transition-duration",
        "transition-property",
        "transition-timing-function"
      ],
      order: "orderOfAppearance",
      status: "standard",
      mdn_url: "https://developer.mozilla.org/docs/Web/CSS/transition"
    },
    "transition-delay": {
      syntax: "<time>#",
      media: "interactive",
      inherited: false,
      animationType: "discrete",
      percentages: "no",
      groups: [
        "CSS Transitions"
      ],
      initial: "0s",
      appliesto: "allElementsAndPseudos",
      computed: "asSpecified",
      order: "uniqueOrder",
      status: "standard",
      mdn_url: "https://developer.mozilla.org/docs/Web/CSS/transition-delay"
    },
    "transition-duration": {
      syntax: "<time>#",
      media: "interactive",
      inherited: false,
      animationType: "discrete",
      percentages: "no",
      groups: [
        "CSS Transitions"
      ],
      initial: "0s",
      appliesto: "allElementsAndPseudos",
      computed: "asSpecified",
      order: "uniqueOrder",
      status: "standard",
      mdn_url: "https://developer.mozilla.org/docs/Web/CSS/transition-duration"
    },
    "transition-property": {
      syntax: "none | <single-transition-property>#",
      media: "visual",
      inherited: false,
      animationType: "discrete",
      percentages: "no",
      groups: [
        "CSS Transitions"
      ],
      initial: "all",
      appliesto: "allElementsAndPseudos",
      computed: "asSpecified",
      order: "uniqueOrder",
      status: "standard",
      mdn_url: "https://developer.mozilla.org/docs/Web/CSS/transition-property"
    },
    "transition-timing-function": {
      syntax: "<easing-function>#",
      media: "interactive",
      inherited: false,
      animationType: "discrete",
      percentages: "no",
      groups: [
        "CSS Transitions"
      ],
      initial: "ease",
      appliesto: "allElementsAndPseudos",
      computed: "asSpecified",
      order: "uniqueOrder",
      status: "standard",
      mdn_url: "https://developer.mozilla.org/docs/Web/CSS/transition-timing-function"
    },
    translate: {
      syntax: "none | <length-percentage> [ <length-percentage> <length>? ]?",
      media: "visual",
      inherited: false,
      animationType: "transform",
      percentages: "referToSizeOfBoundingBox",
      groups: [
        "CSS Transforms"
      ],
      initial: "none",
      appliesto: "transformableElements",
      computed: "asSpecifiedRelativeToAbsoluteLengths",
      order: "perGrammar",
      stacking: true,
      status: "standard",
      mdn_url: "https://developer.mozilla.org/docs/Web/CSS/translate"
    },
    "unicode-bidi": {
      syntax: "normal | embed | isolate | bidi-override | isolate-override | plaintext",
      media: "visual",
      inherited: false,
      animationType: "discrete",
      percentages: "no",
      groups: [
        "CSS Writing Modes"
      ],
      initial: "normal",
      appliesto: "allElementsSomeValuesNoEffectOnNonInlineElements",
      computed: "asSpecified",
      order: "uniqueOrder",
      status: "standard",
      mdn_url: "https://developer.mozilla.org/docs/Web/CSS/unicode-bidi"
    },
    "user-select": {
      syntax: "auto | text | none | contain | all",
      media: "visual",
      inherited: false,
      animationType: "discrete",
      percentages: "no",
      groups: [
        "CSS Basic User Interface"
      ],
      initial: "auto",
      appliesto: "allElements",
      computed: "asSpecified",
      order: "uniqueOrder",
      status: "standard",
      mdn_url: "https://developer.mozilla.org/docs/Web/CSS/user-select"
    },
    "vertical-align": {
      syntax: "baseline | sub | super | text-top | text-bottom | middle | top | bottom | <percentage> | <length>",
      media: "visual",
      inherited: false,
      animationType: "length",
      percentages: "referToLineHeight",
      groups: [
        "CSS Table"
      ],
      initial: "baseline",
      appliesto: "inlineLevelAndTableCellElements",
      computed: "absoluteLengthOrKeyword",
      order: "uniqueOrder",
      alsoAppliesTo: [
        "::first-letter",
        "::first-line",
        "::placeholder"
      ],
      status: "standard",
      mdn_url: "https://developer.mozilla.org/docs/Web/CSS/vertical-align"
    },
    visibility: {
      syntax: "visible | hidden | collapse",
      media: "visual",
      inherited: true,
      animationType: "visibility",
      percentages: "no",
      groups: [
        "CSS Box Model"
      ],
      initial: "visible",
      appliesto: "allElements",
      computed: "asSpecified",
      order: "uniqueOrder",
      status: "standard",
      mdn_url: "https://developer.mozilla.org/docs/Web/CSS/visibility"
    },
    "white-space": {
      syntax: "normal | pre | nowrap | pre-wrap | pre-line | break-spaces",
      media: "visual",
      inherited: true,
      animationType: "discrete",
      percentages: "no",
      groups: [
        "CSS Text"
      ],
      initial: "normal",
      appliesto: "allElements",
      computed: "asSpecified",
      order: "uniqueOrder",
      status: "standard",
      mdn_url: "https://developer.mozilla.org/docs/Web/CSS/white-space"
    },
    widows: {
      syntax: "<integer>",
      media: "visual",
      inherited: true,
      animationType: "discrete",
      percentages: "no",
      groups: [
        "CSS Fragmentation"
      ],
      initial: "2",
      appliesto: "blockContainerElements",
      computed: "asSpecified",
      order: "perGrammar",
      status: "standard",
      mdn_url: "https://developer.mozilla.org/docs/Web/CSS/widows"
    },
    width: {
      syntax: "auto | <length> | <percentage> | min-content | max-content | fit-content | fit-content(<length-percentage>)",
      media: "visual",
      inherited: false,
      animationType: "lpc",
      percentages: "referToWidthOfContainingBlock",
      groups: [
        "CSS Box Model"
      ],
      initial: "auto",
      appliesto: "allElementsButNonReplacedAndTableRows",
      computed: "percentageAutoOrAbsoluteLength",
      order: "lengthOrPercentageBeforeKeywordIfBothPresent",
      status: "standard",
      mdn_url: "https://developer.mozilla.org/docs/Web/CSS/width"
    },
    "will-change": {
      syntax: "auto | <animateable-feature>#",
      media: "all",
      inherited: false,
      animationType: "discrete",
      percentages: "no",
      groups: [
        "CSS Will Change"
      ],
      initial: "auto",
      appliesto: "allElements",
      computed: "asSpecified",
      order: "uniqueOrder",
      status: "standard",
      mdn_url: "https://developer.mozilla.org/docs/Web/CSS/will-change"
    },
    "word-break": {
      syntax: "normal | break-all | keep-all | break-word",
      media: "visual",
      inherited: true,
      animationType: "discrete",
      percentages: "no",
      groups: [
        "CSS Text"
      ],
      initial: "normal",
      appliesto: "allElements",
      computed: "asSpecified",
      order: "uniqueOrder",
      status: "standard",
      mdn_url: "https://developer.mozilla.org/docs/Web/CSS/word-break"
    },
    "word-spacing": {
      syntax: "normal | <length>",
      media: "visual",
      inherited: true,
      animationType: "length",
      percentages: "referToWidthOfAffectedGlyph",
      groups: [
        "CSS Text"
      ],
      initial: "normal",
      appliesto: "allElements",
      computed: "optimumMinAndMaxValueOfAbsoluteLengthPercentageOrNormal",
      order: "uniqueOrder",
      alsoAppliesTo: [
        "::first-letter",
        "::first-line",
        "::placeholder"
      ],
      status: "standard",
      mdn_url: "https://developer.mozilla.org/docs/Web/CSS/word-spacing"
    },
    "word-wrap": {
      syntax: "normal | break-word",
      media: "visual",
      inherited: true,
      animationType: "discrete",
      percentages: "no",
      groups: [
        "CSS Text"
      ],
      initial: "normal",
      appliesto: "nonReplacedInlineElements",
      computed: "asSpecified",
      order: "uniqueOrder",
      status: "standard",
      mdn_url: "https://developer.mozilla.org/docs/Web/CSS/overflow-wrap"
    },
    "writing-mode": {
      syntax: "horizontal-tb | vertical-rl | vertical-lr | sideways-rl | sideways-lr",
      media: "visual",
      inherited: true,
      animationType: "discrete",
      percentages: "no",
      groups: [
        "CSS Writing Modes"
      ],
      initial: "horizontal-tb",
      appliesto: "allElementsExceptTableRowColumnGroupsTableRowsColumns",
      computed: "asSpecified",
      order: "uniqueOrder",
      status: "standard",
      mdn_url: "https://developer.mozilla.org/docs/Web/CSS/writing-mode"
    },
    "z-index": {
      syntax: "auto | <integer>",
      media: "visual",
      inherited: false,
      animationType: "integer",
      percentages: "no",
      groups: [
        "CSS Positioning"
      ],
      initial: "auto",
      appliesto: "positionedElements",
      computed: "asSpecified",
      order: "uniqueOrder",
      stacking: true,
      status: "standard",
      mdn_url: "https://developer.mozilla.org/docs/Web/CSS/z-index"
    },
    zoom: {
      syntax: "normal | reset | <number> | <percentage>",
      media: "visual",
      inherited: false,
      animationType: "integer",
      percentages: "no",
      groups: [
        "Microsoft Extensions"
      ],
      initial: "normal",
      appliesto: "allElements",
      computed: "asSpecified",
      order: "uniqueOrder",
      status: "nonstandard",
      mdn_url: "https://developer.mozilla.org/docs/Web/CSS/zoom"
    }
  };
});

// ../../../../node_modules/.bun/mdn-data@2.0.28/node_modules/mdn-data/css/syntaxes.json
var require_syntaxes2 = __commonJS((exports, module) => {
  module.exports = {
    "absolute-size": {
      syntax: "xx-small | x-small | small | medium | large | x-large | xx-large | xxx-large"
    },
    "alpha-value": {
      syntax: "<number> | <percentage>"
    },
    "angle-percentage": {
      syntax: "<angle> | <percentage>"
    },
    "angular-color-hint": {
      syntax: "<angle-percentage>"
    },
    "angular-color-stop": {
      syntax: "<color> && <color-stop-angle>?"
    },
    "angular-color-stop-list": {
      syntax: "[ <angular-color-stop> [, <angular-color-hint>]? ]# , <angular-color-stop>"
    },
    "animateable-feature": {
      syntax: "scroll-position | contents | <custom-ident>"
    },
    attachment: {
      syntax: "scroll | fixed | local"
    },
    "attr()": {
      syntax: "attr( <attr-name> <type-or-unit>? [, <attr-fallback> ]? )"
    },
    "attr-matcher": {
      syntax: "[ '~' | '|' | '^' | '$' | '*' ]? '='"
    },
    "attr-modifier": {
      syntax: "i | s"
    },
    "attribute-selector": {
      syntax: "'[' <wq-name> ']' | '[' <wq-name> <attr-matcher> [ <string-token> | <ident-token> ] <attr-modifier>? ']'"
    },
    "auto-repeat": {
      syntax: "repeat( [ auto-fill | auto-fit ] , [ <line-names>? <fixed-size> ]+ <line-names>? )"
    },
    "auto-track-list": {
      syntax: `[ <line-names>? [ <fixed-size> | <fixed-repeat> ] ]* <line-names>? <auto-repeat>
[ <line-names>? [ <fixed-size> | <fixed-repeat> ] ]* <line-names>?`
    },
    "baseline-position": {
      syntax: "[ first | last ]? baseline"
    },
    "basic-shape": {
      syntax: "<inset()> | <circle()> | <ellipse()> | <polygon()> | <path()>"
    },
    "bg-image": {
      syntax: "none | <image>"
    },
    "bg-layer": {
      syntax: "<bg-image> || <bg-position> [ / <bg-size> ]? || <repeat-style> || <attachment> || <box> || <box>"
    },
    "bg-position": {
      syntax: "[ [ left | center | right | top | bottom | <length-percentage> ] | [ left | center | right | <length-percentage> ] [ top | center | bottom | <length-percentage> ] | [ center | [ left | right ] <length-percentage>? ] && [ center | [ top | bottom ] <length-percentage>? ] ]"
    },
    "bg-size": {
      syntax: "[ <length-percentage> | auto ]{1,2} | cover | contain"
    },
    "blur()": {
      syntax: "blur( <length> )"
    },
    "blend-mode": {
      syntax: "normal | multiply | screen | overlay | darken | lighten | color-dodge | color-burn | hard-light | soft-light | difference | exclusion | hue | saturation | color | luminosity"
    },
    box: {
      syntax: "border-box | padding-box | content-box"
    },
    "brightness()": {
      syntax: "brightness( <number-percentage> )"
    },
    "calc()": {
      syntax: "calc( <calc-sum> )"
    },
    "calc-sum": {
      syntax: "<calc-product> [ [ '+' | '-' ] <calc-product> ]*"
    },
    "calc-product": {
      syntax: "<calc-value> [ '*' <calc-value> | '/' <number> ]*"
    },
    "calc-value": {
      syntax: "<number> | <dimension> | <percentage> | ( <calc-sum> )"
    },
    "cf-final-image": {
      syntax: "<image> | <color>"
    },
    "cf-mixing-image": {
      syntax: "<percentage>? && <image>"
    },
    "circle()": {
      syntax: "circle( [ <shape-radius> ]? [ at <position> ]? )"
    },
    "clamp()": {
      syntax: "clamp( <calc-sum>#{3} )"
    },
    "class-selector": {
      syntax: "'.' <ident-token>"
    },
    "clip-source": {
      syntax: "<url>"
    },
    color: {
      syntax: "<rgb()> | <rgba()> | <hsl()> | <hsla()> | <hwb()> | <lab()> | <lch()> | <hex-color> | <named-color> | currentcolor | <deprecated-system-color>"
    },
    "color-stop": {
      syntax: "<color-stop-length> | <color-stop-angle>"
    },
    "color-stop-angle": {
      syntax: "<angle-percentage>{1,2}"
    },
    "color-stop-length": {
      syntax: "<length-percentage>{1,2}"
    },
    "color-stop-list": {
      syntax: "[ <linear-color-stop> [, <linear-color-hint>]? ]# , <linear-color-stop>"
    },
    combinator: {
      syntax: "'>' | '+' | '~' | [ '||' ]"
    },
    "common-lig-values": {
      syntax: "[ common-ligatures | no-common-ligatures ]"
    },
    "compat-auto": {
      syntax: "searchfield | textarea | push-button | slider-horizontal | checkbox | radio | square-button | menulist | listbox | meter | progress-bar | button"
    },
    "composite-style": {
      syntax: "clear | copy | source-over | source-in | source-out | source-atop | destination-over | destination-in | destination-out | destination-atop | xor"
    },
    "compositing-operator": {
      syntax: "add | subtract | intersect | exclude"
    },
    "compound-selector": {
      syntax: "[ <type-selector>? <subclass-selector>* [ <pseudo-element-selector> <pseudo-class-selector>* ]* ]!"
    },
    "compound-selector-list": {
      syntax: "<compound-selector>#"
    },
    "complex-selector": {
      syntax: "<compound-selector> [ <combinator>? <compound-selector> ]*"
    },
    "complex-selector-list": {
      syntax: "<complex-selector>#"
    },
    "conic-gradient()": {
      syntax: "conic-gradient( [ from <angle> ]? [ at <position> ]?, <angular-color-stop-list> )"
    },
    "contextual-alt-values": {
      syntax: "[ contextual | no-contextual ]"
    },
    "content-distribution": {
      syntax: "space-between | space-around | space-evenly | stretch"
    },
    "content-list": {
      syntax: "[ <string> | contents | <image> | <counter> | <quote> | <target> | <leader()> ]+"
    },
    "content-position": {
      syntax: "center | start | end | flex-start | flex-end"
    },
    "content-replacement": {
      syntax: "<image>"
    },
    "contrast()": {
      syntax: "contrast( [ <number-percentage> ] )"
    },
    counter: {
      syntax: "<counter()> | <counters()>"
    },
    "counter()": {
      syntax: "counter( <counter-name>, <counter-style>? )"
    },
    "counter-name": {
      syntax: "<custom-ident>"
    },
    "counter-style": {
      syntax: "<counter-style-name> | symbols()"
    },
    "counter-style-name": {
      syntax: "<custom-ident>"
    },
    "counters()": {
      syntax: "counters( <counter-name>, <string>, <counter-style>? )"
    },
    "cross-fade()": {
      syntax: "cross-fade( <cf-mixing-image> , <cf-final-image>? )"
    },
    "cubic-bezier-timing-function": {
      syntax: "ease | ease-in | ease-out | ease-in-out | cubic-bezier(<number [0,1]>, <number>, <number [0,1]>, <number>)"
    },
    "deprecated-system-color": {
      syntax: "ActiveBorder | ActiveCaption | AppWorkspace | Background | ButtonFace | ButtonHighlight | ButtonShadow | ButtonText | CaptionText | GrayText | Highlight | HighlightText | InactiveBorder | InactiveCaption | InactiveCaptionText | InfoBackground | InfoText | Menu | MenuText | Scrollbar | ThreeDDarkShadow | ThreeDFace | ThreeDHighlight | ThreeDLightShadow | ThreeDShadow | Window | WindowFrame | WindowText"
    },
    "discretionary-lig-values": {
      syntax: "[ discretionary-ligatures | no-discretionary-ligatures ]"
    },
    "display-box": {
      syntax: "contents | none"
    },
    "display-inside": {
      syntax: "flow | flow-root | table | flex | grid | ruby"
    },
    "display-internal": {
      syntax: "table-row-group | table-header-group | table-footer-group | table-row | table-cell | table-column-group | table-column | table-caption | ruby-base | ruby-text | ruby-base-container | ruby-text-container"
    },
    "display-legacy": {
      syntax: "inline-block | inline-list-item | inline-table | inline-flex | inline-grid"
    },
    "display-listitem": {
      syntax: "<display-outside>? && [ flow | flow-root ]? && list-item"
    },
    "display-outside": {
      syntax: "block | inline | run-in"
    },
    "drop-shadow()": {
      syntax: "drop-shadow( <length>{2,3} <color>? )"
    },
    "east-asian-variant-values": {
      syntax: "[ jis78 | jis83 | jis90 | jis04 | simplified | traditional ]"
    },
    "east-asian-width-values": {
      syntax: "[ full-width | proportional-width ]"
    },
    "element()": {
      syntax: "element( <id-selector> )"
    },
    "ellipse()": {
      syntax: "ellipse( [ <shape-radius>{2} ]? [ at <position> ]? )"
    },
    "ending-shape": {
      syntax: "circle | ellipse"
    },
    "env()": {
      syntax: "env( <custom-ident> , <declaration-value>? )"
    },
    "explicit-track-list": {
      syntax: "[ <line-names>? <track-size> ]+ <line-names>?"
    },
    "family-name": {
      syntax: "<string> | <custom-ident>+"
    },
    "feature-tag-value": {
      syntax: "<string> [ <integer> | on | off ]?"
    },
    "feature-type": {
      syntax: "@stylistic | @historical-forms | @styleset | @character-variant | @swash | @ornaments | @annotation"
    },
    "feature-value-block": {
      syntax: "<feature-type> '{' <feature-value-declaration-list> '}'"
    },
    "feature-value-block-list": {
      syntax: "<feature-value-block>+"
    },
    "feature-value-declaration": {
      syntax: "<custom-ident>: <integer>+;"
    },
    "feature-value-declaration-list": {
      syntax: "<feature-value-declaration>"
    },
    "feature-value-name": {
      syntax: "<custom-ident>"
    },
    "fill-rule": {
      syntax: "nonzero | evenodd"
    },
    "filter-function": {
      syntax: "<blur()> | <brightness()> | <contrast()> | <drop-shadow()> | <grayscale()> | <hue-rotate()> | <invert()> | <opacity()> | <saturate()> | <sepia()>"
    },
    "filter-function-list": {
      syntax: "[ <filter-function> | <url> ]+"
    },
    "final-bg-layer": {
      syntax: "<'background-color'> || <bg-image> || <bg-position> [ / <bg-size> ]? || <repeat-style> || <attachment> || <box> || <box>"
    },
    "fit-content()": {
      syntax: "fit-content( [ <length> | <percentage> ] )"
    },
    "fixed-breadth": {
      syntax: "<length-percentage>"
    },
    "fixed-repeat": {
      syntax: "repeat( [ <integer [1,]> ] , [ <line-names>? <fixed-size> ]+ <line-names>? )"
    },
    "fixed-size": {
      syntax: "<fixed-breadth> | minmax( <fixed-breadth> , <track-breadth> ) | minmax( <inflexible-breadth> , <fixed-breadth> )"
    },
    "font-stretch-absolute": {
      syntax: "normal | ultra-condensed | extra-condensed | condensed | semi-condensed | semi-expanded | expanded | extra-expanded | ultra-expanded | <percentage>"
    },
    "font-variant-css21": {
      syntax: "[ normal | small-caps ]"
    },
    "font-weight-absolute": {
      syntax: "normal | bold | <number [1,1000]>"
    },
    "frequency-percentage": {
      syntax: "<frequency> | <percentage>"
    },
    "general-enclosed": {
      syntax: "[ <function-token> <any-value> ) ] | ( <ident> <any-value> )"
    },
    "generic-family": {
      syntax: "serif | sans-serif | cursive | fantasy | monospace"
    },
    "generic-name": {
      syntax: "serif | sans-serif | cursive | fantasy | monospace"
    },
    "geometry-box": {
      syntax: "<shape-box> | fill-box | stroke-box | view-box"
    },
    gradient: {
      syntax: "<linear-gradient()> | <repeating-linear-gradient()> | <radial-gradient()> | <repeating-radial-gradient()> | <conic-gradient()> | <repeating-conic-gradient()>"
    },
    "grayscale()": {
      syntax: "grayscale( <number-percentage> )"
    },
    "grid-line": {
      syntax: "auto | <custom-ident> | [ <integer> && <custom-ident>? ] | [ span && [ <integer> || <custom-ident> ] ]"
    },
    "historical-lig-values": {
      syntax: "[ historical-ligatures | no-historical-ligatures ]"
    },
    "hsl()": {
      syntax: "hsl( <hue> <percentage> <percentage> [ / <alpha-value> ]? ) | hsl( <hue>, <percentage>, <percentage>, <alpha-value>? )"
    },
    "hsla()": {
      syntax: "hsla( <hue> <percentage> <percentage> [ / <alpha-value> ]? ) | hsla( <hue>, <percentage>, <percentage>, <alpha-value>? )"
    },
    hue: {
      syntax: "<number> | <angle>"
    },
    "hue-rotate()": {
      syntax: "hue-rotate( <angle> )"
    },
    "hwb()": {
      syntax: "hwb( [<hue> | none] [<percentage> | none] [<percentage> | none] [ / [<alpha-value> | none] ]? )"
    },
    "id-selector": {
      syntax: "<hash-token>"
    },
    image: {
      syntax: "<url> | <image()> | <image-set()> | <element()> | <paint()> | <cross-fade()> | <gradient>"
    },
    "image()": {
      syntax: "image( <image-tags>? [ <image-src>? , <color>? ]! )"
    },
    "image-set()": {
      syntax: "image-set( <image-set-option># )"
    },
    "image-set-option": {
      syntax: "[ <image> | <string> ] [ <resolution> || type(<string>) ]"
    },
    "image-src": {
      syntax: "<url> | <string>"
    },
    "image-tags": {
      syntax: "ltr | rtl"
    },
    "inflexible-breadth": {
      syntax: "<length> | <percentage> | min-content | max-content | auto"
    },
    "inset()": {
      syntax: "inset( <length-percentage>{1,4} [ round <'border-radius'> ]? )"
    },
    "invert()": {
      syntax: "invert( <number-percentage> )"
    },
    "keyframes-name": {
      syntax: "<custom-ident> | <string>"
    },
    "keyframe-block": {
      syntax: `<keyframe-selector># {
  <declaration-list>
}`
    },
    "keyframe-block-list": {
      syntax: "<keyframe-block>+"
    },
    "keyframe-selector": {
      syntax: "from | to | <percentage>"
    },
    "layer()": {
      syntax: "layer( <layer-name> )"
    },
    "layer-name": {
      syntax: "<ident> [ '.' <ident> ]*"
    },
    "leader()": {
      syntax: "leader( <leader-type> )"
    },
    "leader-type": {
      syntax: "dotted | solid | space | <string>"
    },
    "length-percentage": {
      syntax: "<length> | <percentage>"
    },
    "line-names": {
      syntax: "'[' <custom-ident>* ']'"
    },
    "line-name-list": {
      syntax: "[ <line-names> | <name-repeat> ]+"
    },
    "line-style": {
      syntax: "none | hidden | dotted | dashed | solid | double | groove | ridge | inset | outset"
    },
    "line-width": {
      syntax: "<length> | thin | medium | thick"
    },
    "linear-color-hint": {
      syntax: "<length-percentage>"
    },
    "linear-color-stop": {
      syntax: "<color> <color-stop-length>?"
    },
    "linear-gradient()": {
      syntax: "linear-gradient( [ <angle> | to <side-or-corner> ]? , <color-stop-list> )"
    },
    "mask-layer": {
      syntax: "<mask-reference> || <position> [ / <bg-size> ]? || <repeat-style> || <geometry-box> || [ <geometry-box> | no-clip ] || <compositing-operator> || <masking-mode>"
    },
    "mask-position": {
      syntax: "[ <length-percentage> | left | center | right ] [ <length-percentage> | top | center | bottom ]?"
    },
    "mask-reference": {
      syntax: "none | <image> | <mask-source>"
    },
    "mask-source": {
      syntax: "<url>"
    },
    "masking-mode": {
      syntax: "alpha | luminance | match-source"
    },
    "matrix()": {
      syntax: "matrix( <number>#{6} )"
    },
    "matrix3d()": {
      syntax: "matrix3d( <number>#{16} )"
    },
    "max()": {
      syntax: "max( <calc-sum># )"
    },
    "media-and": {
      syntax: "<media-in-parens> [ and <media-in-parens> ]+"
    },
    "media-condition": {
      syntax: "<media-not> | <media-and> | <media-or> | <media-in-parens>"
    },
    "media-condition-without-or": {
      syntax: "<media-not> | <media-and> | <media-in-parens>"
    },
    "media-feature": {
      syntax: "( [ <mf-plain> | <mf-boolean> | <mf-range> ] )"
    },
    "media-in-parens": {
      syntax: "( <media-condition> ) | <media-feature> | <general-enclosed>"
    },
    "media-not": {
      syntax: "not <media-in-parens>"
    },
    "media-or": {
      syntax: "<media-in-parens> [ or <media-in-parens> ]+"
    },
    "media-query": {
      syntax: "<media-condition> | [ not | only ]? <media-type> [ and <media-condition-without-or> ]?"
    },
    "media-query-list": {
      syntax: "<media-query>#"
    },
    "media-type": {
      syntax: "<ident>"
    },
    "mf-boolean": {
      syntax: "<mf-name>"
    },
    "mf-name": {
      syntax: "<ident>"
    },
    "mf-plain": {
      syntax: "<mf-name> : <mf-value>"
    },
    "mf-range": {
      syntax: `<mf-name> [ '<' | '>' ]? '='? <mf-value>
| <mf-value> [ '<' | '>' ]? '='? <mf-name>
| <mf-value> '<' '='? <mf-name> '<' '='? <mf-value>
| <mf-value> '>' '='? <mf-name> '>' '='? <mf-value>`
    },
    "mf-value": {
      syntax: "<number> | <dimension> | <ident> | <ratio>"
    },
    "min()": {
      syntax: "min( <calc-sum># )"
    },
    "minmax()": {
      syntax: "minmax( [ <length> | <percentage> | min-content | max-content | auto ] , [ <length> | <percentage> | <flex> | min-content | max-content | auto ] )"
    },
    "name-repeat": {
      syntax: "repeat( [ <integer [1,]> | auto-fill ], <line-names>+ )"
    },
    "named-color": {
      syntax: "transparent | aliceblue | antiquewhite | aqua | aquamarine | azure | beige | bisque | black | blanchedalmond | blue | blueviolet | brown | burlywood | cadetblue | chartreuse | chocolate | coral | cornflowerblue | cornsilk | crimson | cyan | darkblue | darkcyan | darkgoldenrod | darkgray | darkgreen | darkgrey | darkkhaki | darkmagenta | darkolivegreen | darkorange | darkorchid | darkred | darksalmon | darkseagreen | darkslateblue | darkslategray | darkslategrey | darkturquoise | darkviolet | deeppink | deepskyblue | dimgray | dimgrey | dodgerblue | firebrick | floralwhite | forestgreen | fuchsia | gainsboro | ghostwhite | gold | goldenrod | gray | green | greenyellow | grey | honeydew | hotpink | indianred | indigo | ivory | khaki | lavender | lavenderblush | lawngreen | lemonchiffon | lightblue | lightcoral | lightcyan | lightgoldenrodyellow | lightgray | lightgreen | lightgrey | lightpink | lightsalmon | lightseagreen | lightskyblue | lightslategray | lightslategrey | lightsteelblue | lightyellow | lime | limegreen | linen | magenta | maroon | mediumaquamarine | mediumblue | mediumorchid | mediumpurple | mediumseagreen | mediumslateblue | mediumspringgreen | mediumturquoise | mediumvioletred | midnightblue | mintcream | mistyrose | moccasin | navajowhite | navy | oldlace | olive | olivedrab | orange | orangered | orchid | palegoldenrod | palegreen | paleturquoise | palevioletred | papayawhip | peachpuff | peru | pink | plum | powderblue | purple | rebeccapurple | red | rosybrown | royalblue | saddlebrown | salmon | sandybrown | seagreen | seashell | sienna | silver | skyblue | slateblue | slategray | slategrey | snow | springgreen | steelblue | tan | teal | thistle | tomato | turquoise | violet | wheat | white | whitesmoke | yellow | yellowgreen"
    },
    "namespace-prefix": {
      syntax: "<ident>"
    },
    "ns-prefix": {
      syntax: "[ <ident-token> | '*' ]? '|'"
    },
    "number-percentage": {
      syntax: "<number> | <percentage>"
    },
    "numeric-figure-values": {
      syntax: "[ lining-nums | oldstyle-nums ]"
    },
    "numeric-fraction-values": {
      syntax: "[ diagonal-fractions | stacked-fractions ]"
    },
    "numeric-spacing-values": {
      syntax: "[ proportional-nums | tabular-nums ]"
    },
    nth: {
      syntax: "<an-plus-b> | even | odd"
    },
    "opacity()": {
      syntax: "opacity( [ <number-percentage> ] )"
    },
    "overflow-position": {
      syntax: "unsafe | safe"
    },
    "outline-radius": {
      syntax: "<length> | <percentage>"
    },
    "page-body": {
      syntax: "<declaration>? [ ; <page-body> ]? | <page-margin-box> <page-body>"
    },
    "page-margin-box": {
      syntax: "<page-margin-box-type> '{' <declaration-list> '}'"
    },
    "page-margin-box-type": {
      syntax: "@top-left-corner | @top-left | @top-center | @top-right | @top-right-corner | @bottom-left-corner | @bottom-left | @bottom-center | @bottom-right | @bottom-right-corner | @left-top | @left-middle | @left-bottom | @right-top | @right-middle | @right-bottom"
    },
    "page-selector-list": {
      syntax: "[ <page-selector># ]?"
    },
    "page-selector": {
      syntax: "<pseudo-page>+ | <ident> <pseudo-page>*"
    },
    "page-size": {
      syntax: "A5 | A4 | A3 | B5 | B4 | JIS-B5 | JIS-B4 | letter | legal | ledger"
    },
    "path()": {
      syntax: "path( [ <fill-rule>, ]? <string> )"
    },
    "paint()": {
      syntax: "paint( <ident>, <declaration-value>? )"
    },
    "perspective()": {
      syntax: "perspective( <length> )"
    },
    "polygon()": {
      syntax: "polygon( <fill-rule>? , [ <length-percentage> <length-percentage> ]# )"
    },
    position: {
      syntax: "[ [ left | center | right ] || [ top | center | bottom ] | [ left | center | right | <length-percentage> ] [ top | center | bottom | <length-percentage> ]? | [ [ left | right ] <length-percentage> ] && [ [ top | bottom ] <length-percentage> ] ]"
    },
    "pseudo-class-selector": {
      syntax: "':' <ident-token> | ':' <function-token> <any-value> ')'"
    },
    "pseudo-element-selector": {
      syntax: "':' <pseudo-class-selector>"
    },
    "pseudo-page": {
      syntax: ": [ left | right | first | blank ]"
    },
    quote: {
      syntax: "open-quote | close-quote | no-open-quote | no-close-quote"
    },
    "radial-gradient()": {
      syntax: "radial-gradient( [ <ending-shape> || <size> ]? [ at <position> ]? , <color-stop-list> )"
    },
    "relative-selector": {
      syntax: "<combinator>? <complex-selector>"
    },
    "relative-selector-list": {
      syntax: "<relative-selector>#"
    },
    "relative-size": {
      syntax: "larger | smaller"
    },
    "repeat-style": {
      syntax: "repeat-x | repeat-y | [ repeat | space | round | no-repeat ]{1,2}"
    },
    "repeating-conic-gradient()": {
      syntax: "repeating-conic-gradient( [ from <angle> ]? [ at <position> ]?, <angular-color-stop-list> )"
    },
    "repeating-linear-gradient()": {
      syntax: "repeating-linear-gradient( [ <angle> | to <side-or-corner> ]? , <color-stop-list> )"
    },
    "repeating-radial-gradient()": {
      syntax: "repeating-radial-gradient( [ <ending-shape> || <size> ]? [ at <position> ]? , <color-stop-list> )"
    },
    "rgb()": {
      syntax: "rgb( <percentage>{3} [ / <alpha-value> ]? ) | rgb( <number>{3} [ / <alpha-value> ]? ) | rgb( <percentage>#{3} , <alpha-value>? ) | rgb( <number>#{3} , <alpha-value>? )"
    },
    "rgba()": {
      syntax: "rgba( <percentage>{3} [ / <alpha-value> ]? ) | rgba( <number>{3} [ / <alpha-value> ]? ) | rgba( <percentage>#{3} , <alpha-value>? ) | rgba( <number>#{3} , <alpha-value>? )"
    },
    "rotate()": {
      syntax: "rotate( [ <angle> | <zero> ] )"
    },
    "rotate3d()": {
      syntax: "rotate3d( <number> , <number> , <number> , [ <angle> | <zero> ] )"
    },
    "rotateX()": {
      syntax: "rotateX( [ <angle> | <zero> ] )"
    },
    "rotateY()": {
      syntax: "rotateY( [ <angle> | <zero> ] )"
    },
    "rotateZ()": {
      syntax: "rotateZ( [ <angle> | <zero> ] )"
    },
    "saturate()": {
      syntax: "saturate( <number-percentage> )"
    },
    "scale()": {
      syntax: "scale( <number> , <number>? )"
    },
    "scale3d()": {
      syntax: "scale3d( <number> , <number> , <number> )"
    },
    "scaleX()": {
      syntax: "scaleX( <number> )"
    },
    "scaleY()": {
      syntax: "scaleY( <number> )"
    },
    "scaleZ()": {
      syntax: "scaleZ( <number> )"
    },
    "self-position": {
      syntax: "center | start | end | self-start | self-end | flex-start | flex-end"
    },
    "shape-radius": {
      syntax: "<length-percentage> | closest-side | farthest-side"
    },
    "skew()": {
      syntax: "skew( [ <angle> | <zero> ] , [ <angle> | <zero> ]? )"
    },
    "skewX()": {
      syntax: "skewX( [ <angle> | <zero> ] )"
    },
    "skewY()": {
      syntax: "skewY( [ <angle> | <zero> ] )"
    },
    "sepia()": {
      syntax: "sepia( <number-percentage> )"
    },
    shadow: {
      syntax: "inset? && <length>{2,4} && <color>?"
    },
    "shadow-t": {
      syntax: "[ <length>{2,3} && <color>? ]"
    },
    shape: {
      syntax: "rect(<top>, <right>, <bottom>, <left>)"
    },
    "shape-box": {
      syntax: "<box> | margin-box"
    },
    "side-or-corner": {
      syntax: "[ left | right ] || [ top | bottom ]"
    },
    "single-animation": {
      syntax: "<time> || <easing-function> || <time> || <single-animation-iteration-count> || <single-animation-direction> || <single-animation-fill-mode> || <single-animation-play-state> || [ none | <keyframes-name> ]"
    },
    "single-animation-direction": {
      syntax: "normal | reverse | alternate | alternate-reverse"
    },
    "single-animation-fill-mode": {
      syntax: "none | forwards | backwards | both"
    },
    "single-animation-iteration-count": {
      syntax: "infinite | <number>"
    },
    "single-animation-play-state": {
      syntax: "running | paused"
    },
    "single-animation-timeline": {
      syntax: "auto | none | <timeline-name>"
    },
    "single-transition": {
      syntax: "[ none | <single-transition-property> ] || <time> || <easing-function> || <time>"
    },
    "single-transition-property": {
      syntax: "all | <custom-ident>"
    },
    size: {
      syntax: "closest-side | farthest-side | closest-corner | farthest-corner | <length> | <length-percentage>{2}"
    },
    "step-position": {
      syntax: "jump-start | jump-end | jump-none | jump-both | start | end"
    },
    "step-timing-function": {
      syntax: "step-start | step-end | steps(<integer>[, <step-position>]?)"
    },
    "subclass-selector": {
      syntax: "<id-selector> | <class-selector> | <attribute-selector> | <pseudo-class-selector>"
    },
    "supports-condition": {
      syntax: "not <supports-in-parens> | <supports-in-parens> [ and <supports-in-parens> ]* | <supports-in-parens> [ or <supports-in-parens> ]*"
    },
    "supports-in-parens": {
      syntax: "( <supports-condition> ) | <supports-feature> | <general-enclosed>"
    },
    "supports-feature": {
      syntax: "<supports-decl> | <supports-selector-fn>"
    },
    "supports-decl": {
      syntax: "( <declaration> )"
    },
    "supports-selector-fn": {
      syntax: "selector( <complex-selector> )"
    },
    symbol: {
      syntax: "<string> | <image> | <custom-ident>"
    },
    target: {
      syntax: "<target-counter()> | <target-counters()> | <target-text()>"
    },
    "target-counter()": {
      syntax: "target-counter( [ <string> | <url> ] , <custom-ident> , <counter-style>? )"
    },
    "target-counters()": {
      syntax: "target-counters( [ <string> | <url> ] , <custom-ident> , <string> , <counter-style>? )"
    },
    "target-text()": {
      syntax: "target-text( [ <string> | <url> ] , [ content | before | after | first-letter ]? )"
    },
    "time-percentage": {
      syntax: "<time> | <percentage>"
    },
    "timeline-name": {
      syntax: "<custom-ident> | <string>"
    },
    "easing-function": {
      syntax: "linear | <cubic-bezier-timing-function> | <step-timing-function>"
    },
    "track-breadth": {
      syntax: "<length-percentage> | <flex> | min-content | max-content | auto"
    },
    "track-list": {
      syntax: "[ <line-names>? [ <track-size> | <track-repeat> ] ]+ <line-names>?"
    },
    "track-repeat": {
      syntax: "repeat( [ <integer [1,]> ] , [ <line-names>? <track-size> ]+ <line-names>? )"
    },
    "track-size": {
      syntax: "<track-breadth> | minmax( <inflexible-breadth> , <track-breadth> ) | fit-content( [ <length> | <percentage> ] )"
    },
    "transform-function": {
      syntax: "<matrix()> | <translate()> | <translateX()> | <translateY()> | <scale()> | <scaleX()> | <scaleY()> | <rotate()> | <skew()> | <skewX()> | <skewY()> | <matrix3d()> | <translate3d()> | <translateZ()> | <scale3d()> | <scaleZ()> | <rotate3d()> | <rotateX()> | <rotateY()> | <rotateZ()> | <perspective()>"
    },
    "transform-list": {
      syntax: "<transform-function>+"
    },
    "translate()": {
      syntax: "translate( <length-percentage> , <length-percentage>? )"
    },
    "translate3d()": {
      syntax: "translate3d( <length-percentage> , <length-percentage> , <length> )"
    },
    "translateX()": {
      syntax: "translateX( <length-percentage> )"
    },
    "translateY()": {
      syntax: "translateY( <length-percentage> )"
    },
    "translateZ()": {
      syntax: "translateZ( <length> )"
    },
    "type-or-unit": {
      syntax: "string | color | url | integer | number | length | angle | time | frequency | cap | ch | em | ex | ic | lh | rlh | rem | vb | vi | vw | vh | vmin | vmax | mm | Q | cm | in | pt | pc | px | deg | grad | rad | turn | ms | s | Hz | kHz | %"
    },
    "type-selector": {
      syntax: "<wq-name> | <ns-prefix>? '*'"
    },
    "var()": {
      syntax: "var( <custom-property-name> , <declaration-value>? )"
    },
    "viewport-length": {
      syntax: "auto | <length-percentage>"
    },
    "visual-box": {
      syntax: "content-box | padding-box | border-box"
    },
    "wq-name": {
      syntax: "<ns-prefix>? <ident-token>"
    }
  };
});

// ../../../../node_modules/.bun/css-tree@2.2.1/node_modules/css-tree/cjs/data.cjs
var require_data2 = __commonJS((exports, module) => {
  var dataPatch = require_data_patch2();
  var mdnAtrules = require_at_rules2();
  var mdnProperties = require_properties2();
  var mdnSyntaxes = require_syntaxes2();
  var extendSyntax = /^\s*\|\s*/;
  function preprocessAtrules(dict) {
    const result = Object.create(null);
    for (const atruleName in dict) {
      const atrule = dict[atruleName];
      let descriptors = null;
      if (atrule.descriptors) {
        descriptors = Object.create(null);
        for (const descriptor in atrule.descriptors) {
          descriptors[descriptor] = atrule.descriptors[descriptor].syntax;
        }
      }
      result[atruleName.substr(1)] = {
        prelude: atrule.syntax.trim().replace(/\{(.|\s)+\}/, "").match(/^@\S+\s+([^;\{]*)/)[1].trim() || null,
        descriptors
      };
    }
    return result;
  }
  function patchDictionary(dict, patchDict) {
    const result = {};
    for (const key in dict) {
      result[key] = dict[key].syntax || dict[key];
    }
    for (const key in patchDict) {
      if (key in dict) {
        if (patchDict[key].syntax) {
          result[key] = extendSyntax.test(patchDict[key].syntax) ? result[key] + " " + patchDict[key].syntax.trim() : patchDict[key].syntax;
        } else {
          delete result[key];
        }
      } else {
        if (patchDict[key].syntax) {
          result[key] = patchDict[key].syntax.replace(extendSyntax, "");
        }
      }
    }
    return result;
  }
  function patchAtrules(dict, patchDict) {
    const result = {};
    for (const key in dict) {
      const patchDescriptors = patchDict[key] && patchDict[key].descriptors || null;
      result[key] = {
        prelude: key in patchDict && "prelude" in patchDict[key] ? patchDict[key].prelude : dict[key].prelude || null,
        descriptors: patchDictionary(dict[key].descriptors || {}, patchDescriptors || {})
      };
    }
    for (const key in patchDict) {
      if (!hasOwnProperty.call(dict, key)) {
        result[key] = {
          prelude: patchDict[key].prelude || null,
          descriptors: patchDict[key].descriptors && patchDictionary({}, patchDict[key].descriptors)
        };
      }
    }
    return result;
  }
  var definitions = {
    types: patchDictionary(mdnSyntaxes, dataPatch.types),
    atrules: patchAtrules(preprocessAtrules(mdnAtrules), dataPatch.atrules),
    properties: patchDictionary(mdnProperties, dataPatch.properties)
  };
  module.exports = definitions;
});

// ../../../../node_modules/.bun/css-tree@2.2.1/node_modules/css-tree/cjs/syntax/node/AnPlusB.cjs
var require_AnPlusB2 = __commonJS((exports) => {
  var types = require_types3();
  var charCodeDefinitions = require_char_code_definitions2();
  var PLUSSIGN = 43;
  var HYPHENMINUS = 45;
  var N = 110;
  var DISALLOW_SIGN = true;
  var ALLOW_SIGN = false;
  function checkInteger(offset, disallowSign) {
    let pos = this.tokenStart + offset;
    const code = this.charCodeAt(pos);
    if (code === PLUSSIGN || code === HYPHENMINUS) {
      if (disallowSign) {
        this.error("Number sign is not allowed");
      }
      pos++;
    }
    for (;pos < this.tokenEnd; pos++) {
      if (!charCodeDefinitions.isDigit(this.charCodeAt(pos))) {
        this.error("Integer is expected", pos);
      }
    }
  }
  function checkTokenIsInteger(disallowSign) {
    return checkInteger.call(this, 0, disallowSign);
  }
  function expectCharCode(offset, code) {
    if (!this.cmpChar(this.tokenStart + offset, code)) {
      let msg = "";
      switch (code) {
        case N:
          msg = "N is expected";
          break;
        case HYPHENMINUS:
          msg = "HyphenMinus is expected";
          break;
      }
      this.error(msg, this.tokenStart + offset);
    }
  }
  function consumeB() {
    let offset = 0;
    let sign = 0;
    let type = this.tokenType;
    while (type === types.WhiteSpace || type === types.Comment) {
      type = this.lookupType(++offset);
    }
    if (type !== types.Number) {
      if (this.isDelim(PLUSSIGN, offset) || this.isDelim(HYPHENMINUS, offset)) {
        sign = this.isDelim(PLUSSIGN, offset) ? PLUSSIGN : HYPHENMINUS;
        do {
          type = this.lookupType(++offset);
        } while (type === types.WhiteSpace || type === types.Comment);
        if (type !== types.Number) {
          this.skip(offset);
          checkTokenIsInteger.call(this, DISALLOW_SIGN);
        }
      } else {
        return null;
      }
    }
    if (offset > 0) {
      this.skip(offset);
    }
    if (sign === 0) {
      type = this.charCodeAt(this.tokenStart);
      if (type !== PLUSSIGN && type !== HYPHENMINUS) {
        this.error("Number sign is expected");
      }
    }
    checkTokenIsInteger.call(this, sign !== 0);
    return sign === HYPHENMINUS ? "-" + this.consume(types.Number) : this.consume(types.Number);
  }
  var name = "AnPlusB";
  var structure = {
    a: [String, null],
    b: [String, null]
  };
  function parse() {
    const start = this.tokenStart;
    let a = null;
    let b = null;
    if (this.tokenType === types.Number) {
      checkTokenIsInteger.call(this, ALLOW_SIGN);
      b = this.consume(types.Number);
    } else if (this.tokenType === types.Ident && this.cmpChar(this.tokenStart, HYPHENMINUS)) {
      a = "-1";
      expectCharCode.call(this, 1, N);
      switch (this.tokenEnd - this.tokenStart) {
        case 2:
          this.next();
          b = consumeB.call(this);
          break;
        case 3:
          expectCharCode.call(this, 2, HYPHENMINUS);
          this.next();
          this.skipSC();
          checkTokenIsInteger.call(this, DISALLOW_SIGN);
          b = "-" + this.consume(types.Number);
          break;
        default:
          expectCharCode.call(this, 2, HYPHENMINUS);
          checkInteger.call(this, 3, DISALLOW_SIGN);
          this.next();
          b = this.substrToCursor(start + 2);
      }
    } else if (this.tokenType === types.Ident || this.isDelim(PLUSSIGN) && this.lookupType(1) === types.Ident) {
      let sign = 0;
      a = "1";
      if (this.isDelim(PLUSSIGN)) {
        sign = 1;
        this.next();
      }
      expectCharCode.call(this, 0, N);
      switch (this.tokenEnd - this.tokenStart) {
        case 1:
          this.next();
          b = consumeB.call(this);
          break;
        case 2:
          expectCharCode.call(this, 1, HYPHENMINUS);
          this.next();
          this.skipSC();
          checkTokenIsInteger.call(this, DISALLOW_SIGN);
          b = "-" + this.consume(types.Number);
          break;
        default:
          expectCharCode.call(this, 1, HYPHENMINUS);
          checkInteger.call(this, 2, DISALLOW_SIGN);
          this.next();
          b = this.substrToCursor(start + sign + 1);
      }
    } else if (this.tokenType === types.Dimension) {
      const code = this.charCodeAt(this.tokenStart);
      const sign = code === PLUSSIGN || code === HYPHENMINUS;
      let i = this.tokenStart + sign;
      for (;i < this.tokenEnd; i++) {
        if (!charCodeDefinitions.isDigit(this.charCodeAt(i))) {
          break;
        }
      }
      if (i === this.tokenStart + sign) {
        this.error("Integer is expected", this.tokenStart + sign);
      }
      expectCharCode.call(this, i - this.tokenStart, N);
      a = this.substring(start, i);
      if (i + 1 === this.tokenEnd) {
        this.next();
        b = consumeB.call(this);
      } else {
        expectCharCode.call(this, i - this.tokenStart + 1, HYPHENMINUS);
        if (i + 2 === this.tokenEnd) {
          this.next();
          this.skipSC();
          checkTokenIsInteger.call(this, DISALLOW_SIGN);
          b = "-" + this.consume(types.Number);
        } else {
          checkInteger.call(this, i - this.tokenStart + 2, DISALLOW_SIGN);
          this.next();
          b = this.substrToCursor(i + 1);
        }
      }
    } else {
      this.error();
    }
    if (a !== null && a.charCodeAt(0) === PLUSSIGN) {
      a = a.substr(1);
    }
    if (b !== null && b.charCodeAt(0) === PLUSSIGN) {
      b = b.substr(1);
    }
    return {
      type: "AnPlusB",
      loc: this.getLocation(start, this.tokenStart),
      a,
      b
    };
  }
  function generate(node) {
    if (node.a) {
      const a = node.a === "+1" && "n" || node.a === "1" && "n" || node.a === "-1" && "-n" || node.a + "n";
      if (node.b) {
        const b = node.b[0] === "-" || node.b[0] === "+" ? node.b : "+" + node.b;
        this.tokenize(a + b);
      } else {
        this.tokenize(a);
      }
    } else {
      this.tokenize(node.b);
    }
  }
  exports.generate = generate;
  exports.name = name;
  exports.parse = parse;
  exports.structure = structure;
});

// ../../../../node_modules/.bun/css-tree@2.2.1/node_modules/css-tree/cjs/syntax/node/Atrule.cjs
var require_Atrule2 = __commonJS((exports) => {
  var types = require_types3();
  function consumeRaw(startToken) {
    return this.Raw(startToken, this.consumeUntilLeftCurlyBracketOrSemicolon, true);
  }
  function isDeclarationBlockAtrule() {
    for (let offset = 1, type;type = this.lookupType(offset); offset++) {
      if (type === types.RightCurlyBracket) {
        return true;
      }
      if (type === types.LeftCurlyBracket || type === types.AtKeyword) {
        return false;
      }
    }
    return false;
  }
  var name = "Atrule";
  var walkContext = "atrule";
  var structure = {
    name: String,
    prelude: ["AtrulePrelude", "Raw", null],
    block: ["Block", null]
  };
  function parse() {
    const start = this.tokenStart;
    let name2;
    let nameLowerCase;
    let prelude = null;
    let block = null;
    this.eat(types.AtKeyword);
    name2 = this.substrToCursor(start + 1);
    nameLowerCase = name2.toLowerCase();
    this.skipSC();
    if (this.eof === false && this.tokenType !== types.LeftCurlyBracket && this.tokenType !== types.Semicolon) {
      if (this.parseAtrulePrelude) {
        prelude = this.parseWithFallback(this.AtrulePrelude.bind(this, name2), consumeRaw);
      } else {
        prelude = consumeRaw.call(this, this.tokenIndex);
      }
      this.skipSC();
    }
    switch (this.tokenType) {
      case types.Semicolon:
        this.next();
        break;
      case types.LeftCurlyBracket:
        if (hasOwnProperty.call(this.atrule, nameLowerCase) && typeof this.atrule[nameLowerCase].block === "function") {
          block = this.atrule[nameLowerCase].block.call(this);
        } else {
          block = this.Block(isDeclarationBlockAtrule.call(this));
        }
        break;
    }
    return {
      type: "Atrule",
      loc: this.getLocation(start, this.tokenStart),
      name: name2,
      prelude,
      block
    };
  }
  function generate(node) {
    this.token(types.AtKeyword, "@" + node.name);
    if (node.prelude !== null) {
      this.node(node.prelude);
    }
    if (node.block) {
      this.node(node.block);
    } else {
      this.token(types.Semicolon, ";");
    }
  }
  exports.generate = generate;
  exports.name = name;
  exports.parse = parse;
  exports.structure = structure;
  exports.walkContext = walkContext;
});

// ../../../../node_modules/.bun/css-tree@2.2.1/node_modules/css-tree/cjs/syntax/node/AtrulePrelude.cjs
var require_AtrulePrelude2 = __commonJS((exports) => {
  var types = require_types3();
  var name = "AtrulePrelude";
  var walkContext = "atrulePrelude";
  var structure = {
    children: [[]]
  };
  function parse(name2) {
    let children = null;
    if (name2 !== null) {
      name2 = name2.toLowerCase();
    }
    this.skipSC();
    if (hasOwnProperty.call(this.atrule, name2) && typeof this.atrule[name2].prelude === "function") {
      children = this.atrule[name2].prelude.call(this);
    } else {
      children = this.readSequence(this.scope.AtrulePrelude);
    }
    this.skipSC();
    if (this.eof !== true && this.tokenType !== types.LeftCurlyBracket && this.tokenType !== types.Semicolon) {
      this.error("Semicolon or block is expected");
    }
    return {
      type: "AtrulePrelude",
      loc: this.getLocationFromList(children),
      children
    };
  }
  function generate(node) {
    this.children(node);
  }
  exports.generate = generate;
  exports.name = name;
  exports.parse = parse;
  exports.structure = structure;
  exports.walkContext = walkContext;
});

// ../../../../node_modules/.bun/css-tree@2.2.1/node_modules/css-tree/cjs/syntax/node/AttributeSelector.cjs
var require_AttributeSelector2 = __commonJS((exports) => {
  var types = require_types3();
  var DOLLARSIGN = 36;
  var ASTERISK = 42;
  var EQUALSSIGN = 61;
  var CIRCUMFLEXACCENT = 94;
  var VERTICALLINE = 124;
  var TILDE = 126;
  function getAttributeName() {
    if (this.eof) {
      this.error("Unexpected end of input");
    }
    const start = this.tokenStart;
    let expectIdent = false;
    if (this.isDelim(ASTERISK)) {
      expectIdent = true;
      this.next();
    } else if (!this.isDelim(VERTICALLINE)) {
      this.eat(types.Ident);
    }
    if (this.isDelim(VERTICALLINE)) {
      if (this.charCodeAt(this.tokenStart + 1) !== EQUALSSIGN) {
        this.next();
        this.eat(types.Ident);
      } else if (expectIdent) {
        this.error("Identifier is expected", this.tokenEnd);
      }
    } else if (expectIdent) {
      this.error("Vertical line is expected");
    }
    return {
      type: "Identifier",
      loc: this.getLocation(start, this.tokenStart),
      name: this.substrToCursor(start)
    };
  }
  function getOperator() {
    const start = this.tokenStart;
    const code = this.charCodeAt(start);
    if (code !== EQUALSSIGN && code !== TILDE && code !== CIRCUMFLEXACCENT && code !== DOLLARSIGN && code !== ASTERISK && code !== VERTICALLINE) {
      this.error("Attribute selector (=, ~=, ^=, $=, *=, |=) is expected");
    }
    this.next();
    if (code !== EQUALSSIGN) {
      if (!this.isDelim(EQUALSSIGN)) {
        this.error("Equal sign is expected");
      }
      this.next();
    }
    return this.substrToCursor(start);
  }
  var name = "AttributeSelector";
  var structure = {
    name: "Identifier",
    matcher: [String, null],
    value: ["String", "Identifier", null],
    flags: [String, null]
  };
  function parse() {
    const start = this.tokenStart;
    let name2;
    let matcher = null;
    let value = null;
    let flags = null;
    this.eat(types.LeftSquareBracket);
    this.skipSC();
    name2 = getAttributeName.call(this);
    this.skipSC();
    if (this.tokenType !== types.RightSquareBracket) {
      if (this.tokenType !== types.Ident) {
        matcher = getOperator.call(this);
        this.skipSC();
        value = this.tokenType === types.String ? this.String() : this.Identifier();
        this.skipSC();
      }
      if (this.tokenType === types.Ident) {
        flags = this.consume(types.Ident);
        this.skipSC();
      }
    }
    this.eat(types.RightSquareBracket);
    return {
      type: "AttributeSelector",
      loc: this.getLocation(start, this.tokenStart),
      name: name2,
      matcher,
      value,
      flags
    };
  }
  function generate(node) {
    this.token(types.Delim, "[");
    this.node(node.name);
    if (node.matcher !== null) {
      this.tokenize(node.matcher);
      this.node(node.value);
    }
    if (node.flags !== null) {
      this.token(types.Ident, node.flags);
    }
    this.token(types.Delim, "]");
  }
  exports.generate = generate;
  exports.name = name;
  exports.parse = parse;
  exports.structure = structure;
});

// ../../../../node_modules/.bun/css-tree@2.2.1/node_modules/css-tree/cjs/syntax/node/Block.cjs
var require_Block2 = __commonJS((exports) => {
  var types = require_types3();
  function consumeRaw(startToken) {
    return this.Raw(startToken, null, true);
  }
  function consumeRule() {
    return this.parseWithFallback(this.Rule, consumeRaw);
  }
  function consumeRawDeclaration(startToken) {
    return this.Raw(startToken, this.consumeUntilSemicolonIncluded, true);
  }
  function consumeDeclaration() {
    if (this.tokenType === types.Semicolon) {
      return consumeRawDeclaration.call(this, this.tokenIndex);
    }
    const node = this.parseWithFallback(this.Declaration, consumeRawDeclaration);
    if (this.tokenType === types.Semicolon) {
      this.next();
    }
    return node;
  }
  var name = "Block";
  var walkContext = "block";
  var structure = {
    children: [[
      "Atrule",
      "Rule",
      "Declaration"
    ]]
  };
  function parse(isDeclaration) {
    const consumer = isDeclaration ? consumeDeclaration : consumeRule;
    const start = this.tokenStart;
    let children = this.createList();
    this.eat(types.LeftCurlyBracket);
    scan:
      while (!this.eof) {
        switch (this.tokenType) {
          case types.RightCurlyBracket:
            break scan;
          case types.WhiteSpace:
          case types.Comment:
            this.next();
            break;
          case types.AtKeyword:
            children.push(this.parseWithFallback(this.Atrule, consumeRaw));
            break;
          default:
            children.push(consumer.call(this));
        }
      }
    if (!this.eof) {
      this.eat(types.RightCurlyBracket);
    }
    return {
      type: "Block",
      loc: this.getLocation(start, this.tokenStart),
      children
    };
  }
  function generate(node) {
    this.token(types.LeftCurlyBracket, "{");
    this.children(node, (prev) => {
      if (prev.type === "Declaration") {
        this.token(types.Semicolon, ";");
      }
    });
    this.token(types.RightCurlyBracket, "}");
  }
  exports.generate = generate;
  exports.name = name;
  exports.parse = parse;
  exports.structure = structure;
  exports.walkContext = walkContext;
});

// ../../../../node_modules/.bun/css-tree@2.2.1/node_modules/css-tree/cjs/syntax/node/Brackets.cjs
var require_Brackets2 = __commonJS((exports) => {
  var types = require_types3();
  var name = "Brackets";
  var structure = {
    children: [[]]
  };
  function parse(readSequence, recognizer) {
    const start = this.tokenStart;
    let children = null;
    this.eat(types.LeftSquareBracket);
    children = readSequence.call(this, recognizer);
    if (!this.eof) {
      this.eat(types.RightSquareBracket);
    }
    return {
      type: "Brackets",
      loc: this.getLocation(start, this.tokenStart),
      children
    };
  }
  function generate(node) {
    this.token(types.Delim, "[");
    this.children(node);
    this.token(types.Delim, "]");
  }
  exports.generate = generate;
  exports.name = name;
  exports.parse = parse;
  exports.structure = structure;
});

// ../../../../node_modules/.bun/css-tree@2.2.1/node_modules/css-tree/cjs/syntax/node/CDC.cjs
var require_CDC2 = __commonJS((exports) => {
  var types = require_types3();
  var name = "CDC";
  var structure = [];
  function parse() {
    const start = this.tokenStart;
    this.eat(types.CDC);
    return {
      type: "CDC",
      loc: this.getLocation(start, this.tokenStart)
    };
  }
  function generate() {
    this.token(types.CDC, "-->");
  }
  exports.generate = generate;
  exports.name = name;
  exports.parse = parse;
  exports.structure = structure;
});

// ../../../../node_modules/.bun/css-tree@2.2.1/node_modules/css-tree/cjs/syntax/node/CDO.cjs
var require_CDO2 = __commonJS((exports) => {
  var types = require_types3();
  var name = "CDO";
  var structure = [];
  function parse() {
    const start = this.tokenStart;
    this.eat(types.CDO);
    return {
      type: "CDO",
      loc: this.getLocation(start, this.tokenStart)
    };
  }
  function generate() {
    this.token(types.CDO, "<!--");
  }
  exports.generate = generate;
  exports.name = name;
  exports.parse = parse;
  exports.structure = structure;
});

// ../../../../node_modules/.bun/css-tree@2.2.1/node_modules/css-tree/cjs/syntax/node/ClassSelector.cjs
var require_ClassSelector2 = __commonJS((exports) => {
  var types = require_types3();
  var FULLSTOP = 46;
  var name = "ClassSelector";
  var structure = {
    name: String
  };
  function parse() {
    this.eatDelim(FULLSTOP);
    return {
      type: "ClassSelector",
      loc: this.getLocation(this.tokenStart - 1, this.tokenEnd),
      name: this.consume(types.Ident)
    };
  }
  function generate(node) {
    this.token(types.Delim, ".");
    this.token(types.Ident, node.name);
  }
  exports.generate = generate;
  exports.name = name;
  exports.parse = parse;
  exports.structure = structure;
});

// ../../../../node_modules/.bun/css-tree@2.2.1/node_modules/css-tree/cjs/syntax/node/Combinator.cjs
var require_Combinator2 = __commonJS((exports) => {
  var types = require_types3();
  var PLUSSIGN = 43;
  var SOLIDUS = 47;
  var GREATERTHANSIGN = 62;
  var TILDE = 126;
  var name = "Combinator";
  var structure = {
    name: String
  };
  function parse() {
    const start = this.tokenStart;
    let name2;
    switch (this.tokenType) {
      case types.WhiteSpace:
        name2 = " ";
        break;
      case types.Delim:
        switch (this.charCodeAt(this.tokenStart)) {
          case GREATERTHANSIGN:
          case PLUSSIGN:
          case TILDE:
            this.next();
            break;
          case SOLIDUS:
            this.next();
            this.eatIdent("deep");
            this.eatDelim(SOLIDUS);
            break;
          default:
            this.error("Combinator is expected");
        }
        name2 = this.substrToCursor(start);
        break;
    }
    return {
      type: "Combinator",
      loc: this.getLocation(start, this.tokenStart),
      name: name2
    };
  }
  function generate(node) {
    this.tokenize(node.name);
  }
  exports.generate = generate;
  exports.name = name;
  exports.parse = parse;
  exports.structure = structure;
});

// ../../../../node_modules/.bun/css-tree@2.2.1/node_modules/css-tree/cjs/syntax/node/Comment.cjs
var require_Comment2 = __commonJS((exports) => {
  var types = require_types3();
  var ASTERISK = 42;
  var SOLIDUS = 47;
  var name = "Comment";
  var structure = {
    value: String
  };
  function parse() {
    const start = this.tokenStart;
    let end = this.tokenEnd;
    this.eat(types.Comment);
    if (end - start + 2 >= 2 && this.charCodeAt(end - 2) === ASTERISK && this.charCodeAt(end - 1) === SOLIDUS) {
      end -= 2;
    }
    return {
      type: "Comment",
      loc: this.getLocation(start, this.tokenStart),
      value: this.substring(start + 2, end)
    };
  }
  function generate(node) {
    this.token(types.Comment, "/*" + node.value + "*/");
  }
  exports.generate = generate;
  exports.name = name;
  exports.parse = parse;
  exports.structure = structure;
});

// ../../../../node_modules/.bun/css-tree@2.2.1/node_modules/css-tree/cjs/syntax/node/Declaration.cjs
var require_Declaration2 = __commonJS((exports) => {
  var names = require_names4();
  var types = require_types3();
  var EXCLAMATIONMARK = 33;
  var NUMBERSIGN = 35;
  var DOLLARSIGN = 36;
  var AMPERSAND = 38;
  var ASTERISK = 42;
  var PLUSSIGN = 43;
  var SOLIDUS = 47;
  function consumeValueRaw(startToken) {
    return this.Raw(startToken, this.consumeUntilExclamationMarkOrSemicolon, true);
  }
  function consumeCustomPropertyRaw(startToken) {
    return this.Raw(startToken, this.consumeUntilExclamationMarkOrSemicolon, false);
  }
  function consumeValue() {
    const startValueToken = this.tokenIndex;
    const value = this.Value();
    if (value.type !== "Raw" && this.eof === false && this.tokenType !== types.Semicolon && this.isDelim(EXCLAMATIONMARK) === false && this.isBalanceEdge(startValueToken) === false) {
      this.error();
    }
    return value;
  }
  var name = "Declaration";
  var walkContext = "declaration";
  var structure = {
    important: [Boolean, String],
    property: String,
    value: ["Value", "Raw"]
  };
  function parse() {
    const start = this.tokenStart;
    const startToken = this.tokenIndex;
    const property = readProperty.call(this);
    const customProperty = names.isCustomProperty(property);
    const parseValue = customProperty ? this.parseCustomProperty : this.parseValue;
    const consumeRaw = customProperty ? consumeCustomPropertyRaw : consumeValueRaw;
    let important = false;
    let value;
    this.skipSC();
    this.eat(types.Colon);
    const valueStart = this.tokenIndex;
    if (!customProperty) {
      this.skipSC();
    }
    if (parseValue) {
      value = this.parseWithFallback(consumeValue, consumeRaw);
    } else {
      value = consumeRaw.call(this, this.tokenIndex);
    }
    if (customProperty && value.type === "Value" && value.children.isEmpty) {
      for (let offset = valueStart - this.tokenIndex;offset <= 0; offset++) {
        if (this.lookupType(offset) === types.WhiteSpace) {
          value.children.appendData({
            type: "WhiteSpace",
            loc: null,
            value: " "
          });
          break;
        }
      }
    }
    if (this.isDelim(EXCLAMATIONMARK)) {
      important = getImportant.call(this);
      this.skipSC();
    }
    if (this.eof === false && this.tokenType !== types.Semicolon && this.isBalanceEdge(startToken) === false) {
      this.error();
    }
    return {
      type: "Declaration",
      loc: this.getLocation(start, this.tokenStart),
      important,
      property,
      value
    };
  }
  function generate(node) {
    this.token(types.Ident, node.property);
    this.token(types.Colon, ":");
    this.node(node.value);
    if (node.important) {
      this.token(types.Delim, "!");
      this.token(types.Ident, node.important === true ? "important" : node.important);
    }
  }
  function readProperty() {
    const start = this.tokenStart;
    if (this.tokenType === types.Delim) {
      switch (this.charCodeAt(this.tokenStart)) {
        case ASTERISK:
        case DOLLARSIGN:
        case PLUSSIGN:
        case NUMBERSIGN:
        case AMPERSAND:
          this.next();
          break;
        case SOLIDUS:
          this.next();
          if (this.isDelim(SOLIDUS)) {
            this.next();
          }
          break;
      }
    }
    if (this.tokenType === types.Hash) {
      this.eat(types.Hash);
    } else {
      this.eat(types.Ident);
    }
    return this.substrToCursor(start);
  }
  function getImportant() {
    this.eat(types.Delim);
    this.skipSC();
    const important = this.consume(types.Ident);
    return important === "important" ? true : important;
  }
  exports.generate = generate;
  exports.name = name;
  exports.parse = parse;
  exports.structure = structure;
  exports.walkContext = walkContext;
});

// ../../../../node_modules/.bun/css-tree@2.2.1/node_modules/css-tree/cjs/syntax/node/DeclarationList.cjs
var require_DeclarationList2 = __commonJS((exports) => {
  var types = require_types3();
  function consumeRaw(startToken) {
    return this.Raw(startToken, this.consumeUntilSemicolonIncluded, true);
  }
  var name = "DeclarationList";
  var structure = {
    children: [[
      "Declaration"
    ]]
  };
  function parse() {
    const children = this.createList();
    while (!this.eof) {
      switch (this.tokenType) {
        case types.WhiteSpace:
        case types.Comment:
        case types.Semicolon:
          this.next();
          break;
        default:
          children.push(this.parseWithFallback(this.Declaration, consumeRaw));
      }
    }
    return {
      type: "DeclarationList",
      loc: this.getLocationFromList(children),
      children
    };
  }
  function generate(node) {
    this.children(node, (prev) => {
      if (prev.type === "Declaration") {
        this.token(types.Semicolon, ";");
      }
    });
  }
  exports.generate = generate;
  exports.name = name;
  exports.parse = parse;
  exports.structure = structure;
});

// ../../../../node_modules/.bun/css-tree@2.2.1/node_modules/css-tree/cjs/syntax/node/Dimension.cjs
var require_Dimension2 = __commonJS((exports) => {
  var types = require_types3();
  var name = "Dimension";
  var structure = {
    value: String,
    unit: String
  };
  function parse() {
    const start = this.tokenStart;
    const value = this.consumeNumber(types.Dimension);
    return {
      type: "Dimension",
      loc: this.getLocation(start, this.tokenStart),
      value,
      unit: this.substring(start + value.length, this.tokenStart)
    };
  }
  function generate(node) {
    this.token(types.Dimension, node.value + node.unit);
  }
  exports.generate = generate;
  exports.name = name;
  exports.parse = parse;
  exports.structure = structure;
});

// ../../../../node_modules/.bun/css-tree@2.2.1/node_modules/css-tree/cjs/syntax/node/Function.cjs
var require_Function2 = __commonJS((exports) => {
  var types = require_types3();
  var name = "Function";
  var walkContext = "function";
  var structure = {
    name: String,
    children: [[]]
  };
  function parse(readSequence, recognizer) {
    const start = this.tokenStart;
    const name2 = this.consumeFunctionName();
    const nameLowerCase = name2.toLowerCase();
    let children;
    children = recognizer.hasOwnProperty(nameLowerCase) ? recognizer[nameLowerCase].call(this, recognizer) : readSequence.call(this, recognizer);
    if (!this.eof) {
      this.eat(types.RightParenthesis);
    }
    return {
      type: "Function",
      loc: this.getLocation(start, this.tokenStart),
      name: name2,
      children
    };
  }
  function generate(node) {
    this.token(types.Function, node.name + "(");
    this.children(node);
    this.token(types.RightParenthesis, ")");
  }
  exports.generate = generate;
  exports.name = name;
  exports.parse = parse;
  exports.structure = structure;
  exports.walkContext = walkContext;
});

// ../../../../node_modules/.bun/css-tree@2.2.1/node_modules/css-tree/cjs/syntax/node/Hash.cjs
var require_Hash2 = __commonJS((exports) => {
  var types = require_types3();
  var xxx = "XXX";
  var name = "Hash";
  var structure = {
    value: String
  };
  function parse() {
    const start = this.tokenStart;
    this.eat(types.Hash);
    return {
      type: "Hash",
      loc: this.getLocation(start, this.tokenStart),
      value: this.substrToCursor(start + 1)
    };
  }
  function generate(node) {
    this.token(types.Hash, "#" + node.value);
  }
  exports.generate = generate;
  exports.name = name;
  exports.parse = parse;
  exports.structure = structure;
  exports.xxx = xxx;
});

// ../../../../node_modules/.bun/css-tree@2.2.1/node_modules/css-tree/cjs/syntax/node/Identifier.cjs
var require_Identifier2 = __commonJS((exports) => {
  var types = require_types3();
  var name = "Identifier";
  var structure = {
    name: String
  };
  function parse() {
    return {
      type: "Identifier",
      loc: this.getLocation(this.tokenStart, this.tokenEnd),
      name: this.consume(types.Ident)
    };
  }
  function generate(node) {
    this.token(types.Ident, node.name);
  }
  exports.generate = generate;
  exports.name = name;
  exports.parse = parse;
  exports.structure = structure;
});

// ../../../../node_modules/.bun/css-tree@2.2.1/node_modules/css-tree/cjs/syntax/node/IdSelector.cjs
var require_IdSelector2 = __commonJS((exports) => {
  var types = require_types3();
  var name = "IdSelector";
  var structure = {
    name: String
  };
  function parse() {
    const start = this.tokenStart;
    this.eat(types.Hash);
    return {
      type: "IdSelector",
      loc: this.getLocation(start, this.tokenStart),
      name: this.substrToCursor(start + 1)
    };
  }
  function generate(node) {
    this.token(types.Delim, "#" + node.name);
  }
  exports.generate = generate;
  exports.name = name;
  exports.parse = parse;
  exports.structure = structure;
});

// ../../../../node_modules/.bun/css-tree@2.2.1/node_modules/css-tree/cjs/syntax/node/MediaFeature.cjs
var require_MediaFeature2 = __commonJS((exports) => {
  var types = require_types3();
  var name = "MediaFeature";
  var structure = {
    name: String,
    value: ["Identifier", "Number", "Dimension", "Ratio", null]
  };
  function parse() {
    const start = this.tokenStart;
    let name2;
    let value = null;
    this.eat(types.LeftParenthesis);
    this.skipSC();
    name2 = this.consume(types.Ident);
    this.skipSC();
    if (this.tokenType !== types.RightParenthesis) {
      this.eat(types.Colon);
      this.skipSC();
      switch (this.tokenType) {
        case types.Number:
          if (this.lookupNonWSType(1) === types.Delim) {
            value = this.Ratio();
          } else {
            value = this.Number();
          }
          break;
        case types.Dimension:
          value = this.Dimension();
          break;
        case types.Ident:
          value = this.Identifier();
          break;
        default:
          this.error("Number, dimension, ratio or identifier is expected");
      }
      this.skipSC();
    }
    this.eat(types.RightParenthesis);
    return {
      type: "MediaFeature",
      loc: this.getLocation(start, this.tokenStart),
      name: name2,
      value
    };
  }
  function generate(node) {
    this.token(types.LeftParenthesis, "(");
    this.token(types.Ident, node.name);
    if (node.value !== null) {
      this.token(types.Colon, ":");
      this.node(node.value);
    }
    this.token(types.RightParenthesis, ")");
  }
  exports.generate = generate;
  exports.name = name;
  exports.parse = parse;
  exports.structure = structure;
});

// ../../../../node_modules/.bun/css-tree@2.2.1/node_modules/css-tree/cjs/syntax/node/MediaQuery.cjs
var require_MediaQuery2 = __commonJS((exports) => {
  var types = require_types3();
  var name = "MediaQuery";
  var structure = {
    children: [[
      "Identifier",
      "MediaFeature",
      "WhiteSpace"
    ]]
  };
  function parse() {
    const children = this.createList();
    let child = null;
    this.skipSC();
    scan:
      while (!this.eof) {
        switch (this.tokenType) {
          case types.Comment:
          case types.WhiteSpace:
            this.next();
            continue;
          case types.Ident:
            child = this.Identifier();
            break;
          case types.LeftParenthesis:
            child = this.MediaFeature();
            break;
          default:
            break scan;
        }
        children.push(child);
      }
    if (child === null) {
      this.error("Identifier or parenthesis is expected");
    }
    return {
      type: "MediaQuery",
      loc: this.getLocationFromList(children),
      children
    };
  }
  function generate(node) {
    this.children(node);
  }
  exports.generate = generate;
  exports.name = name;
  exports.parse = parse;
  exports.structure = structure;
});

// ../../../../node_modules/.bun/css-tree@2.2.1/node_modules/css-tree/cjs/syntax/node/MediaQueryList.cjs
var require_MediaQueryList2 = __commonJS((exports) => {
  var types = require_types3();
  var name = "MediaQueryList";
  var structure = {
    children: [[
      "MediaQuery"
    ]]
  };
  function parse() {
    const children = this.createList();
    this.skipSC();
    while (!this.eof) {
      children.push(this.MediaQuery());
      if (this.tokenType !== types.Comma) {
        break;
      }
      this.next();
    }
    return {
      type: "MediaQueryList",
      loc: this.getLocationFromList(children),
      children
    };
  }
  function generate(node) {
    this.children(node, () => this.token(types.Comma, ","));
  }
  exports.generate = generate;
  exports.name = name;
  exports.parse = parse;
  exports.structure = structure;
});

// ../../../../node_modules/.bun/css-tree@2.2.1/node_modules/css-tree/cjs/syntax/node/Nth.cjs
var require_Nth2 = __commonJS((exports) => {
  var types = require_types3();
  var name = "Nth";
  var structure = {
    nth: ["AnPlusB", "Identifier"],
    selector: ["SelectorList", null]
  };
  function parse() {
    this.skipSC();
    const start = this.tokenStart;
    let end = start;
    let selector = null;
    let nth;
    if (this.lookupValue(0, "odd") || this.lookupValue(0, "even")) {
      nth = this.Identifier();
    } else {
      nth = this.AnPlusB();
    }
    end = this.tokenStart;
    this.skipSC();
    if (this.lookupValue(0, "of")) {
      this.next();
      selector = this.SelectorList();
      end = this.tokenStart;
    }
    return {
      type: "Nth",
      loc: this.getLocation(start, end),
      nth,
      selector
    };
  }
  function generate(node) {
    this.node(node.nth);
    if (node.selector !== null) {
      this.token(types.Ident, "of");
      this.node(node.selector);
    }
  }
  exports.generate = generate;
  exports.name = name;
  exports.parse = parse;
  exports.structure = structure;
});

// ../../../../node_modules/.bun/css-tree@2.2.1/node_modules/css-tree/cjs/syntax/node/Number.cjs
var require_Number2 = __commonJS((exports) => {
  var types = require_types3();
  var name = "Number";
  var structure = {
    value: String
  };
  function parse() {
    return {
      type: "Number",
      loc: this.getLocation(this.tokenStart, this.tokenEnd),
      value: this.consume(types.Number)
    };
  }
  function generate(node) {
    this.token(types.Number, node.value);
  }
  exports.generate = generate;
  exports.name = name;
  exports.parse = parse;
  exports.structure = structure;
});

// ../../../../node_modules/.bun/css-tree@2.2.1/node_modules/css-tree/cjs/syntax/node/Operator.cjs
var require_Operator2 = __commonJS((exports) => {
  var name = "Operator";
  var structure = {
    value: String
  };
  function parse() {
    const start = this.tokenStart;
    this.next();
    return {
      type: "Operator",
      loc: this.getLocation(start, this.tokenStart),
      value: this.substrToCursor(start)
    };
  }
  function generate(node) {
    this.tokenize(node.value);
  }
  exports.generate = generate;
  exports.name = name;
  exports.parse = parse;
  exports.structure = structure;
});

// ../../../../node_modules/.bun/css-tree@2.2.1/node_modules/css-tree/cjs/syntax/node/Parentheses.cjs
var require_Parentheses2 = __commonJS((exports) => {
  var types = require_types3();
  var name = "Parentheses";
  var structure = {
    children: [[]]
  };
  function parse(readSequence, recognizer) {
    const start = this.tokenStart;
    let children = null;
    this.eat(types.LeftParenthesis);
    children = readSequence.call(this, recognizer);
    if (!this.eof) {
      this.eat(types.RightParenthesis);
    }
    return {
      type: "Parentheses",
      loc: this.getLocation(start, this.tokenStart),
      children
    };
  }
  function generate(node) {
    this.token(types.LeftParenthesis, "(");
    this.children(node);
    this.token(types.RightParenthesis, ")");
  }
  exports.generate = generate;
  exports.name = name;
  exports.parse = parse;
  exports.structure = structure;
});

// ../../../../node_modules/.bun/css-tree@2.2.1/node_modules/css-tree/cjs/syntax/node/Percentage.cjs
var require_Percentage2 = __commonJS((exports) => {
  var types = require_types3();
  var name = "Percentage";
  var structure = {
    value: String
  };
  function parse() {
    return {
      type: "Percentage",
      loc: this.getLocation(this.tokenStart, this.tokenEnd),
      value: this.consumeNumber(types.Percentage)
    };
  }
  function generate(node) {
    this.token(types.Percentage, node.value + "%");
  }
  exports.generate = generate;
  exports.name = name;
  exports.parse = parse;
  exports.structure = structure;
});

// ../../../../node_modules/.bun/css-tree@2.2.1/node_modules/css-tree/cjs/syntax/node/PseudoClassSelector.cjs
var require_PseudoClassSelector2 = __commonJS((exports) => {
  var types = require_types3();
  var name = "PseudoClassSelector";
  var walkContext = "function";
  var structure = {
    name: String,
    children: [["Raw"], null]
  };
  function parse() {
    const start = this.tokenStart;
    let children = null;
    let name2;
    let nameLowerCase;
    this.eat(types.Colon);
    if (this.tokenType === types.Function) {
      name2 = this.consumeFunctionName();
      nameLowerCase = name2.toLowerCase();
      if (hasOwnProperty.call(this.pseudo, nameLowerCase)) {
        this.skipSC();
        children = this.pseudo[nameLowerCase].call(this);
        this.skipSC();
      } else {
        children = this.createList();
        children.push(this.Raw(this.tokenIndex, null, false));
      }
      this.eat(types.RightParenthesis);
    } else {
      name2 = this.consume(types.Ident);
    }
    return {
      type: "PseudoClassSelector",
      loc: this.getLocation(start, this.tokenStart),
      name: name2,
      children
    };
  }
  function generate(node) {
    this.token(types.Colon, ":");
    if (node.children === null) {
      this.token(types.Ident, node.name);
    } else {
      this.token(types.Function, node.name + "(");
      this.children(node);
      this.token(types.RightParenthesis, ")");
    }
  }
  exports.generate = generate;
  exports.name = name;
  exports.parse = parse;
  exports.structure = structure;
  exports.walkContext = walkContext;
});

// ../../../../node_modules/.bun/css-tree@2.2.1/node_modules/css-tree/cjs/syntax/node/PseudoElementSelector.cjs
var require_PseudoElementSelector2 = __commonJS((exports) => {
  var types = require_types3();
  var name = "PseudoElementSelector";
  var walkContext = "function";
  var structure = {
    name: String,
    children: [["Raw"], null]
  };
  function parse() {
    const start = this.tokenStart;
    let children = null;
    let name2;
    let nameLowerCase;
    this.eat(types.Colon);
    this.eat(types.Colon);
    if (this.tokenType === types.Function) {
      name2 = this.consumeFunctionName();
      nameLowerCase = name2.toLowerCase();
      if (hasOwnProperty.call(this.pseudo, nameLowerCase)) {
        this.skipSC();
        children = this.pseudo[nameLowerCase].call(this);
        this.skipSC();
      } else {
        children = this.createList();
        children.push(this.Raw(this.tokenIndex, null, false));
      }
      this.eat(types.RightParenthesis);
    } else {
      name2 = this.consume(types.Ident);
    }
    return {
      type: "PseudoElementSelector",
      loc: this.getLocation(start, this.tokenStart),
      name: name2,
      children
    };
  }
  function generate(node) {
    this.token(types.Colon, ":");
    this.token(types.Colon, ":");
    if (node.children === null) {
      this.token(types.Ident, node.name);
    } else {
      this.token(types.Function, node.name + "(");
      this.children(node);
      this.token(types.RightParenthesis, ")");
    }
  }
  exports.generate = generate;
  exports.name = name;
  exports.parse = parse;
  exports.structure = structure;
  exports.walkContext = walkContext;
});

// ../../../../node_modules/.bun/css-tree@2.2.1/node_modules/css-tree/cjs/syntax/node/Ratio.cjs
var require_Ratio2 = __commonJS((exports) => {
  var types = require_types3();
  var charCodeDefinitions = require_char_code_definitions2();
  var SOLIDUS = 47;
  var FULLSTOP = 46;
  function consumeNumber() {
    this.skipSC();
    const value = this.consume(types.Number);
    for (let i = 0;i < value.length; i++) {
      const code = value.charCodeAt(i);
      if (!charCodeDefinitions.isDigit(code) && code !== FULLSTOP) {
        this.error("Unsigned number is expected", this.tokenStart - value.length + i);
      }
    }
    if (Number(value) === 0) {
      this.error("Zero number is not allowed", this.tokenStart - value.length);
    }
    return value;
  }
  var name = "Ratio";
  var structure = {
    left: String,
    right: String
  };
  function parse() {
    const start = this.tokenStart;
    const left = consumeNumber.call(this);
    let right;
    this.skipSC();
    this.eatDelim(SOLIDUS);
    right = consumeNumber.call(this);
    return {
      type: "Ratio",
      loc: this.getLocation(start, this.tokenStart),
      left,
      right
    };
  }
  function generate(node) {
    this.token(types.Number, node.left);
    this.token(types.Delim, "/");
    this.token(types.Number, node.right);
  }
  exports.generate = generate;
  exports.name = name;
  exports.parse = parse;
  exports.structure = structure;
});

// ../../../../node_modules/.bun/css-tree@2.2.1/node_modules/css-tree/cjs/syntax/node/Raw.cjs
var require_Raw2 = __commonJS((exports) => {
  var types = require_types3();
  function getOffsetExcludeWS() {
    if (this.tokenIndex > 0) {
      if (this.lookupType(-1) === types.WhiteSpace) {
        return this.tokenIndex > 1 ? this.getTokenStart(this.tokenIndex - 1) : this.firstCharOffset;
      }
    }
    return this.tokenStart;
  }
  var name = "Raw";
  var structure = {
    value: String
  };
  function parse(startToken, consumeUntil, excludeWhiteSpace) {
    const startOffset = this.getTokenStart(startToken);
    let endOffset;
    this.skipUntilBalanced(startToken, consumeUntil || this.consumeUntilBalanceEnd);
    if (excludeWhiteSpace && this.tokenStart > startOffset) {
      endOffset = getOffsetExcludeWS.call(this);
    } else {
      endOffset = this.tokenStart;
    }
    return {
      type: "Raw",
      loc: this.getLocation(startOffset, endOffset),
      value: this.substring(startOffset, endOffset)
    };
  }
  function generate(node) {
    this.tokenize(node.value);
  }
  exports.generate = generate;
  exports.name = name;
  exports.parse = parse;
  exports.structure = structure;
});

// ../../../../node_modules/.bun/css-tree@2.2.1/node_modules/css-tree/cjs/syntax/node/Rule.cjs
var require_Rule2 = __commonJS((exports) => {
  var types = require_types3();
  function consumeRaw(startToken) {
    return this.Raw(startToken, this.consumeUntilLeftCurlyBracket, true);
  }
  function consumePrelude() {
    const prelude = this.SelectorList();
    if (prelude.type !== "Raw" && this.eof === false && this.tokenType !== types.LeftCurlyBracket) {
      this.error();
    }
    return prelude;
  }
  var name = "Rule";
  var walkContext = "rule";
  var structure = {
    prelude: ["SelectorList", "Raw"],
    block: ["Block"]
  };
  function parse() {
    const startToken = this.tokenIndex;
    const startOffset = this.tokenStart;
    let prelude;
    let block;
    if (this.parseRulePrelude) {
      prelude = this.parseWithFallback(consumePrelude, consumeRaw);
    } else {
      prelude = consumeRaw.call(this, startToken);
    }
    block = this.Block(true);
    return {
      type: "Rule",
      loc: this.getLocation(startOffset, this.tokenStart),
      prelude,
      block
    };
  }
  function generate(node) {
    this.node(node.prelude);
    this.node(node.block);
  }
  exports.generate = generate;
  exports.name = name;
  exports.parse = parse;
  exports.structure = structure;
  exports.walkContext = walkContext;
});

// ../../../../node_modules/.bun/css-tree@2.2.1/node_modules/css-tree/cjs/syntax/node/Selector.cjs
var require_Selector2 = __commonJS((exports) => {
  var name = "Selector";
  var structure = {
    children: [[
      "TypeSelector",
      "IdSelector",
      "ClassSelector",
      "AttributeSelector",
      "PseudoClassSelector",
      "PseudoElementSelector",
      "Combinator",
      "WhiteSpace"
    ]]
  };
  function parse() {
    const children = this.readSequence(this.scope.Selector);
    if (this.getFirstListNode(children) === null) {
      this.error("Selector is expected");
    }
    return {
      type: "Selector",
      loc: this.getLocationFromList(children),
      children
    };
  }
  function generate(node) {
    this.children(node);
  }
  exports.generate = generate;
  exports.name = name;
  exports.parse = parse;
  exports.structure = structure;
});

// ../../../../node_modules/.bun/css-tree@2.2.1/node_modules/css-tree/cjs/syntax/node/SelectorList.cjs
var require_SelectorList2 = __commonJS((exports) => {
  var types = require_types3();
  var name = "SelectorList";
  var walkContext = "selector";
  var structure = {
    children: [[
      "Selector",
      "Raw"
    ]]
  };
  function parse() {
    const children = this.createList();
    while (!this.eof) {
      children.push(this.Selector());
      if (this.tokenType === types.Comma) {
        this.next();
        continue;
      }
      break;
    }
    return {
      type: "SelectorList",
      loc: this.getLocationFromList(children),
      children
    };
  }
  function generate(node) {
    this.children(node, () => this.token(types.Comma, ","));
  }
  exports.generate = generate;
  exports.name = name;
  exports.parse = parse;
  exports.structure = structure;
  exports.walkContext = walkContext;
});

// ../../../../node_modules/.bun/css-tree@2.2.1/node_modules/css-tree/cjs/utils/string.cjs
var require_string2 = __commonJS((exports) => {
  var charCodeDefinitions = require_char_code_definitions2();
  var utils = require_utils2();
  var REVERSE_SOLIDUS = 92;
  var QUOTATION_MARK = 34;
  var APOSTROPHE = 39;
  function decode(str) {
    const len = str.length;
    const firstChar = str.charCodeAt(0);
    const start = firstChar === QUOTATION_MARK || firstChar === APOSTROPHE ? 1 : 0;
    const end = start === 1 && len > 1 && str.charCodeAt(len - 1) === firstChar ? len - 2 : len - 1;
    let decoded = "";
    for (let i = start;i <= end; i++) {
      let code = str.charCodeAt(i);
      if (code === REVERSE_SOLIDUS) {
        if (i === end) {
          if (i !== len - 1) {
            decoded = str.substr(i + 1);
          }
          break;
        }
        code = str.charCodeAt(++i);
        if (charCodeDefinitions.isValidEscape(REVERSE_SOLIDUS, code)) {
          const escapeStart = i - 1;
          const escapeEnd = utils.consumeEscaped(str, escapeStart);
          i = escapeEnd - 1;
          decoded += utils.decodeEscaped(str.substring(escapeStart + 1, escapeEnd));
        } else {
          if (code === 13 && str.charCodeAt(i + 1) === 10) {
            i++;
          }
        }
      } else {
        decoded += str[i];
      }
    }
    return decoded;
  }
  function encode(str, apostrophe) {
    const quote = apostrophe ? "'" : '"';
    const quoteCode = apostrophe ? APOSTROPHE : QUOTATION_MARK;
    let encoded = "";
    let wsBeforeHexIsNeeded = false;
    for (let i = 0;i < str.length; i++) {
      const code = str.charCodeAt(i);
      if (code === 0) {
        encoded += "";
        continue;
      }
      if (code <= 31 || code === 127) {
        encoded += "\\" + code.toString(16);
        wsBeforeHexIsNeeded = true;
        continue;
      }
      if (code === quoteCode || code === REVERSE_SOLIDUS) {
        encoded += "\\" + str.charAt(i);
        wsBeforeHexIsNeeded = false;
      } else {
        if (wsBeforeHexIsNeeded && (charCodeDefinitions.isHexDigit(code) || charCodeDefinitions.isWhiteSpace(code))) {
          encoded += " ";
        }
        encoded += str.charAt(i);
        wsBeforeHexIsNeeded = false;
      }
    }
    return quote + encoded + quote;
  }
  exports.decode = decode;
  exports.encode = encode;
});

// ../../../../node_modules/.bun/css-tree@2.2.1/node_modules/css-tree/cjs/syntax/node/String.cjs
var require_String2 = __commonJS((exports) => {
  var string = require_string2();
  var types = require_types3();
  var name = "String";
  var structure = {
    value: String
  };
  function parse() {
    return {
      type: "String",
      loc: this.getLocation(this.tokenStart, this.tokenEnd),
      value: string.decode(this.consume(types.String))
    };
  }
  function generate(node) {
    this.token(types.String, string.encode(node.value));
  }
  exports.generate = generate;
  exports.name = name;
  exports.parse = parse;
  exports.structure = structure;
});

// ../../../../node_modules/.bun/css-tree@2.2.1/node_modules/css-tree/cjs/syntax/node/StyleSheet.cjs
var require_StyleSheet2 = __commonJS((exports) => {
  var types = require_types3();
  var EXCLAMATIONMARK = 33;
  function consumeRaw(startToken) {
    return this.Raw(startToken, null, false);
  }
  var name = "StyleSheet";
  var walkContext = "stylesheet";
  var structure = {
    children: [[
      "Comment",
      "CDO",
      "CDC",
      "Atrule",
      "Rule",
      "Raw"
    ]]
  };
  function parse() {
    const start = this.tokenStart;
    const children = this.createList();
    let child;
    while (!this.eof) {
      switch (this.tokenType) {
        case types.WhiteSpace:
          this.next();
          continue;
        case types.Comment:
          if (this.charCodeAt(this.tokenStart + 2) !== EXCLAMATIONMARK) {
            this.next();
            continue;
          }
          child = this.Comment();
          break;
        case types.CDO:
          child = this.CDO();
          break;
        case types.CDC:
          child = this.CDC();
          break;
        case types.AtKeyword:
          child = this.parseWithFallback(this.Atrule, consumeRaw);
          break;
        default:
          child = this.parseWithFallback(this.Rule, consumeRaw);
      }
      children.push(child);
    }
    return {
      type: "StyleSheet",
      loc: this.getLocation(start, this.tokenStart),
      children
    };
  }
  function generate(node) {
    this.children(node);
  }
  exports.generate = generate;
  exports.name = name;
  exports.parse = parse;
  exports.structure = structure;
  exports.walkContext = walkContext;
});

// ../../../../node_modules/.bun/css-tree@2.2.1/node_modules/css-tree/cjs/syntax/node/TypeSelector.cjs
var require_TypeSelector2 = __commonJS((exports) => {
  var types = require_types3();
  var ASTERISK = 42;
  var VERTICALLINE = 124;
  function eatIdentifierOrAsterisk() {
    if (this.tokenType !== types.Ident && this.isDelim(ASTERISK) === false) {
      this.error("Identifier or asterisk is expected");
    }
    this.next();
  }
  var name = "TypeSelector";
  var structure = {
    name: String
  };
  function parse() {
    const start = this.tokenStart;
    if (this.isDelim(VERTICALLINE)) {
      this.next();
      eatIdentifierOrAsterisk.call(this);
    } else {
      eatIdentifierOrAsterisk.call(this);
      if (this.isDelim(VERTICALLINE)) {
        this.next();
        eatIdentifierOrAsterisk.call(this);
      }
    }
    return {
      type: "TypeSelector",
      loc: this.getLocation(start, this.tokenStart),
      name: this.substrToCursor(start)
    };
  }
  function generate(node) {
    this.tokenize(node.name);
  }
  exports.generate = generate;
  exports.name = name;
  exports.parse = parse;
  exports.structure = structure;
});

// ../../../../node_modules/.bun/css-tree@2.2.1/node_modules/css-tree/cjs/syntax/node/UnicodeRange.cjs
var require_UnicodeRange2 = __commonJS((exports) => {
  var types = require_types3();
  var charCodeDefinitions = require_char_code_definitions2();
  var PLUSSIGN = 43;
  var HYPHENMINUS = 45;
  var QUESTIONMARK = 63;
  function eatHexSequence(offset, allowDash) {
    let len = 0;
    for (let pos = this.tokenStart + offset;pos < this.tokenEnd; pos++) {
      const code = this.charCodeAt(pos);
      if (code === HYPHENMINUS && allowDash && len !== 0) {
        eatHexSequence.call(this, offset + len + 1, false);
        return -1;
      }
      if (!charCodeDefinitions.isHexDigit(code)) {
        this.error(allowDash && len !== 0 ? "Hyphen minus" + (len < 6 ? " or hex digit" : "") + " is expected" : len < 6 ? "Hex digit is expected" : "Unexpected input", pos);
      }
      if (++len > 6) {
        this.error("Too many hex digits", pos);
      }
    }
    this.next();
    return len;
  }
  function eatQuestionMarkSequence(max) {
    let count = 0;
    while (this.isDelim(QUESTIONMARK)) {
      if (++count > max) {
        this.error("Too many question marks");
      }
      this.next();
    }
  }
  function startsWith(code) {
    if (this.charCodeAt(this.tokenStart) !== code) {
      this.error((code === PLUSSIGN ? "Plus sign" : "Hyphen minus") + " is expected");
    }
  }
  function scanUnicodeRange() {
    let hexLength = 0;
    switch (this.tokenType) {
      case types.Number:
        hexLength = eatHexSequence.call(this, 1, true);
        if (this.isDelim(QUESTIONMARK)) {
          eatQuestionMarkSequence.call(this, 6 - hexLength);
          break;
        }
        if (this.tokenType === types.Dimension || this.tokenType === types.Number) {
          startsWith.call(this, HYPHENMINUS);
          eatHexSequence.call(this, 1, false);
          break;
        }
        break;
      case types.Dimension:
        hexLength = eatHexSequence.call(this, 1, true);
        if (hexLength > 0) {
          eatQuestionMarkSequence.call(this, 6 - hexLength);
        }
        break;
      default:
        this.eatDelim(PLUSSIGN);
        if (this.tokenType === types.Ident) {
          hexLength = eatHexSequence.call(this, 0, true);
          if (hexLength > 0) {
            eatQuestionMarkSequence.call(this, 6 - hexLength);
          }
          break;
        }
        if (this.isDelim(QUESTIONMARK)) {
          this.next();
          eatQuestionMarkSequence.call(this, 5);
          break;
        }
        this.error("Hex digit or question mark is expected");
    }
  }
  var name = "UnicodeRange";
  var structure = {
    value: String
  };
  function parse() {
    const start = this.tokenStart;
    this.eatIdent("u");
    scanUnicodeRange.call(this);
    return {
      type: "UnicodeRange",
      loc: this.getLocation(start, this.tokenStart),
      value: this.substrToCursor(start)
    };
  }
  function generate(node) {
    this.tokenize(node.value);
  }
  exports.generate = generate;
  exports.name = name;
  exports.parse = parse;
  exports.structure = structure;
});

// ../../../../node_modules/.bun/css-tree@2.2.1/node_modules/css-tree/cjs/utils/url.cjs
var require_url2 = __commonJS((exports) => {
  var charCodeDefinitions = require_char_code_definitions2();
  var utils = require_utils2();
  var SPACE = 32;
  var REVERSE_SOLIDUS = 92;
  var QUOTATION_MARK = 34;
  var APOSTROPHE = 39;
  var LEFTPARENTHESIS = 40;
  var RIGHTPARENTHESIS = 41;
  function decode(str) {
    const len = str.length;
    let start = 4;
    let end = str.charCodeAt(len - 1) === RIGHTPARENTHESIS ? len - 2 : len - 1;
    let decoded = "";
    while (start < end && charCodeDefinitions.isWhiteSpace(str.charCodeAt(start))) {
      start++;
    }
    while (start < end && charCodeDefinitions.isWhiteSpace(str.charCodeAt(end))) {
      end--;
    }
    for (let i = start;i <= end; i++) {
      let code = str.charCodeAt(i);
      if (code === REVERSE_SOLIDUS) {
        if (i === end) {
          if (i !== len - 1) {
            decoded = str.substr(i + 1);
          }
          break;
        }
        code = str.charCodeAt(++i);
        if (charCodeDefinitions.isValidEscape(REVERSE_SOLIDUS, code)) {
          const escapeStart = i - 1;
          const escapeEnd = utils.consumeEscaped(str, escapeStart);
          i = escapeEnd - 1;
          decoded += utils.decodeEscaped(str.substring(escapeStart + 1, escapeEnd));
        } else {
          if (code === 13 && str.charCodeAt(i + 1) === 10) {
            i++;
          }
        }
      } else {
        decoded += str[i];
      }
    }
    return decoded;
  }
  function encode(str) {
    let encoded = "";
    let wsBeforeHexIsNeeded = false;
    for (let i = 0;i < str.length; i++) {
      const code = str.charCodeAt(i);
      if (code === 0) {
        encoded += "";
        continue;
      }
      if (code <= 31 || code === 127) {
        encoded += "\\" + code.toString(16);
        wsBeforeHexIsNeeded = true;
        continue;
      }
      if (code === SPACE || code === REVERSE_SOLIDUS || code === QUOTATION_MARK || code === APOSTROPHE || code === LEFTPARENTHESIS || code === RIGHTPARENTHESIS) {
        encoded += "\\" + str.charAt(i);
        wsBeforeHexIsNeeded = false;
      } else {
        if (wsBeforeHexIsNeeded && charCodeDefinitions.isHexDigit(code)) {
          encoded += " ";
        }
        encoded += str.charAt(i);
        wsBeforeHexIsNeeded = false;
      }
    }
    return "url(" + encoded + ")";
  }
  exports.decode = decode;
  exports.encode = encode;
});

// ../../../../node_modules/.bun/css-tree@2.2.1/node_modules/css-tree/cjs/syntax/node/Url.cjs
var require_Url2 = __commonJS((exports) => {
  var url = require_url2();
  var string = require_string2();
  var types = require_types3();
  var name = "Url";
  var structure = {
    value: String
  };
  function parse() {
    const start = this.tokenStart;
    let value;
    switch (this.tokenType) {
      case types.Url:
        value = url.decode(this.consume(types.Url));
        break;
      case types.Function:
        if (!this.cmpStr(this.tokenStart, this.tokenEnd, "url(")) {
          this.error("Function name must be `url`");
        }
        this.eat(types.Function);
        this.skipSC();
        value = string.decode(this.consume(types.String));
        this.skipSC();
        if (!this.eof) {
          this.eat(types.RightParenthesis);
        }
        break;
      default:
        this.error("Url or Function is expected");
    }
    return {
      type: "Url",
      loc: this.getLocation(start, this.tokenStart),
      value
    };
  }
  function generate(node) {
    this.token(types.Url, url.encode(node.value));
  }
  exports.generate = generate;
  exports.name = name;
  exports.parse = parse;
  exports.structure = structure;
});

// ../../../../node_modules/.bun/css-tree@2.2.1/node_modules/css-tree/cjs/syntax/node/Value.cjs
var require_Value2 = __commonJS((exports) => {
  var name = "Value";
  var structure = {
    children: [[]]
  };
  function parse() {
    const start = this.tokenStart;
    const children = this.readSequence(this.scope.Value);
    return {
      type: "Value",
      loc: this.getLocation(start, this.tokenStart),
      children
    };
  }
  function generate(node) {
    this.children(node);
  }
  exports.generate = generate;
  exports.name = name;
  exports.parse = parse;
  exports.structure = structure;
});

// ../../../../node_modules/.bun/css-tree@2.2.1/node_modules/css-tree/cjs/syntax/node/WhiteSpace.cjs
var require_WhiteSpace2 = __commonJS((exports) => {
  var types = require_types3();
  var SPACE = Object.freeze({
    type: "WhiteSpace",
    loc: null,
    value: " "
  });
  var name = "WhiteSpace";
  var structure = {
    value: String
  };
  function parse() {
    this.eat(types.WhiteSpace);
    return SPACE;
  }
  function generate(node) {
    this.token(types.WhiteSpace, node.value);
  }
  exports.generate = generate;
  exports.name = name;
  exports.parse = parse;
  exports.structure = structure;
});

// ../../../../node_modules/.bun/css-tree@2.2.1/node_modules/css-tree/cjs/syntax/node/index.cjs
var require_node3 = __commonJS((exports) => {
  var AnPlusB = require_AnPlusB2();
  var Atrule = require_Atrule2();
  var AtrulePrelude = require_AtrulePrelude2();
  var AttributeSelector = require_AttributeSelector2();
  var Block = require_Block2();
  var Brackets = require_Brackets2();
  var CDC = require_CDC2();
  var CDO = require_CDO2();
  var ClassSelector = require_ClassSelector2();
  var Combinator = require_Combinator2();
  var Comment = require_Comment2();
  var Declaration = require_Declaration2();
  var DeclarationList = require_DeclarationList2();
  var Dimension = require_Dimension2();
  var Function = require_Function2();
  var Hash = require_Hash2();
  var Identifier = require_Identifier2();
  var IdSelector = require_IdSelector2();
  var MediaFeature = require_MediaFeature2();
  var MediaQuery = require_MediaQuery2();
  var MediaQueryList = require_MediaQueryList2();
  var Nth = require_Nth2();
  var Number$1 = require_Number2();
  var Operator = require_Operator2();
  var Parentheses = require_Parentheses2();
  var Percentage = require_Percentage2();
  var PseudoClassSelector = require_PseudoClassSelector2();
  var PseudoElementSelector = require_PseudoElementSelector2();
  var Ratio = require_Ratio2();
  var Raw = require_Raw2();
  var Rule = require_Rule2();
  var Selector = require_Selector2();
  var SelectorList = require_SelectorList2();
  var String$1 = require_String2();
  var StyleSheet = require_StyleSheet2();
  var TypeSelector = require_TypeSelector2();
  var UnicodeRange = require_UnicodeRange2();
  var Url = require_Url2();
  var Value = require_Value2();
  var WhiteSpace = require_WhiteSpace2();
  exports.AnPlusB = AnPlusB;
  exports.Atrule = Atrule;
  exports.AtrulePrelude = AtrulePrelude;
  exports.AttributeSelector = AttributeSelector;
  exports.Block = Block;
  exports.Brackets = Brackets;
  exports.CDC = CDC;
  exports.CDO = CDO;
  exports.ClassSelector = ClassSelector;
  exports.Combinator = Combinator;
  exports.Comment = Comment;
  exports.Declaration = Declaration;
  exports.DeclarationList = DeclarationList;
  exports.Dimension = Dimension;
  exports.Function = Function;
  exports.Hash = Hash;
  exports.Identifier = Identifier;
  exports.IdSelector = IdSelector;
  exports.MediaFeature = MediaFeature;
  exports.MediaQuery = MediaQuery;
  exports.MediaQueryList = MediaQueryList;
  exports.Nth = Nth;
  exports.Number = Number$1;
  exports.Operator = Operator;
  exports.Parentheses = Parentheses;
  exports.Percentage = Percentage;
  exports.PseudoClassSelector = PseudoClassSelector;
  exports.PseudoElementSelector = PseudoElementSelector;
  exports.Ratio = Ratio;
  exports.Raw = Raw;
  exports.Rule = Rule;
  exports.Selector = Selector;
  exports.SelectorList = SelectorList;
  exports.String = String$1;
  exports.StyleSheet = StyleSheet;
  exports.TypeSelector = TypeSelector;
  exports.UnicodeRange = UnicodeRange;
  exports.Url = Url;
  exports.Value = Value;
  exports.WhiteSpace = WhiteSpace;
});

// ../../../../node_modules/.bun/css-tree@2.2.1/node_modules/css-tree/cjs/syntax/config/lexer.cjs
var require_lexer2 = __commonJS((exports, module) => {
  var data = require_data2();
  var index = require_node3();
  var lexerConfig = {
    generic: true,
    ...data,
    node: index
  };
  module.exports = lexerConfig;
});

// ../../../../node_modules/.bun/css-tree@2.2.1/node_modules/css-tree/cjs/syntax/scope/default.cjs
var require_default2 = __commonJS((exports, module) => {
  var types = require_types3();
  var NUMBERSIGN = 35;
  var ASTERISK = 42;
  var PLUSSIGN = 43;
  var HYPHENMINUS = 45;
  var SOLIDUS = 47;
  var U = 117;
  function defaultRecognizer(context) {
    switch (this.tokenType) {
      case types.Hash:
        return this.Hash();
      case types.Comma:
        return this.Operator();
      case types.LeftParenthesis:
        return this.Parentheses(this.readSequence, context.recognizer);
      case types.LeftSquareBracket:
        return this.Brackets(this.readSequence, context.recognizer);
      case types.String:
        return this.String();
      case types.Dimension:
        return this.Dimension();
      case types.Percentage:
        return this.Percentage();
      case types.Number:
        return this.Number();
      case types.Function:
        return this.cmpStr(this.tokenStart, this.tokenEnd, "url(") ? this.Url() : this.Function(this.readSequence, context.recognizer);
      case types.Url:
        return this.Url();
      case types.Ident:
        if (this.cmpChar(this.tokenStart, U) && this.cmpChar(this.tokenStart + 1, PLUSSIGN)) {
          return this.UnicodeRange();
        } else {
          return this.Identifier();
        }
      case types.Delim: {
        const code = this.charCodeAt(this.tokenStart);
        if (code === SOLIDUS || code === ASTERISK || code === PLUSSIGN || code === HYPHENMINUS) {
          return this.Operator();
        }
        if (code === NUMBERSIGN) {
          this.error("Hex or identifier is expected", this.tokenStart + 1);
        }
        break;
      }
    }
  }
  module.exports = defaultRecognizer;
});

// ../../../../node_modules/.bun/css-tree@2.2.1/node_modules/css-tree/cjs/syntax/scope/atrulePrelude.cjs
var require_atrulePrelude2 = __commonJS((exports, module) => {
  var _default = require_default2();
  var atrulePrelude = {
    getNode: _default
  };
  module.exports = atrulePrelude;
});

// ../../../../node_modules/.bun/css-tree@2.2.1/node_modules/css-tree/cjs/syntax/scope/selector.cjs
var require_selector2 = __commonJS((exports, module) => {
  var types = require_types3();
  var NUMBERSIGN = 35;
  var ASTERISK = 42;
  var PLUSSIGN = 43;
  var SOLIDUS = 47;
  var FULLSTOP = 46;
  var GREATERTHANSIGN = 62;
  var VERTICALLINE = 124;
  var TILDE = 126;
  function onWhiteSpace(next, children) {
    if (children.last !== null && children.last.type !== "Combinator" && next !== null && next.type !== "Combinator") {
      children.push({
        type: "Combinator",
        loc: null,
        name: " "
      });
    }
  }
  function getNode() {
    switch (this.tokenType) {
      case types.LeftSquareBracket:
        return this.AttributeSelector();
      case types.Hash:
        return this.IdSelector();
      case types.Colon:
        if (this.lookupType(1) === types.Colon) {
          return this.PseudoElementSelector();
        } else {
          return this.PseudoClassSelector();
        }
      case types.Ident:
        return this.TypeSelector();
      case types.Number:
      case types.Percentage:
        return this.Percentage();
      case types.Dimension:
        if (this.charCodeAt(this.tokenStart) === FULLSTOP) {
          this.error("Identifier is expected", this.tokenStart + 1);
        }
        break;
      case types.Delim: {
        const code = this.charCodeAt(this.tokenStart);
        switch (code) {
          case PLUSSIGN:
          case GREATERTHANSIGN:
          case TILDE:
          case SOLIDUS:
            return this.Combinator();
          case FULLSTOP:
            return this.ClassSelector();
          case ASTERISK:
          case VERTICALLINE:
            return this.TypeSelector();
          case NUMBERSIGN:
            return this.IdSelector();
        }
        break;
      }
    }
  }
  var Selector = {
    onWhiteSpace,
    getNode
  };
  module.exports = Selector;
});

// ../../../../node_modules/.bun/css-tree@2.2.1/node_modules/css-tree/cjs/syntax/function/expression.cjs
var require_expression2 = __commonJS((exports, module) => {
  function expressionFn() {
    return this.createSingleNodeList(this.Raw(this.tokenIndex, null, false));
  }
  module.exports = expressionFn;
});

// ../../../../node_modules/.bun/css-tree@2.2.1/node_modules/css-tree/cjs/syntax/function/var.cjs
var require_var2 = __commonJS((exports, module) => {
  var types = require_types3();
  function varFn() {
    const children = this.createList();
    this.skipSC();
    children.push(this.Identifier());
    this.skipSC();
    if (this.tokenType === types.Comma) {
      children.push(this.Operator());
      const startIndex = this.tokenIndex;
      const value = this.parseCustomProperty ? this.Value(null) : this.Raw(this.tokenIndex, this.consumeUntilExclamationMarkOrSemicolon, false);
      if (value.type === "Value" && value.children.isEmpty) {
        for (let offset = startIndex - this.tokenIndex;offset <= 0; offset++) {
          if (this.lookupType(offset) === types.WhiteSpace) {
            value.children.appendData({
              type: "WhiteSpace",
              loc: null,
              value: " "
            });
            break;
          }
        }
      }
      children.push(value);
    }
    return children;
  }
  module.exports = varFn;
});

// ../../../../node_modules/.bun/css-tree@2.2.1/node_modules/css-tree/cjs/syntax/scope/value.cjs
var require_value2 = __commonJS((exports, module) => {
  var _default = require_default2();
  var expression = require_expression2();
  var _var = require_var2();
  function isPlusMinusOperator(node) {
    return node !== null && node.type === "Operator" && (node.value[node.value.length - 1] === "-" || node.value[node.value.length - 1] === "+");
  }
  var value = {
    getNode: _default,
    onWhiteSpace(next, children) {
      if (isPlusMinusOperator(next)) {
        next.value = " " + next.value;
      }
      if (isPlusMinusOperator(children.last)) {
        children.last.value += " ";
      }
    },
    expression,
    var: _var
  };
  module.exports = value;
});

// ../../../../node_modules/.bun/css-tree@2.2.1/node_modules/css-tree/cjs/syntax/scope/index.cjs
var require_scope2 = __commonJS((exports) => {
  var atrulePrelude = require_atrulePrelude2();
  var selector = require_selector2();
  var value = require_value2();
  exports.AtrulePrelude = atrulePrelude;
  exports.Selector = selector;
  exports.Value = value;
});

// ../../../../node_modules/.bun/css-tree@2.2.1/node_modules/css-tree/cjs/syntax/atrule/font-face.cjs
var require_font_face2 = __commonJS((exports, module) => {
  var fontFace = {
    parse: {
      prelude: null,
      block() {
        return this.Block(true);
      }
    }
  };
  module.exports = fontFace;
});

// ../../../../node_modules/.bun/css-tree@2.2.1/node_modules/css-tree/cjs/syntax/atrule/import.cjs
var require_import2 = __commonJS((exports, module) => {
  var types = require_types3();
  var importAtrule = {
    parse: {
      prelude() {
        const children = this.createList();
        this.skipSC();
        switch (this.tokenType) {
          case types.String:
            children.push(this.String());
            break;
          case types.Url:
          case types.Function:
            children.push(this.Url());
            break;
          default:
            this.error("String or url() is expected");
        }
        if (this.lookupNonWSType(0) === types.Ident || this.lookupNonWSType(0) === types.LeftParenthesis) {
          children.push(this.MediaQueryList());
        }
        return children;
      },
      block: null
    }
  };
  module.exports = importAtrule;
});

// ../../../../node_modules/.bun/css-tree@2.2.1/node_modules/css-tree/cjs/syntax/atrule/media.cjs
var require_media2 = __commonJS((exports, module) => {
  var media = {
    parse: {
      prelude() {
        return this.createSingleNodeList(this.MediaQueryList());
      },
      block() {
        return this.Block(false);
      }
    }
  };
  module.exports = media;
});

// ../../../../node_modules/.bun/css-tree@2.2.1/node_modules/css-tree/cjs/syntax/atrule/page.cjs
var require_page2 = __commonJS((exports, module) => {
  var page = {
    parse: {
      prelude() {
        return this.createSingleNodeList(this.SelectorList());
      },
      block() {
        return this.Block(true);
      }
    }
  };
  module.exports = page;
});

// ../../../../node_modules/.bun/css-tree@2.2.1/node_modules/css-tree/cjs/syntax/atrule/supports.cjs
var require_supports2 = __commonJS((exports, module) => {
  var types = require_types3();
  function consumeRaw() {
    return this.createSingleNodeList(this.Raw(this.tokenIndex, null, false));
  }
  function parentheses() {
    this.skipSC();
    if (this.tokenType === types.Ident && this.lookupNonWSType(1) === types.Colon) {
      return this.createSingleNodeList(this.Declaration());
    }
    return readSequence.call(this);
  }
  function readSequence() {
    const children = this.createList();
    let child;
    this.skipSC();
    scan:
      while (!this.eof) {
        switch (this.tokenType) {
          case types.Comment:
          case types.WhiteSpace:
            this.next();
            continue;
          case types.Function:
            child = this.Function(consumeRaw, this.scope.AtrulePrelude);
            break;
          case types.Ident:
            child = this.Identifier();
            break;
          case types.LeftParenthesis:
            child = this.Parentheses(parentheses, this.scope.AtrulePrelude);
            break;
          default:
            break scan;
        }
        children.push(child);
      }
    return children;
  }
  var supports = {
    parse: {
      prelude() {
        const children = readSequence.call(this);
        if (this.getFirstListNode(children) === null) {
          this.error("Condition is expected");
        }
        return children;
      },
      block() {
        return this.Block(false);
      }
    }
  };
  module.exports = supports;
});

// ../../../../node_modules/.bun/css-tree@2.2.1/node_modules/css-tree/cjs/syntax/atrule/index.cjs
var require_atrule2 = __commonJS((exports, module) => {
  var fontFace = require_font_face2();
  var _import = require_import2();
  var media = require_media2();
  var page = require_page2();
  var supports = require_supports2();
  var atrule = {
    "font-face": fontFace,
    import: _import,
    media,
    page,
    supports
  };
  module.exports = atrule;
});

// ../../../../node_modules/.bun/css-tree@2.2.1/node_modules/css-tree/cjs/syntax/pseudo/index.cjs
var require_pseudo2 = __commonJS((exports, module) => {
  var selectorList = {
    parse() {
      return this.createSingleNodeList(this.SelectorList());
    }
  };
  var selector = {
    parse() {
      return this.createSingleNodeList(this.Selector());
    }
  };
  var identList = {
    parse() {
      return this.createSingleNodeList(this.Identifier());
    }
  };
  var nth = {
    parse() {
      return this.createSingleNodeList(this.Nth());
    }
  };
  var pseudo = {
    dir: identList,
    has: selectorList,
    lang: identList,
    matches: selectorList,
    is: selectorList,
    "-moz-any": selectorList,
    "-webkit-any": selectorList,
    where: selectorList,
    not: selectorList,
    "nth-child": nth,
    "nth-last-child": nth,
    "nth-last-of-type": nth,
    "nth-of-type": nth,
    slotted: selector
  };
  module.exports = pseudo;
});

// ../../../../node_modules/.bun/css-tree@2.2.1/node_modules/css-tree/cjs/syntax/node/index-parse.cjs
var require_index_parse2 = __commonJS((exports) => {
  var AnPlusB = require_AnPlusB2();
  var Atrule = require_Atrule2();
  var AtrulePrelude = require_AtrulePrelude2();
  var AttributeSelector = require_AttributeSelector2();
  var Block = require_Block2();
  var Brackets = require_Brackets2();
  var CDC = require_CDC2();
  var CDO = require_CDO2();
  var ClassSelector = require_ClassSelector2();
  var Combinator = require_Combinator2();
  var Comment = require_Comment2();
  var Declaration = require_Declaration2();
  var DeclarationList = require_DeclarationList2();
  var Dimension = require_Dimension2();
  var Function = require_Function2();
  var Hash = require_Hash2();
  var Identifier = require_Identifier2();
  var IdSelector = require_IdSelector2();
  var MediaFeature = require_MediaFeature2();
  var MediaQuery = require_MediaQuery2();
  var MediaQueryList = require_MediaQueryList2();
  var Nth = require_Nth2();
  var Number2 = require_Number2();
  var Operator = require_Operator2();
  var Parentheses = require_Parentheses2();
  var Percentage = require_Percentage2();
  var PseudoClassSelector = require_PseudoClassSelector2();
  var PseudoElementSelector = require_PseudoElementSelector2();
  var Ratio = require_Ratio2();
  var Raw = require_Raw2();
  var Rule = require_Rule2();
  var Selector = require_Selector2();
  var SelectorList = require_SelectorList2();
  var String2 = require_String2();
  var StyleSheet = require_StyleSheet2();
  var TypeSelector = require_TypeSelector2();
  var UnicodeRange = require_UnicodeRange2();
  var Url = require_Url2();
  var Value = require_Value2();
  var WhiteSpace = require_WhiteSpace2();
  exports.AnPlusB = AnPlusB.parse;
  exports.Atrule = Atrule.parse;
  exports.AtrulePrelude = AtrulePrelude.parse;
  exports.AttributeSelector = AttributeSelector.parse;
  exports.Block = Block.parse;
  exports.Brackets = Brackets.parse;
  exports.CDC = CDC.parse;
  exports.CDO = CDO.parse;
  exports.ClassSelector = ClassSelector.parse;
  exports.Combinator = Combinator.parse;
  exports.Comment = Comment.parse;
  exports.Declaration = Declaration.parse;
  exports.DeclarationList = DeclarationList.parse;
  exports.Dimension = Dimension.parse;
  exports.Function = Function.parse;
  exports.Hash = Hash.parse;
  exports.Identifier = Identifier.parse;
  exports.IdSelector = IdSelector.parse;
  exports.MediaFeature = MediaFeature.parse;
  exports.MediaQuery = MediaQuery.parse;
  exports.MediaQueryList = MediaQueryList.parse;
  exports.Nth = Nth.parse;
  exports.Number = Number2.parse;
  exports.Operator = Operator.parse;
  exports.Parentheses = Parentheses.parse;
  exports.Percentage = Percentage.parse;
  exports.PseudoClassSelector = PseudoClassSelector.parse;
  exports.PseudoElementSelector = PseudoElementSelector.parse;
  exports.Ratio = Ratio.parse;
  exports.Raw = Raw.parse;
  exports.Rule = Rule.parse;
  exports.Selector = Selector.parse;
  exports.SelectorList = SelectorList.parse;
  exports.String = String2.parse;
  exports.StyleSheet = StyleSheet.parse;
  exports.TypeSelector = TypeSelector.parse;
  exports.UnicodeRange = UnicodeRange.parse;
  exports.Url = Url.parse;
  exports.Value = Value.parse;
  exports.WhiteSpace = WhiteSpace.parse;
});

// ../../../../node_modules/.bun/css-tree@2.2.1/node_modules/css-tree/cjs/syntax/config/parser.cjs
var require_parser3 = __commonJS((exports, module) => {
  var index = require_scope2();
  var index$1 = require_atrule2();
  var index$2 = require_pseudo2();
  var indexParse = require_index_parse2();
  var config = {
    parseContext: {
      default: "StyleSheet",
      stylesheet: "StyleSheet",
      atrule: "Atrule",
      atrulePrelude(options) {
        return this.AtrulePrelude(options.atrule ? String(options.atrule) : null);
      },
      mediaQueryList: "MediaQueryList",
      mediaQuery: "MediaQuery",
      rule: "Rule",
      selectorList: "SelectorList",
      selector: "Selector",
      block() {
        return this.Block(true);
      },
      declarationList: "DeclarationList",
      declaration: "Declaration",
      value: "Value"
    },
    scope: index,
    atrule: index$1,
    pseudo: index$2,
    node: indexParse
  };
  module.exports = config;
});

// ../../../../node_modules/.bun/css-tree@2.2.1/node_modules/css-tree/cjs/syntax/config/walker.cjs
var require_walker2 = __commonJS((exports, module) => {
  var index = require_node3();
  var config = {
    node: index
  };
  module.exports = config;
});

// ../../../../node_modules/.bun/css-tree@2.2.1/node_modules/css-tree/cjs/syntax/index.cjs
var require_syntax2 = __commonJS((exports, module) => {
  var create = require_create10();
  var lexer = require_lexer2();
  var parser = require_parser3();
  var walker = require_walker2();
  var syntax = create({
    ...lexer,
    ...parser,
    ...walker
  });
  module.exports = syntax;
});

// ../../../../node_modules/.bun/css-tree@2.2.1/node_modules/css-tree/package.json
var require_package3 = __commonJS((exports, module) => {
  module.exports = {
    name: "css-tree",
    version: "2.2.1",
    description: "A tool set for CSS: fast detailed parser (CSS  AST), walker (AST traversal), generator (AST  CSS) and lexer (validation and matching) based on specs and browser implementations",
    author: "Roman Dvornov <rdvornov@gmail.com> (https://github.com/lahmatiy)",
    license: "MIT",
    repository: "csstree/csstree",
    keywords: [
      "css",
      "ast",
      "tokenizer",
      "parser",
      "walker",
      "lexer",
      "generator",
      "utils",
      "syntax",
      "validation"
    ],
    type: "module",
    module: "./lib/index.js",
    main: "./cjs/index.cjs",
    exports: {
      ".": {
        import: "./lib/index.js",
        require: "./cjs/index.cjs"
      },
      "./dist/*": "./dist/*.js",
      "./package.json": "./package.json",
      "./tokenizer": {
        import: "./lib/tokenizer/index.js",
        require: "./cjs/tokenizer/index.cjs"
      },
      "./parser": {
        import: "./lib/parser/index.js",
        require: "./cjs/parser/index.cjs"
      },
      "./selector-parser": {
        import: "./lib/parser/parse-selector.js",
        require: "./cjs/parser/parse-selector.cjs"
      },
      "./generator": {
        import: "./lib/generator/index.js",
        require: "./cjs/generator/index.cjs"
      },
      "./walker": {
        import: "./lib/walker/index.js",
        require: "./cjs/walker/index.cjs"
      },
      "./convertor": {
        import: "./lib/convertor/index.js",
        require: "./cjs/convertor/index.cjs"
      },
      "./lexer": {
        import: "./lib/lexer/index.js",
        require: "./cjs/lexer/index.cjs"
      },
      "./definition-syntax": {
        import: "./lib/definition-syntax/index.js",
        require: "./cjs/definition-syntax/index.cjs"
      },
      "./definition-syntax-data": {
        import: "./lib/data.js",
        require: "./cjs/data.cjs"
      },
      "./definition-syntax-data-patch": {
        import: "./lib/data-patch.js",
        require: "./cjs/data-patch.cjs"
      },
      "./utils": {
        import: "./lib/utils/index.js",
        require: "./cjs/utils/index.cjs"
      }
    },
    browser: {
      "./cjs/data.cjs": "./dist/data.cjs",
      "./cjs/version.cjs": "./dist/version.cjs",
      "./lib/data.js": "./dist/data.js",
      "./lib/version.js": "./dist/version.js"
    },
    unpkg: "dist/csstree.esm.js",
    jsdelivr: "dist/csstree.esm.js",
    scripts: {
      watch: "npm run build -- --watch",
      build: "npm run bundle && npm run esm-to-cjs --",
      "build-and-test": "npm run build && npm run test:dist && npm run test:cjs",
      bundle: "node scripts/bundle",
      "bundle-and-test": "npm run bundle && npm run test:dist",
      "esm-to-cjs": "node scripts/esm-to-cjs.cjs",
      "esm-to-cjs-and-test": "npm run esm-to-cjs && npm run test:cjs",
      lint: "eslint lib scripts && node scripts/review-syntax-patch --lint && node scripts/update-docs --lint",
      "lint-and-test": "npm run lint && npm test",
      "update:docs": "node scripts/update-docs",
      "review:syntax-patch": "node scripts/review-syntax-patch",
      test: "mocha lib/__tests --reporter ${REPORTER:-progress}",
      "test:cjs": "mocha cjs/__tests --reporter ${REPORTER:-progress}",
      "test:dist": "mocha dist/__tests --reporter ${REPORTER:-progress}",
      coverage: "c8 --exclude lib/__tests --reporter=lcovonly npm test",
      prepublishOnly: "npm run lint-and-test && npm run build-and-test",
      hydrogen: "node --trace-hydrogen --trace-phase=Z --trace-deopt --code-comments --hydrogen-track-positions --redirect-code-traces --redirect-code-traces-to=code.asm --trace_hydrogen_file=code.cfg --print-opt-code bin/parse --stat -o /dev/null"
    },
    dependencies: {
      "mdn-data": "2.0.28",
      "source-map-js": "^1.0.1"
    },
    devDependencies: {
      c8: "^7.7.1",
      clap: "^2.0.1",
      esbuild: "^0.14.53",
      eslint: "^8.4.1",
      "json-to-ast": "^2.1.0",
      mocha: "^9.1.4",
      rollup: "^2.68.0"
    },
    engines: {
      node: "^10 || ^12.20.0 || ^14.13.0 || >=15.0.0",
      npm: ">=7.0.0"
    },
    files: [
      "data",
      "dist",
      "cjs",
      "!cjs/__tests",
      "lib",
      "!lib/__tests"
    ]
  };
});

// ../../../../node_modules/.bun/css-tree@2.2.1/node_modules/css-tree/cjs/version.cjs
var require_version3 = __commonJS((exports) => {
  var { version } = require_package3();
  exports.version = version;
});

// ../../../../node_modules/.bun/css-tree@2.2.1/node_modules/css-tree/cjs/definition-syntax/index.cjs
var require_definition_syntax2 = __commonJS((exports) => {
  var SyntaxError2 = require_SyntaxError4();
  var generate = require_generate2();
  var parse = require_parse4();
  var walk = require_walk2();
  exports.SyntaxError = SyntaxError2.SyntaxError;
  exports.generate = generate.generate;
  exports.parse = parse.parse;
  exports.walk = walk.walk;
});

// ../../../../node_modules/.bun/css-tree@2.2.1/node_modules/css-tree/cjs/utils/clone.cjs
var require_clone2 = __commonJS((exports) => {
  var List = require_List2();
  function clone(node) {
    const result = {};
    for (const key in node) {
      let value = node[key];
      if (value) {
        if (Array.isArray(value) || value instanceof List.List) {
          value = value.map(clone);
        } else if (value.constructor === Object) {
          value = clone(value);
        }
      }
      result[key] = value;
    }
    return result;
  }
  exports.clone = clone;
});

// ../../../../node_modules/.bun/css-tree@2.2.1/node_modules/css-tree/cjs/utils/ident.cjs
var require_ident2 = __commonJS((exports) => {
  var charCodeDefinitions = require_char_code_definitions2();
  var utils = require_utils2();
  var REVERSE_SOLIDUS = 92;
  function decode(str) {
    const end = str.length - 1;
    let decoded = "";
    for (let i = 0;i < str.length; i++) {
      let code = str.charCodeAt(i);
      if (code === REVERSE_SOLIDUS) {
        if (i === end) {
          break;
        }
        code = str.charCodeAt(++i);
        if (charCodeDefinitions.isValidEscape(REVERSE_SOLIDUS, code)) {
          const escapeStart = i - 1;
          const escapeEnd = utils.consumeEscaped(str, escapeStart);
          i = escapeEnd - 1;
          decoded += utils.decodeEscaped(str.substring(escapeStart + 1, escapeEnd));
        } else {
          if (code === 13 && str.charCodeAt(i + 1) === 10) {
            i++;
          }
        }
      } else {
        decoded += str[i];
      }
    }
    return decoded;
  }
  function encode(str) {
    let encoded = "";
    if (str.length === 1 && str.charCodeAt(0) === 45) {
      return "\\-";
    }
    for (let i = 0;i < str.length; i++) {
      const code = str.charCodeAt(i);
      if (code === 0) {
        encoded += "";
        continue;
      }
      if (code <= 31 || code === 127 || code >= 48 && code <= 57 && (i === 0 || i === 1 && str.charCodeAt(0) === 45)) {
        encoded += "\\" + code.toString(16) + " ";
        continue;
      }
      if (charCodeDefinitions.isName(code)) {
        encoded += str.charAt(i);
      } else {
        encoded += "\\" + str.charAt(i);
      }
    }
    return encoded;
  }
  exports.decode = decode;
  exports.encode = encode;
});

// ../../../../node_modules/.bun/css-tree@2.2.1/node_modules/css-tree/cjs/index.cjs
var require_cjs2 = __commonJS((exports) => {
  var index$1 = require_syntax2();
  var version = require_version3();
  var create = require_create10();
  var List = require_List2();
  var Lexer = require_Lexer2();
  var index = require_definition_syntax2();
  var clone = require_clone2();
  var names$1 = require_names4();
  var ident = require_ident2();
  var string = require_string2();
  var url = require_url2();
  var types = require_types3();
  var names = require_names3();
  var TokenStream = require_TokenStream2();
  var {
    tokenize,
    parse,
    generate,
    lexer,
    createLexer,
    walk,
    find,
    findLast,
    findAll,
    toPlainObject,
    fromPlainObject,
    fork
  } = index$1;
  exports.version = version.version;
  exports.createSyntax = create;
  exports.List = List.List;
  exports.Lexer = Lexer.Lexer;
  exports.definitionSyntax = index;
  exports.clone = clone.clone;
  exports.isCustomProperty = names$1.isCustomProperty;
  exports.keyword = names$1.keyword;
  exports.property = names$1.property;
  exports.vendorPrefix = names$1.vendorPrefix;
  exports.ident = ident;
  exports.string = string;
  exports.url = url;
  exports.tokenTypes = types;
  exports.tokenNames = names;
  exports.TokenStream = TokenStream.TokenStream;
  exports.createLexer = createLexer;
  exports.find = find;
  exports.findAll = findAll;
  exports.findLast = findLast;
  exports.fork = fork;
  exports.fromPlainObject = fromPlainObject;
  exports.generate = generate;
  exports.lexer = lexer;
  exports.parse = parse;
  exports.toPlainObject = toPlainObject;
  exports.tokenize = tokenize;
  exports.walk = walk;
});

// ../../../../node_modules/.bun/csso@5.0.5/node_modules/csso/cjs/usage.cjs
var require_usage = __commonJS((exports) => {
  var { hasOwnProperty: hasOwnProperty2 } = Object.prototype;
  function buildMap(list, caseInsensitive) {
    const map = Object.create(null);
    if (!Array.isArray(list)) {
      return null;
    }
    for (let name of list) {
      if (caseInsensitive) {
        name = name.toLowerCase();
      }
      map[name] = true;
    }
    return map;
  }
  function buildList(data) {
    if (!data) {
      return null;
    }
    const tags = buildMap(data.tags, true);
    const ids = buildMap(data.ids);
    const classes = buildMap(data.classes);
    if (tags === null && ids === null && classes === null) {
      return null;
    }
    return {
      tags,
      ids,
      classes
    };
  }
  function buildIndex(data) {
    let scopes = false;
    if (data.scopes && Array.isArray(data.scopes)) {
      scopes = Object.create(null);
      for (let i = 0;i < data.scopes.length; i++) {
        const list = data.scopes[i];
        if (!list || !Array.isArray(list)) {
          throw new Error("Wrong usage format");
        }
        for (const name of list) {
          if (hasOwnProperty2.call(scopes, name)) {
            throw new Error(`Class can't be used for several scopes: ${name}`);
          }
          scopes[name] = i + 1;
        }
      }
    }
    return {
      whitelist: buildList(data),
      blacklist: buildList(data.blacklist),
      scopes
    };
  }
  exports.buildIndex = buildIndex;
});

// ../../../../node_modules/.bun/csso@5.0.5/node_modules/csso/cjs/clean/utils.cjs
var require_utils3 = __commonJS((exports) => {
  function hasNoChildren(node) {
    return !node || !node.children || node.children.isEmpty;
  }
  function isNodeChildrenList(node, list) {
    return node !== null && node.children === list;
  }
  exports.hasNoChildren = hasNoChildren;
  exports.isNodeChildrenList = isNodeChildrenList;
});

// ../../../../node_modules/.bun/csso@5.0.5/node_modules/csso/cjs/clean/Atrule.cjs
var require_Atrule3 = __commonJS((exports, module) => {
  var cssTree = require_cjs2();
  var utils = require_utils3();
  function cleanAtrule(node, item, list) {
    if (node.block) {
      if (this.stylesheet !== null) {
        this.stylesheet.firstAtrulesAllowed = false;
      }
      if (utils.hasNoChildren(node.block)) {
        list.remove(item);
        return;
      }
    }
    switch (node.name) {
      case "charset":
        if (utils.hasNoChildren(node.prelude)) {
          list.remove(item);
          return;
        }
        if (item.prev) {
          list.remove(item);
          return;
        }
        break;
      case "import":
        if (this.stylesheet === null || !this.stylesheet.firstAtrulesAllowed) {
          list.remove(item);
          return;
        }
        list.prevUntil(item.prev, function(rule) {
          if (rule.type === "Atrule") {
            if (rule.name === "import" || rule.name === "charset") {
              return;
            }
          }
          this.root.firstAtrulesAllowed = false;
          list.remove(item);
          return true;
        }, this);
        break;
      default: {
        const name = cssTree.keyword(node.name).basename;
        if (name === "keyframes" || name === "media" || name === "supports") {
          if (utils.hasNoChildren(node.prelude) || utils.hasNoChildren(node.block)) {
            list.remove(item);
          }
        }
      }
    }
  }
  module.exports = cleanAtrule;
});

// ../../../../node_modules/.bun/csso@5.0.5/node_modules/csso/cjs/clean/Comment.cjs
var require_Comment3 = __commonJS((exports, module) => {
  function cleanComment(data, item, list) {
    list.remove(item);
  }
  module.exports = cleanComment;
});

// ../../../../node_modules/.bun/csso@5.0.5/node_modules/csso/cjs/clean/Declaration.cjs
var require_Declaration3 = __commonJS((exports, module) => {
  var cssTree = require_cjs2();
  function cleanDeclartion(node, item, list) {
    if (node.value.children && node.value.children.isEmpty) {
      list.remove(item);
      return;
    }
    if (cssTree.property(node.property).custom) {
      if (/\S/.test(node.value.value)) {
        node.value.value = node.value.value.trim();
      }
    }
  }
  module.exports = cleanDeclartion;
});

// ../../../../node_modules/.bun/csso@5.0.5/node_modules/csso/cjs/clean/Raw.cjs
var require_Raw3 = __commonJS((exports, module) => {
  var utils = require_utils3();
  function cleanRaw(node, item, list) {
    if (utils.isNodeChildrenList(this.stylesheet, list) || utils.isNodeChildrenList(this.block, list)) {
      list.remove(item);
    }
  }
  module.exports = cleanRaw;
});

// ../../../../node_modules/.bun/csso@5.0.5/node_modules/csso/cjs/clean/Rule.cjs
var require_Rule3 = __commonJS((exports, module) => {
  var cssTree = require_cjs2();
  var utils = require_utils3();
  var { hasOwnProperty: hasOwnProperty2 } = Object.prototype;
  var skipUsageFilteringAtrule = new Set(["keyframes"]);
  function cleanUnused(selectorList, usageData) {
    selectorList.children.forEach((selector, item, list) => {
      let shouldRemove = false;
      cssTree.walk(selector, function(node) {
        if (this.selector === null || this.selector === selectorList) {
          switch (node.type) {
            case "SelectorList":
              if (this.function === null || this.function.name.toLowerCase() !== "not") {
                if (cleanUnused(node, usageData)) {
                  shouldRemove = true;
                }
              }
              break;
            case "ClassSelector":
              if (usageData.whitelist !== null && usageData.whitelist.classes !== null && !hasOwnProperty2.call(usageData.whitelist.classes, node.name)) {
                shouldRemove = true;
              }
              if (usageData.blacklist !== null && usageData.blacklist.classes !== null && hasOwnProperty2.call(usageData.blacklist.classes, node.name)) {
                shouldRemove = true;
              }
              break;
            case "IdSelector":
              if (usageData.whitelist !== null && usageData.whitelist.ids !== null && !hasOwnProperty2.call(usageData.whitelist.ids, node.name)) {
                shouldRemove = true;
              }
              if (usageData.blacklist !== null && usageData.blacklist.ids !== null && hasOwnProperty2.call(usageData.blacklist.ids, node.name)) {
                shouldRemove = true;
              }
              break;
            case "TypeSelector":
              if (node.name.charAt(node.name.length - 1) !== "*") {
                if (usageData.whitelist !== null && usageData.whitelist.tags !== null && !hasOwnProperty2.call(usageData.whitelist.tags, node.name.toLowerCase())) {
                  shouldRemove = true;
                }
                if (usageData.blacklist !== null && usageData.blacklist.tags !== null && hasOwnProperty2.call(usageData.blacklist.tags, node.name.toLowerCase())) {
                  shouldRemove = true;
                }
              }
              break;
          }
        }
      });
      if (shouldRemove) {
        list.remove(item);
      }
    });
    return selectorList.children.isEmpty;
  }
  function cleanRule(node, item, list, options) {
    if (utils.hasNoChildren(node.prelude) || utils.hasNoChildren(node.block)) {
      list.remove(item);
      return;
    }
    if (this.atrule && skipUsageFilteringAtrule.has(cssTree.keyword(this.atrule.name).basename)) {
      return;
    }
    const { usage } = options;
    if (usage && (usage.whitelist !== null || usage.blacklist !== null)) {
      cleanUnused(node.prelude, usage);
      if (utils.hasNoChildren(node.prelude)) {
        list.remove(item);
        return;
      }
    }
  }
  module.exports = cleanRule;
});

// ../../../../node_modules/.bun/csso@5.0.5/node_modules/csso/cjs/clean/TypeSelector.cjs
var require_TypeSelector3 = __commonJS((exports, module) => {
  function cleanTypeSelector(node, item, list) {
    const name = item.data.name;
    if (name !== "*") {
      return;
    }
    const nextType = item.next && item.next.data.type;
    if (nextType === "IdSelector" || nextType === "ClassSelector" || nextType === "AttributeSelector" || nextType === "PseudoClassSelector" || nextType === "PseudoElementSelector") {
      list.remove(item);
    }
  }
  module.exports = cleanTypeSelector;
});

// ../../../../node_modules/.bun/csso@5.0.5/node_modules/csso/cjs/clean/WhiteSpace.cjs
var require_WhiteSpace3 = __commonJS((exports, module) => {
  function cleanWhitespace(node, item, list) {
    list.remove(item);
  }
  module.exports = cleanWhitespace;
});

// ../../../../node_modules/.bun/csso@5.0.5/node_modules/csso/cjs/clean/index.cjs
var require_clean = __commonJS((exports, module) => {
  var cssTree = require_cjs2();
  var Atrule = require_Atrule3();
  var Comment = require_Comment3();
  var Declaration = require_Declaration3();
  var Raw = require_Raw3();
  var Rule = require_Rule3();
  var TypeSelector = require_TypeSelector3();
  var WhiteSpace = require_WhiteSpace3();
  var handlers = {
    Atrule,
    Comment,
    Declaration,
    Raw,
    Rule,
    TypeSelector,
    WhiteSpace
  };
  function clean(ast, options) {
    cssTree.walk(ast, {
      leave(node, item, list) {
        if (handlers.hasOwnProperty(node.type)) {
          handlers[node.type].call(this, node, item, list, options);
        }
      }
    });
  }
  module.exports = clean;
});

// ../../../../node_modules/.bun/csso@5.0.5/node_modules/csso/cjs/replace/atrule/keyframes.cjs
var require_keyframes = __commonJS((exports, module) => {
  function compressKeyframes(node) {
    node.block.children.forEach((rule) => {
      rule.prelude.children.forEach((simpleselector) => {
        simpleselector.children.forEach((data, item) => {
          if (data.type === "Percentage" && data.value === "100") {
            item.data = {
              type: "TypeSelector",
              loc: data.loc,
              name: "to"
            };
          } else if (data.type === "TypeSelector" && data.name === "from") {
            item.data = {
              type: "Percentage",
              loc: data.loc,
              value: "0"
            };
          }
        });
      });
    });
  }
  module.exports = compressKeyframes;
});

// ../../../../node_modules/.bun/csso@5.0.5/node_modules/csso/cjs/replace/Atrule.cjs
var require_Atrule4 = __commonJS((exports, module) => {
  var cssTree = require_cjs2();
  var keyframes = require_keyframes();
  function Atrule(node) {
    if (cssTree.keyword(node.name).basename === "keyframes") {
      keyframes(node);
    }
  }
  module.exports = Atrule;
});

// ../../../../node_modules/.bun/csso@5.0.5/node_modules/csso/cjs/replace/AttributeSelector.cjs
var require_AttributeSelector3 = __commonJS((exports, module) => {
  var blockUnquoteRx = /^(-?\d|--)|[\u0000-\u002c\u002e\u002f\u003A-\u0040\u005B-\u005E\u0060\u007B-\u009f]/;
  function canUnquote(value) {
    if (value === "" || value === "-") {
      return false;
    }
    return !blockUnquoteRx.test(value);
  }
  function AttributeSelector(node) {
    const attrValue = node.value;
    if (!attrValue || attrValue.type !== "String") {
      return;
    }
    if (canUnquote(attrValue.value)) {
      node.value = {
        type: "Identifier",
        loc: attrValue.loc,
        name: attrValue.value
      };
    }
  }
  module.exports = AttributeSelector;
});

// ../../../../node_modules/.bun/csso@5.0.5/node_modules/csso/cjs/replace/property/font.cjs
var require_font = __commonJS((exports, module) => {
  function compressFont(node) {
    const list = node.children;
    list.forEachRight(function(node2, item) {
      if (node2.type === "Identifier") {
        if (node2.name === "bold") {
          item.data = {
            type: "Number",
            loc: node2.loc,
            value: "700"
          };
        } else if (node2.name === "normal") {
          const prev = item.prev;
          if (prev && prev.data.type === "Operator" && prev.data.value === "/") {
            this.remove(prev);
          }
          this.remove(item);
        }
      }
    });
    if (list.isEmpty) {
      list.insert(list.createItem({
        type: "Identifier",
        name: "normal"
      }));
    }
  }
  module.exports = compressFont;
});

// ../../../../node_modules/.bun/csso@5.0.5/node_modules/csso/cjs/replace/property/font-weight.cjs
var require_font_weight = __commonJS((exports, module) => {
  function compressFontWeight(node) {
    const value = node.children.head.data;
    if (value.type === "Identifier") {
      switch (value.name) {
        case "normal":
          node.children.head.data = {
            type: "Number",
            loc: value.loc,
            value: "400"
          };
          break;
        case "bold":
          node.children.head.data = {
            type: "Number",
            loc: value.loc,
            value: "700"
          };
          break;
      }
    }
  }
  module.exports = compressFontWeight;
});

// ../../../../node_modules/.bun/csso@5.0.5/node_modules/csso/cjs/replace/property/background.cjs
var require_background = __commonJS((exports, module) => {
  var cssTree = require_cjs2();
  function compressBackground(node) {
    function flush() {
      if (!buffer.length) {
        buffer.unshift({
          type: "Number",
          loc: null,
          value: "0"
        }, {
          type: "Number",
          loc: null,
          value: "0"
        });
      }
      newValue.push.apply(newValue, buffer);
      buffer = [];
    }
    let newValue = [];
    let buffer = [];
    node.children.forEach((node2) => {
      if (node2.type === "Operator" && node2.value === ",") {
        flush();
        newValue.push(node2);
        return;
      }
      if (node2.type === "Identifier") {
        if (node2.name === "transparent" || node2.name === "none" || node2.name === "repeat" || node2.name === "scroll") {
          return;
        }
      }
      buffer.push(node2);
    });
    flush();
    node.children = new cssTree.List().fromArray(newValue);
  }
  module.exports = compressBackground;
});

// ../../../../node_modules/.bun/csso@5.0.5/node_modules/csso/cjs/replace/property/border.cjs
var require_border = __commonJS((exports, module) => {
  function compressBorder(node) {
    node.children.forEach((node2, item, list) => {
      if (node2.type === "Identifier" && node2.name.toLowerCase() === "none") {
        if (list.head === list.tail) {
          item.data = {
            type: "Number",
            loc: node2.loc,
            value: "0"
          };
        } else {
          list.remove(item);
        }
      }
    });
  }
  module.exports = compressBorder;
});

// ../../../../node_modules/.bun/csso@5.0.5/node_modules/csso/cjs/replace/Value.cjs
var require_Value3 = __commonJS((exports, module) => {
  var cssTree = require_cjs2();
  var font = require_font();
  var fontWeight = require_font_weight();
  var background = require_background();
  var border = require_border();
  var handlers = {
    font,
    "font-weight": fontWeight,
    background,
    border,
    outline: border
  };
  function compressValue(node) {
    if (!this.declaration) {
      return;
    }
    const property = cssTree.property(this.declaration.property);
    if (handlers.hasOwnProperty(property.basename)) {
      handlers[property.basename](node);
    }
  }
  module.exports = compressValue;
});

// ../../../../node_modules/.bun/csso@5.0.5/node_modules/csso/cjs/replace/Number.cjs
var require_Number3 = __commonJS((exports) => {
  var OMIT_PLUSSIGN = /^(?:\+|(-))?0*(\d*)(?:\.0*|(\.\d*?)0*)?$/;
  var KEEP_PLUSSIGN = /^([\+\-])?0*(\d*)(?:\.0*|(\.\d*?)0*)?$/;
  var unsafeToRemovePlusSignAfter = new Set([
    "Dimension",
    "Hash",
    "Identifier",
    "Number",
    "Raw",
    "UnicodeRange"
  ]);
  function packNumber(value, item) {
    const regexp = item && item.prev !== null && unsafeToRemovePlusSignAfter.has(item.prev.data.type) ? KEEP_PLUSSIGN : OMIT_PLUSSIGN;
    value = String(value).replace(regexp, "$1$2$3");
    if (value === "" || value === "-") {
      value = "0";
    }
    return value;
  }
  function Number2(node) {
    node.value = packNumber(node.value);
  }
  exports.Number = Number2;
  exports.packNumber = packNumber;
});

// ../../../../node_modules/.bun/csso@5.0.5/node_modules/csso/cjs/replace/Dimension.cjs
var require_Dimension3 = __commonJS((exports, module) => {
  var _Number = require_Number3();
  var MATH_FUNCTIONS = new Set([
    "calc",
    "min",
    "max",
    "clamp"
  ]);
  var LENGTH_UNIT = new Set([
    "px",
    "mm",
    "cm",
    "in",
    "pt",
    "pc",
    "em",
    "ex",
    "ch",
    "rem",
    "vh",
    "vw",
    "vmin",
    "vmax",
    "vm"
  ]);
  function compressDimension(node, item) {
    const value = _Number.packNumber(node.value);
    node.value = value;
    if (value === "0" && this.declaration !== null && this.atrulePrelude === null) {
      const unit = node.unit.toLowerCase();
      if (!LENGTH_UNIT.has(unit)) {
        return;
      }
      if (this.declaration.property === "-ms-flex" || this.declaration.property === "flex") {
        return;
      }
      if (this.function && MATH_FUNCTIONS.has(this.function.name)) {
        return;
      }
      item.data = {
        type: "Number",
        loc: node.loc,
        value
      };
    }
  }
  module.exports = compressDimension;
});

// ../../../../node_modules/.bun/csso@5.0.5/node_modules/csso/cjs/replace/Percentage.cjs
var require_Percentage3 = __commonJS((exports, module) => {
  var cssTree = require_cjs2();
  var _Number = require_Number3();
  var blacklist = new Set([
    "width",
    "min-width",
    "max-width",
    "height",
    "min-height",
    "max-height",
    "flex",
    "-ms-flex"
  ]);
  function compressPercentage(node, item) {
    node.value = _Number.packNumber(node.value);
    if (node.value === "0" && this.declaration && !blacklist.has(this.declaration.property)) {
      item.data = {
        type: "Number",
        loc: node.loc,
        value: node.value
      };
      if (!cssTree.lexer.matchDeclaration(this.declaration).isType(item.data, "length")) {
        item.data = node;
      }
    }
  }
  module.exports = compressPercentage;
});

// ../../../../node_modules/.bun/csso@5.0.5/node_modules/csso/cjs/replace/Url.cjs
var require_Url3 = __commonJS((exports, module) => {
  function Url(node) {
    node.value = node.value.replace(/\\/g, "/");
  }
  module.exports = Url;
});

// ../../../../node_modules/.bun/csso@5.0.5/node_modules/csso/cjs/replace/color.cjs
var require_color = __commonJS((exports) => {
  var cssTree = require_cjs2();
  var _Number = require_Number3();
  var NAME_TO_HEX = {
    aliceblue: "f0f8ff",
    antiquewhite: "faebd7",
    aqua: "0ff",
    aquamarine: "7fffd4",
    azure: "f0ffff",
    beige: "f5f5dc",
    bisque: "ffe4c4",
    black: "000",
    blanchedalmond: "ffebcd",
    blue: "00f",
    blueviolet: "8a2be2",
    brown: "a52a2a",
    burlywood: "deb887",
    cadetblue: "5f9ea0",
    chartreuse: "7fff00",
    chocolate: "d2691e",
    coral: "ff7f50",
    cornflowerblue: "6495ed",
    cornsilk: "fff8dc",
    crimson: "dc143c",
    cyan: "0ff",
    darkblue: "00008b",
    darkcyan: "008b8b",
    darkgoldenrod: "b8860b",
    darkgray: "a9a9a9",
    darkgrey: "a9a9a9",
    darkgreen: "006400",
    darkkhaki: "bdb76b",
    darkmagenta: "8b008b",
    darkolivegreen: "556b2f",
    darkorange: "ff8c00",
    darkorchid: "9932cc",
    darkred: "8b0000",
    darksalmon: "e9967a",
    darkseagreen: "8fbc8f",
    darkslateblue: "483d8b",
    darkslategray: "2f4f4f",
    darkslategrey: "2f4f4f",
    darkturquoise: "00ced1",
    darkviolet: "9400d3",
    deeppink: "ff1493",
    deepskyblue: "00bfff",
    dimgray: "696969",
    dimgrey: "696969",
    dodgerblue: "1e90ff",
    firebrick: "b22222",
    floralwhite: "fffaf0",
    forestgreen: "228b22",
    fuchsia: "f0f",
    gainsboro: "dcdcdc",
    ghostwhite: "f8f8ff",
    gold: "ffd700",
    goldenrod: "daa520",
    gray: "808080",
    grey: "808080",
    green: "008000",
    greenyellow: "adff2f",
    honeydew: "f0fff0",
    hotpink: "ff69b4",
    indianred: "cd5c5c",
    indigo: "4b0082",
    ivory: "fffff0",
    khaki: "f0e68c",
    lavender: "e6e6fa",
    lavenderblush: "fff0f5",
    lawngreen: "7cfc00",
    lemonchiffon: "fffacd",
    lightblue: "add8e6",
    lightcoral: "f08080",
    lightcyan: "e0ffff",
    lightgoldenrodyellow: "fafad2",
    lightgray: "d3d3d3",
    lightgrey: "d3d3d3",
    lightgreen: "90ee90",
    lightpink: "ffb6c1",
    lightsalmon: "ffa07a",
    lightseagreen: "20b2aa",
    lightskyblue: "87cefa",
    lightslategray: "789",
    lightslategrey: "789",
    lightsteelblue: "b0c4de",
    lightyellow: "ffffe0",
    lime: "0f0",
    limegreen: "32cd32",
    linen: "faf0e6",
    magenta: "f0f",
    maroon: "800000",
    mediumaquamarine: "66cdaa",
    mediumblue: "0000cd",
    mediumorchid: "ba55d3",
    mediumpurple: "9370db",
    mediumseagreen: "3cb371",
    mediumslateblue: "7b68ee",
    mediumspringgreen: "00fa9a",
    mediumturquoise: "48d1cc",
    mediumvioletred: "c71585",
    midnightblue: "191970",
    mintcream: "f5fffa",
    mistyrose: "ffe4e1",
    moccasin: "ffe4b5",
    navajowhite: "ffdead",
    navy: "000080",
    oldlace: "fdf5e6",
    olive: "808000",
    olivedrab: "6b8e23",
    orange: "ffa500",
    orangered: "ff4500",
    orchid: "da70d6",
    palegoldenrod: "eee8aa",
    palegreen: "98fb98",
    paleturquoise: "afeeee",
    palevioletred: "db7093",
    papayawhip: "ffefd5",
    peachpuff: "ffdab9",
    peru: "cd853f",
    pink: "ffc0cb",
    plum: "dda0dd",
    powderblue: "b0e0e6",
    purple: "800080",
    rebeccapurple: "639",
    red: "f00",
    rosybrown: "bc8f8f",
    royalblue: "4169e1",
    saddlebrown: "8b4513",
    salmon: "fa8072",
    sandybrown: "f4a460",
    seagreen: "2e8b57",
    seashell: "fff5ee",
    sienna: "a0522d",
    silver: "c0c0c0",
    skyblue: "87ceeb",
    slateblue: "6a5acd",
    slategray: "708090",
    slategrey: "708090",
    snow: "fffafa",
    springgreen: "00ff7f",
    steelblue: "4682b4",
    tan: "d2b48c",
    teal: "008080",
    thistle: "d8bfd8",
    tomato: "ff6347",
    turquoise: "40e0d0",
    violet: "ee82ee",
    wheat: "f5deb3",
    white: "fff",
    whitesmoke: "f5f5f5",
    yellow: "ff0",
    yellowgreen: "9acd32"
  };
  var HEX_TO_NAME = {
    "800000": "maroon",
    "800080": "purple",
    "808000": "olive",
    "808080": "gray",
    "00ffff": "cyan",
    f0ffff: "azure",
    f5f5dc: "beige",
    ffe4c4: "bisque",
    "000000": "black",
    "0000ff": "blue",
    a52a2a: "brown",
    ff7f50: "coral",
    ffd700: "gold",
    "008000": "green",
    "4b0082": "indigo",
    fffff0: "ivory",
    f0e68c: "khaki",
    "00ff00": "lime",
    faf0e6: "linen",
    "000080": "navy",
    ffa500: "orange",
    da70d6: "orchid",
    cd853f: "peru",
    ffc0cb: "pink",
    dda0dd: "plum",
    f00: "red",
    ff0000: "red",
    fa8072: "salmon",
    a0522d: "sienna",
    c0c0c0: "silver",
    fffafa: "snow",
    d2b48c: "tan",
    "008080": "teal",
    ff6347: "tomato",
    ee82ee: "violet",
    f5deb3: "wheat",
    ffffff: "white",
    ffff00: "yellow"
  };
  function hueToRgb(p, q, t) {
    if (t < 0) {
      t += 1;
    }
    if (t > 1) {
      t -= 1;
    }
    if (t < 1 / 6) {
      return p + (q - p) * 6 * t;
    }
    if (t < 1 / 2) {
      return q;
    }
    if (t < 2 / 3) {
      return p + (q - p) * (2 / 3 - t) * 6;
    }
    return p;
  }
  function hslToRgb(h, s, l, a) {
    let r;
    let g;
    let b;
    if (s === 0) {
      r = g = b = l;
    } else {
      const q = l < 0.5 ? l * (1 + s) : l + s - l * s;
      const p = 2 * l - q;
      r = hueToRgb(p, q, h + 1 / 3);
      g = hueToRgb(p, q, h);
      b = hueToRgb(p, q, h - 1 / 3);
    }
    return [
      Math.round(r * 255),
      Math.round(g * 255),
      Math.round(b * 255),
      a
    ];
  }
  function toHex(value) {
    value = value.toString(16);
    return value.length === 1 ? "0" + value : value;
  }
  function parseFunctionArgs(functionArgs, count, rgb) {
    let cursor = functionArgs.head;
    let args = [];
    let wasValue = false;
    while (cursor !== null) {
      const { type, value } = cursor.data;
      switch (type) {
        case "Number":
        case "Percentage":
          if (wasValue) {
            return;
          }
          wasValue = true;
          args.push({
            type,
            value: Number(value)
          });
          break;
        case "Operator":
          if (value === ",") {
            if (!wasValue) {
              return;
            }
            wasValue = false;
          } else if (wasValue || value !== "+") {
            return;
          }
          break;
        default:
          return;
      }
      cursor = cursor.next;
    }
    if (args.length !== count) {
      return;
    }
    if (args.length === 4) {
      if (args[3].type !== "Number") {
        return;
      }
      args[3].type = "Alpha";
    }
    if (rgb) {
      if (args[0].type !== args[1].type || args[0].type !== args[2].type) {
        return;
      }
    } else {
      if (args[0].type !== "Number" || args[1].type !== "Percentage" || args[2].type !== "Percentage") {
        return;
      }
      args[0].type = "Angle";
    }
    return args.map(function(arg) {
      let value = Math.max(0, arg.value);
      switch (arg.type) {
        case "Number":
          value = Math.min(value, 255);
          break;
        case "Percentage":
          value = Math.min(value, 100) / 100;
          if (!rgb) {
            return value;
          }
          value = 255 * value;
          break;
        case "Angle":
          return (value % 360 + 360) % 360 / 360;
        case "Alpha":
          return Math.min(value, 1);
      }
      return Math.round(value);
    });
  }
  function compressFunction(node, item) {
    let functionName = node.name;
    let args;
    if (functionName === "rgba" || functionName === "hsla") {
      args = parseFunctionArgs(node.children, 4, functionName === "rgba");
      if (!args) {
        return;
      }
      if (functionName === "hsla") {
        args = hslToRgb(...args);
        node.name = "rgba";
      }
      if (args[3] === 0) {
        const scopeFunctionName = this.function && this.function.name;
        if (args[0] === 0 && args[1] === 0 && args[2] === 0 || !/^(?:to|from|color-stop)$|gradient$/i.test(scopeFunctionName)) {
          item.data = {
            type: "Identifier",
            loc: node.loc,
            name: "transparent"
          };
          return;
        }
      }
      if (args[3] !== 1) {
        node.children.forEach((node2, item2, list) => {
          if (node2.type === "Operator") {
            if (node2.value !== ",") {
              list.remove(item2);
            }
            return;
          }
          item2.data = {
            type: "Number",
            loc: node2.loc,
            value: _Number.packNumber(args.shift())
          };
        });
        return;
      }
      functionName = "rgb";
    }
    if (functionName === "hsl") {
      args = args || parseFunctionArgs(node.children, 3, false);
      if (!args) {
        return;
      }
      args = hslToRgb(...args);
      functionName = "rgb";
    }
    if (functionName === "rgb") {
      args = args || parseFunctionArgs(node.children, 3, true);
      if (!args) {
        return;
      }
      item.data = {
        type: "Hash",
        loc: node.loc,
        value: toHex(args[0]) + toHex(args[1]) + toHex(args[2])
      };
      compressHex(item.data, item);
    }
  }
  function compressIdent(node, item) {
    if (this.declaration === null) {
      return;
    }
    let color = node.name.toLowerCase();
    if (NAME_TO_HEX.hasOwnProperty(color) && cssTree.lexer.matchDeclaration(this.declaration).isType(node, "color")) {
      const hex = NAME_TO_HEX[color];
      if (hex.length + 1 <= color.length) {
        item.data = {
          type: "Hash",
          loc: node.loc,
          value: hex
        };
      } else {
        if (color === "grey") {
          color = "gray";
        }
        node.name = color;
      }
    }
  }
  function compressHex(node, item) {
    let color = node.value.toLowerCase();
    if (color.length === 6 && color[0] === color[1] && color[2] === color[3] && color[4] === color[5]) {
      color = color[0] + color[2] + color[4];
    }
    if (HEX_TO_NAME[color]) {
      item.data = {
        type: "Identifier",
        loc: node.loc,
        name: HEX_TO_NAME[color]
      };
    } else {
      node.value = color;
    }
  }
  exports.compressFunction = compressFunction;
  exports.compressHex = compressHex;
  exports.compressIdent = compressIdent;
});

// ../../../../node_modules/.bun/csso@5.0.5/node_modules/csso/cjs/replace/index.cjs
var require_replace = __commonJS((exports, module) => {
  var cssTree = require_cjs2();
  var Atrule = require_Atrule4();
  var AttributeSelector = require_AttributeSelector3();
  var Value = require_Value3();
  var Dimension = require_Dimension3();
  var Percentage = require_Percentage3();
  var _Number = require_Number3();
  var Url = require_Url3();
  var color = require_color();
  var handlers = {
    Atrule,
    AttributeSelector,
    Value,
    Dimension,
    Percentage,
    Number: _Number.Number,
    Url,
    Hash: color.compressHex,
    Identifier: color.compressIdent,
    Function: color.compressFunction
  };
  function replace(ast) {
    cssTree.walk(ast, {
      leave(node, item, list) {
        if (handlers.hasOwnProperty(node.type)) {
          handlers[node.type].call(this, node, item, list);
        }
      }
    });
  }
  module.exports = replace;
});

// ../../../../node_modules/.bun/csso@5.0.5/node_modules/csso/cjs/restructure/prepare/createDeclarationIndexer.cjs
var require_createDeclarationIndexer = __commonJS((exports, module) => {
  var cssTree = require_cjs2();

  class Index {
    constructor() {
      this.map = new Map;
    }
    resolve(str) {
      let index = this.map.get(str);
      if (index === undefined) {
        index = this.map.size + 1;
        this.map.set(str, index);
      }
      return index;
    }
  }
  function createDeclarationIndexer() {
    const ids = new Index;
    return function markDeclaration(node) {
      const id = cssTree.generate(node);
      node.id = ids.resolve(id);
      node.length = id.length;
      node.fingerprint = null;
      return node;
    };
  }
  module.exports = createDeclarationIndexer;
});

// ../../../../node_modules/.bun/csso@5.0.5/node_modules/csso/cjs/restructure/prepare/specificity.cjs
var require_specificity = __commonJS((exports, module) => {
  var cssTree = require_cjs2();
  function ensureSelectorList(node) {
    if (node.type === "Raw") {
      return cssTree.parse(node.value, { context: "selectorList" });
    }
    return node;
  }
  function maxSpecificity(a, b) {
    for (let i = 0;i < 3; i++) {
      if (a[i] !== b[i]) {
        return a[i] > b[i] ? a : b;
      }
    }
    return a;
  }
  function maxSelectorListSpecificity(selectorList) {
    return ensureSelectorList(selectorList).children.reduce((result, node) => maxSpecificity(specificity(node), result), [0, 0, 0]);
  }
  function specificity(simpleSelector) {
    let A = 0;
    let B = 0;
    let C = 0;
    simpleSelector.children.forEach((node) => {
      switch (node.type) {
        case "IdSelector":
          A++;
          break;
        case "ClassSelector":
        case "AttributeSelector":
          B++;
          break;
        case "PseudoClassSelector":
          switch (node.name.toLowerCase()) {
            case "not":
            case "has":
            case "is":
            case "matches":
            case "-webkit-any":
            case "-moz-any": {
              const [a, b, c] = maxSelectorListSpecificity(node.children.first);
              A += a;
              B += b;
              C += c;
              break;
            }
            case "nth-child":
            case "nth-last-child": {
              const arg = node.children.first;
              if (arg.type === "Nth" && arg.selector) {
                const [a, b, c] = maxSelectorListSpecificity(arg.selector);
                A += a;
                B += b + 1;
                C += c;
              } else {
                B++;
              }
              break;
            }
            case "where":
              break;
            case "before":
            case "after":
            case "first-line":
            case "first-letter":
              C++;
              break;
            default:
              B++;
          }
          break;
        case "TypeSelector":
          if (!node.name.endsWith("*")) {
            C++;
          }
          break;
        case "PseudoElementSelector":
          C++;
          break;
      }
    });
    return [A, B, C];
  }
  module.exports = specificity;
});

// ../../../../node_modules/.bun/csso@5.0.5/node_modules/csso/cjs/restructure/prepare/processSelector.cjs
var require_processSelector = __commonJS((exports, module) => {
  var cssTree = require_cjs2();
  var specificity = require_specificity();
  var nonFreezePseudoElements = new Set([
    "first-letter",
    "first-line",
    "after",
    "before"
  ]);
  var nonFreezePseudoClasses = new Set([
    "link",
    "visited",
    "hover",
    "active",
    "first-letter",
    "first-line",
    "after",
    "before"
  ]);
  function processSelector(node, usageData) {
    const pseudos = new Set;
    node.prelude.children.forEach(function(simpleSelector) {
      let tagName = "*";
      let scope = 0;
      simpleSelector.children.forEach(function(node2) {
        switch (node2.type) {
          case "ClassSelector":
            if (usageData && usageData.scopes) {
              const classScope = usageData.scopes[node2.name] || 0;
              if (scope !== 0 && classScope !== scope) {
                throw new Error("Selector can't has classes from different scopes: " + cssTree.generate(simpleSelector));
              }
              scope = classScope;
            }
            break;
          case "PseudoClassSelector": {
            const name = node2.name.toLowerCase();
            if (!nonFreezePseudoClasses.has(name)) {
              pseudos.add(`:${name}`);
            }
            break;
          }
          case "PseudoElementSelector": {
            const name = node2.name.toLowerCase();
            if (!nonFreezePseudoElements.has(name)) {
              pseudos.add(`::${name}`);
            }
            break;
          }
          case "TypeSelector":
            tagName = node2.name.toLowerCase();
            break;
          case "AttributeSelector":
            if (node2.flags) {
              pseudos.add(`[${node2.flags.toLowerCase()}]`);
            }
            break;
          case "Combinator":
            tagName = "*";
            break;
        }
      });
      simpleSelector.compareMarker = specificity(simpleSelector).toString();
      simpleSelector.id = null;
      simpleSelector.id = cssTree.generate(simpleSelector);
      if (scope) {
        simpleSelector.compareMarker += ":" + scope;
      }
      if (tagName !== "*") {
        simpleSelector.compareMarker += "," + tagName;
      }
    });
    node.pseudoSignature = pseudos.size > 0 ? [...pseudos].sort().join(",") : false;
  }
  module.exports = processSelector;
});

// ../../../../node_modules/.bun/csso@5.0.5/node_modules/csso/cjs/restructure/prepare/index.cjs
var require_prepare = __commonJS((exports, module) => {
  var cssTree = require_cjs2();
  var createDeclarationIndexer = require_createDeclarationIndexer();
  var processSelector = require_processSelector();
  function prepare(ast, options) {
    const markDeclaration = createDeclarationIndexer();
    cssTree.walk(ast, {
      visit: "Rule",
      enter(node) {
        node.block.children.forEach(markDeclaration);
        processSelector(node, options.usage);
      }
    });
    cssTree.walk(ast, {
      visit: "Atrule",
      enter(node) {
        if (node.prelude) {
          node.prelude.id = null;
          node.prelude.id = cssTree.generate(node.prelude);
        }
        if (cssTree.keyword(node.name).basename === "keyframes") {
          node.block.avoidRulesMerge = true;
          node.block.children.forEach(function(rule) {
            rule.prelude.children.forEach(function(simpleselector) {
              simpleselector.compareMarker = simpleselector.id;
            });
          });
        }
      }
    });
    return {
      declaration: markDeclaration
    };
  }
  module.exports = prepare;
});

// ../../../../node_modules/.bun/csso@5.0.5/node_modules/csso/cjs/restructure/1-mergeAtrule.cjs
var require_1_mergeAtrule = __commonJS((exports, module) => {
  var cssTree = require_cjs2();
  var { hasOwnProperty: hasOwnProperty2 } = Object.prototype;
  function addRuleToMap(map, item, list, single) {
    const node = item.data;
    const name = cssTree.keyword(node.name).basename;
    const id = node.name.toLowerCase() + "/" + (node.prelude ? node.prelude.id : null);
    if (!hasOwnProperty2.call(map, name)) {
      map[name] = Object.create(null);
    }
    if (single) {
      delete map[name][id];
    }
    if (!hasOwnProperty2.call(map[name], id)) {
      map[name][id] = new cssTree.List;
    }
    map[name][id].append(list.remove(item));
  }
  function relocateAtrules(ast, options) {
    const collected = Object.create(null);
    let topInjectPoint = null;
    ast.children.forEach(function(node, item, list) {
      if (node.type === "Atrule") {
        const name = cssTree.keyword(node.name).basename;
        switch (name) {
          case "keyframes":
            addRuleToMap(collected, item, list, true);
            return;
          case "media":
            if (options.forceMediaMerge) {
              addRuleToMap(collected, item, list, false);
              return;
            }
            break;
        }
        if (topInjectPoint === null && name !== "charset" && name !== "import") {
          topInjectPoint = item;
        }
      } else {
        if (topInjectPoint === null) {
          topInjectPoint = item;
        }
      }
    });
    for (const atrule in collected) {
      for (const id in collected[atrule]) {
        ast.children.insertList(collected[atrule][id], atrule === "media" ? null : topInjectPoint);
      }
    }
  }
  function isMediaRule(node) {
    return node.type === "Atrule" && node.name === "media";
  }
  function processAtrule(node, item, list) {
    if (!isMediaRule(node)) {
      return;
    }
    const prev = item.prev && item.prev.data;
    if (!prev || !isMediaRule(prev)) {
      return;
    }
    if (node.prelude && prev.prelude && node.prelude.id === prev.prelude.id) {
      prev.block.children.appendList(node.block.children);
      list.remove(item);
    }
  }
  function rejoinAtrule(ast, options) {
    relocateAtrules(ast, options);
    cssTree.walk(ast, {
      visit: "Atrule",
      reverse: true,
      enter: processAtrule
    });
  }
  module.exports = rejoinAtrule;
});

// ../../../../node_modules/.bun/csso@5.0.5/node_modules/csso/cjs/restructure/utils.cjs
var require_utils4 = __commonJS((exports) => {
  var { hasOwnProperty: hasOwnProperty2 } = Object.prototype;
  function isEqualSelectors(a, b) {
    let cursor1 = a.head;
    let cursor2 = b.head;
    while (cursor1 !== null && cursor2 !== null && cursor1.data.id === cursor2.data.id) {
      cursor1 = cursor1.next;
      cursor2 = cursor2.next;
    }
    return cursor1 === null && cursor2 === null;
  }
  function isEqualDeclarations(a, b) {
    let cursor1 = a.head;
    let cursor2 = b.head;
    while (cursor1 !== null && cursor2 !== null && cursor1.data.id === cursor2.data.id) {
      cursor1 = cursor1.next;
      cursor2 = cursor2.next;
    }
    return cursor1 === null && cursor2 === null;
  }
  function compareDeclarations(declarations1, declarations2) {
    const result = {
      eq: [],
      ne1: [],
      ne2: [],
      ne2overrided: []
    };
    const fingerprints = Object.create(null);
    const declarations2hash = Object.create(null);
    for (let cursor = declarations2.head;cursor; cursor = cursor.next) {
      declarations2hash[cursor.data.id] = true;
    }
    for (let cursor = declarations1.head;cursor; cursor = cursor.next) {
      const data = cursor.data;
      if (data.fingerprint) {
        fingerprints[data.fingerprint] = data.important;
      }
      if (declarations2hash[data.id]) {
        declarations2hash[data.id] = false;
        result.eq.push(data);
      } else {
        result.ne1.push(data);
      }
    }
    for (let cursor = declarations2.head;cursor; cursor = cursor.next) {
      const data = cursor.data;
      if (declarations2hash[data.id]) {
        if (!hasOwnProperty2.call(fingerprints, data.fingerprint) || !fingerprints[data.fingerprint] && data.important) {
          result.ne2.push(data);
        }
        result.ne2overrided.push(data);
      }
    }
    return result;
  }
  function addSelectors(dest, source) {
    source.forEach((sourceData) => {
      const newStr = sourceData.id;
      let cursor = dest.head;
      while (cursor) {
        const nextStr = cursor.data.id;
        if (nextStr === newStr) {
          return;
        }
        if (nextStr > newStr) {
          break;
        }
        cursor = cursor.next;
      }
      dest.insert(dest.createItem(sourceData), cursor);
    });
    return dest;
  }
  function hasSimilarSelectors(selectors1, selectors2) {
    let cursor1 = selectors1.head;
    while (cursor1 !== null) {
      let cursor2 = selectors2.head;
      while (cursor2 !== null) {
        if (cursor1.data.compareMarker === cursor2.data.compareMarker) {
          return true;
        }
        cursor2 = cursor2.next;
      }
      cursor1 = cursor1.next;
    }
    return false;
  }
  function unsafeToSkipNode(node) {
    switch (node.type) {
      case "Rule":
        return hasSimilarSelectors(node.prelude.children, this);
      case "Atrule":
        if (node.block) {
          return node.block.children.some(unsafeToSkipNode, this);
        }
        break;
      case "Declaration":
        return false;
    }
    return true;
  }
  exports.addSelectors = addSelectors;
  exports.compareDeclarations = compareDeclarations;
  exports.hasSimilarSelectors = hasSimilarSelectors;
  exports.isEqualDeclarations = isEqualDeclarations;
  exports.isEqualSelectors = isEqualSelectors;
  exports.unsafeToSkipNode = unsafeToSkipNode;
});

// ../../../../node_modules/.bun/csso@5.0.5/node_modules/csso/cjs/restructure/2-initialMergeRuleset.cjs
var require_2_initialMergeRuleset = __commonJS((exports, module) => {
  var cssTree = require_cjs2();
  var utils = require_utils4();
  function processRule(node, item, list) {
    const selectors = node.prelude.children;
    const declarations = node.block.children;
    list.prevUntil(item.prev, function(prev) {
      if (prev.type !== "Rule") {
        return utils.unsafeToSkipNode.call(selectors, prev);
      }
      const prevSelectors = prev.prelude.children;
      const prevDeclarations = prev.block.children;
      if (node.pseudoSignature === prev.pseudoSignature) {
        if (utils.isEqualSelectors(prevSelectors, selectors)) {
          prevDeclarations.appendList(declarations);
          list.remove(item);
          return true;
        }
        if (utils.isEqualDeclarations(declarations, prevDeclarations)) {
          utils.addSelectors(prevSelectors, selectors);
          list.remove(item);
          return true;
        }
      }
      return utils.hasSimilarSelectors(selectors, prevSelectors);
    });
  }
  function initialMergeRule(ast) {
    cssTree.walk(ast, {
      visit: "Rule",
      enter: processRule
    });
  }
  module.exports = initialMergeRule;
});

// ../../../../node_modules/.bun/csso@5.0.5/node_modules/csso/cjs/restructure/3-disjoinRuleset.cjs
var require_3_disjoinRuleset = __commonJS((exports, module) => {
  var cssTree = require_cjs2();
  function processRule(node, item, list) {
    const selectors = node.prelude.children;
    while (selectors.head !== selectors.tail) {
      const newSelectors = new cssTree.List;
      newSelectors.insert(selectors.remove(selectors.head));
      list.insert(list.createItem({
        type: "Rule",
        loc: node.loc,
        prelude: {
          type: "SelectorList",
          loc: node.prelude.loc,
          children: newSelectors
        },
        block: {
          type: "Block",
          loc: node.block.loc,
          children: node.block.children.copy()
        },
        pseudoSignature: node.pseudoSignature
      }), item);
    }
  }
  function disjoinRule(ast) {
    cssTree.walk(ast, {
      visit: "Rule",
      reverse: true,
      enter: processRule
    });
  }
  module.exports = disjoinRule;
});

// ../../../../node_modules/.bun/csso@5.0.5/node_modules/csso/cjs/restructure/4-restructShorthand.cjs
var require_4_restructShorthand = __commonJS((exports, module) => {
  var cssTree = require_cjs2();
  var REPLACE = 1;
  var REMOVE = 2;
  var TOP = 0;
  var RIGHT = 1;
  var BOTTOM = 2;
  var LEFT = 3;
  var SIDES = ["top", "right", "bottom", "left"];
  var SIDE = {
    "margin-top": "top",
    "margin-right": "right",
    "margin-bottom": "bottom",
    "margin-left": "left",
    "padding-top": "top",
    "padding-right": "right",
    "padding-bottom": "bottom",
    "padding-left": "left",
    "border-top-color": "top",
    "border-right-color": "right",
    "border-bottom-color": "bottom",
    "border-left-color": "left",
    "border-top-width": "top",
    "border-right-width": "right",
    "border-bottom-width": "bottom",
    "border-left-width": "left",
    "border-top-style": "top",
    "border-right-style": "right",
    "border-bottom-style": "bottom",
    "border-left-style": "left"
  };
  var MAIN_PROPERTY = {
    margin: "margin",
    "margin-top": "margin",
    "margin-right": "margin",
    "margin-bottom": "margin",
    "margin-left": "margin",
    padding: "padding",
    "padding-top": "padding",
    "padding-right": "padding",
    "padding-bottom": "padding",
    "padding-left": "padding",
    "border-color": "border-color",
    "border-top-color": "border-color",
    "border-right-color": "border-color",
    "border-bottom-color": "border-color",
    "border-left-color": "border-color",
    "border-width": "border-width",
    "border-top-width": "border-width",
    "border-right-width": "border-width",
    "border-bottom-width": "border-width",
    "border-left-width": "border-width",
    "border-style": "border-style",
    "border-top-style": "border-style",
    "border-right-style": "border-style",
    "border-bottom-style": "border-style",
    "border-left-style": "border-style"
  };

  class TRBL {
    constructor(name) {
      this.name = name;
      this.loc = null;
      this.iehack = undefined;
      this.sides = {
        top: null,
        right: null,
        bottom: null,
        left: null
      };
    }
    getValueSequence(declaration, count) {
      const values = [];
      let iehack = "";
      const hasBadValues = declaration.value.type !== "Value" || declaration.value.children.some(function(child) {
        let special = false;
        switch (child.type) {
          case "Identifier":
            switch (child.name) {
              case "\\0":
              case "\\9":
                iehack = child.name;
                return;
              case "inherit":
              case "initial":
              case "unset":
              case "revert":
                special = child.name;
                break;
            }
            break;
          case "Dimension":
            switch (child.unit) {
              case "rem":
              case "vw":
              case "vh":
              case "vmin":
              case "vmax":
              case "vm":
                special = child.unit;
                break;
            }
            break;
          case "Hash":
          case "Number":
          case "Percentage":
            break;
          case "Function":
            if (child.name === "var") {
              return true;
            }
            special = child.name;
            break;
          default:
            return true;
        }
        values.push({
          node: child,
          special,
          important: declaration.important
        });
      });
      if (hasBadValues || values.length > count) {
        return false;
      }
      if (typeof this.iehack === "string" && this.iehack !== iehack) {
        return false;
      }
      this.iehack = iehack;
      return values;
    }
    canOverride(side, value) {
      const currentValue = this.sides[side];
      return !currentValue || value.important && !currentValue.important;
    }
    add(name, declaration) {
      function attemptToAdd() {
        const sides = this.sides;
        const side = SIDE[name];
        if (side) {
          if (side in sides === false) {
            return false;
          }
          const values = this.getValueSequence(declaration, 1);
          if (!values || !values.length) {
            return false;
          }
          for (const key in sides) {
            if (sides[key] !== null && sides[key].special !== values[0].special) {
              return false;
            }
          }
          if (!this.canOverride(side, values[0])) {
            return true;
          }
          sides[side] = values[0];
          return true;
        } else if (name === this.name) {
          const values = this.getValueSequence(declaration, 4);
          if (!values || !values.length) {
            return false;
          }
          switch (values.length) {
            case 1:
              values[RIGHT] = values[TOP];
              values[BOTTOM] = values[TOP];
              values[LEFT] = values[TOP];
              break;
            case 2:
              values[BOTTOM] = values[TOP];
              values[LEFT] = values[RIGHT];
              break;
            case 3:
              values[LEFT] = values[RIGHT];
              break;
          }
          for (let i = 0;i < 4; i++) {
            for (const key in sides) {
              if (sides[key] !== null && sides[key].special !== values[i].special) {
                return false;
              }
            }
          }
          for (let i = 0;i < 4; i++) {
            if (this.canOverride(SIDES[i], values[i])) {
              sides[SIDES[i]] = values[i];
            }
          }
          return true;
        }
      }
      if (!attemptToAdd.call(this)) {
        return false;
      }
      if (!this.loc) {
        this.loc = declaration.loc;
      }
      return true;
    }
    isOkToMinimize() {
      const top = this.sides.top;
      const right = this.sides.right;
      const bottom = this.sides.bottom;
      const left = this.sides.left;
      if (top && right && bottom && left) {
        const important = top.important + right.important + bottom.important + left.important;
        return important === 0 || important === 4;
      }
      return false;
    }
    getValue() {
      const result = new cssTree.List;
      const sides = this.sides;
      const values = [
        sides.top,
        sides.right,
        sides.bottom,
        sides.left
      ];
      const stringValues = [
        cssTree.generate(sides.top.node),
        cssTree.generate(sides.right.node),
        cssTree.generate(sides.bottom.node),
        cssTree.generate(sides.left.node)
      ];
      if (stringValues[LEFT] === stringValues[RIGHT]) {
        values.pop();
        if (stringValues[BOTTOM] === stringValues[TOP]) {
          values.pop();
          if (stringValues[RIGHT] === stringValues[TOP]) {
            values.pop();
          }
        }
      }
      for (let i = 0;i < values.length; i++) {
        result.appendData(values[i].node);
      }
      if (this.iehack) {
        result.appendData({
          type: "Identifier",
          loc: null,
          name: this.iehack
        });
      }
      return {
        type: "Value",
        loc: null,
        children: result
      };
    }
    getDeclaration() {
      return {
        type: "Declaration",
        loc: this.loc,
        important: this.sides.top.important,
        property: this.name,
        value: this.getValue()
      };
    }
  }
  function processRule(rule, shorts, shortDeclarations, lastShortSelector) {
    const declarations = rule.block.children;
    const selector = rule.prelude.children.first.id;
    rule.block.children.forEachRight(function(declaration, item) {
      const property = declaration.property;
      if (!MAIN_PROPERTY.hasOwnProperty(property)) {
        return;
      }
      const key = MAIN_PROPERTY[property];
      let shorthand;
      let operation;
      if (!lastShortSelector || selector === lastShortSelector) {
        if (key in shorts) {
          operation = REMOVE;
          shorthand = shorts[key];
        }
      }
      if (!shorthand || !shorthand.add(property, declaration)) {
        operation = REPLACE;
        shorthand = new TRBL(key);
        if (!shorthand.add(property, declaration)) {
          lastShortSelector = null;
          return;
        }
      }
      shorts[key] = shorthand;
      shortDeclarations.push({
        operation,
        block: declarations,
        item,
        shorthand
      });
      lastShortSelector = selector;
    });
    return lastShortSelector;
  }
  function processShorthands(shortDeclarations, markDeclaration) {
    shortDeclarations.forEach(function(item) {
      const shorthand = item.shorthand;
      if (!shorthand.isOkToMinimize()) {
        return;
      }
      if (item.operation === REPLACE) {
        item.item.data = markDeclaration(shorthand.getDeclaration());
      } else {
        item.block.remove(item.item);
      }
    });
  }
  function restructBlock(ast, indexer) {
    const stylesheetMap = {};
    const shortDeclarations = [];
    cssTree.walk(ast, {
      visit: "Rule",
      reverse: true,
      enter(node) {
        const stylesheet = this.block || this.stylesheet;
        const ruleId = (node.pseudoSignature || "") + "|" + node.prelude.children.first.id;
        let ruleMap;
        let shorts;
        if (!stylesheetMap.hasOwnProperty(stylesheet.id)) {
          ruleMap = {
            lastShortSelector: null
          };
          stylesheetMap[stylesheet.id] = ruleMap;
        } else {
          ruleMap = stylesheetMap[stylesheet.id];
        }
        if (ruleMap.hasOwnProperty(ruleId)) {
          shorts = ruleMap[ruleId];
        } else {
          shorts = {};
          ruleMap[ruleId] = shorts;
        }
        ruleMap.lastShortSelector = processRule.call(this, node, shorts, shortDeclarations, ruleMap.lastShortSelector);
      }
    });
    processShorthands(shortDeclarations, indexer.declaration);
  }
  module.exports = restructBlock;
});

// ../../../../node_modules/.bun/csso@5.0.5/node_modules/csso/cjs/restructure/6-restructBlock.cjs
var require_6_restructBlock = __commonJS((exports, module) => {
  var cssTree = require_cjs2();
  var fingerprintId = 1;
  var dontRestructure = new Set([
    "src"
  ]);
  var DONT_MIX_VALUE = {
    display: /table|ruby|flex|-(flex)?box$|grid|contents|run-in/i,
    "text-align": /^(start|end|match-parent|justify-all)$/i
  };
  var SAFE_VALUES = {
    cursor: [
      "auto",
      "crosshair",
      "default",
      "move",
      "text",
      "wait",
      "help",
      "n-resize",
      "e-resize",
      "s-resize",
      "w-resize",
      "ne-resize",
      "nw-resize",
      "se-resize",
      "sw-resize",
      "pointer",
      "progress",
      "not-allowed",
      "no-drop",
      "vertical-text",
      "all-scroll",
      "col-resize",
      "row-resize"
    ],
    overflow: [
      "hidden",
      "visible",
      "scroll",
      "auto"
    ],
    position: [
      "static",
      "relative",
      "absolute",
      "fixed"
    ]
  };
  var NEEDLESS_TABLE = {
    "border-width": ["border"],
    "border-style": ["border"],
    "border-color": ["border"],
    "border-top": ["border"],
    "border-right": ["border"],
    "border-bottom": ["border"],
    "border-left": ["border"],
    "border-top-width": ["border-top", "border-width", "border"],
    "border-right-width": ["border-right", "border-width", "border"],
    "border-bottom-width": ["border-bottom", "border-width", "border"],
    "border-left-width": ["border-left", "border-width", "border"],
    "border-top-style": ["border-top", "border-style", "border"],
    "border-right-style": ["border-right", "border-style", "border"],
    "border-bottom-style": ["border-bottom", "border-style", "border"],
    "border-left-style": ["border-left", "border-style", "border"],
    "border-top-color": ["border-top", "border-color", "border"],
    "border-right-color": ["border-right", "border-color", "border"],
    "border-bottom-color": ["border-bottom", "border-color", "border"],
    "border-left-color": ["border-left", "border-color", "border"],
    "margin-top": ["margin"],
    "margin-right": ["margin"],
    "margin-bottom": ["margin"],
    "margin-left": ["margin"],
    "padding-top": ["padding"],
    "padding-right": ["padding"],
    "padding-bottom": ["padding"],
    "padding-left": ["padding"],
    "font-style": ["font"],
    "font-variant": ["font"],
    "font-weight": ["font"],
    "font-size": ["font"],
    "font-family": ["font"],
    "list-style-type": ["list-style"],
    "list-style-position": ["list-style"],
    "list-style-image": ["list-style"]
  };
  function getPropertyFingerprint(propertyName, declaration, fingerprints) {
    const realName = cssTree.property(propertyName).basename;
    if (realName === "background") {
      return propertyName + ":" + cssTree.generate(declaration.value);
    }
    const declarationId = declaration.id;
    let fingerprint = fingerprints[declarationId];
    if (!fingerprint) {
      switch (declaration.value.type) {
        case "Value":
          const special = {};
          let vendorId = "";
          let iehack = "";
          let raw = false;
          declaration.value.children.forEach(function walk(node) {
            switch (node.type) {
              case "Value":
              case "Brackets":
              case "Parentheses":
                node.children.forEach(walk);
                break;
              case "Raw":
                raw = true;
                break;
              case "Identifier": {
                const { name } = node;
                if (!vendorId) {
                  vendorId = cssTree.keyword(name).vendor;
                }
                if (/\\[09]/.test(name)) {
                  iehack = RegExp.lastMatch;
                }
                if (SAFE_VALUES.hasOwnProperty(realName)) {
                  if (SAFE_VALUES[realName].indexOf(name) === -1) {
                    special[name] = true;
                  }
                } else if (DONT_MIX_VALUE.hasOwnProperty(realName)) {
                  if (DONT_MIX_VALUE[realName].test(name)) {
                    special[name] = true;
                  }
                }
                break;
              }
              case "Function": {
                let { name } = node;
                if (!vendorId) {
                  vendorId = cssTree.keyword(name).vendor;
                }
                if (name === "rect") {
                  const hasComma = node.children.some((node2) => node2.type === "Operator" && node2.value === ",");
                  if (!hasComma) {
                    name = "rect-backward";
                  }
                }
                special[name + "()"] = true;
                node.children.forEach(walk);
                break;
              }
              case "Dimension": {
                const { unit } = node;
                if (/\\[09]/.test(unit)) {
                  iehack = RegExp.lastMatch;
                }
                switch (unit) {
                  case "rem":
                  case "vw":
                  case "vh":
                  case "vmin":
                  case "vmax":
                  case "vm":
                    special[unit] = true;
                    break;
                }
                break;
              }
            }
          });
          fingerprint = raw ? "!" + fingerprintId++ : "!" + Object.keys(special).sort() + "|" + iehack + vendorId;
          break;
        case "Raw":
          fingerprint = "!" + declaration.value.value;
          break;
        default:
          fingerprint = cssTree.generate(declaration.value);
      }
      fingerprints[declarationId] = fingerprint;
    }
    return propertyName + fingerprint;
  }
  function needless(props, declaration, fingerprints) {
    const property = cssTree.property(declaration.property);
    if (NEEDLESS_TABLE.hasOwnProperty(property.basename)) {
      const table = NEEDLESS_TABLE[property.basename];
      for (const entry of table) {
        const ppre = getPropertyFingerprint(property.prefix + entry, declaration, fingerprints);
        const prev = props.hasOwnProperty(ppre) ? props[ppre] : null;
        if (prev && (!declaration.important || prev.item.data.important)) {
          return prev;
        }
      }
    }
  }
  function processRule(rule, item, list, props, fingerprints) {
    const declarations = rule.block.children;
    declarations.forEachRight(function(declaration, declarationItem) {
      const { property } = declaration;
      const fingerprint = getPropertyFingerprint(property, declaration, fingerprints);
      const prev = props[fingerprint];
      if (prev && !dontRestructure.has(property)) {
        if (declaration.important && !prev.item.data.important) {
          props[fingerprint] = {
            block: declarations,
            item: declarationItem
          };
          prev.block.remove(prev.item);
        } else {
          declarations.remove(declarationItem);
        }
      } else {
        const prev2 = needless(props, declaration, fingerprints);
        if (prev2) {
          declarations.remove(declarationItem);
        } else {
          declaration.fingerprint = fingerprint;
          props[fingerprint] = {
            block: declarations,
            item: declarationItem
          };
        }
      }
    });
    if (declarations.isEmpty) {
      list.remove(item);
    }
  }
  function restructBlock(ast) {
    const stylesheetMap = {};
    const fingerprints = Object.create(null);
    cssTree.walk(ast, {
      visit: "Rule",
      reverse: true,
      enter(node, item, list) {
        const stylesheet = this.block || this.stylesheet;
        const ruleId = (node.pseudoSignature || "") + "|" + node.prelude.children.first.id;
        let ruleMap;
        let props;
        if (!stylesheetMap.hasOwnProperty(stylesheet.id)) {
          ruleMap = {};
          stylesheetMap[stylesheet.id] = ruleMap;
        } else {
          ruleMap = stylesheetMap[stylesheet.id];
        }
        if (ruleMap.hasOwnProperty(ruleId)) {
          props = ruleMap[ruleId];
        } else {
          props = {};
          ruleMap[ruleId] = props;
        }
        processRule.call(this, node, item, list, props, fingerprints);
      }
    });
  }
  module.exports = restructBlock;
});

// ../../../../node_modules/.bun/csso@5.0.5/node_modules/csso/cjs/restructure/7-mergeRuleset.cjs
var require_7_mergeRuleset = __commonJS((exports, module) => {
  var cssTree = require_cjs2();
  var utils = require_utils4();
  function processRule(node, item, list) {
    const selectors = node.prelude.children;
    const declarations = node.block.children;
    const nodeCompareMarker = selectors.first.compareMarker;
    const skippedCompareMarkers = {};
    list.nextUntil(item.next, function(next, nextItem) {
      if (next.type !== "Rule") {
        return utils.unsafeToSkipNode.call(selectors, next);
      }
      if (node.pseudoSignature !== next.pseudoSignature) {
        return true;
      }
      const nextFirstSelector = next.prelude.children.head;
      const nextDeclarations = next.block.children;
      const nextCompareMarker = nextFirstSelector.data.compareMarker;
      if (nextCompareMarker in skippedCompareMarkers) {
        return true;
      }
      if (selectors.head === selectors.tail) {
        if (selectors.first.id === nextFirstSelector.data.id) {
          declarations.appendList(nextDeclarations);
          list.remove(nextItem);
          return;
        }
      }
      if (utils.isEqualDeclarations(declarations, nextDeclarations)) {
        const nextStr = nextFirstSelector.data.id;
        selectors.some((data, item2) => {
          const curStr = data.id;
          if (nextStr < curStr) {
            selectors.insert(nextFirstSelector, item2);
            return true;
          }
          if (!item2.next) {
            selectors.insert(nextFirstSelector);
            return true;
          }
        });
        list.remove(nextItem);
        return;
      }
      if (nextCompareMarker === nodeCompareMarker) {
        return true;
      }
      skippedCompareMarkers[nextCompareMarker] = true;
    });
  }
  function mergeRule(ast) {
    cssTree.walk(ast, {
      visit: "Rule",
      enter: processRule
    });
  }
  module.exports = mergeRule;
});

// ../../../../node_modules/.bun/csso@5.0.5/node_modules/csso/cjs/restructure/8-restructRuleset.cjs
var require_8_restructRuleset = __commonJS((exports, module) => {
  var cssTree = require_cjs2();
  var utils = require_utils4();
  function calcSelectorLength(list) {
    return list.reduce((res, data) => res + data.id.length + 1, 0) - 1;
  }
  function calcDeclarationsLength(tokens) {
    let length = 0;
    for (const token of tokens) {
      length += token.length;
    }
    return length + tokens.length - 1;
  }
  function processRule(node, item, list) {
    const avoidRulesMerge = this.block !== null ? this.block.avoidRulesMerge : false;
    const selectors = node.prelude.children;
    const block = node.block;
    const disallowDownMarkers = Object.create(null);
    let allowMergeUp = true;
    let allowMergeDown = true;
    list.prevUntil(item.prev, function(prev, prevItem) {
      const prevBlock = prev.block;
      const prevType = prev.type;
      if (prevType !== "Rule") {
        const unsafe = utils.unsafeToSkipNode.call(selectors, prev);
        if (!unsafe && prevType === "Atrule" && prevBlock) {
          cssTree.walk(prevBlock, {
            visit: "Rule",
            enter(node2) {
              node2.prelude.children.forEach((data) => {
                disallowDownMarkers[data.compareMarker] = true;
              });
            }
          });
        }
        return unsafe;
      }
      if (node.pseudoSignature !== prev.pseudoSignature) {
        return true;
      }
      const prevSelectors = prev.prelude.children;
      allowMergeDown = !prevSelectors.some((selector) => (selector.compareMarker in disallowDownMarkers));
      if (!allowMergeDown && !allowMergeUp) {
        return true;
      }
      if (allowMergeUp && utils.isEqualSelectors(prevSelectors, selectors)) {
        prevBlock.children.appendList(block.children);
        list.remove(item);
        return true;
      }
      const diff = utils.compareDeclarations(block.children, prevBlock.children);
      if (diff.eq.length) {
        if (!diff.ne1.length && !diff.ne2.length) {
          if (allowMergeDown) {
            utils.addSelectors(selectors, prevSelectors);
            list.remove(prevItem);
          }
          return true;
        } else if (!avoidRulesMerge) {
          if (diff.ne1.length && !diff.ne2.length) {
            const selectorLength = calcSelectorLength(selectors);
            const blockLength = calcDeclarationsLength(diff.eq);
            if (allowMergeUp && selectorLength < blockLength) {
              utils.addSelectors(prevSelectors, selectors);
              block.children.fromArray(diff.ne1);
            }
          } else if (!diff.ne1.length && diff.ne2.length) {
            const selectorLength = calcSelectorLength(prevSelectors);
            const blockLength = calcDeclarationsLength(diff.eq);
            if (allowMergeDown && selectorLength < blockLength) {
              utils.addSelectors(selectors, prevSelectors);
              prevBlock.children.fromArray(diff.ne2);
            }
          } else {
            const newSelector = {
              type: "SelectorList",
              loc: null,
              children: utils.addSelectors(prevSelectors.copy(), selectors)
            };
            const newBlockLength = calcSelectorLength(newSelector.children) + 2;
            const blockLength = calcDeclarationsLength(diff.eq);
            if (blockLength >= newBlockLength) {
              const newItem = list.createItem({
                type: "Rule",
                loc: null,
                prelude: newSelector,
                block: {
                  type: "Block",
                  loc: null,
                  children: new cssTree.List().fromArray(diff.eq)
                },
                pseudoSignature: node.pseudoSignature
              });
              block.children.fromArray(diff.ne1);
              prevBlock.children.fromArray(diff.ne2overrided);
              if (allowMergeUp) {
                list.insert(newItem, prevItem);
              } else {
                list.insert(newItem, item);
              }
              return true;
            }
          }
        }
      }
      if (allowMergeUp) {
        allowMergeUp = !prevSelectors.some((prevSelector) => selectors.some((selector) => selector.compareMarker === prevSelector.compareMarker));
      }
      prevSelectors.forEach((data) => {
        disallowDownMarkers[data.compareMarker] = true;
      });
    });
  }
  function restructRule(ast) {
    cssTree.walk(ast, {
      visit: "Rule",
      reverse: true,
      enter: processRule
    });
  }
  module.exports = restructRule;
});

// ../../../../node_modules/.bun/csso@5.0.5/node_modules/csso/cjs/restructure/index.cjs
var require_restructure = __commonJS((exports, module) => {
  var index = require_prepare();
  var _1MergeAtrule = require_1_mergeAtrule();
  var _2InitialMergeRuleset = require_2_initialMergeRuleset();
  var _3DisjoinRuleset = require_3_disjoinRuleset();
  var _4RestructShorthand = require_4_restructShorthand();
  var _6RestructBlock = require_6_restructBlock();
  var _7MergeRuleset = require_7_mergeRuleset();
  var _8RestructRuleset = require_8_restructRuleset();
  function restructure(ast, options) {
    const indexer = index(ast, options);
    options.logger("prepare", ast);
    _1MergeAtrule(ast, options);
    options.logger("mergeAtrule", ast);
    _2InitialMergeRuleset(ast);
    options.logger("initialMergeRuleset", ast);
    _3DisjoinRuleset(ast);
    options.logger("disjoinRuleset", ast);
    _4RestructShorthand(ast, indexer);
    options.logger("restructShorthand", ast);
    _6RestructBlock(ast);
    options.logger("restructBlock", ast);
    _7MergeRuleset(ast);
    options.logger("mergeRuleset", ast);
    _8RestructRuleset(ast);
    options.logger("restructRuleset", ast);
  }
  module.exports = restructure;
});

// ../../../../node_modules/.bun/csso@5.0.5/node_modules/csso/cjs/compress.cjs
var require_compress = __commonJS((exports, module) => {
  var cssTree = require_cjs2();
  var usage = require_usage();
  var index = require_clean();
  var index$1 = require_replace();
  var index$2 = require_restructure();
  function readChunk(input, specialComments) {
    const children = new cssTree.List;
    let nonSpaceTokenInBuffer = false;
    let protectedComment;
    input.nextUntil(input.head, (node, item, list) => {
      if (node.type === "Comment") {
        if (!specialComments || node.value.charAt(0) !== "!") {
          list.remove(item);
          return;
        }
        if (nonSpaceTokenInBuffer || protectedComment) {
          return true;
        }
        list.remove(item);
        protectedComment = node;
        return;
      }
      if (node.type !== "WhiteSpace") {
        nonSpaceTokenInBuffer = true;
      }
      children.insert(list.remove(item));
    });
    return {
      comment: protectedComment,
      stylesheet: {
        type: "StyleSheet",
        loc: null,
        children
      }
    };
  }
  function compressChunk(ast, firstAtrulesAllowed, num, options) {
    options.logger(`Compress block #${num}`, null, true);
    let seed = 1;
    if (ast.type === "StyleSheet") {
      ast.firstAtrulesAllowed = firstAtrulesAllowed;
      ast.id = seed++;
    }
    cssTree.walk(ast, {
      visit: "Atrule",
      enter(node) {
        if (node.block !== null) {
          node.block.id = seed++;
        }
      }
    });
    options.logger("init", ast);
    index(ast, options);
    options.logger("clean", ast);
    index$1(ast);
    options.logger("replace", ast);
    if (options.restructuring) {
      index$2(ast, options);
    }
    return ast;
  }
  function getCommentsOption(options) {
    let comments = "comments" in options ? options.comments : "exclamation";
    if (typeof comments === "boolean") {
      comments = comments ? "exclamation" : false;
    } else if (comments !== "exclamation" && comments !== "first-exclamation") {
      comments = false;
    }
    return comments;
  }
  function getRestructureOption(options) {
    if ("restructure" in options) {
      return options.restructure;
    }
    return "restructuring" in options ? options.restructuring : true;
  }
  function wrapBlock(block) {
    return new cssTree.List().appendData({
      type: "Rule",
      loc: null,
      prelude: {
        type: "SelectorList",
        loc: null,
        children: new cssTree.List().appendData({
          type: "Selector",
          loc: null,
          children: new cssTree.List().appendData({
            type: "TypeSelector",
            loc: null,
            name: "x"
          })
        })
      },
      block
    });
  }
  function compress(ast, options) {
    ast = ast || { type: "StyleSheet", loc: null, children: new cssTree.List };
    options = options || {};
    const compressOptions = {
      logger: typeof options.logger === "function" ? options.logger : function() {},
      restructuring: getRestructureOption(options),
      forceMediaMerge: Boolean(options.forceMediaMerge),
      usage: options.usage ? usage.buildIndex(options.usage) : false
    };
    const output = new cssTree.List;
    let specialComments = getCommentsOption(options);
    let firstAtrulesAllowed = true;
    let input;
    let chunk;
    let chunkNum = 1;
    let chunkChildren;
    if (options.clone) {
      ast = cssTree.clone(ast);
    }
    if (ast.type === "StyleSheet") {
      input = ast.children;
      ast.children = output;
    } else {
      input = wrapBlock(ast);
    }
    do {
      chunk = readChunk(input, Boolean(specialComments));
      compressChunk(chunk.stylesheet, firstAtrulesAllowed, chunkNum++, compressOptions);
      chunkChildren = chunk.stylesheet.children;
      if (chunk.comment) {
        if (!output.isEmpty) {
          output.insert(cssTree.List.createItem({
            type: "Raw",
            value: `
`
          }));
        }
        output.insert(cssTree.List.createItem(chunk.comment));
        if (!chunkChildren.isEmpty) {
          output.insert(cssTree.List.createItem({
            type: "Raw",
            value: `
`
          }));
        }
      }
      if (firstAtrulesAllowed && !chunkChildren.isEmpty) {
        const lastRule = chunkChildren.last;
        if (lastRule.type !== "Atrule" || lastRule.name !== "import" && lastRule.name !== "charset") {
          firstAtrulesAllowed = false;
        }
      }
      if (specialComments !== "exclamation") {
        specialComments = false;
      }
      output.appendList(chunkChildren);
    } while (!input.isEmpty);
    return {
      ast
    };
  }
  module.exports = compress;
});

// ../../../../node_modules/.bun/csso@5.0.5/node_modules/csso/cjs/syntax.cjs
var require_syntax3 = __commonJS((exports) => {
  var cssTree = require_cjs2();
  var compress = require_compress();
  var specificity = require_specificity();
  function encodeString(value) {
    const stringApostrophe = cssTree.string.encode(value, true);
    const stringQuote = cssTree.string.encode(value);
    return stringApostrophe.length < stringQuote.length ? stringApostrophe : stringQuote;
  }
  var {
    lexer,
    tokenize,
    parse,
    generate,
    walk,
    find,
    findLast,
    findAll,
    fromPlainObject,
    toPlainObject
  } = cssTree.fork({
    node: {
      String: {
        generate(node) {
          this.token(cssTree.tokenTypes.String, encodeString(node.value));
        }
      },
      Url: {
        generate(node) {
          const encodedUrl = cssTree.url.encode(node.value);
          const string = encodeString(node.value);
          this.token(cssTree.tokenTypes.Url, encodedUrl.length <= string.length + 5 ? encodedUrl : "url(" + string + ")");
        }
      }
    }
  });
  exports.compress = compress;
  exports.specificity = specificity;
  exports.find = find;
  exports.findAll = findAll;
  exports.findLast = findLast;
  exports.fromPlainObject = fromPlainObject;
  exports.generate = generate;
  exports.lexer = lexer;
  exports.parse = parse;
  exports.toPlainObject = toPlainObject;
  exports.tokenize = tokenize;
  exports.walk = walk;
});

// ../../../../node_modules/.bun/csso@5.0.5/node_modules/csso/cjs/utils.cjs
var require_utils5 = __commonJS((exports) => {
  var processSelector = require_processSelector();
  var utils$1 = require_utils4();
  exports.processSelector = processSelector;
  exports.addSelectors = utils$1.addSelectors;
  exports.compareDeclarations = utils$1.compareDeclarations;
  exports.hasSimilarSelectors = utils$1.hasSimilarSelectors;
  exports.isEqualDeclarations = utils$1.isEqualDeclarations;
  exports.isEqualSelectors = utils$1.isEqualSelectors;
  exports.unsafeToSkipNode = utils$1.unsafeToSkipNode;
});

// ../../../../node_modules/.bun/csso@5.0.5/node_modules/csso/cjs/index.cjs
var require_cjs3 = __commonJS((exports) => {
  var version = require_version2();
  var syntax = require_syntax3();
  var utils = require_utils5();
  var { parse, generate, compress } = syntax;
  function debugOutput(name, options, startTime, data) {
    if (options.debug) {
      console.error(`## ${name} done in %d ms
`, Date.now() - startTime);
    }
    return data;
  }
  function createDefaultLogger(level) {
    let lastDebug;
    return function logger(title, ast) {
      let line = title;
      if (ast) {
        line = `[${((Date.now() - lastDebug) / 1000).toFixed(3)}s] ${line}`;
      }
      if (level > 1 && ast) {
        let css = generate(ast);
        if (level === 2 && css.length > 256) {
          css = css.substr(0, 256) + "...";
        }
        line += `
  ${css}
`;
      }
      console.error(line);
      lastDebug = Date.now();
    };
  }
  function buildCompressOptions(options) {
    options = { ...options };
    if (typeof options.logger !== "function" && options.debug) {
      options.logger = createDefaultLogger(options.debug);
    }
    return options;
  }
  function runHandler(ast, options, handlers) {
    if (!Array.isArray(handlers)) {
      handlers = [handlers];
    }
    handlers.forEach((fn) => fn(ast, options));
  }
  function minify(context, source, options) {
    options = options || {};
    const filename = options.filename || "<unknown>";
    let result;
    const ast = debugOutput("parsing", options, Date.now(), parse(source, {
      context,
      filename,
      positions: Boolean(options.sourceMap)
    }));
    if (options.beforeCompress) {
      debugOutput("beforeCompress", options, Date.now(), runHandler(ast, options, options.beforeCompress));
    }
    const compressResult = debugOutput("compress", options, Date.now(), compress(ast, buildCompressOptions(options)));
    if (options.afterCompress) {
      debugOutput("afterCompress", options, Date.now(), runHandler(compressResult, options, options.afterCompress));
    }
    if (options.sourceMap) {
      result = debugOutput("generate(sourceMap: true)", options, Date.now(), (() => {
        const tmp = generate(compressResult.ast, { sourceMap: true });
        tmp.map._file = filename;
        tmp.map.setSourceContent(filename, source);
        return tmp;
      })());
    } else {
      result = debugOutput("generate", options, Date.now(), {
        css: generate(compressResult.ast),
        map: null
      });
    }
    return result;
  }
  function minifyStylesheet(source, options) {
    return minify("stylesheet", source, options);
  }
  function minifyBlock(source, options) {
    return minify("declarationList", source, options);
  }
  exports.version = version.version;
  exports.syntax = syntax;
  exports.utils = utils;
  exports.minify = minifyStylesheet;
  exports.minifyBlock = minifyBlock;
});

// ../../../../node_modules/.bun/svgo@3.3.2/node_modules/svgo/lib/style.js
var require_style = __commonJS((exports) => {
  var csstree = require_cjs();
  var csswhat = require_commonjs();
  var {
    syntax: { specificity }
  } = require_cjs3();
  var { visit, matches } = require_xast();
  var {
    attrsGroups,
    inheritableAttrs,
    presentationNonInheritableGroupAttrs
  } = require__collections();
  var csstreeWalkSkip = csstree.walk.skip;
  var parseRule = (ruleNode, dynamic) => {
    const declarations = [];
    ruleNode.block.children.forEach((cssNode) => {
      if (cssNode.type === "Declaration") {
        declarations.push({
          name: cssNode.property,
          value: csstree.generate(cssNode.value),
          important: cssNode.important === true
        });
      }
    });
    const rules = [];
    csstree.walk(ruleNode.prelude, (node) => {
      if (node.type === "Selector") {
        const newNode = csstree.clone(node);
        let hasPseudoClasses = false;
        csstree.walk(newNode, (pseudoClassNode, item, list) => {
          if (pseudoClassNode.type === "PseudoClassSelector") {
            hasPseudoClasses = true;
            list.remove(item);
          }
        });
        rules.push({
          specificity: specificity(node),
          dynamic: hasPseudoClasses || dynamic,
          selector: csstree.generate(newNode),
          declarations
        });
      }
    });
    return rules;
  };
  var parseStylesheet = (css, dynamic) => {
    const rules = [];
    const ast = csstree.parse(css, {
      parseValue: false,
      parseAtrulePrelude: false
    });
    csstree.walk(ast, (cssNode) => {
      if (cssNode.type === "Rule") {
        rules.push(...parseRule(cssNode, dynamic || false));
        return csstreeWalkSkip;
      }
      if (cssNode.type === "Atrule") {
        if (cssNode.name === "keyframes" || cssNode.name === "-webkit-keyframes") {
          return csstreeWalkSkip;
        }
        csstree.walk(cssNode, (ruleNode) => {
          if (ruleNode.type === "Rule") {
            rules.push(...parseRule(ruleNode, dynamic || true));
            return csstreeWalkSkip;
          }
        });
        return csstreeWalkSkip;
      }
    });
    return rules;
  };
  var parseStyleDeclarations = (css) => {
    const declarations = [];
    const ast = csstree.parse(css, {
      context: "declarationList",
      parseValue: false
    });
    csstree.walk(ast, (cssNode) => {
      if (cssNode.type === "Declaration") {
        declarations.push({
          name: cssNode.property,
          value: csstree.generate(cssNode.value),
          important: cssNode.important === true
        });
      }
    });
    return declarations;
  };
  var computeOwnStyle = (stylesheet, node) => {
    const computedStyle = {};
    const importantStyles = new Map;
    for (const [name, value] of Object.entries(node.attributes)) {
      if (attrsGroups.presentation.has(name)) {
        computedStyle[name] = { type: "static", inherited: false, value };
        importantStyles.set(name, false);
      }
    }
    for (const { selector, declarations, dynamic } of stylesheet.rules) {
      if (matches(node, selector)) {
        for (const { name, value, important } of declarations) {
          const computed = computedStyle[name];
          if (computed && computed.type === "dynamic") {
            continue;
          }
          if (dynamic) {
            computedStyle[name] = { type: "dynamic", inherited: false };
            continue;
          }
          if (computed == null || important === true || importantStyles.get(name) === false) {
            computedStyle[name] = { type: "static", inherited: false, value };
            importantStyles.set(name, important);
          }
        }
      }
    }
    const styleDeclarations = node.attributes.style == null ? [] : parseStyleDeclarations(node.attributes.style);
    for (const { name, value, important } of styleDeclarations) {
      const computed = computedStyle[name];
      if (computed && computed.type === "dynamic") {
        continue;
      }
      if (computed == null || important === true || importantStyles.get(name) === false) {
        computedStyle[name] = { type: "static", inherited: false, value };
        importantStyles.set(name, important);
      }
    }
    return computedStyle;
  };
  var compareSpecificity = (a, b) => {
    for (let i = 0;i < 4; i += 1) {
      if (a[i] < b[i]) {
        return -1;
      } else if (a[i] > b[i]) {
        return 1;
      }
    }
    return 0;
  };
  exports.compareSpecificity = compareSpecificity;
  var collectStylesheet = (root) => {
    const rules = [];
    const parents = new Map;
    visit(root, {
      element: {
        enter: (node, parentNode) => {
          parents.set(node, parentNode);
          if (node.name !== "style") {
            return;
          }
          if (node.attributes.type == null || node.attributes.type === "" || node.attributes.type === "text/css") {
            const dynamic = node.attributes.media != null && node.attributes.media !== "all";
            for (const child of node.children) {
              if (child.type === "text" || child.type === "cdata") {
                rules.push(...parseStylesheet(child.value, dynamic));
              }
            }
          }
        }
      }
    });
    rules.sort((a, b) => compareSpecificity(a.specificity, b.specificity));
    return { rules, parents };
  };
  exports.collectStylesheet = collectStylesheet;
  var computeStyle = (stylesheet, node) => {
    const { parents } = stylesheet;
    const computedStyles = computeOwnStyle(stylesheet, node);
    let parent = parents.get(node);
    while (parent != null && parent.type !== "root") {
      const inheritedStyles = computeOwnStyle(stylesheet, parent);
      for (const [name, computed] of Object.entries(inheritedStyles)) {
        if (computedStyles[name] == null && inheritableAttrs.has(name) && !presentationNonInheritableGroupAttrs.has(name)) {
          computedStyles[name] = { ...computed, inherited: true };
        }
      }
      parent = parents.get(parent);
    }
    return computedStyles;
  };
  exports.computeStyle = computeStyle;
  var includesAttrSelector = (selector, name, value = null, traversed = false) => {
    const selectors = typeof selector === "string" ? csswhat.parse(selector) : csswhat.parse(csstree.generate(selector.data));
    for (const subselector of selectors) {
      const hasAttrSelector = subselector.some((segment, index) => {
        if (traversed) {
          if (index === subselector.length - 1) {
            return false;
          }
          const isNextTraversal = csswhat.isTraversal(subselector[index + 1]);
          if (!isNextTraversal) {
            return false;
          }
        }
        if (segment.type !== "attribute" || segment.name !== name) {
          return false;
        }
        return value == null ? true : segment.value === value;
      });
      if (hasAttrSelector) {
        return true;
      }
    }
    return false;
  };
  exports.includesAttrSelector = includesAttrSelector;
});

// ../../../../node_modules/.bun/svgo@3.3.2/node_modules/svgo/plugins/inlineStyles.js
var require_inlineStyles = __commonJS((exports) => {
  var csstree = require_cjs();
  var {
    syntax: { specificity }
  } = require_cjs3();
  var {
    visitSkip,
    querySelectorAll,
    detachNodeFromParent
  } = require_xast();
  var { compareSpecificity, includesAttrSelector } = require_style();
  var { attrsGroups, pseudoClasses } = require__collections();
  exports.name = "inlineStyles";
  exports.description = "inline styles (additional options)";
  var preservedPseudos = [
    ...pseudoClasses.functional,
    ...pseudoClasses.treeStructural
  ];
  exports.fn = (root, params) => {
    const {
      onlyMatchedOnce = true,
      removeMatchedSelectors = true,
      useMqs = ["", "screen"],
      usePseudos = [""]
    } = params;
    const styles = [];
    let selectors = [];
    return {
      element: {
        enter: (node, parentNode) => {
          if (node.name === "foreignObject") {
            return visitSkip;
          }
          if (node.name !== "style" || node.children.length === 0) {
            return;
          }
          if (node.attributes.type != null && node.attributes.type !== "" && node.attributes.type !== "text/css") {
            return;
          }
          const cssText = node.children.filter((child) => child.type === "text" || child.type === "cdata").map((child) => child.value).join("");
          let cssAst = null;
          try {
            cssAst = csstree.parse(cssText, {
              parseValue: false,
              parseCustomProperty: false
            });
          } catch {
            return;
          }
          if (cssAst.type === "StyleSheet") {
            styles.push({ node, parentNode, cssAst });
          }
          csstree.walk(cssAst, {
            visit: "Rule",
            enter(node2) {
              const atrule = this.atrule;
              let mediaQuery = "";
              if (atrule != null) {
                mediaQuery = atrule.name;
                if (atrule.prelude != null) {
                  mediaQuery += ` ${csstree.generate(atrule.prelude)}`;
                }
              }
              if (!useMqs.includes(mediaQuery)) {
                return;
              }
              if (node2.prelude.type === "SelectorList") {
                node2.prelude.children.forEach((childNode, item) => {
                  if (childNode.type === "Selector") {
                    const pseudos = [];
                    childNode.children.forEach((grandchildNode, grandchildItem, grandchildList) => {
                      const isPseudo = grandchildNode.type === "PseudoClassSelector" || grandchildNode.type === "PseudoElementSelector";
                      if (isPseudo && !preservedPseudos.includes(grandchildNode.name)) {
                        pseudos.push({
                          item: grandchildItem,
                          list: grandchildList
                        });
                      }
                    });
                    const pseudoSelectors = csstree.generate({
                      type: "Selector",
                      children: new csstree.List().fromArray(pseudos.map((pseudo) => pseudo.item.data))
                    });
                    if (usePseudos.includes(pseudoSelectors)) {
                      for (const pseudo of pseudos) {
                        pseudo.list.remove(pseudo.item);
                      }
                    }
                    selectors.push({ node: childNode, rule: node2, item });
                  }
                });
              }
            }
          });
        }
      },
      root: {
        exit: () => {
          if (styles.length === 0) {
            return;
          }
          const sortedSelectors = selectors.slice().sort((a, b) => {
            const aSpecificity = specificity(a.item.data);
            const bSpecificity = specificity(b.item.data);
            return compareSpecificity(aSpecificity, bSpecificity);
          }).reverse();
          for (const selector of sortedSelectors) {
            const selectorText = csstree.generate(selector.item.data);
            const matchedElements = [];
            try {
              for (const node of querySelectorAll(root, selectorText)) {
                if (node.type === "element") {
                  matchedElements.push(node);
                }
              }
            } catch (selectError) {
              continue;
            }
            if (matchedElements.length === 0) {
              continue;
            }
            if (onlyMatchedOnce && matchedElements.length > 1) {
              continue;
            }
            for (const selectedEl of matchedElements) {
              const styleDeclarationList = csstree.parse(selectedEl.attributes.style ?? "", {
                context: "declarationList",
                parseValue: false
              });
              if (styleDeclarationList.type !== "DeclarationList") {
                continue;
              }
              const styleDeclarationItems = new Map;
              let firstListItem;
              csstree.walk(styleDeclarationList, {
                visit: "Declaration",
                enter(node, item) {
                  if (firstListItem == null) {
                    firstListItem = item;
                  }
                  styleDeclarationItems.set(node.property.toLowerCase(), item);
                }
              });
              csstree.walk(selector.rule, {
                visit: "Declaration",
                enter(ruleDeclaration) {
                  const property = ruleDeclaration.property;
                  if (attrsGroups.presentation.has(property) && !selectors.some((selector2) => includesAttrSelector(selector2.item, property))) {
                    delete selectedEl.attributes[property];
                  }
                  const matchedItem = styleDeclarationItems.get(property);
                  const ruleDeclarationItem = styleDeclarationList.children.createItem(ruleDeclaration);
                  if (matchedItem == null) {
                    styleDeclarationList.children.insert(ruleDeclarationItem, firstListItem);
                  } else if (matchedItem.data.important !== true && ruleDeclaration.important === true) {
                    styleDeclarationList.children.replace(matchedItem, ruleDeclarationItem);
                    styleDeclarationItems.set(property, ruleDeclarationItem);
                  }
                }
              });
              const newStyles = csstree.generate(styleDeclarationList);
              if (newStyles.length !== 0) {
                selectedEl.attributes.style = newStyles;
              }
            }
            if (removeMatchedSelectors && matchedElements.length !== 0 && selector.rule.prelude.type === "SelectorList") {
              selector.rule.prelude.children.remove(selector.item);
            }
            selector.matchedElements = matchedElements;
          }
          if (!removeMatchedSelectors) {
            return;
          }
          for (const selector of sortedSelectors) {
            if (selector.matchedElements == null) {
              continue;
            }
            if (onlyMatchedOnce && selector.matchedElements.length > 1) {
              continue;
            }
            for (const selectedEl of selector.matchedElements) {
              const classList = new Set(selectedEl.attributes.class == null ? null : selectedEl.attributes.class.split(" "));
              for (const child of selector.node.children) {
                if (child.type === "ClassSelector" && !selectors.some((selector2) => includesAttrSelector(selector2.item, "class", child.name, true))) {
                  classList.delete(child.name);
                }
              }
              if (classList.size === 0) {
                delete selectedEl.attributes.class;
              } else {
                selectedEl.attributes.class = Array.from(classList).join(" ");
              }
              const firstSubSelector = selector.node.children.first;
              if (firstSubSelector?.type === "IdSelector" && selectedEl.attributes.id === firstSubSelector.name && !selectors.some((selector2) => includesAttrSelector(selector2.item, "id", firstSubSelector.name, true))) {
                delete selectedEl.attributes.id;
              }
            }
          }
          for (const style of styles) {
            csstree.walk(style.cssAst, {
              visit: "Rule",
              enter: function(node, item, list) {
                if (node.type === "Rule" && node.prelude.type === "SelectorList" && node.prelude.children.isEmpty) {
                  list.remove(item);
                }
              }
            });
            if (style.cssAst.children.isEmpty) {
              detachNodeFromParent(style.node, style.parentNode);
            } else {
              const firstChild = style.node.children[0];
              if (firstChild.type === "text" || firstChild.type === "cdata") {
                firstChild.value = csstree.generate(style.cssAst);
              }
            }
          }
        }
      }
    };
  };
});

// ../../../../node_modules/.bun/svgo@3.3.2/node_modules/svgo/lib/svgo/tools.js
var require_tools = __commonJS((exports) => {
  var { attrsGroups, referencesProps } = require__collections();
  var regReferencesUrl = /\burl\((["'])?#(.+?)\1\)/g;
  var regReferencesHref = /^#(.+?)$/;
  var regReferencesBegin = /(\w+)\.[a-zA-Z]/;
  exports.encodeSVGDatauri = (str, type) => {
    var prefix = "data:image/svg+xml";
    if (!type || type === "base64") {
      prefix += ";base64,";
      str = prefix + Buffer.from(str).toString("base64");
    } else if (type === "enc") {
      str = prefix + "," + encodeURIComponent(str);
    } else if (type === "unenc") {
      str = prefix + "," + str;
    }
    return str;
  };
  exports.decodeSVGDatauri = (str) => {
    var regexp = /data:image\/svg\+xml(;charset=[^;,]*)?(;base64)?,(.*)/;
    var match = regexp.exec(str);
    if (!match)
      return str;
    var data = match[3];
    if (match[2]) {
      str = Buffer.from(data, "base64").toString("utf8");
    } else if (data.charAt(0) === "%") {
      str = decodeURIComponent(data);
    } else if (data.charAt(0) === "<") {
      str = data;
    }
    return str;
  };
  exports.cleanupOutData = (data, params, command) => {
    let str = "";
    let delimiter;
    let prev;
    data.forEach((item, i) => {
      delimiter = " ";
      if (i == 0)
        delimiter = "";
      if (params.noSpaceAfterFlags && (command == "A" || command == "a")) {
        var pos = i % 7;
        if (pos == 4 || pos == 5)
          delimiter = "";
      }
      const itemStr = params.leadingZero ? removeLeadingZero(item) : item.toString();
      if (params.negativeExtraSpace && delimiter != "" && (item < 0 || itemStr.charAt(0) === "." && prev % 1 !== 0)) {
        delimiter = "";
      }
      prev = item;
      str += delimiter + itemStr;
    });
    return str;
  };
  var removeLeadingZero = (value) => {
    const strValue = value.toString();
    if (0 < value && value < 1 && strValue.startsWith("0")) {
      return strValue.slice(1);
    }
    if (-1 < value && value < 0 && strValue[1] === "0") {
      return strValue[0] + strValue.slice(2);
    }
    return strValue;
  };
  exports.removeLeadingZero = removeLeadingZero;
  var hasScripts = (node) => {
    if (node.name === "script" && node.children.length !== 0) {
      return true;
    }
    if (node.name === "a") {
      const hasJsLinks = Object.entries(node.attributes).some(([attrKey, attrValue]) => (attrKey === "href" || attrKey.endsWith(":href")) && attrValue != null && attrValue.trimStart().startsWith("javascript:"));
      if (hasJsLinks) {
        return true;
      }
    }
    const eventAttrs = [
      ...attrsGroups.animationEvent,
      ...attrsGroups.documentEvent,
      ...attrsGroups.documentElementEvent,
      ...attrsGroups.globalEvent,
      ...attrsGroups.graphicalEvent
    ];
    return eventAttrs.some((attr) => node.attributes[attr] != null);
  };
  exports.hasScripts = hasScripts;
  var includesUrlReference = (body) => {
    return new RegExp(regReferencesUrl).test(body);
  };
  exports.includesUrlReference = includesUrlReference;
  var findReferences = (attribute, value) => {
    const results = [];
    if (referencesProps.has(attribute)) {
      const matches = value.matchAll(regReferencesUrl);
      for (const match of matches) {
        results.push(match[2]);
      }
    }
    if (attribute === "href" || attribute.endsWith(":href")) {
      const match = regReferencesHref.exec(value);
      if (match != null) {
        results.push(match[1]);
      }
    }
    if (attribute === "begin") {
      const match = regReferencesBegin.exec(value);
      if (match != null) {
        results.push(match[1]);
      }
    }
    return results.map((body) => decodeURI(body));
  };
  exports.findReferences = findReferences;
  var toFixed = (num, precision) => {
    const pow = 10 ** precision;
    return Math.round(num * pow) / pow;
  };
  exports.toFixed = toFixed;
});

// ../../../../node_modules/.bun/svgo@3.3.2/node_modules/svgo/plugins/minifyStyles.js
var require_minifyStyles = __commonJS((exports) => {
  var csso = require_cjs3();
  var { detachNodeFromParent } = require_xast();
  var { hasScripts } = require_tools();
  exports.name = "minifyStyles";
  exports.description = "minifies styles and removes unused styles";
  exports.fn = (_root, { usage, ...params }) => {
    const styleElements = new Map;
    const elementsWithStyleAttributes = [];
    const tagsUsage = new Set;
    const idsUsage = new Set;
    const classesUsage = new Set;
    let enableTagsUsage = true;
    let enableIdsUsage = true;
    let enableClassesUsage = true;
    let forceUsageDeoptimized = false;
    if (typeof usage === "boolean") {
      enableTagsUsage = usage;
      enableIdsUsage = usage;
      enableClassesUsage = usage;
    } else if (usage) {
      enableTagsUsage = usage.tags == null ? true : usage.tags;
      enableIdsUsage = usage.ids == null ? true : usage.ids;
      enableClassesUsage = usage.classes == null ? true : usage.classes;
      forceUsageDeoptimized = usage.force == null ? false : usage.force;
    }
    let deoptimized = false;
    return {
      element: {
        enter: (node, parentNode) => {
          if (hasScripts(node)) {
            deoptimized = true;
          }
          tagsUsage.add(node.name);
          if (node.attributes.id != null) {
            idsUsage.add(node.attributes.id);
          }
          if (node.attributes.class != null) {
            for (const className of node.attributes.class.split(/\s+/)) {
              classesUsage.add(className);
            }
          }
          if (node.name === "style" && node.children.length !== 0) {
            styleElements.set(node, parentNode);
          } else if (node.attributes.style != null) {
            elementsWithStyleAttributes.push(node);
          }
        }
      },
      root: {
        exit: () => {
          const cssoUsage = {};
          if (!deoptimized || forceUsageDeoptimized) {
            if (enableTagsUsage) {
              cssoUsage.tags = Array.from(tagsUsage);
            }
            if (enableIdsUsage) {
              cssoUsage.ids = Array.from(idsUsage);
            }
            if (enableClassesUsage) {
              cssoUsage.classes = Array.from(classesUsage);
            }
          }
          for (const [styleNode, styleNodeParent] of styleElements.entries()) {
            if (styleNode.children[0].type === "text" || styleNode.children[0].type === "cdata") {
              const cssText = styleNode.children[0].value;
              const minified = csso.minify(cssText, {
                ...params,
                usage: cssoUsage
              }).css;
              if (minified.length === 0) {
                detachNodeFromParent(styleNode, styleNodeParent);
                continue;
              }
              if (cssText.indexOf(">") >= 0 || cssText.indexOf("<") >= 0) {
                styleNode.children[0].type = "cdata";
                styleNode.children[0].value = minified;
              } else {
                styleNode.children[0].type = "text";
                styleNode.children[0].value = minified;
              }
            }
          }
          for (const node of elementsWithStyleAttributes) {
            const elemStyle = node.attributes.style;
            node.attributes.style = csso.minifyBlock(elemStyle, {
              ...params
            }).css;
          }
        }
      }
    };
  };
});

// ../../../../node_modules/.bun/svgo@3.3.2/node_modules/svgo/plugins/cleanupIds.js
var require_cleanupIds = __commonJS((exports) => {
  var { visitSkip } = require_xast();
  var { hasScripts, findReferences } = require_tools();
  exports.name = "cleanupIds";
  exports.description = "removes unused IDs and minifies used";
  var generateIdChars = [
    "a",
    "b",
    "c",
    "d",
    "e",
    "f",
    "g",
    "h",
    "i",
    "j",
    "k",
    "l",
    "m",
    "n",
    "o",
    "p",
    "q",
    "r",
    "s",
    "t",
    "u",
    "v",
    "w",
    "x",
    "y",
    "z",
    "A",
    "B",
    "C",
    "D",
    "E",
    "F",
    "G",
    "H",
    "I",
    "J",
    "K",
    "L",
    "M",
    "N",
    "O",
    "P",
    "Q",
    "R",
    "S",
    "T",
    "U",
    "V",
    "W",
    "X",
    "Y",
    "Z"
  ];
  var maxIdIndex = generateIdChars.length - 1;
  var hasStringPrefix = (string, prefixes) => {
    for (const prefix of prefixes) {
      if (string.startsWith(prefix)) {
        return true;
      }
    }
    return false;
  };
  var generateId = (currentId) => {
    if (currentId == null) {
      return [0];
    }
    currentId[currentId.length - 1] += 1;
    for (let i = currentId.length - 1;i > 0; i--) {
      if (currentId[i] > maxIdIndex) {
        currentId[i] = 0;
        if (currentId[i - 1] !== undefined) {
          currentId[i - 1]++;
        }
      }
    }
    if (currentId[0] > maxIdIndex) {
      currentId[0] = 0;
      currentId.unshift(0);
    }
    return currentId;
  };
  var getIdString = (arr) => {
    return arr.map((i) => generateIdChars[i]).join("");
  };
  exports.fn = (_root, params) => {
    const {
      remove = true,
      minify = true,
      preserve = [],
      preservePrefixes = [],
      force = false
    } = params;
    const preserveIds = new Set(Array.isArray(preserve) ? preserve : preserve ? [preserve] : []);
    const preserveIdPrefixes = Array.isArray(preservePrefixes) ? preservePrefixes : preservePrefixes ? [preservePrefixes] : [];
    const nodeById = new Map;
    const referencesById = new Map;
    let deoptimized = false;
    return {
      element: {
        enter: (node) => {
          if (!force) {
            if (node.name === "style" && node.children.length !== 0 || hasScripts(node)) {
              deoptimized = true;
              return;
            }
            if (node.name === "svg") {
              let hasDefsOnly = true;
              for (const child of node.children) {
                if (child.type !== "element" || child.name !== "defs") {
                  hasDefsOnly = false;
                  break;
                }
              }
              if (hasDefsOnly) {
                return visitSkip;
              }
            }
          }
          for (const [name, value] of Object.entries(node.attributes)) {
            if (name === "id") {
              const id = value;
              if (nodeById.has(id)) {
                delete node.attributes.id;
              } else {
                nodeById.set(id, node);
              }
            } else {
              const ids = findReferences(name, value);
              for (const id of ids) {
                let refs = referencesById.get(id);
                if (refs == null) {
                  refs = [];
                  referencesById.set(id, refs);
                }
                refs.push({ element: node, name });
              }
            }
          }
        }
      },
      root: {
        exit: () => {
          if (deoptimized) {
            return;
          }
          const isIdPreserved = (id) => preserveIds.has(id) || hasStringPrefix(id, preserveIdPrefixes);
          let currentId = null;
          for (const [id, refs] of referencesById) {
            const node = nodeById.get(id);
            if (node != null) {
              if (minify && isIdPreserved(id) === false) {
                let currentIdString = null;
                do {
                  currentId = generateId(currentId);
                  currentIdString = getIdString(currentId);
                } while (isIdPreserved(currentIdString) || referencesById.has(currentIdString) && nodeById.get(currentIdString) == null);
                node.attributes.id = currentIdString;
                for (const { element, name } of refs) {
                  const value = element.attributes[name];
                  if (value.includes("#")) {
                    element.attributes[name] = value.replace(`#${encodeURI(id)}`, `#${currentIdString}`);
                  } else {
                    element.attributes[name] = value.replace(`${id}.`, `${currentIdString}.`);
                  }
                }
              }
              nodeById.delete(id);
            }
          }
          if (remove) {
            for (const [id, node] of nodeById) {
              if (isIdPreserved(id) === false) {
                delete node.attributes.id;
              }
            }
          }
        }
      }
    };
  };
});

// ../../../../node_modules/.bun/svgo@3.3.2/node_modules/svgo/plugins/removeUselessDefs.js
var require_removeUselessDefs = __commonJS((exports) => {
  var { detachNodeFromParent } = require_xast();
  var { elemsGroups } = require__collections();
  exports.name = "removeUselessDefs";
  exports.description = "removes elements in <defs> without id";
  exports.fn = () => {
    return {
      element: {
        enter: (node, parentNode) => {
          if (node.name === "defs") {
            const usefulNodes = [];
            collectUsefulNodes(node, usefulNodes);
            if (usefulNodes.length === 0) {
              detachNodeFromParent(node, parentNode);
            }
            for (const usefulNode of usefulNodes) {
              Object.defineProperty(usefulNode, "parentNode", {
                writable: true,
                value: node
              });
            }
            node.children = usefulNodes;
          } else if (elemsGroups.nonRendering.has(node.name) && node.attributes.id == null) {
            detachNodeFromParent(node, parentNode);
          }
        }
      }
    };
  };
  var collectUsefulNodes = (node, usefulNodes) => {
    for (const child of node.children) {
      if (child.type === "element") {
        if (child.attributes.id != null || child.name === "style") {
          usefulNodes.push(child);
        } else {
          collectUsefulNodes(child, usefulNodes);
        }
      }
    }
  };
});

// ../../../../node_modules/.bun/svgo@3.3.2/node_modules/svgo/plugins/cleanupNumericValues.js
var require_cleanupNumericValues = __commonJS((exports) => {
  var { removeLeadingZero } = require_tools();
  exports.name = "cleanupNumericValues";
  exports.description = "rounds numeric values to the fixed precision, removes default px units";
  var regNumericValues = /^([-+]?\d*\.?\d+([eE][-+]?\d+)?)(px|pt|pc|mm|cm|m|in|ft|em|ex|%)?$/;
  var absoluteLengths = {
    cm: 96 / 2.54,
    mm: 96 / 25.4,
    in: 96,
    pt: 4 / 3,
    pc: 16,
    px: 1
  };
  exports.fn = (_root, params) => {
    const {
      floatPrecision = 3,
      leadingZero = true,
      defaultPx = true,
      convertToPx = true
    } = params;
    return {
      element: {
        enter: (node) => {
          if (node.attributes.viewBox != null) {
            const nums = node.attributes.viewBox.split(/\s,?\s*|,\s*/g);
            node.attributes.viewBox = nums.map((value) => {
              const num = Number(value);
              return Number.isNaN(num) ? value : Number(num.toFixed(floatPrecision));
            }).join(" ");
          }
          for (const [name, value] of Object.entries(node.attributes)) {
            if (name === "version") {
              continue;
            }
            const match = value.match(regNumericValues);
            if (match) {
              let num = Number(Number(match[1]).toFixed(floatPrecision));
              let matchedUnit = match[3] || "";
              let units = matchedUnit;
              if (convertToPx && units !== "" && units in absoluteLengths) {
                const pxNum = Number((absoluteLengths[units] * Number(match[1])).toFixed(floatPrecision));
                if (pxNum.toString().length < match[0].length) {
                  num = pxNum;
                  units = "px";
                }
              }
              let str;
              if (leadingZero) {
                str = removeLeadingZero(num);
              } else {
                str = num.toString();
              }
              if (defaultPx && units === "px") {
                units = "";
              }
              node.attributes[name] = str + units;
            }
          }
        }
      }
    };
  };
});

// ../../../../node_modules/.bun/svgo@3.3.2/node_modules/svgo/plugins/convertColors.js
var require_convertColors = __commonJS((exports) => {
  var collections = require__collections();
  exports.name = "convertColors";
  exports.description = "converts colors: rgb() to #rrggbb and #rrggbb to #rgb";
  var rNumber = "([+-]?(?:\\d*\\.\\d+|\\d+\\.?)%?)";
  var rComma = "\\s*,\\s*";
  var regRGB = new RegExp("^rgb\\(\\s*" + rNumber + rComma + rNumber + rComma + rNumber + "\\s*\\)$");
  var regHEX = /^#(([a-fA-F0-9])\2){3}$/;
  var convertRgbToHex = ([r, g, b]) => {
    const hexNumber = (256 + r << 8 | g) << 8 | b;
    return "#" + hexNumber.toString(16).slice(1).toUpperCase();
  };
  exports.fn = (_root, params) => {
    const {
      currentColor = false,
      names2hex = true,
      rgb2hex = true,
      shorthex = true,
      shortname = true
    } = params;
    return {
      element: {
        enter: (node) => {
          for (const [name, value] of Object.entries(node.attributes)) {
            if (collections.colorsProps.has(name)) {
              let val = value;
              if (currentColor) {
                let matched;
                if (typeof currentColor === "string") {
                  matched = val === currentColor;
                } else if (currentColor instanceof RegExp) {
                  matched = currentColor.exec(val) != null;
                } else {
                  matched = val !== "none";
                }
                if (matched) {
                  val = "currentColor";
                }
              }
              if (names2hex) {
                const colorName = val.toLowerCase();
                if (collections.colorsNames[colorName] != null) {
                  val = collections.colorsNames[colorName];
                }
              }
              if (rgb2hex) {
                let match = val.match(regRGB);
                if (match != null) {
                  let nums = match.slice(1, 4).map((m) => {
                    let n;
                    if (m.indexOf("%") > -1) {
                      n = Math.round(parseFloat(m) * 2.55);
                    } else {
                      n = Number(m);
                    }
                    return Math.max(0, Math.min(n, 255));
                  });
                  val = convertRgbToHex(nums);
                }
              }
              if (shorthex) {
                let match = val.match(regHEX);
                if (match != null) {
                  val = "#" + match[0][1] + match[0][3] + match[0][5];
                }
              }
              if (shortname) {
                const colorName = val.toLowerCase();
                if (collections.colorsShortNames[colorName] != null) {
                  val = collections.colorsShortNames[colorName];
                }
              }
              node.attributes[name] = val;
            }
          }
        }
      }
    };
  };
});

// ../../../../node_modules/.bun/svgo@3.3.2/node_modules/svgo/plugins/removeUnknownsAndDefaults.js
var require_removeUnknownsAndDefaults = __commonJS((exports) => {
  var { visitSkip, detachNodeFromParent } = require_xast();
  var { collectStylesheet, computeStyle } = require_style();
  var {
    elems,
    attrsGroups,
    elemsGroups,
    attrsGroupsDefaults,
    presentationNonInheritableGroupAttrs
  } = require__collections();
  exports.name = "removeUnknownsAndDefaults";
  exports.description = "removes unknown elements content and attributes, removes attrs with default values";
  var allowedChildrenPerElement = new Map;
  var allowedAttributesPerElement = new Map;
  var attributesDefaultsPerElement = new Map;
  for (const [name, config] of Object.entries(elems)) {
    const allowedChildren = new Set;
    if (config.content) {
      for (const elementName of config.content) {
        allowedChildren.add(elementName);
      }
    }
    if (config.contentGroups) {
      for (const contentGroupName of config.contentGroups) {
        const elemsGroup = elemsGroups[contentGroupName];
        if (elemsGroup) {
          for (const elementName of elemsGroup) {
            allowedChildren.add(elementName);
          }
        }
      }
    }
    const allowedAttributes = new Set;
    if (config.attrs) {
      for (const attrName of config.attrs) {
        allowedAttributes.add(attrName);
      }
    }
    const attributesDefaults = new Map;
    if (config.defaults) {
      for (const [attrName, defaultValue] of Object.entries(config.defaults)) {
        attributesDefaults.set(attrName, defaultValue);
      }
    }
    for (const attrsGroupName of config.attrsGroups) {
      const attrsGroup = attrsGroups[attrsGroupName];
      if (attrsGroup) {
        for (const attrName of attrsGroup) {
          allowedAttributes.add(attrName);
        }
      }
      const groupDefaults = attrsGroupsDefaults[attrsGroupName];
      if (groupDefaults) {
        for (const [attrName, defaultValue] of Object.entries(groupDefaults)) {
          attributesDefaults.set(attrName, defaultValue);
        }
      }
    }
    allowedChildrenPerElement.set(name, allowedChildren);
    allowedAttributesPerElement.set(name, allowedAttributes);
    attributesDefaultsPerElement.set(name, attributesDefaults);
  }
  exports.fn = (root, params) => {
    const {
      unknownContent = true,
      unknownAttrs = true,
      defaultAttrs = true,
      defaultMarkupDeclarations = true,
      uselessOverrides = true,
      keepDataAttrs = true,
      keepAriaAttrs = true,
      keepRoleAttr = false
    } = params;
    const stylesheet = collectStylesheet(root);
    return {
      instruction: {
        enter: (node) => {
          if (defaultMarkupDeclarations) {
            node.value = node.value.replace(/\s*standalone\s*=\s*(["'])no\1/, "");
          }
        }
      },
      element: {
        enter: (node, parentNode) => {
          if (node.name.includes(":")) {
            return;
          }
          if (node.name === "foreignObject") {
            return visitSkip;
          }
          if (unknownContent && parentNode.type === "element") {
            const allowedChildren = allowedChildrenPerElement.get(parentNode.name);
            if (allowedChildren == null || allowedChildren.size === 0) {
              if (allowedChildrenPerElement.get(node.name) == null) {
                detachNodeFromParent(node, parentNode);
                return;
              }
            } else {
              if (allowedChildren.has(node.name) === false) {
                detachNodeFromParent(node, parentNode);
                return;
              }
            }
          }
          const allowedAttributes = allowedAttributesPerElement.get(node.name);
          const attributesDefaults = attributesDefaultsPerElement.get(node.name);
          const computedParentStyle = parentNode.type === "element" ? computeStyle(stylesheet, parentNode) : null;
          for (const [name, value] of Object.entries(node.attributes)) {
            if (keepDataAttrs && name.startsWith("data-")) {
              continue;
            }
            if (keepAriaAttrs && name.startsWith("aria-")) {
              continue;
            }
            if (keepRoleAttr && name === "role") {
              continue;
            }
            if (name === "xmlns") {
              continue;
            }
            if (name.includes(":")) {
              const [prefix] = name.split(":");
              if (prefix !== "xml" && prefix !== "xlink") {
                continue;
              }
            }
            if (unknownAttrs && allowedAttributes && allowedAttributes.has(name) === false) {
              delete node.attributes[name];
            }
            if (defaultAttrs && node.attributes.id == null && attributesDefaults && attributesDefaults.get(name) === value) {
              if (computedParentStyle?.[name] == null) {
                delete node.attributes[name];
              }
            }
            if (uselessOverrides && node.attributes.id == null) {
              const style = computedParentStyle?.[name];
              if (presentationNonInheritableGroupAttrs.has(name) === false && style != null && style.type === "static" && style.value === value) {
                delete node.attributes[name];
              }
            }
          }
        }
      }
    };
  };
});

// ../../../../node_modules/.bun/svgo@3.3.2/node_modules/svgo/plugins/removeNonInheritableGroupAttrs.js
var require_removeNonInheritableGroupAttrs = __commonJS((exports) => {
  var {
    inheritableAttrs,
    attrsGroups,
    presentationNonInheritableGroupAttrs
  } = require__collections();
  exports.name = "removeNonInheritableGroupAttrs";
  exports.description = "removes non-inheritable groups presentational attributes";
  exports.fn = () => {
    return {
      element: {
        enter: (node) => {
          if (node.name === "g") {
            for (const name of Object.keys(node.attributes)) {
              if (attrsGroups.presentation.has(name) && !inheritableAttrs.has(name) && !presentationNonInheritableGroupAttrs.has(name)) {
                delete node.attributes[name];
              }
            }
          }
        }
      }
    };
  };
});

// ../../../../node_modules/.bun/svgo@3.3.2/node_modules/svgo/plugins/removeUselessStrokeAndFill.js
var require_removeUselessStrokeAndFill = __commonJS((exports) => {
  var { visit, visitSkip, detachNodeFromParent } = require_xast();
  var { collectStylesheet, computeStyle } = require_style();
  var { hasScripts } = require_tools();
  var { elemsGroups } = require__collections();
  exports.name = "removeUselessStrokeAndFill";
  exports.description = "removes useless stroke and fill attributes";
  exports.fn = (root, params) => {
    const {
      stroke: removeStroke = true,
      fill: removeFill = true,
      removeNone = false
    } = params;
    let hasStyleOrScript = false;
    visit(root, {
      element: {
        enter: (node) => {
          if (node.name === "style" || hasScripts(node)) {
            hasStyleOrScript = true;
          }
        }
      }
    });
    if (hasStyleOrScript) {
      return null;
    }
    const stylesheet = collectStylesheet(root);
    return {
      element: {
        enter: (node, parentNode) => {
          if (node.attributes.id != null) {
            return visitSkip;
          }
          if (!elemsGroups.shape.has(node.name)) {
            return;
          }
          const computedStyle = computeStyle(stylesheet, node);
          const stroke = computedStyle.stroke;
          const strokeOpacity = computedStyle["stroke-opacity"];
          const strokeWidth = computedStyle["stroke-width"];
          const markerEnd = computedStyle["marker-end"];
          const fill = computedStyle.fill;
          const fillOpacity = computedStyle["fill-opacity"];
          const computedParentStyle = parentNode.type === "element" ? computeStyle(stylesheet, parentNode) : null;
          const parentStroke = computedParentStyle == null ? null : computedParentStyle.stroke;
          if (removeStroke) {
            if (stroke == null || stroke.type === "static" && stroke.value == "none" || strokeOpacity != null && strokeOpacity.type === "static" && strokeOpacity.value === "0" || strokeWidth != null && strokeWidth.type === "static" && strokeWidth.value === "0") {
              if (strokeWidth != null && strokeWidth.type === "static" && strokeWidth.value === "0" || markerEnd == null) {
                for (const name of Object.keys(node.attributes)) {
                  if (name.startsWith("stroke")) {
                    delete node.attributes[name];
                  }
                }
                if (parentStroke != null && parentStroke.type === "static" && parentStroke.value !== "none") {
                  node.attributes.stroke = "none";
                }
              }
            }
          }
          if (removeFill) {
            if (fill != null && fill.type === "static" && fill.value === "none" || fillOpacity != null && fillOpacity.type === "static" && fillOpacity.value === "0") {
              for (const name of Object.keys(node.attributes)) {
                if (name.startsWith("fill-")) {
                  delete node.attributes[name];
                }
              }
              if (fill == null || fill.type === "static" && fill.value !== "none") {
                node.attributes.fill = "none";
              }
            }
          }
          if (removeNone) {
            if ((stroke == null || node.attributes.stroke === "none") && (fill != null && fill.type === "static" && fill.value === "none" || node.attributes.fill === "none")) {
              detachNodeFromParent(node, parentNode);
            }
          }
        }
      }
    };
  };
});

// ../../../../node_modules/.bun/svgo@3.3.2/node_modules/svgo/plugins/removeViewBox.js
var require_removeViewBox = __commonJS((exports) => {
  exports.name = "removeViewBox";
  exports.description = "removes viewBox attribute when possible";
  var viewBoxElems = new Set(["pattern", "svg", "symbol"]);
  exports.fn = () => {
    return {
      element: {
        enter: (node, parentNode) => {
          if (viewBoxElems.has(node.name) && node.attributes.viewBox != null && node.attributes.width != null && node.attributes.height != null) {
            if (node.name === "svg" && parentNode.type !== "root") {
              return;
            }
            const nums = node.attributes.viewBox.split(/[ ,]+/g);
            if (nums[0] === "0" && nums[1] === "0" && node.attributes.width.replace(/px$/, "") === nums[2] && node.attributes.height.replace(/px$/, "") === nums[3]) {
              delete node.attributes.viewBox;
            }
          }
        }
      }
    };
  };
});

// ../../../../node_modules/.bun/svgo@3.3.2/node_modules/svgo/plugins/cleanupEnableBackground.js
var require_cleanupEnableBackground = __commonJS((exports) => {
  var csstree = require_cjs();
  var { visit } = require_xast();
  exports.name = "cleanupEnableBackground";
  exports.description = "remove or cleanup enable-background attribute when possible";
  var regEnableBackground = /^new\s0\s0\s([-+]?\d*\.?\d+([eE][-+]?\d+)?)\s([-+]?\d*\.?\d+([eE][-+]?\d+)?)$/;
  exports.fn = (root) => {
    let hasFilter = false;
    visit(root, {
      element: {
        enter: (node) => {
          if (node.name === "filter") {
            hasFilter = true;
          }
        }
      }
    });
    return {
      element: {
        enter: (node) => {
          let newStyle = null;
          let enableBackgroundDeclaration = null;
          if (node.attributes.style != null) {
            newStyle = csstree.parse(node.attributes.style, {
              context: "declarationList"
            });
            if (newStyle.type === "DeclarationList") {
              const enableBackgroundDeclarations = [];
              csstree.walk(newStyle, (node2, nodeItem) => {
                if (node2.type === "Declaration" && node2.property === "enable-background") {
                  enableBackgroundDeclarations.push(nodeItem);
                  enableBackgroundDeclaration = nodeItem;
                }
              });
              for (let i = 0;i < enableBackgroundDeclarations.length - 1; i++) {
                newStyle.children.remove(enableBackgroundDeclarations[i]);
              }
            }
          }
          if (!hasFilter) {
            delete node.attributes["enable-background"];
            if (newStyle?.type === "DeclarationList") {
              if (enableBackgroundDeclaration) {
                newStyle.children.remove(enableBackgroundDeclaration);
              }
              if (newStyle.children.isEmpty) {
                delete node.attributes.style;
              } else {
                node.attributes.style = csstree.generate(newStyle);
              }
            }
            return;
          }
          const hasDimensions = node.attributes.width != null && node.attributes.height != null;
          if ((node.name === "svg" || node.name === "mask" || node.name === "pattern") && hasDimensions) {
            const attrValue = node.attributes["enable-background"];
            const attrCleaned = cleanupValue(attrValue, node.name, node.attributes.width, node.attributes.height);
            if (attrCleaned) {
              node.attributes["enable-background"] = attrCleaned;
            } else {
              delete node.attributes["enable-background"];
            }
            if (newStyle?.type === "DeclarationList" && enableBackgroundDeclaration) {
              const styleValue = csstree.generate(enableBackgroundDeclaration.data.value);
              const styleCleaned = cleanupValue(styleValue, node.name, node.attributes.width, node.attributes.height);
              if (styleCleaned) {
                enableBackgroundDeclaration.data.value = {
                  type: "Raw",
                  value: styleCleaned
                };
              } else {
                newStyle.children.remove(enableBackgroundDeclaration);
              }
            }
          }
          if (newStyle?.type === "DeclarationList") {
            if (newStyle.children.isEmpty) {
              delete node.attributes.style;
            } else {
              node.attributes.style = csstree.generate(newStyle);
            }
          }
        }
      }
    };
  };
  var cleanupValue = (value, nodeName, width, height) => {
    const match = regEnableBackground.exec(value);
    if (match != null && width === match[1] && height === match[3]) {
      return nodeName === "svg" ? undefined : "new";
    }
    return value;
  };
});

// ../../../../node_modules/.bun/svgo@3.3.2/node_modules/svgo/lib/path.js
var require_path = __commonJS((exports) => {
  var { removeLeadingZero, toFixed } = require_tools();
  var argsCountPerCommand = {
    M: 2,
    m: 2,
    Z: 0,
    z: 0,
    L: 2,
    l: 2,
    H: 1,
    h: 1,
    V: 1,
    v: 1,
    C: 6,
    c: 6,
    S: 4,
    s: 4,
    Q: 4,
    q: 4,
    T: 2,
    t: 2,
    A: 7,
    a: 7
  };
  var isCommand = (c) => {
    return c in argsCountPerCommand;
  };
  var isWsp = (c) => {
    const codePoint = c.codePointAt(0);
    return codePoint === 32 || codePoint === 9 || codePoint === 13 || codePoint === 10;
  };
  var isDigit = (c) => {
    const codePoint = c.codePointAt(0);
    if (codePoint == null) {
      return false;
    }
    return 48 <= codePoint && codePoint <= 57;
  };
  var readNumber = (string, cursor) => {
    let i = cursor;
    let value = "";
    let state = "none";
    for (;i < string.length; i += 1) {
      const c = string[i];
      if (c === "+" || c === "-") {
        if (state === "none") {
          state = "sign";
          value += c;
          continue;
        }
        if (state === "e") {
          state = "exponent_sign";
          value += c;
          continue;
        }
      }
      if (isDigit(c)) {
        if (state === "none" || state === "sign" || state === "whole") {
          state = "whole";
          value += c;
          continue;
        }
        if (state === "decimal_point" || state === "decimal") {
          state = "decimal";
          value += c;
          continue;
        }
        if (state === "e" || state === "exponent_sign" || state === "exponent") {
          state = "exponent";
          value += c;
          continue;
        }
      }
      if (c === ".") {
        if (state === "none" || state === "sign" || state === "whole") {
          state = "decimal_point";
          value += c;
          continue;
        }
      }
      if (c === "E" || c == "e") {
        if (state === "whole" || state === "decimal_point" || state === "decimal") {
          state = "e";
          value += c;
          continue;
        }
      }
      break;
    }
    const number = Number.parseFloat(value);
    if (Number.isNaN(number)) {
      return [cursor, null];
    } else {
      return [i - 1, number];
    }
  };
  var parsePathData = (string) => {
    const pathData = [];
    let command = null;
    let args = [];
    let argsCount = 0;
    let canHaveComma = false;
    let hadComma = false;
    for (let i = 0;i < string.length; i += 1) {
      const c = string.charAt(i);
      if (isWsp(c)) {
        continue;
      }
      if (canHaveComma && c === ",") {
        if (hadComma) {
          break;
        }
        hadComma = true;
        continue;
      }
      if (isCommand(c)) {
        if (hadComma) {
          return pathData;
        }
        if (command == null) {
          if (c !== "M" && c !== "m") {
            return pathData;
          }
        } else {
          if (args.length !== 0) {
            return pathData;
          }
        }
        command = c;
        args = [];
        argsCount = argsCountPerCommand[command];
        canHaveComma = false;
        if (argsCount === 0) {
          pathData.push({ command, args });
        }
        continue;
      }
      if (command == null) {
        return pathData;
      }
      let newCursor = i;
      let number = null;
      if (command === "A" || command === "a") {
        const position = args.length;
        if (position === 0 || position === 1) {
          if (c !== "+" && c !== "-") {
            [newCursor, number] = readNumber(string, i);
          }
        }
        if (position === 2 || position === 5 || position === 6) {
          [newCursor, number] = readNumber(string, i);
        }
        if (position === 3 || position === 4) {
          if (c === "0") {
            number = 0;
          }
          if (c === "1") {
            number = 1;
          }
        }
      } else {
        [newCursor, number] = readNumber(string, i);
      }
      if (number == null) {
        return pathData;
      }
      args.push(number);
      canHaveComma = true;
      hadComma = false;
      i = newCursor;
      if (args.length === argsCount) {
        pathData.push({ command, args });
        if (command === "M") {
          command = "L";
        }
        if (command === "m") {
          command = "l";
        }
        args = [];
      }
    }
    return pathData;
  };
  exports.parsePathData = parsePathData;
  var roundAndStringify = (number, precision) => {
    if (precision != null) {
      number = toFixed(number, precision);
    }
    return {
      roundedStr: removeLeadingZero(number),
      rounded: number
    };
  };
  var stringifyArgs = (command, args, precision, disableSpaceAfterFlags) => {
    let result = "";
    let previous;
    for (let i = 0;i < args.length; i++) {
      const { roundedStr, rounded } = roundAndStringify(args[i], precision);
      if (disableSpaceAfterFlags && (command === "A" || command === "a") && (i % 7 === 4 || i % 7 === 5)) {
        result += roundedStr;
      } else if (i === 0 || rounded < 0) {
        result += roundedStr;
      } else if (!Number.isInteger(previous) && rounded != 0 && rounded < 1 && rounded > -1) {
        result += roundedStr;
      } else {
        result += ` ${roundedStr}`;
      }
      previous = rounded;
    }
    return result;
  };
  var stringifyPathData = ({ pathData, precision, disableSpaceAfterFlags }) => {
    if (pathData.length === 1) {
      const { command, args } = pathData[0];
      return command + stringifyArgs(command, args, precision, disableSpaceAfterFlags);
    }
    let result = "";
    let prev = { ...pathData[0] };
    if (pathData[1].command === "L") {
      prev.command = "M";
    } else if (pathData[1].command === "l") {
      prev.command = "m";
    }
    for (let i = 1;i < pathData.length; i++) {
      const { command, args } = pathData[i];
      if (prev.command === command && prev.command !== "M" && prev.command !== "m" || prev.command === "M" && command === "L" || prev.command === "m" && command === "l") {
        prev.args = [...prev.args, ...args];
        if (i === pathData.length - 1) {
          result += prev.command + stringifyArgs(prev.command, prev.args, precision, disableSpaceAfterFlags);
        }
      } else {
        result += prev.command + stringifyArgs(prev.command, prev.args, precision, disableSpaceAfterFlags);
        if (i === pathData.length - 1) {
          result += command + stringifyArgs(command, args, precision, disableSpaceAfterFlags);
        } else {
          prev = { command, args };
        }
      }
    }
    return result;
  };
  exports.stringifyPathData = stringifyPathData;
});

// ../../../../node_modules/.bun/svgo@3.3.2/node_modules/svgo/plugins/removeHiddenElems.js
var require_removeHiddenElems = __commonJS((exports) => {
  var { elemsGroups } = require__collections();
  var {
    visit,
    visitSkip,
    querySelector,
    detachNodeFromParent
  } = require_xast();
  var { collectStylesheet, computeStyle } = require_style();
  var { parsePathData } = require_path();
  var { hasScripts, findReferences } = require_tools();
  var nonRendering = elemsGroups.nonRendering;
  exports.name = "removeHiddenElems";
  exports.description = "removes hidden elements (zero sized, with absent attributes)";
  exports.fn = (root, params) => {
    const {
      isHidden = true,
      displayNone = true,
      opacity0 = true,
      circleR0 = true,
      ellipseRX0 = true,
      ellipseRY0 = true,
      rectWidth0 = true,
      rectHeight0 = true,
      patternWidth0 = true,
      patternHeight0 = true,
      imageWidth0 = true,
      imageHeight0 = true,
      pathEmptyD = true,
      polylineEmptyPoints = true,
      polygonEmptyPoints = true
    } = params;
    const stylesheet = collectStylesheet(root);
    const nonRenderedNodes = new Map;
    const removedDefIds = new Set;
    const allDefs = new Map;
    const allReferences = new Set;
    const referencesById = new Map;
    let deoptimized = false;
    function removeElement(node, parentNode) {
      if (node.type === "element" && node.attributes.id != null && parentNode.type === "element" && parentNode.name === "defs") {
        removedDefIds.add(node.attributes.id);
      }
      detachNodeFromParent(node, parentNode);
    }
    visit(root, {
      element: {
        enter: (node, parentNode) => {
          if (nonRendering.has(node.name)) {
            if (node.attributes.id == null) {
              detachNodeFromParent(node, parentNode);
              return visitSkip;
            }
            nonRenderedNodes.set(node, parentNode);
            return visitSkip;
          }
          const computedStyle = computeStyle(stylesheet, node);
          if (opacity0 && computedStyle.opacity && computedStyle.opacity.type === "static" && computedStyle.opacity.value === "0") {
            removeElement(node, parentNode);
          }
        }
      }
    });
    return {
      element: {
        enter: (node, parentNode) => {
          if (node.name === "style" && node.children.length !== 0 || hasScripts(node)) {
            deoptimized = true;
            return;
          }
          if (node.name === "defs") {
            allDefs.set(node, parentNode);
          }
          if (node.name === "use") {
            for (const attr of Object.keys(node.attributes)) {
              if (attr !== "href" && !attr.endsWith(":href"))
                continue;
              const value = node.attributes[attr];
              const id = value.slice(1);
              let refs = referencesById.get(id);
              if (!refs) {
                refs = [];
                referencesById.set(id, refs);
              }
              refs.push({ node, parentNode });
            }
          }
          const computedStyle = computeStyle(stylesheet, node);
          if (isHidden && computedStyle.visibility && computedStyle.visibility.type === "static" && computedStyle.visibility.value === "hidden" && querySelector(node, "[visibility=visible]") == null) {
            removeElement(node, parentNode);
            return;
          }
          if (displayNone && computedStyle.display && computedStyle.display.type === "static" && computedStyle.display.value === "none" && node.name !== "marker") {
            removeElement(node, parentNode);
            return;
          }
          if (circleR0 && node.name === "circle" && node.children.length === 0 && node.attributes.r === "0") {
            removeElement(node, parentNode);
            return;
          }
          if (ellipseRX0 && node.name === "ellipse" && node.children.length === 0 && node.attributes.rx === "0") {
            removeElement(node, parentNode);
            return;
          }
          if (ellipseRY0 && node.name === "ellipse" && node.children.length === 0 && node.attributes.ry === "0") {
            removeElement(node, parentNode);
            return;
          }
          if (rectWidth0 && node.name === "rect" && node.children.length === 0 && node.attributes.width === "0") {
            removeElement(node, parentNode);
            return;
          }
          if (rectHeight0 && rectWidth0 && node.name === "rect" && node.children.length === 0 && node.attributes.height === "0") {
            removeElement(node, parentNode);
            return;
          }
          if (patternWidth0 && node.name === "pattern" && node.attributes.width === "0") {
            removeElement(node, parentNode);
            return;
          }
          if (patternHeight0 && node.name === "pattern" && node.attributes.height === "0") {
            removeElement(node, parentNode);
            return;
          }
          if (imageWidth0 && node.name === "image" && node.attributes.width === "0") {
            removeElement(node, parentNode);
            return;
          }
          if (imageHeight0 && node.name === "image" && node.attributes.height === "0") {
            removeElement(node, parentNode);
            return;
          }
          if (pathEmptyD && node.name === "path") {
            if (node.attributes.d == null) {
              removeElement(node, parentNode);
              return;
            }
            const pathData = parsePathData(node.attributes.d);
            if (pathData.length === 0) {
              removeElement(node, parentNode);
              return;
            }
            if (pathData.length === 1 && computedStyle["marker-start"] == null && computedStyle["marker-end"] == null) {
              removeElement(node, parentNode);
              return;
            }
          }
          if (polylineEmptyPoints && node.name === "polyline" && node.attributes.points == null) {
            removeElement(node, parentNode);
            return;
          }
          if (polygonEmptyPoints && node.name === "polygon" && node.attributes.points == null) {
            removeElement(node, parentNode);
            return;
          }
          for (const [name, value] of Object.entries(node.attributes)) {
            const ids = findReferences(name, value);
            for (const id of ids) {
              allReferences.add(id);
            }
          }
        }
      },
      root: {
        exit: () => {
          for (const id of removedDefIds) {
            const refs = referencesById.get(id);
            if (refs) {
              for (const { node, parentNode } of refs) {
                detachNodeFromParent(node, parentNode);
              }
            }
          }
          if (!deoptimized) {
            for (const [
              nonRenderedNode,
              nonRenderedParent
            ] of nonRenderedNodes.entries()) {
              const id = nonRenderedNode.attributes.id;
              if (!allReferences.has(id)) {
                detachNodeFromParent(nonRenderedNode, nonRenderedParent);
              }
            }
          }
          for (const [node, parentNode] of allDefs.entries()) {
            if (node.children.length === 0) {
              detachNodeFromParent(node, parentNode);
            }
          }
        }
      }
    };
  };
});

// ../../../../node_modules/.bun/svgo@3.3.2/node_modules/svgo/plugins/removeEmptyText.js
var require_removeEmptyText = __commonJS((exports) => {
  var { detachNodeFromParent } = require_xast();
  exports.name = "removeEmptyText";
  exports.description = "removes empty <text> elements";
  exports.fn = (root, params) => {
    const { text = true, tspan = true, tref = true } = params;
    return {
      element: {
        enter: (node, parentNode) => {
          if (text && node.name === "text" && node.children.length === 0) {
            detachNodeFromParent(node, parentNode);
          }
          if (tspan && node.name === "tspan" && node.children.length === 0) {
            detachNodeFromParent(node, parentNode);
          }
          if (tref && node.name === "tref" && node.attributes["xlink:href"] == null) {
            detachNodeFromParent(node, parentNode);
          }
        }
      }
    };
  };
});

// ../../../../node_modules/.bun/svgo@3.3.2/node_modules/svgo/plugins/convertShapeToPath.js
var require_convertShapeToPath = __commonJS((exports) => {
  var { stringifyPathData } = require_path();
  var { detachNodeFromParent } = require_xast();
  exports.name = "convertShapeToPath";
  exports.description = "converts basic shapes to more compact path form";
  var regNumber = /[-+]?(?:\d*\.\d+|\d+\.?)(?:[eE][-+]?\d+)?/g;
  exports.fn = (root, params) => {
    const { convertArcs = false, floatPrecision: precision } = params;
    return {
      element: {
        enter: (node, parentNode) => {
          if (node.name === "rect" && node.attributes.width != null && node.attributes.height != null && node.attributes.rx == null && node.attributes.ry == null) {
            const x = Number(node.attributes.x || "0");
            const y = Number(node.attributes.y || "0");
            const width = Number(node.attributes.width);
            const height = Number(node.attributes.height);
            if (Number.isNaN(x - y + width - height))
              return;
            const pathData = [
              { command: "M", args: [x, y] },
              { command: "H", args: [x + width] },
              { command: "V", args: [y + height] },
              { command: "H", args: [x] },
              { command: "z", args: [] }
            ];
            node.name = "path";
            node.attributes.d = stringifyPathData({ pathData, precision });
            delete node.attributes.x;
            delete node.attributes.y;
            delete node.attributes.width;
            delete node.attributes.height;
          }
          if (node.name === "line") {
            const x1 = Number(node.attributes.x1 || "0");
            const y1 = Number(node.attributes.y1 || "0");
            const x2 = Number(node.attributes.x2 || "0");
            const y2 = Number(node.attributes.y2 || "0");
            if (Number.isNaN(x1 - y1 + x2 - y2))
              return;
            const pathData = [
              { command: "M", args: [x1, y1] },
              { command: "L", args: [x2, y2] }
            ];
            node.name = "path";
            node.attributes.d = stringifyPathData({ pathData, precision });
            delete node.attributes.x1;
            delete node.attributes.y1;
            delete node.attributes.x2;
            delete node.attributes.y2;
          }
          if ((node.name === "polyline" || node.name === "polygon") && node.attributes.points != null) {
            const coords = (node.attributes.points.match(regNumber) || []).map(Number);
            if (coords.length < 4) {
              detachNodeFromParent(node, parentNode);
              return;
            }
            const pathData = [];
            for (let i = 0;i < coords.length; i += 2) {
              pathData.push({
                command: i === 0 ? "M" : "L",
                args: coords.slice(i, i + 2)
              });
            }
            if (node.name === "polygon") {
              pathData.push({ command: "z", args: [] });
            }
            node.name = "path";
            node.attributes.d = stringifyPathData({ pathData, precision });
            delete node.attributes.points;
          }
          if (node.name === "circle" && convertArcs) {
            const cx = Number(node.attributes.cx || "0");
            const cy = Number(node.attributes.cy || "0");
            const r = Number(node.attributes.r || "0");
            if (Number.isNaN(cx - cy + r)) {
              return;
            }
            const pathData = [
              { command: "M", args: [cx, cy - r] },
              { command: "A", args: [r, r, 0, 1, 0, cx, cy + r] },
              { command: "A", args: [r, r, 0, 1, 0, cx, cy - r] },
              { command: "z", args: [] }
            ];
            node.name = "path";
            node.attributes.d = stringifyPathData({ pathData, precision });
            delete node.attributes.cx;
            delete node.attributes.cy;
            delete node.attributes.r;
          }
          if (node.name === "ellipse" && convertArcs) {
            const ecx = Number(node.attributes.cx || "0");
            const ecy = Number(node.attributes.cy || "0");
            const rx = Number(node.attributes.rx || "0");
            const ry = Number(node.attributes.ry || "0");
            if (Number.isNaN(ecx - ecy + rx - ry)) {
              return;
            }
            const pathData = [
              { command: "M", args: [ecx, ecy - ry] },
              { command: "A", args: [rx, ry, 0, 1, 0, ecx, ecy + ry] },
              { command: "A", args: [rx, ry, 0, 1, 0, ecx, ecy - ry] },
              { command: "z", args: [] }
            ];
            node.name = "path";
            node.attributes.d = stringifyPathData({ pathData, precision });
            delete node.attributes.cx;
            delete node.attributes.cy;
            delete node.attributes.rx;
            delete node.attributes.ry;
          }
        }
      }
    };
  };
});

// ../../../../node_modules/.bun/svgo@3.3.2/node_modules/svgo/plugins/convertEllipseToCircle.js
var require_convertEllipseToCircle = __commonJS((exports) => {
  exports.name = "convertEllipseToCircle";
  exports.description = "converts non-eccentric <ellipse>s to <circle>s";
  exports.fn = () => {
    return {
      element: {
        enter: (node) => {
          if (node.name === "ellipse") {
            const rx = node.attributes.rx || "0";
            const ry = node.attributes.ry || "0";
            if (rx === ry || rx === "auto" || ry === "auto") {
              node.name = "circle";
              const radius = rx === "auto" ? ry : rx;
              delete node.attributes.rx;
              delete node.attributes.ry;
              node.attributes.r = radius;
            }
          }
        }
      }
    };
  };
});

// ../../../../node_modules/.bun/svgo@3.3.2/node_modules/svgo/plugins/moveElemsAttrsToGroup.js
var require_moveElemsAttrsToGroup = __commonJS((exports) => {
  var { visit } = require_xast();
  var { inheritableAttrs, pathElems } = require__collections();
  exports.name = "moveElemsAttrsToGroup";
  exports.description = "Move common attributes of group children to the group";
  exports.fn = (root) => {
    let deoptimizedWithStyles = false;
    visit(root, {
      element: {
        enter: (node) => {
          if (node.name === "style") {
            deoptimizedWithStyles = true;
          }
        }
      }
    });
    return {
      element: {
        exit: (node) => {
          if (node.name !== "g" || node.children.length <= 1) {
            return;
          }
          if (deoptimizedWithStyles) {
            return;
          }
          const commonAttributes = new Map;
          let initial = true;
          let everyChildIsPath = true;
          for (const child of node.children) {
            if (child.type === "element") {
              if (!pathElems.has(child.name)) {
                everyChildIsPath = false;
              }
              if (initial) {
                initial = false;
                for (const [name, value] of Object.entries(child.attributes)) {
                  if (inheritableAttrs.has(name)) {
                    commonAttributes.set(name, value);
                  }
                }
              } else {
                for (const [name, value] of commonAttributes) {
                  if (child.attributes[name] !== value) {
                    commonAttributes.delete(name);
                  }
                }
              }
            }
          }
          if (node.attributes["clip-path"] != null || node.attributes.mask != null) {
            commonAttributes.delete("transform");
          }
          if (everyChildIsPath) {
            commonAttributes.delete("transform");
          }
          for (const [name, value] of commonAttributes) {
            if (name === "transform") {
              if (node.attributes.transform != null) {
                node.attributes.transform = `${node.attributes.transform} ${value}`;
              } else {
                node.attributes.transform = value;
              }
            } else {
              node.attributes[name] = value;
            }
          }
          for (const child of node.children) {
            if (child.type === "element") {
              for (const [name] of commonAttributes) {
                delete child.attributes[name];
              }
            }
          }
        }
      }
    };
  };
});

// ../../../../node_modules/.bun/svgo@3.3.2/node_modules/svgo/plugins/moveGroupAttrsToElems.js
var require_moveGroupAttrsToElems = __commonJS((exports) => {
  var { pathElems, referencesProps } = require__collections();
  var { includesUrlReference } = require_tools();
  exports.name = "moveGroupAttrsToElems";
  exports.description = "moves some group attributes to the content elements";
  var pathElemsWithGroupsAndText = [...pathElems, "g", "text"];
  exports.fn = () => {
    return {
      element: {
        enter: (node) => {
          if (node.name === "g" && node.children.length !== 0 && node.attributes.transform != null && Object.entries(node.attributes).some(([name, value]) => referencesProps.has(name) && includesUrlReference(value)) === false && node.children.every((child) => child.type === "element" && pathElemsWithGroupsAndText.includes(child.name) && child.attributes.id == null)) {
            for (const child of node.children) {
              const value = node.attributes.transform;
              if (child.type === "element") {
                if (child.attributes.transform != null) {
                  child.attributes.transform = `${value} ${child.attributes.transform}`;
                } else {
                  child.attributes.transform = value;
                }
              }
            }
            delete node.attributes.transform;
          }
        }
      }
    };
  };
});

// ../../../../node_modules/.bun/svgo@3.3.2/node_modules/svgo/plugins/collapseGroups.js
var require_collapseGroups = __commonJS((exports) => {
  var { inheritableAttrs, elemsGroups } = require__collections();
  exports.name = "collapseGroups";
  exports.description = "collapses useless groups";
  var hasAnimatedAttr = (node, name) => {
    if (node.type === "element") {
      if (elemsGroups.animation.has(node.name) && node.attributes.attributeName === name) {
        return true;
      }
      for (const child of node.children) {
        if (hasAnimatedAttr(child, name)) {
          return true;
        }
      }
    }
    return false;
  };
  exports.fn = () => {
    return {
      element: {
        exit: (node, parentNode) => {
          if (parentNode.type === "root" || parentNode.name === "switch") {
            return;
          }
          if (node.name !== "g" || node.children.length === 0) {
            return;
          }
          if (Object.keys(node.attributes).length !== 0 && node.children.length === 1) {
            const firstChild = node.children[0];
            if (firstChild.type === "element" && firstChild.attributes.id == null && node.attributes.filter == null && (node.attributes.class == null || firstChild.attributes.class == null) && (node.attributes["clip-path"] == null && node.attributes.mask == null || firstChild.name === "g" && node.attributes.transform == null && firstChild.attributes.transform == null)) {
              for (const [name, value] of Object.entries(node.attributes)) {
                if (hasAnimatedAttr(firstChild, name)) {
                  return;
                }
                if (firstChild.attributes[name] == null) {
                  firstChild.attributes[name] = value;
                } else if (name === "transform") {
                  firstChild.attributes[name] = value + " " + firstChild.attributes[name];
                } else if (firstChild.attributes[name] === "inherit") {
                  firstChild.attributes[name] = value;
                } else if (inheritableAttrs.has(name) === false && firstChild.attributes[name] !== value) {
                  return;
                }
                delete node.attributes[name];
              }
            }
          }
          if (Object.keys(node.attributes).length === 0) {
            for (const child of node.children) {
              if (child.type === "element" && elemsGroups.animation.has(child.name)) {
                return;
              }
            }
            const index = parentNode.children.indexOf(node);
            parentNode.children.splice(index, 1, ...node.children);
            for (const child of node.children) {
              Object.defineProperty(child, "parentNode", {
                writable: true,
                value: parentNode
              });
            }
          }
        }
      }
    };
  };
});

// ../../../../node_modules/.bun/svgo@3.3.2/node_modules/svgo/plugins/_path.js
var require__path = __commonJS((exports) => {
  var { parsePathData, stringifyPathData } = require_path();
  var prevCtrlPoint;
  var path2js = (path) => {
    if (path.pathJS)
      return path.pathJS;
    const pathData = [];
    const newPathData = parsePathData(path.attributes.d);
    for (const { command, args } of newPathData) {
      pathData.push({ command, args });
    }
    if (pathData.length && pathData[0].command == "m") {
      pathData[0].command = "M";
    }
    path.pathJS = pathData;
    return pathData;
  };
  exports.path2js = path2js;
  var convertRelativeToAbsolute = (data) => {
    const newData = [];
    let start = [0, 0];
    let cursor = [0, 0];
    for (let { command, args } of data) {
      args = args.slice();
      if (command === "m") {
        args[0] += cursor[0];
        args[1] += cursor[1];
        command = "M";
      }
      if (command === "M") {
        cursor[0] = args[0];
        cursor[1] = args[1];
        start[0] = cursor[0];
        start[1] = cursor[1];
      }
      if (command === "h") {
        args[0] += cursor[0];
        command = "H";
      }
      if (command === "H") {
        cursor[0] = args[0];
      }
      if (command === "v") {
        args[0] += cursor[1];
        command = "V";
      }
      if (command === "V") {
        cursor[1] = args[0];
      }
      if (command === "l") {
        args[0] += cursor[0];
        args[1] += cursor[1];
        command = "L";
      }
      if (command === "L") {
        cursor[0] = args[0];
        cursor[1] = args[1];
      }
      if (command === "c") {
        args[0] += cursor[0];
        args[1] += cursor[1];
        args[2] += cursor[0];
        args[3] += cursor[1];
        args[4] += cursor[0];
        args[5] += cursor[1];
        command = "C";
      }
      if (command === "C") {
        cursor[0] = args[4];
        cursor[1] = args[5];
      }
      if (command === "s") {
        args[0] += cursor[0];
        args[1] += cursor[1];
        args[2] += cursor[0];
        args[3] += cursor[1];
        command = "S";
      }
      if (command === "S") {
        cursor[0] = args[2];
        cursor[1] = args[3];
      }
      if (command === "q") {
        args[0] += cursor[0];
        args[1] += cursor[1];
        args[2] += cursor[0];
        args[3] += cursor[1];
        command = "Q";
      }
      if (command === "Q") {
        cursor[0] = args[2];
        cursor[1] = args[3];
      }
      if (command === "t") {
        args[0] += cursor[0];
        args[1] += cursor[1];
        command = "T";
      }
      if (command === "T") {
        cursor[0] = args[0];
        cursor[1] = args[1];
      }
      if (command === "a") {
        args[5] += cursor[0];
        args[6] += cursor[1];
        command = "A";
      }
      if (command === "A") {
        cursor[0] = args[5];
        cursor[1] = args[6];
      }
      if (command === "z" || command === "Z") {
        cursor[0] = start[0];
        cursor[1] = start[1];
        command = "z";
      }
      newData.push({ command, args });
    }
    return newData;
  };
  exports.js2path = function(path, data, params) {
    path.pathJS = data;
    const pathData = [];
    for (const item of data) {
      if (pathData.length !== 0 && (item.command === "M" || item.command === "m")) {
        const last = pathData[pathData.length - 1];
        if (last.command === "M" || last.command === "m") {
          pathData.pop();
        }
      }
      pathData.push({
        command: item.command,
        args: item.args
      });
    }
    path.attributes.d = stringifyPathData({
      pathData,
      precision: params.floatPrecision,
      disableSpaceAfterFlags: params.noSpaceAfterFlags
    });
  };
  function set(dest, source) {
    dest[0] = source[source.length - 2];
    dest[1] = source[source.length - 1];
    return dest;
  }
  exports.intersects = function(path1, path2) {
    const points1 = gatherPoints(convertRelativeToAbsolute(path1));
    const points2 = gatherPoints(convertRelativeToAbsolute(path2));
    if (points1.maxX <= points2.minX || points2.maxX <= points1.minX || points1.maxY <= points2.minY || points2.maxY <= points1.minY || points1.list.every((set1) => {
      return points2.list.every((set2) => {
        return set1.list[set1.maxX][0] <= set2.list[set2.minX][0] || set2.list[set2.maxX][0] <= set1.list[set1.minX][0] || set1.list[set1.maxY][1] <= set2.list[set2.minY][1] || set2.list[set2.maxY][1] <= set1.list[set1.minY][1];
      });
    }))
      return false;
    const hullNest1 = points1.list.map(convexHull);
    const hullNest2 = points2.list.map(convexHull);
    return hullNest1.some(function(hull1) {
      if (hull1.list.length < 3)
        return false;
      return hullNest2.some(function(hull2) {
        if (hull2.list.length < 3)
          return false;
        var simplex = [getSupport(hull1, hull2, [1, 0])], direction = minus(simplex[0]);
        var iterations = 1e4;
        while (true) {
          if (iterations-- == 0) {
            console.error("Error: infinite loop while processing mergePaths plugin.");
            return true;
          }
          simplex.push(getSupport(hull1, hull2, direction));
          if (dot(direction, simplex[simplex.length - 1]) <= 0)
            return false;
          if (processSimplex(simplex, direction))
            return true;
        }
      });
    });
    function getSupport(a, b, direction) {
      return sub(supportPoint(a, direction), supportPoint(b, minus(direction)));
    }
    function supportPoint(polygon, direction) {
      var index = direction[1] >= 0 ? direction[0] < 0 ? polygon.maxY : polygon.maxX : direction[0] < 0 ? polygon.minX : polygon.minY, max = -Infinity, value;
      while ((value = dot(polygon.list[index], direction)) > max) {
        max = value;
        index = ++index % polygon.list.length;
      }
      return polygon.list[(index || polygon.list.length) - 1];
    }
  };
  function processSimplex(simplex, direction) {
    if (simplex.length == 2) {
      let a = simplex[1], b = simplex[0], AO = minus(simplex[1]), AB = sub(b, a);
      if (dot(AO, AB) > 0) {
        set(direction, orth(AB, a));
      } else {
        set(direction, AO);
        simplex.shift();
      }
    } else {
      let a = simplex[2], b = simplex[1], c = simplex[0], AB = sub(b, a), AC = sub(c, a), AO = minus(a), ACB = orth(AB, AC), ABC = orth(AC, AB);
      if (dot(ACB, AO) > 0) {
        if (dot(AB, AO) > 0) {
          set(direction, ACB);
          simplex.shift();
        } else {
          set(direction, AO);
          simplex.splice(0, 2);
        }
      } else if (dot(ABC, AO) > 0) {
        if (dot(AC, AO) > 0) {
          set(direction, ABC);
          simplex.splice(1, 1);
        } else {
          set(direction, AO);
          simplex.splice(0, 2);
        }
      } else
        return true;
    }
    return false;
  }
  function minus(v) {
    return [-v[0], -v[1]];
  }
  function sub(v1, v2) {
    return [v1[0] - v2[0], v1[1] - v2[1]];
  }
  function dot(v1, v2) {
    return v1[0] * v2[0] + v1[1] * v2[1];
  }
  function orth(v, from) {
    var o = [-v[1], v[0]];
    return dot(o, minus(from)) < 0 ? minus(o) : o;
  }
  function gatherPoints(pathData) {
    const points = { list: [], minX: 0, minY: 0, maxX: 0, maxY: 0 };
    const addPoint = (path, point) => {
      if (!path.list.length || point[1] > path.list[path.maxY][1]) {
        path.maxY = path.list.length;
        points.maxY = points.list.length ? Math.max(point[1], points.maxY) : point[1];
      }
      if (!path.list.length || point[0] > path.list[path.maxX][0]) {
        path.maxX = path.list.length;
        points.maxX = points.list.length ? Math.max(point[0], points.maxX) : point[0];
      }
      if (!path.list.length || point[1] < path.list[path.minY][1]) {
        path.minY = path.list.length;
        points.minY = points.list.length ? Math.min(point[1], points.minY) : point[1];
      }
      if (!path.list.length || point[0] < path.list[path.minX][0]) {
        path.minX = path.list.length;
        points.minX = points.list.length ? Math.min(point[0], points.minX) : point[0];
      }
      path.list.push(point);
    };
    for (let i = 0;i < pathData.length; i += 1) {
      const pathDataItem = pathData[i];
      let subPath = points.list.length === 0 ? { list: [], minX: 0, minY: 0, maxX: 0, maxY: 0 } : points.list[points.list.length - 1];
      let prev = i === 0 ? null : pathData[i - 1];
      let basePoint = subPath.list.length === 0 ? null : subPath.list[subPath.list.length - 1];
      let data = pathDataItem.args;
      let ctrlPoint = basePoint;
      const toAbsolute = (n, i2) => n + (basePoint == null ? 0 : basePoint[i2 % 2]);
      switch (pathDataItem.command) {
        case "M":
          subPath = { list: [], minX: 0, minY: 0, maxX: 0, maxY: 0 };
          points.list.push(subPath);
          break;
        case "H":
          if (basePoint != null) {
            addPoint(subPath, [data[0], basePoint[1]]);
          }
          break;
        case "V":
          if (basePoint != null) {
            addPoint(subPath, [basePoint[0], data[0]]);
          }
          break;
        case "Q":
          addPoint(subPath, data.slice(0, 2));
          prevCtrlPoint = [data[2] - data[0], data[3] - data[1]];
          break;
        case "T":
          if (basePoint != null && prev != null && (prev.command == "Q" || prev.command == "T")) {
            ctrlPoint = [
              basePoint[0] + prevCtrlPoint[0],
              basePoint[1] + prevCtrlPoint[1]
            ];
            addPoint(subPath, ctrlPoint);
            prevCtrlPoint = [data[0] - ctrlPoint[0], data[1] - ctrlPoint[1]];
          }
          break;
        case "C":
          if (basePoint != null) {
            addPoint(subPath, [
              0.5 * (basePoint[0] + data[0]),
              0.5 * (basePoint[1] + data[1])
            ]);
          }
          addPoint(subPath, [
            0.5 * (data[0] + data[2]),
            0.5 * (data[1] + data[3])
          ]);
          addPoint(subPath, [
            0.5 * (data[2] + data[4]),
            0.5 * (data[3] + data[5])
          ]);
          prevCtrlPoint = [data[4] - data[2], data[5] - data[3]];
          break;
        case "S":
          if (basePoint != null && prev != null && (prev.command == "C" || prev.command == "S")) {
            addPoint(subPath, [
              basePoint[0] + 0.5 * prevCtrlPoint[0],
              basePoint[1] + 0.5 * prevCtrlPoint[1]
            ]);
            ctrlPoint = [
              basePoint[0] + prevCtrlPoint[0],
              basePoint[1] + prevCtrlPoint[1]
            ];
          }
          if (ctrlPoint != null) {
            addPoint(subPath, [
              0.5 * (ctrlPoint[0] + data[0]),
              0.5 * (ctrlPoint[1] + data[1])
            ]);
          }
          addPoint(subPath, [
            0.5 * (data[0] + data[2]),
            0.5 * (data[1] + data[3])
          ]);
          prevCtrlPoint = [data[2] - data[0], data[3] - data[1]];
          break;
        case "A":
          if (basePoint != null) {
            var curves = a2c.apply(0, basePoint.concat(data));
            for (var cData;(cData = curves.splice(0, 6).map(toAbsolute)).length; ) {
              if (basePoint != null) {
                addPoint(subPath, [
                  0.5 * (basePoint[0] + cData[0]),
                  0.5 * (basePoint[1] + cData[1])
                ]);
              }
              addPoint(subPath, [
                0.5 * (cData[0] + cData[2]),
                0.5 * (cData[1] + cData[3])
              ]);
              addPoint(subPath, [
                0.5 * (cData[2] + cData[4]),
                0.5 * (cData[3] + cData[5])
              ]);
              if (curves.length)
                addPoint(subPath, basePoint = cData.slice(-2));
            }
          }
          break;
      }
      if (data.length >= 2)
        addPoint(subPath, data.slice(-2));
    }
    return points;
  }
  function convexHull(points) {
    points.list.sort(function(a, b) {
      return a[0] == b[0] ? a[1] - b[1] : a[0] - b[0];
    });
    var lower = [], minY = 0, bottom = 0;
    for (let i = 0;i < points.list.length; i++) {
      while (lower.length >= 2 && cross(lower[lower.length - 2], lower[lower.length - 1], points.list[i]) <= 0) {
        lower.pop();
      }
      if (points.list[i][1] < points.list[minY][1]) {
        minY = i;
        bottom = lower.length;
      }
      lower.push(points.list[i]);
    }
    var upper = [], maxY = points.list.length - 1, top = 0;
    for (let i = points.list.length;i--; ) {
      while (upper.length >= 2 && cross(upper[upper.length - 2], upper[upper.length - 1], points.list[i]) <= 0) {
        upper.pop();
      }
      if (points.list[i][1] > points.list[maxY][1]) {
        maxY = i;
        top = upper.length;
      }
      upper.push(points.list[i]);
    }
    upper.pop();
    lower.pop();
    const hullList = lower.concat(upper);
    const hull = {
      list: hullList,
      minX: 0,
      maxX: lower.length,
      minY: bottom,
      maxY: (lower.length + top) % hullList.length
    };
    return hull;
  }
  function cross(o, a, b) {
    return (a[0] - o[0]) * (b[1] - o[1]) - (a[1] - o[1]) * (b[0] - o[0]);
  }
  var a2c = (x1, y1, rx, ry, angle, large_arc_flag, sweep_flag, x2, y2, recursive) => {
    const _120 = Math.PI * 120 / 180;
    const rad = Math.PI / 180 * (+angle || 0);
    let res = [];
    const rotateX = (x3, y3, rad2) => {
      return x3 * Math.cos(rad2) - y3 * Math.sin(rad2);
    };
    const rotateY = (x3, y3, rad2) => {
      return x3 * Math.sin(rad2) + y3 * Math.cos(rad2);
    };
    if (!recursive) {
      x1 = rotateX(x1, y1, -rad);
      y1 = rotateY(x1, y1, -rad);
      x2 = rotateX(x2, y2, -rad);
      y2 = rotateY(x2, y2, -rad);
      var x = (x1 - x2) / 2, y = (y1 - y2) / 2;
      var h = x * x / (rx * rx) + y * y / (ry * ry);
      if (h > 1) {
        h = Math.sqrt(h);
        rx = h * rx;
        ry = h * ry;
      }
      var rx2 = rx * rx;
      var ry2 = ry * ry;
      var k = (large_arc_flag == sweep_flag ? -1 : 1) * Math.sqrt(Math.abs((rx2 * ry2 - rx2 * y * y - ry2 * x * x) / (rx2 * y * y + ry2 * x * x)));
      var cx = k * rx * y / ry + (x1 + x2) / 2;
      var cy = k * -ry * x / rx + (y1 + y2) / 2;
      var f1 = Math.asin(Number(((y1 - cy) / ry).toFixed(9)));
      var f2 = Math.asin(Number(((y2 - cy) / ry).toFixed(9)));
      f1 = x1 < cx ? Math.PI - f1 : f1;
      f2 = x2 < cx ? Math.PI - f2 : f2;
      f1 < 0 && (f1 = Math.PI * 2 + f1);
      f2 < 0 && (f2 = Math.PI * 2 + f2);
      if (sweep_flag && f1 > f2) {
        f1 = f1 - Math.PI * 2;
      }
      if (!sweep_flag && f2 > f1) {
        f2 = f2 - Math.PI * 2;
      }
    } else {
      f1 = recursive[0];
      f2 = recursive[1];
      cx = recursive[2];
      cy = recursive[3];
    }
    var df = f2 - f1;
    if (Math.abs(df) > _120) {
      var f2old = f2, x2old = x2, y2old = y2;
      f2 = f1 + _120 * (sweep_flag && f2 > f1 ? 1 : -1);
      x2 = cx + rx * Math.cos(f2);
      y2 = cy + ry * Math.sin(f2);
      res = a2c(x2, y2, rx, ry, angle, 0, sweep_flag, x2old, y2old, [
        f2,
        f2old,
        cx,
        cy
      ]);
    }
    df = f2 - f1;
    var c1 = Math.cos(f1), s1 = Math.sin(f1), c2 = Math.cos(f2), s2 = Math.sin(f2), t = Math.tan(df / 4), hx = 4 / 3 * rx * t, hy = 4 / 3 * ry * t, m = [
      -hx * s1,
      hy * c1,
      x2 + hx * s2 - x1,
      y2 - hy * c2 - y1,
      x2 - x1,
      y2 - y1
    ];
    if (recursive) {
      return m.concat(res);
    } else {
      res = m.concat(res);
      var newres = [];
      for (var i = 0, n = res.length;i < n; i++) {
        newres[i] = i % 2 ? rotateY(res[i - 1], res[i], rad) : rotateX(res[i], res[i + 1], rad);
      }
      return newres;
    }
  };
});

// ../../../../node_modules/.bun/svgo@3.3.2/node_modules/svgo/plugins/_transforms.js
var require__transforms = __commonJS((exports) => {
  var { toFixed } = require_tools();
  var transformTypes = new Set([
    "matrix",
    "rotate",
    "scale",
    "skewX",
    "skewY",
    "translate"
  ]);
  var regTransformSplit = /\s*(matrix|translate|scale|rotate|skewX|skewY)\s*\(\s*(.+?)\s*\)[\s,]*/;
  var regNumericValues = /[-+]?(?:\d*\.\d+|\d+\.?)(?:[eE][-+]?\d+)?/g;
  exports.transform2js = (transformString) => {
    const transforms = [];
    let currentTransform = null;
    for (const item of transformString.split(regTransformSplit)) {
      if (!item) {
        continue;
      }
      if (transformTypes.has(item)) {
        currentTransform = { name: item, data: [] };
        transforms.push(currentTransform);
      } else {
        let num;
        while (num = regNumericValues.exec(item)) {
          num = Number(num);
          if (currentTransform != null) {
            currentTransform.data.push(num);
          }
        }
      }
    }
    return currentTransform == null || currentTransform.data.length == 0 ? [] : transforms;
  };
  exports.transformsMultiply = (transforms) => {
    const matrixData = transforms.map((transform) => {
      if (transform.name === "matrix") {
        return transform.data;
      }
      return transformToMatrix(transform);
    });
    const matrixTransform = {
      name: "matrix",
      data: matrixData.length > 0 ? matrixData.reduce(multiplyTransformMatrices) : []
    };
    return matrixTransform;
  };
  var mth = {
    rad: (deg) => {
      return deg * Math.PI / 180;
    },
    deg: (rad) => {
      return rad * 180 / Math.PI;
    },
    cos: (deg) => {
      return Math.cos(mth.rad(deg));
    },
    acos: (val, floatPrecision) => {
      return toFixed(mth.deg(Math.acos(val)), floatPrecision);
    },
    sin: (deg) => {
      return Math.sin(mth.rad(deg));
    },
    asin: (val, floatPrecision) => {
      return toFixed(mth.deg(Math.asin(val)), floatPrecision);
    },
    tan: (deg) => {
      return Math.tan(mth.rad(deg));
    },
    atan: (val, floatPrecision) => {
      return toFixed(mth.deg(Math.atan(val)), floatPrecision);
    }
  };
  exports.matrixToTransform = (transform, params) => {
    const floatPrecision = params.floatPrecision;
    const data = transform.data;
    const transforms = [];
    if (data[4] || data[5]) {
      transforms.push({
        name: "translate",
        data: data.slice(4, data[5] ? 6 : 5)
      });
    }
    let sx = toFixed(Math.hypot(data[0], data[1]), params.transformPrecision);
    let sy = toFixed((data[0] * data[3] - data[1] * data[2]) / sx, params.transformPrecision);
    const colsSum = data[0] * data[2] + data[1] * data[3];
    const rowsSum = data[0] * data[1] + data[2] * data[3];
    const scaleBefore = rowsSum !== 0 || sx === sy;
    if (!data[1] && data[2]) {
      transforms.push({
        name: "skewX",
        data: [mth.atan(data[2] / sy, floatPrecision)]
      });
    } else if (data[1] && !data[2]) {
      transforms.push({
        name: "skewY",
        data: [mth.atan(data[1] / data[0], floatPrecision)]
      });
      sx = data[0];
      sy = data[3];
    } else if (!colsSum || sx === 1 && sy === 1 || !scaleBefore) {
      if (!scaleBefore) {
        sx = Math.hypot(data[0], data[2]);
        sy = Math.hypot(data[1], data[3]);
        if (toFixed(data[0], params.transformPrecision) < 0) {
          sx = -sx;
        }
        if (data[3] < 0 || Math.sign(data[1]) === Math.sign(data[2]) && toFixed(data[3], params.transformPrecision) === 0) {
          sy = -sy;
        }
        transforms.push({ name: "scale", data: [sx, sy] });
      }
      const angle = Math.min(Math.max(-1, data[0] / sx), 1);
      const rotate = [
        mth.acos(angle, floatPrecision) * ((scaleBefore ? 1 : sy) * data[1] < 0 ? -1 : 1)
      ];
      if (rotate[0]) {
        transforms.push({ name: "rotate", data: rotate });
      }
      if (rowsSum && colsSum)
        transforms.push({
          name: "skewX",
          data: [mth.atan(colsSum / (sx * sx), floatPrecision)]
        });
      if (rotate[0] && (data[4] || data[5])) {
        transforms.shift();
        const oneOverCos = 1 - data[0] / sx;
        const sin = data[1] / (scaleBefore ? sx : sy);
        const x = data[4] * (scaleBefore ? 1 : sy);
        const y = data[5] * (scaleBefore ? 1 : sx);
        const denom = (oneOverCos ** 2 + sin ** 2) * (scaleBefore ? 1 : sx * sy);
        rotate.push((oneOverCos * x - sin * y) / denom, (oneOverCos * y + sin * x) / denom);
      }
    } else if (data[1] || data[2]) {
      return [transform];
    }
    if (scaleBefore && (sx != 1 || sy != 1) || !transforms.length) {
      transforms.push({
        name: "scale",
        data: sx == sy ? [sx] : [sx, sy]
      });
    }
    return transforms;
  };
  var transformToMatrix = (transform) => {
    if (transform.name === "matrix") {
      return transform.data;
    }
    switch (transform.name) {
      case "translate":
        return [1, 0, 0, 1, transform.data[0], transform.data[1] || 0];
      case "scale":
        return [
          transform.data[0],
          0,
          0,
          transform.data[1] || transform.data[0],
          0,
          0
        ];
      case "rotate":
        var cos = mth.cos(transform.data[0]), sin = mth.sin(transform.data[0]), cx = transform.data[1] || 0, cy = transform.data[2] || 0;
        return [
          cos,
          sin,
          -sin,
          cos,
          (1 - cos) * cx + sin * cy,
          (1 - cos) * cy - sin * cx
        ];
      case "skewX":
        return [1, 0, mth.tan(transform.data[0]), 1, 0, 0];
      case "skewY":
        return [1, mth.tan(transform.data[0]), 0, 1, 0, 0];
      default:
        throw Error(`Unknown transform ${transform.name}`);
    }
  };
  exports.transformArc = (cursor, arc, transform) => {
    const x = arc[5] - cursor[0];
    const y = arc[6] - cursor[1];
    let a = arc[0];
    let b = arc[1];
    const rot = arc[2] * Math.PI / 180;
    const cos = Math.cos(rot);
    const sin = Math.sin(rot);
    if (a > 0 && b > 0) {
      let h = Math.pow(x * cos + y * sin, 2) / (4 * a * a) + Math.pow(y * cos - x * sin, 2) / (4 * b * b);
      if (h > 1) {
        h = Math.sqrt(h);
        a *= h;
        b *= h;
      }
    }
    const ellipse = [a * cos, a * sin, -b * sin, b * cos, 0, 0];
    const m = multiplyTransformMatrices(transform, ellipse);
    const lastCol = m[2] * m[2] + m[3] * m[3];
    const squareSum = m[0] * m[0] + m[1] * m[1] + lastCol;
    const root = Math.hypot(m[0] - m[3], m[1] + m[2]) * Math.hypot(m[0] + m[3], m[1] - m[2]);
    if (!root) {
      arc[0] = arc[1] = Math.sqrt(squareSum / 2);
      arc[2] = 0;
    } else {
      const majorAxisSqr = (squareSum + root) / 2;
      const minorAxisSqr = (squareSum - root) / 2;
      const major = Math.abs(majorAxisSqr - lastCol) > 0.000001;
      const sub = (major ? majorAxisSqr : minorAxisSqr) - lastCol;
      const rowsSum = m[0] * m[2] + m[1] * m[3];
      const term1 = m[0] * sub + m[2] * rowsSum;
      const term2 = m[1] * sub + m[3] * rowsSum;
      arc[0] = Math.sqrt(majorAxisSqr);
      arc[1] = Math.sqrt(minorAxisSqr);
      arc[2] = ((major ? term2 < 0 : term1 > 0) ? -1 : 1) * Math.acos((major ? term1 : term2) / Math.hypot(term1, term2)) * 180 / Math.PI;
    }
    if (transform[0] < 0 !== transform[3] < 0) {
      arc[4] = 1 - arc[4];
    }
    return arc;
  };
  var multiplyTransformMatrices = (a, b) => {
    return [
      a[0] * b[0] + a[2] * b[1],
      a[1] * b[0] + a[3] * b[1],
      a[0] * b[2] + a[2] * b[3],
      a[1] * b[2] + a[3] * b[3],
      a[0] * b[4] + a[2] * b[5] + a[4],
      a[1] * b[4] + a[3] * b[5] + a[5]
    ];
  };
});

// ../../../../node_modules/.bun/svgo@3.3.2/node_modules/svgo/plugins/applyTransforms.js
var require_applyTransforms = __commonJS((exports) => {
  var { collectStylesheet, computeStyle } = require_style();
  var {
    transformsMultiply,
    transform2js,
    transformArc
  } = require__transforms();
  var { path2js } = require__path();
  var {
    removeLeadingZero,
    includesUrlReference
  } = require_tools();
  var { referencesProps, attrsGroupsDefaults } = require__collections();
  var regNumericValues = /[-+]?(\d*\.\d+|\d+\.?)(?:[eE][-+]?\d+)?/g;
  var applyTransforms = (root, params) => {
    const stylesheet = collectStylesheet(root);
    return {
      element: {
        enter: (node) => {
          if (node.attributes.d == null) {
            return;
          }
          if (node.attributes.id != null) {
            return;
          }
          if (node.attributes.transform == null || node.attributes.transform === "" || node.attributes.style != null || Object.entries(node.attributes).some(([name, value]) => referencesProps.has(name) && includesUrlReference(value))) {
            return;
          }
          const computedStyle = computeStyle(stylesheet, node);
          const transformStyle = computedStyle.transform;
          if (transformStyle.type === "static" && transformStyle.value !== node.attributes.transform) {
            return;
          }
          const matrix = transformsMultiply(transform2js(node.attributes.transform));
          const stroke = computedStyle.stroke?.type === "static" ? computedStyle.stroke.value : null;
          const strokeWidth = computedStyle["stroke-width"]?.type === "static" ? computedStyle["stroke-width"].value : null;
          const transformPrecision = params.transformPrecision;
          if (computedStyle.stroke?.type === "dynamic" || computedStyle["stroke-width"]?.type === "dynamic") {
            return;
          }
          const scale = Number(Math.sqrt(matrix.data[0] * matrix.data[0] + matrix.data[1] * matrix.data[1]).toFixed(transformPrecision));
          if (stroke && stroke != "none") {
            if (!params.applyTransformsStroked) {
              return;
            }
            if ((matrix.data[0] !== matrix.data[3] || matrix.data[1] !== -matrix.data[2]) && (matrix.data[0] !== -matrix.data[3] || matrix.data[1] !== matrix.data[2])) {
              return;
            }
            if (scale !== 1) {
              if (node.attributes["vector-effect"] !== "non-scaling-stroke") {
                node.attributes["stroke-width"] = (strokeWidth || attrsGroupsDefaults.presentation["stroke-width"]).trim().replace(regNumericValues, (num) => removeLeadingZero(Number(num) * scale));
                if (node.attributes["stroke-dashoffset"] != null) {
                  node.attributes["stroke-dashoffset"] = node.attributes["stroke-dashoffset"].trim().replace(regNumericValues, (num) => removeLeadingZero(Number(num) * scale));
                }
                if (node.attributes["stroke-dasharray"] != null) {
                  node.attributes["stroke-dasharray"] = node.attributes["stroke-dasharray"].trim().replace(regNumericValues, (num) => removeLeadingZero(Number(num) * scale));
                }
              }
            }
          }
          const pathData = path2js(node);
          applyMatrixToPathData(pathData, matrix.data);
          delete node.attributes.transform;
        }
      }
    };
  };
  exports.applyTransforms = applyTransforms;
  var transformAbsolutePoint = (matrix, x, y) => {
    const newX = matrix[0] * x + matrix[2] * y + matrix[4];
    const newY = matrix[1] * x + matrix[3] * y + matrix[5];
    return [newX, newY];
  };
  var transformRelativePoint = (matrix, x, y) => {
    const newX = matrix[0] * x + matrix[2] * y;
    const newY = matrix[1] * x + matrix[3] * y;
    return [newX, newY];
  };
  var applyMatrixToPathData = (pathData, matrix) => {
    const start = [0, 0];
    const cursor = [0, 0];
    for (const pathItem of pathData) {
      let { command, args } = pathItem;
      if (command === "M") {
        cursor[0] = args[0];
        cursor[1] = args[1];
        start[0] = cursor[0];
        start[1] = cursor[1];
        const [x, y] = transformAbsolutePoint(matrix, args[0], args[1]);
        args[0] = x;
        args[1] = y;
      }
      if (command === "m") {
        cursor[0] += args[0];
        cursor[1] += args[1];
        start[0] = cursor[0];
        start[1] = cursor[1];
        const [x, y] = transformRelativePoint(matrix, args[0], args[1]);
        args[0] = x;
        args[1] = y;
      }
      if (command === "H") {
        command = "L";
        args = [args[0], cursor[1]];
      }
      if (command === "h") {
        command = "l";
        args = [args[0], 0];
      }
      if (command === "V") {
        command = "L";
        args = [cursor[0], args[0]];
      }
      if (command === "v") {
        command = "l";
        args = [0, args[0]];
      }
      if (command === "L") {
        cursor[0] = args[0];
        cursor[1] = args[1];
        const [x, y] = transformAbsolutePoint(matrix, args[0], args[1]);
        args[0] = x;
        args[1] = y;
      }
      if (command === "l") {
        cursor[0] += args[0];
        cursor[1] += args[1];
        const [x, y] = transformRelativePoint(matrix, args[0], args[1]);
        args[0] = x;
        args[1] = y;
      }
      if (command === "C") {
        cursor[0] = args[4];
        cursor[1] = args[5];
        const [x1, y1] = transformAbsolutePoint(matrix, args[0], args[1]);
        const [x2, y2] = transformAbsolutePoint(matrix, args[2], args[3]);
        const [x, y] = transformAbsolutePoint(matrix, args[4], args[5]);
        args[0] = x1;
        args[1] = y1;
        args[2] = x2;
        args[3] = y2;
        args[4] = x;
        args[5] = y;
      }
      if (command === "c") {
        cursor[0] += args[4];
        cursor[1] += args[5];
        const [x1, y1] = transformRelativePoint(matrix, args[0], args[1]);
        const [x2, y2] = transformRelativePoint(matrix, args[2], args[3]);
        const [x, y] = transformRelativePoint(matrix, args[4], args[5]);
        args[0] = x1;
        args[1] = y1;
        args[2] = x2;
        args[3] = y2;
        args[4] = x;
        args[5] = y;
      }
      if (command === "S") {
        cursor[0] = args[2];
        cursor[1] = args[3];
        const [x2, y2] = transformAbsolutePoint(matrix, args[0], args[1]);
        const [x, y] = transformAbsolutePoint(matrix, args[2], args[3]);
        args[0] = x2;
        args[1] = y2;
        args[2] = x;
        args[3] = y;
      }
      if (command === "s") {
        cursor[0] += args[2];
        cursor[1] += args[3];
        const [x2, y2] = transformRelativePoint(matrix, args[0], args[1]);
        const [x, y] = transformRelativePoint(matrix, args[2], args[3]);
        args[0] = x2;
        args[1] = y2;
        args[2] = x;
        args[3] = y;
      }
      if (command === "Q") {
        cursor[0] = args[2];
        cursor[1] = args[3];
        const [x1, y1] = transformAbsolutePoint(matrix, args[0], args[1]);
        const [x, y] = transformAbsolutePoint(matrix, args[2], args[3]);
        args[0] = x1;
        args[1] = y1;
        args[2] = x;
        args[3] = y;
      }
      if (command === "q") {
        cursor[0] += args[2];
        cursor[1] += args[3];
        const [x1, y1] = transformRelativePoint(matrix, args[0], args[1]);
        const [x, y] = transformRelativePoint(matrix, args[2], args[3]);
        args[0] = x1;
        args[1] = y1;
        args[2] = x;
        args[3] = y;
      }
      if (command === "T") {
        cursor[0] = args[0];
        cursor[1] = args[1];
        const [x, y] = transformAbsolutePoint(matrix, args[0], args[1]);
        args[0] = x;
        args[1] = y;
      }
      if (command === "t") {
        cursor[0] += args[0];
        cursor[1] += args[1];
        const [x, y] = transformRelativePoint(matrix, args[0], args[1]);
        args[0] = x;
        args[1] = y;
      }
      if (command === "A") {
        transformArc(cursor, args, matrix);
        cursor[0] = args[5];
        cursor[1] = args[6];
        if (Math.abs(args[2]) > 80) {
          const a = args[0];
          const rotation = args[2];
          args[0] = args[1];
          args[1] = a;
          args[2] = rotation + (rotation > 0 ? -90 : 90);
        }
        const [x, y] = transformAbsolutePoint(matrix, args[5], args[6]);
        args[5] = x;
        args[6] = y;
      }
      if (command === "a") {
        transformArc([0, 0], args, matrix);
        cursor[0] += args[5];
        cursor[1] += args[6];
        if (Math.abs(args[2]) > 80) {
          const a = args[0];
          const rotation = args[2];
          args[0] = args[1];
          args[1] = a;
          args[2] = rotation + (rotation > 0 ? -90 : 90);
        }
        const [x, y] = transformRelativePoint(matrix, args[5], args[6]);
        args[5] = x;
        args[6] = y;
      }
      if (command === "z" || command === "Z") {
        cursor[0] = start[0];
        cursor[1] = start[1];
      }
      pathItem.command = command;
      pathItem.args = args;
    }
  };
});

// ../../../../node_modules/.bun/svgo@3.3.2/node_modules/svgo/plugins/convertPathData.js
var require_convertPathData = __commonJS((exports) => {
  var { collectStylesheet, computeStyle } = require_style();
  var { visit } = require_xast();
  var { pathElems } = require__collections();
  var { path2js, js2path } = require__path();
  var { applyTransforms } = require_applyTransforms();
  var { cleanupOutData, toFixed } = require_tools();
  exports.name = "convertPathData";
  exports.description = "optimizes path data: writes in shorter form, applies transformations";
  var roundData;
  var precision;
  var error;
  var arcThreshold;
  var arcTolerance;
  exports.fn = (root, params) => {
    const {
      applyTransforms: _applyTransforms = true,
      applyTransformsStroked = true,
      makeArcs = {
        threshold: 2.5,
        tolerance: 0.5
      },
      straightCurves = true,
      convertToQ = true,
      lineShorthands = true,
      convertToZ = true,
      curveSmoothShorthands = true,
      floatPrecision = 3,
      transformPrecision = 5,
      smartArcRounding = true,
      removeUseless = true,
      collapseRepeated = true,
      utilizeAbsolute = true,
      leadingZero = true,
      negativeExtraSpace = true,
      noSpaceAfterFlags = false,
      forceAbsolutePath = false
    } = params;
    const newParams = {
      applyTransforms: _applyTransforms,
      applyTransformsStroked,
      makeArcs,
      straightCurves,
      convertToQ,
      lineShorthands,
      convertToZ,
      curveSmoothShorthands,
      floatPrecision,
      transformPrecision,
      smartArcRounding,
      removeUseless,
      collapseRepeated,
      utilizeAbsolute,
      leadingZero,
      negativeExtraSpace,
      noSpaceAfterFlags,
      forceAbsolutePath
    };
    if (_applyTransforms) {
      visit(root, applyTransforms(root, {
        transformPrecision,
        applyTransformsStroked
      }));
    }
    const stylesheet = collectStylesheet(root);
    return {
      element: {
        enter: (node) => {
          if (pathElems.has(node.name) && node.attributes.d != null) {
            const computedStyle = computeStyle(stylesheet, node);
            precision = floatPrecision;
            error = precision !== false ? +Math.pow(0.1, precision).toFixed(precision) : 0.01;
            roundData = precision && precision > 0 && precision < 20 ? strongRound : round;
            if (makeArcs) {
              arcThreshold = makeArcs.threshold;
              arcTolerance = makeArcs.tolerance;
            }
            const hasMarkerMid = computedStyle["marker-mid"] != null;
            const maybeHasStroke = computedStyle.stroke && (computedStyle.stroke.type === "dynamic" || computedStyle.stroke.value !== "none");
            const maybeHasLinecap = computedStyle["stroke-linecap"] && (computedStyle["stroke-linecap"].type === "dynamic" || computedStyle["stroke-linecap"].value !== "butt");
            const maybeHasStrokeAndLinecap = maybeHasStroke && maybeHasLinecap;
            const isSafeToUseZ = maybeHasStroke ? computedStyle["stroke-linecap"]?.type === "static" && computedStyle["stroke-linecap"].value === "round" && computedStyle["stroke-linejoin"]?.type === "static" && computedStyle["stroke-linejoin"].value === "round" : true;
            var data = path2js(node);
            if (data.length) {
              convertToRelative(data);
              data = filters(data, newParams, {
                isSafeToUseZ,
                maybeHasStrokeAndLinecap,
                hasMarkerMid
              });
              if (utilizeAbsolute) {
                data = convertToMixed(data, newParams);
              }
              js2path(node, data, newParams);
            }
          }
        }
      }
    };
  };
  var convertToRelative = (pathData) => {
    let start = [0, 0];
    let cursor = [0, 0];
    let prevCoords = [0, 0];
    for (let i = 0;i < pathData.length; i += 1) {
      const pathItem = pathData[i];
      let { command, args } = pathItem;
      if (command === "m") {
        cursor[0] += args[0];
        cursor[1] += args[1];
        start[0] = cursor[0];
        start[1] = cursor[1];
      }
      if (command === "M") {
        if (i !== 0) {
          command = "m";
        }
        args[0] -= cursor[0];
        args[1] -= cursor[1];
        cursor[0] += args[0];
        cursor[1] += args[1];
        start[0] = cursor[0];
        start[1] = cursor[1];
      }
      if (command === "l") {
        cursor[0] += args[0];
        cursor[1] += args[1];
      }
      if (command === "L") {
        command = "l";
        args[0] -= cursor[0];
        args[1] -= cursor[1];
        cursor[0] += args[0];
        cursor[1] += args[1];
      }
      if (command === "h") {
        cursor[0] += args[0];
      }
      if (command === "H") {
        command = "h";
        args[0] -= cursor[0];
        cursor[0] += args[0];
      }
      if (command === "v") {
        cursor[1] += args[0];
      }
      if (command === "V") {
        command = "v";
        args[0] -= cursor[1];
        cursor[1] += args[0];
      }
      if (command === "c") {
        cursor[0] += args[4];
        cursor[1] += args[5];
      }
      if (command === "C") {
        command = "c";
        args[0] -= cursor[0];
        args[1] -= cursor[1];
        args[2] -= cursor[0];
        args[3] -= cursor[1];
        args[4] -= cursor[0];
        args[5] -= cursor[1];
        cursor[0] += args[4];
        cursor[1] += args[5];
      }
      if (command === "s") {
        cursor[0] += args[2];
        cursor[1] += args[3];
      }
      if (command === "S") {
        command = "s";
        args[0] -= cursor[0];
        args[1] -= cursor[1];
        args[2] -= cursor[0];
        args[3] -= cursor[1];
        cursor[0] += args[2];
        cursor[1] += args[3];
      }
      if (command === "q") {
        cursor[0] += args[2];
        cursor[1] += args[3];
      }
      if (command === "Q") {
        command = "q";
        args[0] -= cursor[0];
        args[1] -= cursor[1];
        args[2] -= cursor[0];
        args[3] -= cursor[1];
        cursor[0] += args[2];
        cursor[1] += args[3];
      }
      if (command === "t") {
        cursor[0] += args[0];
        cursor[1] += args[1];
      }
      if (command === "T") {
        command = "t";
        args[0] -= cursor[0];
        args[1] -= cursor[1];
        cursor[0] += args[0];
        cursor[1] += args[1];
      }
      if (command === "a") {
        cursor[0] += args[5];
        cursor[1] += args[6];
      }
      if (command === "A") {
        command = "a";
        args[5] -= cursor[0];
        args[6] -= cursor[1];
        cursor[0] += args[5];
        cursor[1] += args[6];
      }
      if (command === "Z" || command === "z") {
        cursor[0] = start[0];
        cursor[1] = start[1];
      }
      pathItem.command = command;
      pathItem.args = args;
      pathItem.base = prevCoords;
      pathItem.coords = [cursor[0], cursor[1]];
      prevCoords = pathItem.coords;
    }
    return pathData;
  };
  function filters(path, params, { isSafeToUseZ, maybeHasStrokeAndLinecap, hasMarkerMid }) {
    const stringify = data2Path.bind(null, params);
    const relSubpoint = [0, 0];
    const pathBase = [0, 0];
    let prev = {};
    let prevQControlPoint;
    path = path.filter(function(item, index, path2) {
      const qControlPoint = prevQControlPoint;
      prevQControlPoint = undefined;
      let command = item.command;
      let data = item.args;
      let next = path2[index + 1];
      if (command !== "Z" && command !== "z") {
        var sdata = data, circle;
        if (command === "s") {
          sdata = [0, 0].concat(data);
          const pdata = prev.args;
          const n = pdata.length;
          sdata[0] = pdata[n - 2] - pdata[n - 4];
          sdata[1] = pdata[n - 1] - pdata[n - 3];
        }
        if (params.makeArcs && (command == "c" || command == "s") && isConvex(sdata) && (circle = findCircle(sdata))) {
          var r = roundData([circle.radius])[0], angle = findArcAngle(sdata, circle), sweep = sdata[5] * sdata[0] - sdata[4] * sdata[1] > 0 ? 1 : 0, arc = {
            command: "a",
            args: [r, r, 0, 0, sweep, sdata[4], sdata[5]],
            coords: item.coords.slice(),
            base: item.base
          }, output = [arc], relCenter = [
            circle.center[0] - sdata[4],
            circle.center[1] - sdata[5]
          ], relCircle = { center: relCenter, radius: circle.radius }, arcCurves = [item], hasPrev = 0, suffix = "", nextLonghand;
          if (prev.command == "c" && isConvex(prev.args) && isArcPrev(prev.args, circle) || prev.command == "a" && prev.sdata && isArcPrev(prev.sdata, circle)) {
            arcCurves.unshift(prev);
            arc.base = prev.base;
            arc.args[5] = arc.coords[0] - arc.base[0];
            arc.args[6] = arc.coords[1] - arc.base[1];
            var prevData = prev.command == "a" ? prev.sdata : prev.args;
            var prevAngle = findArcAngle(prevData, {
              center: [
                prevData[4] + circle.center[0],
                prevData[5] + circle.center[1]
              ],
              radius: circle.radius
            });
            angle += prevAngle;
            if (angle > Math.PI)
              arc.args[3] = 1;
            hasPrev = 1;
          }
          for (var j = index;(next = path2[++j]) && (next.command === "c" || next.command === "s"); ) {
            var nextData = next.args;
            if (next.command == "s") {
              nextLonghand = makeLonghand({ command: "s", args: next.args.slice() }, path2[j - 1].args);
              nextData = nextLonghand.args;
              nextLonghand.args = nextData.slice(0, 2);
              suffix = stringify([nextLonghand]);
            }
            if (isConvex(nextData) && isArc(nextData, relCircle)) {
              angle += findArcAngle(nextData, relCircle);
              if (angle - 2 * Math.PI > 0.001)
                break;
              if (angle > Math.PI)
                arc.args[3] = 1;
              arcCurves.push(next);
              if (2 * Math.PI - angle > 0.001) {
                arc.coords = next.coords;
                arc.args[5] = arc.coords[0] - arc.base[0];
                arc.args[6] = arc.coords[1] - arc.base[1];
              } else {
                arc.args[5] = 2 * (relCircle.center[0] - nextData[4]);
                arc.args[6] = 2 * (relCircle.center[1] - nextData[5]);
                arc.coords = [
                  arc.base[0] + arc.args[5],
                  arc.base[1] + arc.args[6]
                ];
                arc = {
                  command: "a",
                  args: [
                    r,
                    r,
                    0,
                    0,
                    sweep,
                    next.coords[0] - arc.coords[0],
                    next.coords[1] - arc.coords[1]
                  ],
                  coords: next.coords,
                  base: arc.coords
                };
                output.push(arc);
                j++;
                break;
              }
              relCenter[0] -= nextData[4];
              relCenter[1] -= nextData[5];
            } else
              break;
          }
          if ((stringify(output) + suffix).length < stringify(arcCurves).length) {
            if (path2[j] && path2[j].command == "s") {
              makeLonghand(path2[j], path2[j - 1].args);
            }
            if (hasPrev) {
              var prevArc = output.shift();
              roundData(prevArc.args);
              relSubpoint[0] += prevArc.args[5] - prev.args[prev.args.length - 2];
              relSubpoint[1] += prevArc.args[6] - prev.args[prev.args.length - 1];
              prev.command = "a";
              prev.args = prevArc.args;
              item.base = prev.coords = prevArc.coords;
            }
            arc = output.shift();
            if (arcCurves.length == 1) {
              item.sdata = sdata.slice();
            } else if (arcCurves.length - 1 - hasPrev > 0) {
              path2.splice(index + 1, arcCurves.length - 1 - hasPrev, ...output);
            }
            if (!arc)
              return false;
            command = "a";
            data = arc.args;
            item.coords = arc.coords;
          }
        }
        if (precision !== false) {
          if (command === "m" || command === "l" || command === "t" || command === "q" || command === "s" || command === "c") {
            for (var i = data.length;i--; ) {
              data[i] += item.base[i % 2] - relSubpoint[i % 2];
            }
          } else if (command == "h") {
            data[0] += item.base[0] - relSubpoint[0];
          } else if (command == "v") {
            data[0] += item.base[1] - relSubpoint[1];
          } else if (command == "a") {
            data[5] += item.base[0] - relSubpoint[0];
            data[6] += item.base[1] - relSubpoint[1];
          }
          roundData(data);
          if (command == "h")
            relSubpoint[0] += data[0];
          else if (command == "v")
            relSubpoint[1] += data[0];
          else {
            relSubpoint[0] += data[data.length - 2];
            relSubpoint[1] += data[data.length - 1];
          }
          roundData(relSubpoint);
          if (command === "M" || command === "m") {
            pathBase[0] = relSubpoint[0];
            pathBase[1] = relSubpoint[1];
          }
        }
        const sagitta = command === "a" ? calculateSagitta(data) : undefined;
        if (params.smartArcRounding && sagitta !== undefined && precision) {
          for (let precisionNew = precision;precisionNew >= 0; precisionNew--) {
            const radius = toFixed(data[0], precisionNew);
            const sagittaNew = calculateSagitta([radius, radius, ...data.slice(2)]);
            if (Math.abs(sagitta - sagittaNew) < error) {
              data[0] = radius;
              data[1] = radius;
            } else {
              break;
            }
          }
        }
        if (params.straightCurves) {
          if (command === "c" && isCurveStraightLine(data) || command === "s" && isCurveStraightLine(sdata)) {
            if (next && next.command == "s")
              makeLonghand(next, data);
            command = "l";
            data = data.slice(-2);
          } else if (command === "q" && isCurveStraightLine(data)) {
            if (next && next.command == "t")
              makeLonghand(next, data);
            command = "l";
            data = data.slice(-2);
          } else if (command === "t" && prev.command !== "q" && prev.command !== "t") {
            command = "l";
            data = data.slice(-2);
          } else if (command === "a" && (data[0] === 0 || data[1] === 0 || sagitta !== undefined && sagitta < error)) {
            command = "l";
            data = data.slice(-2);
          }
        }
        if (params.convertToQ && command == "c") {
          const x1 = 0.75 * (item.base[0] + data[0]) - 0.25 * item.base[0];
          const x2 = 0.75 * (item.base[0] + data[2]) - 0.25 * (item.base[0] + data[4]);
          if (Math.abs(x1 - x2) < error * 2) {
            const y1 = 0.75 * (item.base[1] + data[1]) - 0.25 * item.base[1];
            const y2 = 0.75 * (item.base[1] + data[3]) - 0.25 * (item.base[1] + data[5]);
            if (Math.abs(y1 - y2) < error * 2) {
              const newData = data.slice();
              newData.splice(0, 4, x1 + x2 - item.base[0], y1 + y2 - item.base[1]);
              roundData(newData);
              const originalLength = cleanupOutData(data, params).length, newLength = cleanupOutData(newData, params).length;
              if (newLength < originalLength) {
                command = "q";
                data = newData;
                if (next && next.command == "s")
                  makeLonghand(next, data);
              }
            }
          }
        }
        if (params.lineShorthands && command === "l") {
          if (data[1] === 0) {
            command = "h";
            data.pop();
          } else if (data[0] === 0) {
            command = "v";
            data.shift();
          }
        }
        if (params.collapseRepeated && hasMarkerMid === false && (command === "m" || command === "h" || command === "v") && prev.command && command == prev.command.toLowerCase() && (command != "h" && command != "v" || prev.args[0] >= 0 == data[0] >= 0)) {
          prev.args[0] += data[0];
          if (command != "h" && command != "v") {
            prev.args[1] += data[1];
          }
          prev.coords = item.coords;
          path2[index] = prev;
          return false;
        }
        if (params.curveSmoothShorthands && prev.command) {
          if (command === "c") {
            if (prev.command === "c" && Math.abs(data[0] - -(prev.args[2] - prev.args[4])) < error && Math.abs(data[1] - -(prev.args[3] - prev.args[5])) < error) {
              command = "s";
              data = data.slice(2);
            } else if (prev.command === "s" && Math.abs(data[0] - -(prev.args[0] - prev.args[2])) < error && Math.abs(data[1] - -(prev.args[1] - prev.args[3])) < error) {
              command = "s";
              data = data.slice(2);
            } else if (prev.command !== "c" && prev.command !== "s" && Math.abs(data[0]) < error && Math.abs(data[1]) < error) {
              command = "s";
              data = data.slice(2);
            }
          } else if (command === "q") {
            if (prev.command === "q" && Math.abs(data[0] - (prev.args[2] - prev.args[0])) < error && Math.abs(data[1] - (prev.args[3] - prev.args[1])) < error) {
              command = "t";
              data = data.slice(2);
            } else if (prev.command === "t") {
              const predictedControlPoint = reflectPoint(qControlPoint, item.base);
              const realControlPoint = [
                data[0] + item.base[0],
                data[1] + item.base[1]
              ];
              if (Math.abs(predictedControlPoint[0] - realControlPoint[0]) < error && Math.abs(predictedControlPoint[1] - realControlPoint[1]) < error) {
                command = "t";
                data = data.slice(2);
              }
            }
          }
        }
        if (params.removeUseless && !maybeHasStrokeAndLinecap) {
          if ((command === "l" || command === "h" || command === "v" || command === "q" || command === "t" || command === "c" || command === "s") && data.every(function(i2) {
            return i2 === 0;
          })) {
            path2[index] = prev;
            return false;
          }
          if (command === "a" && data[5] === 0 && data[6] === 0) {
            path2[index] = prev;
            return false;
          }
        }
        if (params.convertToZ && (isSafeToUseZ || next?.command === "Z" || next?.command === "z") && (command === "l" || command === "h" || command === "v")) {
          if (Math.abs(pathBase[0] - item.coords[0]) < error && Math.abs(pathBase[1] - item.coords[1]) < error) {
            command = "z";
            data = [];
          }
        }
        item.command = command;
        item.args = data;
      } else {
        relSubpoint[0] = pathBase[0];
        relSubpoint[1] = pathBase[1];
        if (prev.command === "Z" || prev.command === "z")
          return false;
      }
      if ((command === "Z" || command === "z") && params.removeUseless && isSafeToUseZ && Math.abs(item.base[0] - item.coords[0]) < error / 10 && Math.abs(item.base[1] - item.coords[1]) < error / 10)
        return false;
      if (command === "q") {
        prevQControlPoint = [data[0] + item.base[0], data[1] + item.base[1]];
      } else if (command === "t") {
        if (qControlPoint) {
          prevQControlPoint = reflectPoint(qControlPoint, item.base);
        } else {
          prevQControlPoint = item.coords;
        }
      }
      prev = item;
      return true;
    });
    return path;
  }
  function convertToMixed(path, params) {
    var prev = path[0];
    path = path.filter(function(item, index) {
      if (index == 0)
        return true;
      if (item.command === "Z" || item.command === "z") {
        prev = item;
        return true;
      }
      var { command, args: data } = item, adata = data.slice(), rdata = data.slice();
      if (command === "m" || command === "l" || command === "t" || command === "q" || command === "s" || command === "c") {
        for (var i = adata.length;i--; ) {
          adata[i] += item.base[i % 2];
        }
      } else if (command == "h") {
        adata[0] += item.base[0];
      } else if (command == "v") {
        adata[0] += item.base[1];
      } else if (command == "a") {
        adata[5] += item.base[0];
        adata[6] += item.base[1];
      }
      roundData(adata);
      roundData(rdata);
      var absoluteDataStr = cleanupOutData(adata, params), relativeDataStr = cleanupOutData(rdata, params);
      if (params.forceAbsolutePath || absoluteDataStr.length < relativeDataStr.length && !(params.negativeExtraSpace && command == prev.command && prev.command.charCodeAt(0) > 96 && absoluteDataStr.length == relativeDataStr.length - 1 && (data[0] < 0 || Math.floor(data[0]) === 0 && !Number.isInteger(data[0]) && prev.args[prev.args.length - 1] % 1))) {
        item.command = command.toUpperCase();
        item.args = adata;
      }
      prev = item;
      return true;
    });
    return path;
  }
  function isConvex(data) {
    var center = getIntersection([
      0,
      0,
      data[2],
      data[3],
      data[0],
      data[1],
      data[4],
      data[5]
    ]);
    return center != null && data[2] < center[0] == center[0] < 0 && data[3] < center[1] == center[1] < 0 && data[4] < center[0] == center[0] < data[0] && data[5] < center[1] == center[1] < data[1];
  }
  function getIntersection(coords) {
    var a1 = coords[1] - coords[3], b1 = coords[2] - coords[0], c1 = coords[0] * coords[3] - coords[2] * coords[1], a2 = coords[5] - coords[7], b2 = coords[6] - coords[4], c2 = coords[4] * coords[7] - coords[5] * coords[6], denom = a1 * b2 - a2 * b1;
    if (!denom)
      return;
    var cross = [(b1 * c2 - b2 * c1) / denom, (a1 * c2 - a2 * c1) / -denom];
    if (!isNaN(cross[0]) && !isNaN(cross[1]) && isFinite(cross[0]) && isFinite(cross[1])) {
      return cross;
    }
  }
  function strongRound(data) {
    const precisionNum = precision || 0;
    for (let i = data.length;i-- > 0; ) {
      const fixed = toFixed(data[i], precisionNum);
      if (fixed !== data[i]) {
        const rounded = toFixed(data[i], precisionNum - 1);
        data[i] = toFixed(Math.abs(rounded - data[i]), precisionNum + 1) >= error ? fixed : rounded;
      }
    }
    return data;
  }
  function round(data) {
    for (var i = data.length;i-- > 0; ) {
      data[i] = Math.round(data[i]);
    }
    return data;
  }
  function isCurveStraightLine(data) {
    var i = data.length - 2, a = -data[i + 1], b = data[i], d = 1 / (a * a + b * b);
    if (i <= 1 || !isFinite(d))
      return false;
    while ((i -= 2) >= 0) {
      if (Math.sqrt(Math.pow(a * data[i] + b * data[i + 1], 2) * d) > error)
        return false;
    }
    return true;
  }
  function calculateSagitta(data) {
    if (data[3] === 1)
      return;
    const [rx, ry] = data;
    if (Math.abs(rx - ry) > error)
      return;
    const chord = Math.sqrt(data[5] ** 2 + data[6] ** 2);
    if (chord > rx * 2)
      return;
    return rx - Math.sqrt(rx ** 2 - 0.25 * chord ** 2);
  }
  function makeLonghand(item, data) {
    switch (item.command) {
      case "s":
        item.command = "c";
        break;
      case "t":
        item.command = "q";
        break;
    }
    item.args.unshift(data[data.length - 2] - data[data.length - 4], data[data.length - 1] - data[data.length - 3]);
    return item;
  }
  function getDistance(point1, point2) {
    return Math.sqrt((point1[0] - point2[0]) ** 2 + (point1[1] - point2[1]) ** 2);
  }
  function reflectPoint(controlPoint, base) {
    return [2 * base[0] - controlPoint[0], 2 * base[1] - controlPoint[1]];
  }
  function getCubicBezierPoint(curve, t) {
    var sqrT = t * t, cubT = sqrT * t, mt = 1 - t, sqrMt = mt * mt;
    return [
      3 * sqrMt * t * curve[0] + 3 * mt * sqrT * curve[2] + cubT * curve[4],
      3 * sqrMt * t * curve[1] + 3 * mt * sqrT * curve[3] + cubT * curve[5]
    ];
  }
  function findCircle(curve) {
    var midPoint = getCubicBezierPoint(curve, 1 / 2), m1 = [midPoint[0] / 2, midPoint[1] / 2], m2 = [(midPoint[0] + curve[4]) / 2, (midPoint[1] + curve[5]) / 2], center = getIntersection([
      m1[0],
      m1[1],
      m1[0] + m1[1],
      m1[1] - m1[0],
      m2[0],
      m2[1],
      m2[0] + (m2[1] - midPoint[1]),
      m2[1] - (m2[0] - midPoint[0])
    ]), radius = center && getDistance([0, 0], center), tolerance = Math.min(arcThreshold * error, arcTolerance * radius / 100);
    if (center && radius < 1000000000000000 && [1 / 4, 3 / 4].every(function(point) {
      return Math.abs(getDistance(getCubicBezierPoint(curve, point), center) - radius) <= tolerance;
    }))
      return { center, radius };
  }
  function isArc(curve, circle) {
    var tolerance = Math.min(arcThreshold * error, arcTolerance * circle.radius / 100);
    return [0, 1 / 4, 1 / 2, 3 / 4, 1].every(function(point) {
      return Math.abs(getDistance(getCubicBezierPoint(curve, point), circle.center) - circle.radius) <= tolerance;
    });
  }
  function isArcPrev(curve, circle) {
    return isArc(curve, {
      center: [circle.center[0] + curve[4], circle.center[1] + curve[5]],
      radius: circle.radius
    });
  }
  function findArcAngle(curve, relCircle) {
    var x1 = -relCircle.center[0], y1 = -relCircle.center[1], x2 = curve[4] - relCircle.center[0], y2 = curve[5] - relCircle.center[1];
    return Math.acos((x1 * x2 + y1 * y2) / Math.sqrt((x1 * x1 + y1 * y1) * (x2 * x2 + y2 * y2)));
  }
  function data2Path(params, pathData) {
    return pathData.reduce(function(pathString, item) {
      var strData = "";
      if (item.args) {
        strData = cleanupOutData(roundData(item.args.slice()), params);
      }
      return pathString + item.command + strData;
    }, "");
  }
});

// ../../../../node_modules/.bun/svgo@3.3.2/node_modules/svgo/plugins/convertTransform.js
var require_convertTransform = __commonJS((exports) => {
  var { cleanupOutData, toFixed } = require_tools();
  var {
    transform2js,
    transformsMultiply,
    matrixToTransform
  } = require__transforms();
  exports.name = "convertTransform";
  exports.description = "collapses multiple transformations and optimizes it";
  exports.fn = (_root, params) => {
    const {
      convertToShorts: convertToShorts2 = true,
      degPrecision,
      floatPrecision = 3,
      transformPrecision = 5,
      matrixToTransform: matrixToTransform2 = true,
      shortTranslate = true,
      shortScale = true,
      shortRotate = true,
      removeUseless: removeUseless2 = true,
      collapseIntoOne = true,
      leadingZero = true,
      negativeExtraSpace = false
    } = params;
    const newParams = {
      convertToShorts: convertToShorts2,
      degPrecision,
      floatPrecision,
      transformPrecision,
      matrixToTransform: matrixToTransform2,
      shortTranslate,
      shortScale,
      shortRotate,
      removeUseless: removeUseless2,
      collapseIntoOne,
      leadingZero,
      negativeExtraSpace
    };
    return {
      element: {
        enter: (node) => {
          if (node.attributes.transform != null) {
            convertTransform(node, "transform", newParams);
          }
          if (node.attributes.gradientTransform != null) {
            convertTransform(node, "gradientTransform", newParams);
          }
          if (node.attributes.patternTransform != null) {
            convertTransform(node, "patternTransform", newParams);
          }
        }
      }
    };
  };
  var convertTransform = (item, attrName, params) => {
    let data = transform2js(item.attributes[attrName]);
    params = definePrecision(data, params);
    if (params.collapseIntoOne && data.length > 1) {
      data = [transformsMultiply(data)];
    }
    if (params.convertToShorts) {
      data = convertToShorts(data, params);
    } else {
      data.forEach((item2) => roundTransform(item2, params));
    }
    if (params.removeUseless) {
      data = removeUseless(data);
    }
    if (data.length) {
      item.attributes[attrName] = js2transform(data, params);
    } else {
      delete item.attributes[attrName];
    }
  };
  var definePrecision = (data, { ...newParams }) => {
    const matrixData = [];
    for (const item of data) {
      if (item.name == "matrix") {
        matrixData.push(...item.data.slice(0, 4));
      }
    }
    let numberOfDigits = newParams.transformPrecision;
    if (matrixData.length) {
      newParams.transformPrecision = Math.min(newParams.transformPrecision, Math.max.apply(Math, matrixData.map(floatDigits)) || newParams.transformPrecision);
      numberOfDigits = Math.max.apply(Math, matrixData.map((n) => n.toString().replace(/\D+/g, "").length));
    }
    if (newParams.degPrecision == null) {
      newParams.degPrecision = Math.max(0, Math.min(newParams.floatPrecision, numberOfDigits - 2));
    }
    return newParams;
  };
  var degRound = (data, params) => {
    if (params.degPrecision != null && params.degPrecision >= 1 && params.floatPrecision < 20) {
      return smartRound(params.degPrecision, data);
    } else {
      return round(data);
    }
  };
  var floatRound = (data, params) => {
    if (params.floatPrecision >= 1 && params.floatPrecision < 20) {
      return smartRound(params.floatPrecision, data);
    } else {
      return round(data);
    }
  };
  var transformRound = (data, params) => {
    if (params.transformPrecision >= 1 && params.floatPrecision < 20) {
      return smartRound(params.transformPrecision, data);
    } else {
      return round(data);
    }
  };
  var floatDigits = (n) => {
    const str = n.toString();
    return str.slice(str.indexOf(".")).length - 1;
  };
  var convertToShorts = (transforms, params) => {
    for (var i = 0;i < transforms.length; i++) {
      let transform = transforms[i];
      if (params.matrixToTransform && transform.name === "matrix") {
        var decomposed = matrixToTransform(transform, params);
        if (js2transform(decomposed, params).length <= js2transform([transform], params).length) {
          transforms.splice(i, 1, ...decomposed);
        }
        transform = transforms[i];
      }
      roundTransform(transform, params);
      if (params.shortTranslate && transform.name === "translate" && transform.data.length === 2 && !transform.data[1]) {
        transform.data.pop();
      }
      if (params.shortScale && transform.name === "scale" && transform.data.length === 2 && transform.data[0] === transform.data[1]) {
        transform.data.pop();
      }
      if (params.shortRotate && transforms[i - 2]?.name === "translate" && transforms[i - 1].name === "rotate" && transforms[i].name === "translate" && transforms[i - 2].data[0] === -transforms[i].data[0] && transforms[i - 2].data[1] === -transforms[i].data[1]) {
        transforms.splice(i - 2, 3, {
          name: "rotate",
          data: [
            transforms[i - 1].data[0],
            transforms[i - 2].data[0],
            transforms[i - 2].data[1]
          ]
        });
        i -= 2;
      }
    }
    return transforms;
  };
  var removeUseless = (transforms) => {
    return transforms.filter((transform) => {
      if (["translate", "rotate", "skewX", "skewY"].indexOf(transform.name) > -1 && (transform.data.length == 1 || transform.name == "rotate") && !transform.data[0] || transform.name == "translate" && !transform.data[0] && !transform.data[1] || transform.name == "scale" && transform.data[0] == 1 && (transform.data.length < 2 || transform.data[1] == 1) || transform.name == "matrix" && transform.data[0] == 1 && transform.data[3] == 1 && !(transform.data[1] || transform.data[2] || transform.data[4] || transform.data[5])) {
        return false;
      }
      return true;
    });
  };
  var js2transform = (transformJS, params) => {
    const transformString = transformJS.map((transform) => {
      roundTransform(transform, params);
      return `${transform.name}(${cleanupOutData(transform.data, params)})`;
    }).join("");
    return transformString;
  };
  var roundTransform = (transform, params) => {
    switch (transform.name) {
      case "translate":
        transform.data = floatRound(transform.data, params);
        break;
      case "rotate":
        transform.data = [
          ...degRound(transform.data.slice(0, 1), params),
          ...floatRound(transform.data.slice(1), params)
        ];
        break;
      case "skewX":
      case "skewY":
        transform.data = degRound(transform.data, params);
        break;
      case "scale":
        transform.data = transformRound(transform.data, params);
        break;
      case "matrix":
        transform.data = [
          ...transformRound(transform.data.slice(0, 4), params),
          ...floatRound(transform.data.slice(4), params)
        ];
        break;
    }
    return transform;
  };
  var round = (data) => {
    return data.map(Math.round);
  };
  var smartRound = (precision, data) => {
    for (var i = data.length, tolerance = +Math.pow(0.1, precision).toFixed(precision);i--; ) {
      if (toFixed(data[i], precision) !== data[i]) {
        var rounded = +data[i].toFixed(precision - 1);
        data[i] = +Math.abs(rounded - data[i]).toFixed(precision + 1) >= tolerance ? +data[i].toFixed(precision) : rounded;
      }
    }
    return data;
  };
});

// ../../../../node_modules/.bun/svgo@3.3.2/node_modules/svgo/plugins/removeEmptyAttrs.js
var require_removeEmptyAttrs = __commonJS((exports) => {
  var { attrsGroups } = require__collections();
  exports.name = "removeEmptyAttrs";
  exports.description = "removes empty attributes";
  exports.fn = () => {
    return {
      element: {
        enter: (node) => {
          for (const [name, value] of Object.entries(node.attributes)) {
            if (value === "" && !attrsGroups.conditionalProcessing.has(name)) {
              delete node.attributes[name];
            }
          }
        }
      }
    };
  };
});

// ../../../../node_modules/.bun/svgo@3.3.2/node_modules/svgo/plugins/removeEmptyContainers.js
var require_removeEmptyContainers = __commonJS((exports) => {
  var { detachNodeFromParent } = require_xast();
  var { elemsGroups } = require__collections();
  exports.name = "removeEmptyContainers";
  exports.description = "removes empty container elements";
  exports.fn = () => {
    return {
      element: {
        exit: (node, parentNode) => {
          if (node.name === "svg" || !elemsGroups.container.has(node.name) || node.children.length !== 0) {
            return;
          }
          if (node.name === "pattern" && Object.keys(node.attributes).length !== 0) {
            return;
          }
          if (node.name === "g" && node.attributes.filter != null) {
            return;
          }
          if (node.name === "mask" && node.attributes.id != null) {
            return;
          }
          if (parentNode.type === "element" && parentNode.name === "switch") {
            return;
          }
          detachNodeFromParent(node, parentNode);
        }
      }
    };
  };
});

// ../../../../node_modules/.bun/svgo@3.3.2/node_modules/svgo/plugins/mergePaths.js
var require_mergePaths = __commonJS((exports) => {
  var { collectStylesheet, computeStyle } = require_style();
  var { path2js, js2path, intersects } = require__path();
  exports.name = "mergePaths";
  exports.description = "merges multiple paths in one if possible";
  exports.fn = (root, params) => {
    const {
      force = false,
      floatPrecision,
      noSpaceAfterFlags = false
    } = params;
    const stylesheet = collectStylesheet(root);
    return {
      element: {
        enter: (node) => {
          if (node.children.length <= 1) {
            return;
          }
          const elementsToRemove = [];
          let prevChild = node.children[0];
          let prevPathData = null;
          const updatePreviousPath = (child, pathData) => {
            js2path(child, pathData, {
              floatPrecision,
              noSpaceAfterFlags
            });
            prevPathData = null;
          };
          for (let i = 1;i < node.children.length; i++) {
            const child = node.children[i];
            if (prevChild.type !== "element" || prevChild.name !== "path" || prevChild.children.length !== 0 || prevChild.attributes.d == null) {
              if (prevPathData && prevChild.type === "element") {
                updatePreviousPath(prevChild, prevPathData);
              }
              prevChild = child;
              continue;
            }
            if (child.type !== "element" || child.name !== "path" || child.children.length !== 0 || child.attributes.d == null) {
              if (prevPathData) {
                updatePreviousPath(prevChild, prevPathData);
              }
              prevChild = child;
              continue;
            }
            const computedStyle = computeStyle(stylesheet, child);
            if (computedStyle["marker-start"] || computedStyle["marker-mid"] || computedStyle["marker-end"]) {
              if (prevPathData) {
                updatePreviousPath(prevChild, prevPathData);
              }
              prevChild = child;
              continue;
            }
            const childAttrs = Object.keys(child.attributes);
            if (childAttrs.length !== Object.keys(prevChild.attributes).length) {
              if (prevPathData) {
                updatePreviousPath(prevChild, prevPathData);
              }
              prevChild = child;
              continue;
            }
            const areAttrsEqual = childAttrs.some((attr) => {
              return attr !== "d" && prevChild.type === "element" && prevChild.attributes[attr] !== child.attributes[attr];
            });
            if (areAttrsEqual) {
              if (prevPathData) {
                updatePreviousPath(prevChild, prevPathData);
              }
              prevChild = child;
              continue;
            }
            const hasPrevPath = prevPathData != null;
            const currentPathData = path2js(child);
            prevPathData = prevPathData ?? path2js(prevChild);
            if (force || !intersects(prevPathData, currentPathData)) {
              prevPathData.push(...currentPathData);
              elementsToRemove.push(child);
              continue;
            }
            if (hasPrevPath) {
              updatePreviousPath(prevChild, prevPathData);
            }
            prevChild = child;
            prevPathData = null;
          }
          if (prevPathData && prevChild.type === "element") {
            updatePreviousPath(prevChild, prevPathData);
          }
          node.children = node.children.filter((child) => !elementsToRemove.includes(child));
        }
      }
    };
  };
});

// ../../../../node_modules/.bun/svgo@3.3.2/node_modules/svgo/plugins/removeUnusedNS.js
var require_removeUnusedNS = __commonJS((exports) => {
  exports.name = "removeUnusedNS";
  exports.description = "removes unused namespaces declaration";
  exports.fn = () => {
    const unusedNamespaces = new Set;
    return {
      element: {
        enter: (node, parentNode) => {
          if (node.name === "svg" && parentNode.type === "root") {
            for (const name of Object.keys(node.attributes)) {
              if (name.startsWith("xmlns:")) {
                const local = name.slice("xmlns:".length);
                unusedNamespaces.add(local);
              }
            }
          }
          if (unusedNamespaces.size !== 0) {
            if (node.name.includes(":")) {
              const [ns] = node.name.split(":");
              if (unusedNamespaces.has(ns)) {
                unusedNamespaces.delete(ns);
              }
            }
            for (const name of Object.keys(node.attributes)) {
              if (name.includes(":")) {
                const [ns] = name.split(":");
                unusedNamespaces.delete(ns);
              }
            }
          }
        },
        exit: (node, parentNode) => {
          if (node.name === "svg" && parentNode.type === "root") {
            for (const name of unusedNamespaces) {
              delete node.attributes[`xmlns:${name}`];
            }
          }
        }
      }
    };
  };
});

// ../../../../node_modules/.bun/svgo@3.3.2/node_modules/svgo/plugins/sortAttrs.js
var require_sortAttrs = __commonJS((exports) => {
  exports.name = "sortAttrs";
  exports.description = "Sort element attributes for better compression";
  exports.fn = (_root, params) => {
    const {
      order = [
        "id",
        "width",
        "height",
        "x",
        "x1",
        "x2",
        "y",
        "y1",
        "y2",
        "cx",
        "cy",
        "r",
        "fill",
        "stroke",
        "marker",
        "d",
        "points"
      ],
      xmlnsOrder = "front"
    } = params;
    const getNsPriority = (name) => {
      if (xmlnsOrder === "front") {
        if (name === "xmlns") {
          return 3;
        }
        if (name.startsWith("xmlns:")) {
          return 2;
        }
      }
      if (name.includes(":")) {
        return 1;
      }
      return 0;
    };
    const compareAttrs = ([aName], [bName]) => {
      const aPriority = getNsPriority(aName);
      const bPriority = getNsPriority(bName);
      const priorityNs = bPriority - aPriority;
      if (priorityNs !== 0) {
        return priorityNs;
      }
      const [aPart] = aName.split("-");
      const [bPart] = bName.split("-");
      if (aPart !== bPart) {
        const aInOrderFlag = order.includes(aPart) ? 1 : 0;
        const bInOrderFlag = order.includes(bPart) ? 1 : 0;
        if (aInOrderFlag === 1 && bInOrderFlag === 1) {
          return order.indexOf(aPart) - order.indexOf(bPart);
        }
        const priorityOrder = bInOrderFlag - aInOrderFlag;
        if (priorityOrder !== 0) {
          return priorityOrder;
        }
      }
      return aName < bName ? -1 : 1;
    };
    return {
      element: {
        enter: (node) => {
          const attrs = Object.entries(node.attributes);
          attrs.sort(compareAttrs);
          const sortedAttributes = {};
          for (const [name, value] of attrs) {
            sortedAttributes[name] = value;
          }
          node.attributes = sortedAttributes;
        }
      }
    };
  };
});

// ../../../../node_modules/.bun/svgo@3.3.2/node_modules/svgo/plugins/sortDefsChildren.js
var require_sortDefsChildren = __commonJS((exports) => {
  exports.name = "sortDefsChildren";
  exports.description = "Sorts children of <defs> to improve compression";
  exports.fn = () => {
    return {
      element: {
        enter: (node) => {
          if (node.name === "defs") {
            const frequencies = new Map;
            for (const child of node.children) {
              if (child.type === "element") {
                const frequency = frequencies.get(child.name);
                if (frequency == null) {
                  frequencies.set(child.name, 1);
                } else {
                  frequencies.set(child.name, frequency + 1);
                }
              }
            }
            node.children.sort((a, b) => {
              if (a.type !== "element" || b.type !== "element") {
                return 0;
              }
              const aFrequency = frequencies.get(a.name);
              const bFrequency = frequencies.get(b.name);
              if (aFrequency != null && bFrequency != null) {
                const frequencyComparison = bFrequency - aFrequency;
                if (frequencyComparison !== 0) {
                  return frequencyComparison;
                }
              }
              const lengthComparison = b.name.length - a.name.length;
              if (lengthComparison !== 0) {
                return lengthComparison;
              }
              if (a.name !== b.name) {
                return a.name > b.name ? -1 : 1;
              }
              return 0;
            });
          }
        }
      }
    };
  };
});

// ../../../../node_modules/.bun/svgo@3.3.2/node_modules/svgo/plugins/removeTitle.js
var require_removeTitle = __commonJS((exports) => {
  var { detachNodeFromParent } = require_xast();
  exports.name = "removeTitle";
  exports.description = "removes <title>";
  exports.fn = () => {
    return {
      element: {
        enter: (node, parentNode) => {
          if (node.name === "title") {
            detachNodeFromParent(node, parentNode);
          }
        }
      }
    };
  };
});

// ../../../../node_modules/.bun/svgo@3.3.2/node_modules/svgo/plugins/removeDesc.js
var require_removeDesc = __commonJS((exports) => {
  var { detachNodeFromParent } = require_xast();
  exports.name = "removeDesc";
  exports.description = "removes <desc>";
  var standardDescs = /^(Created with|Created using)/;
  exports.fn = (root, params) => {
    const { removeAny = false } = params;
    return {
      element: {
        enter: (node, parentNode) => {
          if (node.name === "desc") {
            if (removeAny || node.children.length === 0 || node.children[0].type === "text" && standardDescs.test(node.children[0].value)) {
              detachNodeFromParent(node, parentNode);
            }
          }
        }
      }
    };
  };
});

// ../../../../node_modules/.bun/svgo@3.3.2/node_modules/svgo/plugins/preset-default.js
var require_preset_default = __commonJS((exports, module) => {
  var { createPreset } = require_plugins();
  var removeDoctype = require_removeDoctype();
  var removeXMLProcInst = require_removeXMLProcInst();
  var removeComments = require_removeComments();
  var removeMetadata = require_removeMetadata();
  var removeEditorsNSData = require_removeEditorsNSData();
  var cleanupAttrs = require_cleanupAttrs();
  var mergeStyles = require_mergeStyles();
  var inlineStyles = require_inlineStyles();
  var minifyStyles = require_minifyStyles();
  var cleanupIds = require_cleanupIds();
  var removeUselessDefs = require_removeUselessDefs();
  var cleanupNumericValues = require_cleanupNumericValues();
  var convertColors = require_convertColors();
  var removeUnknownsAndDefaults = require_removeUnknownsAndDefaults();
  var removeNonInheritableGroupAttrs = require_removeNonInheritableGroupAttrs();
  var removeUselessStrokeAndFill = require_removeUselessStrokeAndFill();
  var removeViewBox = require_removeViewBox();
  var cleanupEnableBackground = require_cleanupEnableBackground();
  var removeHiddenElems = require_removeHiddenElems();
  var removeEmptyText = require_removeEmptyText();
  var convertShapeToPath = require_convertShapeToPath();
  var convertEllipseToCircle = require_convertEllipseToCircle();
  var moveElemsAttrsToGroup = require_moveElemsAttrsToGroup();
  var moveGroupAttrsToElems = require_moveGroupAttrsToElems();
  var collapseGroups = require_collapseGroups();
  var convertPathData = require_convertPathData();
  var convertTransform = require_convertTransform();
  var removeEmptyAttrs = require_removeEmptyAttrs();
  var removeEmptyContainers = require_removeEmptyContainers();
  var mergePaths = require_mergePaths();
  var removeUnusedNS = require_removeUnusedNS();
  var sortAttrs = require_sortAttrs();
  var sortDefsChildren = require_sortDefsChildren();
  var removeTitle = require_removeTitle();
  var removeDesc = require_removeDesc();
  var presetDefault = createPreset({
    name: "preset-default",
    plugins: [
      removeDoctype,
      removeXMLProcInst,
      removeComments,
      removeMetadata,
      removeEditorsNSData,
      cleanupAttrs,
      mergeStyles,
      inlineStyles,
      minifyStyles,
      cleanupIds,
      removeUselessDefs,
      cleanupNumericValues,
      convertColors,
      removeUnknownsAndDefaults,
      removeNonInheritableGroupAttrs,
      removeUselessStrokeAndFill,
      removeViewBox,
      cleanupEnableBackground,
      removeHiddenElems,
      removeEmptyText,
      convertShapeToPath,
      convertEllipseToCircle,
      moveElemsAttrsToGroup,
      moveGroupAttrsToElems,
      collapseGroups,
      convertPathData,
      convertTransform,
      removeEmptyAttrs,
      removeEmptyContainers,
      mergePaths,
      removeUnusedNS,
      sortAttrs,
      sortDefsChildren,
      removeTitle,
      removeDesc
    ]
  });
  module.exports = presetDefault;
});

// ../../../../node_modules/.bun/svgo@3.3.2/node_modules/svgo/plugins/addAttributesToSVGElement.js
var require_addAttributesToSVGElement = __commonJS((exports) => {
  exports.name = "addAttributesToSVGElement";
  exports.description = "adds attributes to an outer <svg> element";
  var ENOCLS = `Error in plugin "addAttributesToSVGElement": absent parameters.
It should have a list of "attributes" or one "attribute".
Config example:

plugins: [
  {
    name: 'addAttributesToSVGElement',
    params: {
      attribute: "mySvg"
    }
  }
]

plugins: [
  {
    name: 'addAttributesToSVGElement',
    params: {
      attributes: ["mySvg", "size-big"]
    }
  }
]

plugins: [
  {
    name: 'addAttributesToSVGElement',
    params: {
      attributes: [
        {
          focusable: false
        },
        {
          'data-image': icon
        }
      ]
    }
  }
]
`;
  exports.fn = (root, params) => {
    if (!Array.isArray(params.attributes) && !params.attribute) {
      console.error(ENOCLS);
      return null;
    }
    const attributes = params.attributes || [params.attribute];
    return {
      element: {
        enter: (node, parentNode) => {
          if (node.name === "svg" && parentNode.type === "root") {
            for (const attribute of attributes) {
              if (typeof attribute === "string") {
                if (node.attributes[attribute] == null) {
                  node.attributes[attribute] = undefined;
                }
              }
              if (typeof attribute === "object") {
                for (const key of Object.keys(attribute)) {
                  if (node.attributes[key] == null) {
                    node.attributes[key] = attribute[key];
                  }
                }
              }
            }
          }
        }
      }
    };
  };
});

// ../../../../node_modules/.bun/svgo@3.3.2/node_modules/svgo/plugins/addClassesToSVGElement.js
var require_addClassesToSVGElement = __commonJS((exports) => {
  exports.name = "addClassesToSVGElement";
  exports.description = "adds classnames to an outer <svg> element";
  var ENOCLS = `Error in plugin "addClassesToSVGElement": absent parameters.
It should have a list of classes in "classNames" or one "className".
Config example:

plugins: [
  {
    name: "addClassesToSVGElement",
    params: {
      className: "mySvg"
    }
  }
]

plugins: [
  {
    name: "addClassesToSVGElement",
    params: {
      classNames: ["mySvg", "size-big"]
    }
  }
]
`;
  exports.fn = (root, params) => {
    if (!(Array.isArray(params.classNames) && params.classNames.some(String)) && !params.className) {
      console.error(ENOCLS);
      return null;
    }
    const classNames = params.classNames || [params.className];
    return {
      element: {
        enter: (node, parentNode) => {
          if (node.name === "svg" && parentNode.type === "root") {
            const classList = new Set(node.attributes.class == null ? null : node.attributes.class.split(" "));
            for (const className of classNames) {
              if (className != null) {
                classList.add(className);
              }
            }
            node.attributes.class = Array.from(classList).join(" ");
          }
        }
      }
    };
  };
});

// ../../../../node_modules/.bun/svgo@3.3.2/node_modules/svgo/plugins/cleanupListOfValues.js
var require_cleanupListOfValues = __commonJS((exports) => {
  var { removeLeadingZero } = require_tools();
  exports.name = "cleanupListOfValues";
  exports.description = "rounds list of values to the fixed precision";
  var regNumericValues = /^([-+]?\d*\.?\d+([eE][-+]?\d+)?)(px|pt|pc|mm|cm|m|in|ft|em|ex|%)?$/;
  var regSeparator = /\s+,?\s*|,\s*/;
  var absoluteLengths = {
    cm: 96 / 2.54,
    mm: 96 / 25.4,
    in: 96,
    pt: 4 / 3,
    pc: 16,
    px: 1
  };
  exports.fn = (_root, params) => {
    const {
      floatPrecision = 3,
      leadingZero = true,
      defaultPx = true,
      convertToPx = true
    } = params;
    const roundValues = (lists) => {
      const roundedList = [];
      for (const elem of lists.split(regSeparator)) {
        const match = elem.match(regNumericValues);
        const matchNew = elem.match(/new/);
        if (match) {
          let num = Number(Number(match[1]).toFixed(floatPrecision));
          let matchedUnit = match[3] || "";
          let units = matchedUnit;
          if (convertToPx && units && units in absoluteLengths) {
            const pxNum = Number((absoluteLengths[units] * Number(match[1])).toFixed(floatPrecision));
            if (pxNum.toString().length < match[0].length) {
              num = pxNum;
              units = "px";
            }
          }
          let str;
          if (leadingZero) {
            str = removeLeadingZero(num);
          } else {
            str = num.toString();
          }
          if (defaultPx && units === "px") {
            units = "";
          }
          roundedList.push(str + units);
        } else if (matchNew) {
          roundedList.push("new");
        } else if (elem) {
          roundedList.push(elem);
        }
      }
      return roundedList.join(" ");
    };
    return {
      element: {
        enter: (node) => {
          if (node.attributes.points != null) {
            node.attributes.points = roundValues(node.attributes.points);
          }
          if (node.attributes["enable-background"] != null) {
            node.attributes["enable-background"] = roundValues(node.attributes["enable-background"]);
          }
          if (node.attributes.viewBox != null) {
            node.attributes.viewBox = roundValues(node.attributes.viewBox);
          }
          if (node.attributes["stroke-dasharray"] != null) {
            node.attributes["stroke-dasharray"] = roundValues(node.attributes["stroke-dasharray"]);
          }
          if (node.attributes.dx != null) {
            node.attributes.dx = roundValues(node.attributes.dx);
          }
          if (node.attributes.dy != null) {
            node.attributes.dy = roundValues(node.attributes.dy);
          }
          if (node.attributes.x != null) {
            node.attributes.x = roundValues(node.attributes.x);
          }
          if (node.attributes.y != null) {
            node.attributes.y = roundValues(node.attributes.y);
          }
        }
      }
    };
  };
});

// ../../../../node_modules/.bun/svgo@3.3.2/node_modules/svgo/plugins/convertOneStopGradients.js
var require_convertOneStopGradients = __commonJS((exports) => {
  var { attrsGroupsDefaults, colorsProps } = require__collections();
  var {
    detachNodeFromParent,
    querySelectorAll,
    querySelector
  } = require_xast();
  var { computeStyle, collectStylesheet } = require_style();
  exports.name = "convertOneStopGradients";
  exports.description = "converts one-stop (single color) gradients to a plain color";
  exports.fn = (root) => {
    const stylesheet = collectStylesheet(root);
    const effectedDefs = new Set;
    const allDefs = new Map;
    const gradientsToDetach = new Map;
    let xlinkHrefCount = 0;
    return {
      element: {
        enter: (node, parentNode) => {
          if (node.attributes["xlink:href"] != null) {
            xlinkHrefCount++;
          }
          if (node.name === "defs") {
            allDefs.set(node, parentNode);
            return;
          }
          if (node.name !== "linearGradient" && node.name !== "radialGradient") {
            return;
          }
          const stops = node.children.filter((child) => {
            return child.type === "element" && child.name === "stop";
          });
          const href = node.attributes["xlink:href"] || node.attributes["href"];
          let effectiveNode = stops.length === 0 && href != null && href.startsWith("#") ? querySelector(root, href) : node;
          if (effectiveNode == null || effectiveNode.type !== "element") {
            gradientsToDetach.set(node, parentNode);
            return;
          }
          const effectiveStops = effectiveNode.children.filter((child) => {
            return child.type === "element" && child.name === "stop";
          });
          if (effectiveStops.length !== 1 || effectiveStops[0].type !== "element") {
            return;
          }
          if (parentNode.type === "element" && parentNode.name === "defs") {
            effectedDefs.add(parentNode);
          }
          gradientsToDetach.set(node, parentNode);
          let color;
          const style = computeStyle(stylesheet, effectiveStops[0])["stop-color"];
          if (style != null && style.type === "static") {
            color = style.value;
          }
          const selectorVal = `url(#${node.attributes.id})`;
          const selector = [...colorsProps].map((attr) => `[${attr}="${selectorVal}"]`).join(",");
          const elements = querySelectorAll(root, selector);
          for (const element of elements) {
            if (element.type !== "element") {
              continue;
            }
            for (const attr of colorsProps) {
              if (element.attributes[attr] !== selectorVal) {
                continue;
              }
              if (color != null) {
                element.attributes[attr] = color;
              } else {
                delete element.attributes[attr];
              }
            }
          }
          const styledElements = querySelectorAll(root, `[style*=${selectorVal}]`);
          for (const element of styledElements) {
            if (element.type !== "element") {
              continue;
            }
            element.attributes.style = element.attributes.style.replace(selectorVal, color || attrsGroupsDefaults.presentation["stop-color"]);
          }
        },
        exit: (node) => {
          if (node.name === "svg") {
            for (const [gradient, parent] of gradientsToDetach.entries()) {
              if (gradient.attributes["xlink:href"] != null) {
                xlinkHrefCount--;
              }
              detachNodeFromParent(gradient, parent);
            }
            if (xlinkHrefCount === 0) {
              delete node.attributes["xmlns:xlink"];
            }
            for (const [defs, parent] of allDefs.entries()) {
              if (effectedDefs.has(defs) && defs.children.length === 0) {
                detachNodeFromParent(defs, parent);
              }
            }
          }
        }
      }
    };
  };
});

// ../../../../node_modules/.bun/svgo@3.3.2/node_modules/svgo/plugins/convertStyleToAttrs.js
var require_convertStyleToAttrs = __commonJS((exports) => {
  var { attrsGroups } = require__collections();
  exports.name = "convertStyleToAttrs";
  exports.description = "converts style to attributes";
  var g = (...args) => {
    return "(?:" + args.join("|") + ")";
  };
  var stylingProps = attrsGroups.presentation;
  var rEscape = "\\\\(?:[0-9a-f]{1,6}\\s?|\\r\\n|.)";
  var rAttr = "\\s*(" + g("[^:;\\\\]", rEscape) + "*?)\\s*";
  var rSingleQuotes = "'(?:[^'\\n\\r\\\\]|" + rEscape + ")*?(?:'|$)";
  var rQuotes = '"(?:[^"\\n\\r\\\\]|' + rEscape + ')*?(?:"|$)';
  var rQuotedString = new RegExp("^" + g(rSingleQuotes, rQuotes) + "$");
  var rParenthesis = "\\(" + g(`[^'"()\\\\]+`, rEscape, rSingleQuotes, rQuotes) + "*?" + "\\)";
  var rValue = "\\s*(" + g(`[^!'"();\\\\]+?`, rEscape, rSingleQuotes, rQuotes, rParenthesis, "[^;]*?") + "*?" + ")";
  var rDeclEnd = "\\s*(?:;\\s*|$)";
  var rImportant = "(\\s*!important(?![-(\\w]))?";
  var regDeclarationBlock = new RegExp(rAttr + ":" + rValue + rImportant + rDeclEnd, "ig");
  var regStripComments = new RegExp(g(rEscape, rSingleQuotes, rQuotes, "/\\*[^]*?\\*/"), "ig");
  exports.fn = (_root, params) => {
    const { keepImportant = false } = params;
    return {
      element: {
        enter: (node) => {
          if (node.attributes.style != null) {
            let styles = [];
            const newAttributes = {};
            const styleValue = node.attributes.style.replace(regStripComments, (match) => {
              return match[0] == "/" ? "" : match[0] == "\\" && /[-g-z]/i.test(match[1]) ? match[1] : match;
            });
            regDeclarationBlock.lastIndex = 0;
            for (var rule;rule = regDeclarationBlock.exec(styleValue); ) {
              if (!keepImportant || !rule[3]) {
                styles.push([rule[1], rule[2]]);
              }
            }
            if (styles.length) {
              styles = styles.filter(function(style) {
                if (style[0]) {
                  var prop = style[0].toLowerCase(), val = style[1];
                  if (rQuotedString.test(val)) {
                    val = val.slice(1, -1);
                  }
                  if (stylingProps.has(prop)) {
                    newAttributes[prop] = val;
                    return false;
                  }
                }
                return true;
              });
              Object.assign(node.attributes, newAttributes);
              if (styles.length) {
                node.attributes.style = styles.map((declaration) => declaration.join(":")).join(";");
              } else {
                delete node.attributes.style;
              }
            }
          }
        }
      }
    };
  };
});

// ../../../../node_modules/.bun/svgo@3.3.2/node_modules/svgo/plugins/prefixIds.js
var require_prefixIds = __commonJS((exports) => {
  var csstree = require_cjs();
  var { referencesProps } = require__collections();
  exports.name = "prefixIds";
  exports.description = "prefix IDs";
  var getBasename = (path) => {
    const matched = /[/\\]?([^/\\]+)$/.exec(path);
    if (matched) {
      return matched[1];
    }
    return "";
  };
  var escapeIdentifierName = (str) => {
    return str.replace(/[. ]/g, "_");
  };
  var unquote = (string) => {
    if (string.startsWith('"') && string.endsWith('"') || string.startsWith("'") && string.endsWith("'")) {
      return string.slice(1, -1);
    }
    return string;
  };
  var prefixId = (prefixGenerator, body) => {
    const prefix = prefixGenerator(body);
    if (body.startsWith(prefix)) {
      return body;
    }
    return prefix + body;
  };
  var prefixReference = (prefixGenerator, reference) => {
    if (reference.startsWith("#")) {
      return "#" + prefixId(prefixGenerator, reference.slice(1));
    }
    return null;
  };
  var generatePrefix = (body, node, info, prefixGenerator, delim, history) => {
    if (typeof prefixGenerator === "function") {
      let prefix = history.get(body);
      if (prefix != null) {
        return prefix;
      }
      prefix = prefixGenerator(node, info) + delim;
      history.set(body, prefix);
      return prefix;
    }
    if (typeof prefixGenerator === "string") {
      return prefixGenerator + delim;
    }
    if (prefixGenerator === false) {
      return "";
    }
    if (info.path != null && info.path.length > 0) {
      return escapeIdentifierName(getBasename(info.path)) + delim;
    }
    return "prefix" + delim;
  };
  exports.fn = (_root, params, info) => {
    const {
      delim = "__",
      prefix,
      prefixIds = true,
      prefixClassNames = true
    } = params;
    const prefixMap = new Map;
    return {
      element: {
        enter: (node) => {
          const prefixGenerator = (id) => generatePrefix(id, node, info, prefix, delim, prefixMap);
          if (node.name === "style") {
            if (node.children.length === 0) {
              return;
            }
            for (const child of node.children) {
              if (child.type !== "text" && child.type !== "cdata") {
                continue;
              }
              const cssText = child.value;
              let cssAst = null;
              try {
                cssAst = csstree.parse(cssText, {
                  parseValue: true,
                  parseCustomProperty: false
                });
              } catch {
                return;
              }
              csstree.walk(cssAst, (node2) => {
                if (prefixIds && node2.type === "IdSelector" || prefixClassNames && node2.type === "ClassSelector") {
                  node2.name = prefixId(prefixGenerator, node2.name);
                  return;
                }
                if (node2.type === "Url" && node2.value.length > 0) {
                  const prefixed = prefixReference(prefixGenerator, unquote(node2.value));
                  if (prefixed != null) {
                    node2.value = prefixed;
                  }
                }
              });
              child.value = csstree.generate(cssAst);
              return;
            }
          }
          if (prefixIds && node.attributes.id != null && node.attributes.id.length !== 0) {
            node.attributes.id = prefixId(prefixGenerator, node.attributes.id);
          }
          if (prefixClassNames && node.attributes.class != null && node.attributes.class.length !== 0) {
            node.attributes.class = node.attributes.class.split(/\s+/).map((name) => prefixId(prefixGenerator, name)).join(" ");
          }
          for (const name of ["href", "xlink:href"]) {
            if (node.attributes[name] != null && node.attributes[name].length !== 0) {
              const prefixed = prefixReference(prefixGenerator, node.attributes[name]);
              if (prefixed != null) {
                node.attributes[name] = prefixed;
              }
            }
          }
          for (const name of referencesProps) {
            if (node.attributes[name] != null && node.attributes[name].length !== 0) {
              node.attributes[name] = node.attributes[name].replace(/\burl\((["'])?(#.+?)\1\)/gi, (match, _, url) => {
                const prefixed = prefixReference(prefixGenerator, url);
                if (prefixed == null) {
                  return match;
                }
                return `url(${prefixed})`;
              });
            }
          }
          for (const name of ["begin", "end"]) {
            if (node.attributes[name] != null && node.attributes[name].length !== 0) {
              const parts = node.attributes[name].split(/\s*;\s+/).map((val) => {
                if (val.endsWith(".end") || val.endsWith(".start")) {
                  const [id, postfix] = val.split(".");
                  return `${prefixId(prefixGenerator, id)}.${postfix}`;
                }
                return val;
              });
              node.attributes[name] = parts.join("; ");
            }
          }
        }
      }
    };
  };
});

// ../../../../node_modules/.bun/svgo@3.3.2/node_modules/svgo/plugins/removeAttributesBySelector.js
var require_removeAttributesBySelector = __commonJS((exports) => {
  var { querySelectorAll } = require_xast();
  exports.name = "removeAttributesBySelector";
  exports.description = "removes attributes of elements that match a css selector";
  exports.fn = (root, params) => {
    const selectors = Array.isArray(params.selectors) ? params.selectors : [params];
    for (const { selector, attributes } of selectors) {
      const nodes = querySelectorAll(root, selector);
      for (const node of nodes) {
        if (node.type === "element") {
          if (Array.isArray(attributes)) {
            for (const name of attributes) {
              delete node.attributes[name];
            }
          } else {
            delete node.attributes[attributes];
          }
        }
      }
    }
    return {};
  };
});

// ../../../../node_modules/.bun/svgo@3.3.2/node_modules/svgo/plugins/removeAttrs.js
var require_removeAttrs = __commonJS((exports) => {
  exports.name = "removeAttrs";
  exports.description = "removes specified attributes";
  var DEFAULT_SEPARATOR = ":";
  var ENOATTRS = `Warning: The plugin "removeAttrs" requires the "attrs" parameter.
It should have a pattern to remove, otherwise the plugin is a noop.
Config example:

plugins: [
  {
    name: "removeAttrs",
    params: {
      attrs: "(fill|stroke)"
    }
  }
]
`;
  exports.fn = (root, params) => {
    if (typeof params.attrs == "undefined") {
      console.warn(ENOATTRS);
      return null;
    }
    const elemSeparator = typeof params.elemSeparator == "string" ? params.elemSeparator : DEFAULT_SEPARATOR;
    const preserveCurrentColor = typeof params.preserveCurrentColor == "boolean" ? params.preserveCurrentColor : false;
    const attrs = Array.isArray(params.attrs) ? params.attrs : [params.attrs];
    return {
      element: {
        enter: (node) => {
          for (let pattern of attrs) {
            if (!pattern.includes(elemSeparator)) {
              pattern = [".*", pattern, ".*"].join(elemSeparator);
            } else if (pattern.split(elemSeparator).length < 3) {
              pattern = [pattern, ".*"].join(elemSeparator);
            }
            const list = pattern.split(elemSeparator).map((value) => {
              if (value === "*") {
                value = ".*";
              }
              return new RegExp(["^", value, "$"].join(""), "i");
            });
            if (list[0].test(node.name)) {
              for (const [name, value] of Object.entries(node.attributes)) {
                const isFillCurrentColor = preserveCurrentColor && name == "fill" && value == "currentColor";
                const isStrokeCurrentColor = preserveCurrentColor && name == "stroke" && value == "currentColor";
                if (!isFillCurrentColor && !isStrokeCurrentColor && list[1].test(name) && list[2].test(value)) {
                  delete node.attributes[name];
                }
              }
            }
          }
        }
      }
    };
  };
});

// ../../../../node_modules/.bun/svgo@3.3.2/node_modules/svgo/plugins/removeDimensions.js
var require_removeDimensions = __commonJS((exports) => {
  exports.name = "removeDimensions";
  exports.description = "removes width and height in presence of viewBox (opposite to removeViewBox, disable it first)";
  exports.fn = () => {
    return {
      element: {
        enter: (node) => {
          if (node.name === "svg") {
            if (node.attributes.viewBox != null) {
              delete node.attributes.width;
              delete node.attributes.height;
            } else if (node.attributes.width != null && node.attributes.height != null && Number.isNaN(Number(node.attributes.width)) === false && Number.isNaN(Number(node.attributes.height)) === false) {
              const width = Number(node.attributes.width);
              const height = Number(node.attributes.height);
              node.attributes.viewBox = `0 0 ${width} ${height}`;
              delete node.attributes.width;
              delete node.attributes.height;
            }
          }
        }
      }
    };
  };
});

// ../../../../node_modules/.bun/svgo@3.3.2/node_modules/svgo/plugins/removeElementsByAttr.js
var require_removeElementsByAttr = __commonJS((exports) => {
  var { detachNodeFromParent } = require_xast();
  exports.name = "removeElementsByAttr";
  exports.description = "removes arbitrary elements by ID or className (disabled by default)";
  exports.fn = (root, params) => {
    const ids = params.id == null ? [] : Array.isArray(params.id) ? params.id : [params.id];
    const classes = params.class == null ? [] : Array.isArray(params.class) ? params.class : [params.class];
    return {
      element: {
        enter: (node, parentNode) => {
          if (node.attributes.id != null && ids.length !== 0) {
            if (ids.includes(node.attributes.id)) {
              detachNodeFromParent(node, parentNode);
            }
          }
          if (node.attributes.class && classes.length !== 0) {
            const classList = node.attributes.class.split(" ");
            for (const item of classes) {
              if (classList.includes(item)) {
                detachNodeFromParent(node, parentNode);
                break;
              }
            }
          }
        }
      }
    };
  };
});

// ../../../../node_modules/.bun/svgo@3.3.2/node_modules/svgo/plugins/removeOffCanvasPaths.js
var require_removeOffCanvasPaths = __commonJS((exports) => {
  var { visitSkip, detachNodeFromParent } = require_xast();
  var { parsePathData } = require_path();
  var { intersects } = require__path();
  exports.name = "removeOffCanvasPaths";
  exports.description = "removes elements that are drawn outside of the viewbox (disabled by default)";
  exports.fn = () => {
    let viewBoxData = null;
    return {
      element: {
        enter: (node, parentNode) => {
          if (node.name === "svg" && parentNode.type === "root") {
            let viewBox = "";
            if (node.attributes.viewBox != null) {
              viewBox = node.attributes.viewBox;
            } else if (node.attributes.height != null && node.attributes.width != null) {
              viewBox = `0 0 ${node.attributes.width} ${node.attributes.height}`;
            }
            viewBox = viewBox.replace(/[,+]|px/g, " ").replace(/\s+/g, " ").replace(/^\s*|\s*$/g, "");
            const m = /^(-?\d*\.?\d+) (-?\d*\.?\d+) (\d*\.?\d+) (\d*\.?\d+)$/.exec(viewBox);
            if (m == null) {
              return;
            }
            const left = Number.parseFloat(m[1]);
            const top = Number.parseFloat(m[2]);
            const width = Number.parseFloat(m[3]);
            const height = Number.parseFloat(m[4]);
            viewBoxData = {
              left,
              top,
              right: left + width,
              bottom: top + height,
              width,
              height
            };
          }
          if (node.attributes.transform != null) {
            return visitSkip;
          }
          if (node.name === "path" && node.attributes.d != null && viewBoxData != null) {
            const pathData = parsePathData(node.attributes.d);
            let visible = false;
            for (const pathDataItem of pathData) {
              if (pathDataItem.command === "M") {
                const [x, y] = pathDataItem.args;
                if (x >= viewBoxData.left && x <= viewBoxData.right && y >= viewBoxData.top && y <= viewBoxData.bottom) {
                  visible = true;
                }
              }
            }
            if (visible) {
              return;
            }
            if (pathData.length === 2) {
              pathData.push({ command: "z", args: [] });
            }
            const { left, top, width, height } = viewBoxData;
            const viewBoxPathData = [
              { command: "M", args: [left, top] },
              { command: "h", args: [width] },
              { command: "v", args: [height] },
              { command: "H", args: [left] },
              { command: "z", args: [] }
            ];
            if (intersects(viewBoxPathData, pathData) === false) {
              detachNodeFromParent(node, parentNode);
            }
          }
        }
      }
    };
  };
});

// ../../../../node_modules/.bun/svgo@3.3.2/node_modules/svgo/plugins/removeRasterImages.js
var require_removeRasterImages = __commonJS((exports) => {
  var { detachNodeFromParent } = require_xast();
  exports.name = "removeRasterImages";
  exports.description = "removes raster images (disabled by default)";
  exports.fn = () => {
    return {
      element: {
        enter: (node, parentNode) => {
          if (node.name === "image" && node.attributes["xlink:href"] != null && /(\.|image\/)(jpe?g|png|gif)/.test(node.attributes["xlink:href"])) {
            detachNodeFromParent(node, parentNode);
          }
        }
      }
    };
  };
});

// ../../../../node_modules/.bun/svgo@3.3.2/node_modules/svgo/plugins/removeScriptElement.js
var require_removeScriptElement = __commonJS((exports) => {
  var { detachNodeFromParent } = require_xast();
  var { attrsGroups } = require__collections();
  exports.name = "removeScriptElement";
  exports.description = "removes scripts (disabled by default)";
  var eventAttrs = [
    ...attrsGroups.animationEvent,
    ...attrsGroups.documentEvent,
    ...attrsGroups.documentElementEvent,
    ...attrsGroups.globalEvent,
    ...attrsGroups.graphicalEvent
  ];
  exports.fn = () => {
    return {
      element: {
        enter: (node, parentNode) => {
          if (node.name === "script") {
            detachNodeFromParent(node, parentNode);
            return;
          }
          for (const attr of eventAttrs) {
            if (node.attributes[attr] != null) {
              delete node.attributes[attr];
            }
          }
        },
        exit: (node, parentNode) => {
          if (node.name !== "a") {
            return;
          }
          for (const attr of Object.keys(node.attributes)) {
            if (attr === "href" || attr.endsWith(":href")) {
              if (node.attributes[attr] == null || !node.attributes[attr].trimStart().startsWith("javascript:")) {
                continue;
              }
              const index = parentNode.children.indexOf(node);
              parentNode.children.splice(index, 1, ...node.children);
              for (const child of node.children) {
                Object.defineProperty(child, "parentNode", {
                  writable: true,
                  value: parentNode
                });
              }
            }
          }
        }
      }
    };
  };
});

// ../../../../node_modules/.bun/svgo@3.3.2/node_modules/svgo/plugins/removeStyleElement.js
var require_removeStyleElement = __commonJS((exports) => {
  var { detachNodeFromParent } = require_xast();
  exports.name = "removeStyleElement";
  exports.description = "removes <style> element (disabled by default)";
  exports.fn = () => {
    return {
      element: {
        enter: (node, parentNode) => {
          if (node.name === "style") {
            detachNodeFromParent(node, parentNode);
          }
        }
      }
    };
  };
});

// ../../../../node_modules/.bun/svgo@3.3.2/node_modules/svgo/plugins/removeXlink.js
var require_removeXlink = __commonJS((exports) => {
  var { elems } = require__collections();
  exports.name = "removeXlink";
  exports.description = "remove xlink namespace and replaces attributes with the SVG 2 equivalent where applicable";
  var XLINK_NAMESPACE = "http://www.w3.org/1999/xlink";
  var SHOW_TO_TARGET = {
    new: "_blank",
    replace: "_self"
  };
  var LEGACY_ELEMENTS = new Set([
    "cursor",
    "filter",
    "font-face-uri",
    "glyphRef",
    "tref"
  ]);
  var findPrefixedAttrs = (node, prefixes, attr) => {
    return prefixes.map((prefix) => `${prefix}:${attr}`).filter((attr2) => node.attributes[attr2] != null);
  };
  exports.fn = (_, params) => {
    const { includeLegacy } = params;
    const xlinkPrefixes = [];
    const overriddenPrefixes = [];
    const usedInLegacyElement = [];
    return {
      element: {
        enter: (node) => {
          for (const [key, value] of Object.entries(node.attributes)) {
            if (key.startsWith("xmlns:")) {
              const prefix = key.split(":", 2)[1];
              if (value === XLINK_NAMESPACE) {
                xlinkPrefixes.push(prefix);
                continue;
              }
              if (xlinkPrefixes.includes(prefix)) {
                overriddenPrefixes.push(prefix);
              }
            }
          }
          if (overriddenPrefixes.some((prefix) => xlinkPrefixes.includes(prefix))) {
            return;
          }
          const showAttrs = findPrefixedAttrs(node, xlinkPrefixes, "show");
          let showHandled = node.attributes.target != null;
          for (let i = showAttrs.length - 1;i >= 0; i--) {
            const attr = showAttrs[i];
            const value = node.attributes[attr];
            const mapping = SHOW_TO_TARGET[value];
            if (showHandled || mapping == null) {
              delete node.attributes[attr];
              continue;
            }
            if (mapping !== elems[node.name]?.defaults?.target) {
              node.attributes.target = mapping;
            }
            delete node.attributes[attr];
            showHandled = true;
          }
          const titleAttrs = findPrefixedAttrs(node, xlinkPrefixes, "title");
          for (let i = titleAttrs.length - 1;i >= 0; i--) {
            const attr = titleAttrs[i];
            const value = node.attributes[attr];
            const hasTitle = node.children.filter((child) => child.type === "element" && child.name === "title");
            if (hasTitle.length > 0) {
              delete node.attributes[attr];
              continue;
            }
            const titleTag = {
              type: "element",
              name: "title",
              attributes: {},
              children: [
                {
                  type: "text",
                  value
                }
              ]
            };
            Object.defineProperty(titleTag, "parentNode", {
              writable: true,
              value: node
            });
            node.children.unshift(titleTag);
            delete node.attributes[attr];
          }
          const hrefAttrs = findPrefixedAttrs(node, xlinkPrefixes, "href");
          if (hrefAttrs.length > 0 && LEGACY_ELEMENTS.has(node.name) && !includeLegacy) {
            hrefAttrs.map((attr) => attr.split(":", 1)[0]).forEach((prefix) => usedInLegacyElement.push(prefix));
            return;
          }
          for (let i = hrefAttrs.length - 1;i >= 0; i--) {
            const attr = hrefAttrs[i];
            const value = node.attributes[attr];
            if (node.attributes.href != null) {
              delete node.attributes[attr];
              continue;
            }
            node.attributes.href = value;
            delete node.attributes[attr];
          }
        },
        exit: (node) => {
          for (const [key, value] of Object.entries(node.attributes)) {
            const [prefix, attr] = key.split(":", 2);
            if (xlinkPrefixes.includes(prefix) && !overriddenPrefixes.includes(prefix) && !usedInLegacyElement.includes(prefix) && !includeLegacy) {
              delete node.attributes[key];
              continue;
            }
            if (key.startsWith("xmlns:") && !usedInLegacyElement.includes(attr)) {
              if (value === XLINK_NAMESPACE) {
                const index = xlinkPrefixes.indexOf(attr);
                xlinkPrefixes.splice(index, 1);
                delete node.attributes[key];
                continue;
              }
              if (overriddenPrefixes.includes(prefix)) {
                const index = overriddenPrefixes.indexOf(attr);
                overriddenPrefixes.splice(index, 1);
              }
            }
          }
        }
      }
    };
  };
});

// ../../../../node_modules/.bun/svgo@3.3.2/node_modules/svgo/plugins/removeXMLNS.js
var require_removeXMLNS = __commonJS((exports) => {
  exports.name = "removeXMLNS";
  exports.description = "removes xmlns attribute (for inline svg, disabled by default)";
  exports.fn = () => {
    return {
      element: {
        enter: (node) => {
          if (node.name === "svg") {
            delete node.attributes.xmlns;
          }
        }
      }
    };
  };
});

// ../../../../node_modules/.bun/svgo@3.3.2/node_modules/svgo/plugins/reusePaths.js
var require_reusePaths = __commonJS((exports) => {
  var { collectStylesheet } = require_style();
  var { detachNodeFromParent, querySelectorAll } = require_xast();
  exports.name = "reusePaths";
  exports.description = "Finds <path> elements with the same d, fill, and " + "stroke, and converts them to <use> elements " + "referencing a single <path> def.";
  exports.fn = (root) => {
    const stylesheet = collectStylesheet(root);
    const paths = new Map;
    let svgDefs;
    const hrefs = new Set;
    return {
      element: {
        enter: (node, parentNode) => {
          if (node.name === "path" && node.attributes.d != null) {
            const d = node.attributes.d;
            const fill = node.attributes.fill || "";
            const stroke = node.attributes.stroke || "";
            const key = d + ";s:" + stroke + ";f:" + fill;
            let list = paths.get(key);
            if (list == null) {
              list = [];
              paths.set(key, list);
            }
            list.push(node);
          }
          if (svgDefs == null && node.name === "defs" && parentNode.type === "element" && parentNode.name === "svg") {
            svgDefs = node;
          }
          if (node.name === "use") {
            for (const name of ["href", "xlink:href"]) {
              const href = node.attributes[name];
              if (href != null && href.startsWith("#") && href.length > 1) {
                hrefs.add(href.slice(1));
              }
            }
          }
        },
        exit: (node, parentNode) => {
          if (node.name === "svg" && parentNode.type === "root") {
            let defsTag = svgDefs;
            if (defsTag == null) {
              defsTag = {
                type: "element",
                name: "defs",
                attributes: {},
                children: []
              };
              Object.defineProperty(defsTag, "parentNode", {
                writable: true,
                value: node
              });
            }
            let index = 0;
            for (const list of paths.values()) {
              if (list.length > 1) {
                const reusablePath = {
                  type: "element",
                  name: "path",
                  attributes: {},
                  children: []
                };
                for (const attr of ["fill", "stroke", "d"]) {
                  if (list[0].attributes[attr] != null) {
                    reusablePath.attributes[attr] = list[0].attributes[attr];
                  }
                }
                const originalId = list[0].attributes.id;
                if (originalId == null || hrefs.has(originalId) || stylesheet.rules.some((rule) => rule.selector === `#${originalId}`)) {
                  reusablePath.attributes.id = "reuse-" + index++;
                } else {
                  reusablePath.attributes.id = originalId;
                  delete list[0].attributes.id;
                }
                Object.defineProperty(reusablePath, "parentNode", {
                  writable: true,
                  value: defsTag
                });
                defsTag.children.push(reusablePath);
                for (const pathNode of list) {
                  delete pathNode.attributes.d;
                  delete pathNode.attributes.stroke;
                  delete pathNode.attributes.fill;
                  if (defsTag.children.includes(pathNode) && pathNode.children.length === 0) {
                    if (Object.keys(pathNode.attributes).length === 0) {
                      detachNodeFromParent(pathNode, defsTag);
                      continue;
                    }
                    if (Object.keys(pathNode.attributes).length === 1 && pathNode.attributes.id != null) {
                      detachNodeFromParent(pathNode, defsTag);
                      const selector = `[xlink\\:href=#${pathNode.attributes.id}], [href=#${pathNode.attributes.id}]`;
                      for (const child of querySelectorAll(node, selector)) {
                        if (child.type !== "element") {
                          continue;
                        }
                        for (const name of ["href", "xlink:href"]) {
                          if (child.attributes[name] != null) {
                            child.attributes[name] = "#" + reusablePath.attributes.id;
                          }
                        }
                      }
                      continue;
                    }
                  }
                  pathNode.name = "use";
                  pathNode.attributes["xlink:href"] = "#" + reusablePath.attributes.id;
                }
              }
            }
            if (defsTag.children.length !== 0) {
              if (node.attributes["xmlns:xlink"] == null) {
                node.attributes["xmlns:xlink"] = "http://www.w3.org/1999/xlink";
              }
              if (svgDefs == null) {
                node.children.unshift(defsTag);
              }
            }
          }
        }
      }
    };
  };
});

// ../../../../node_modules/.bun/svgo@3.3.2/node_modules/svgo/lib/builtin.js
var require_builtin = __commonJS((exports) => {
  exports.builtin = [
    require_preset_default(),
    require_addAttributesToSVGElement(),
    require_addClassesToSVGElement(),
    require_cleanupAttrs(),
    require_cleanupEnableBackground(),
    require_cleanupIds(),
    require_cleanupListOfValues(),
    require_cleanupNumericValues(),
    require_collapseGroups(),
    require_convertColors(),
    require_convertEllipseToCircle(),
    require_convertOneStopGradients(),
    require_convertPathData(),
    require_convertShapeToPath(),
    require_convertStyleToAttrs(),
    require_convertTransform(),
    require_mergeStyles(),
    require_inlineStyles(),
    require_mergePaths(),
    require_minifyStyles(),
    require_moveElemsAttrsToGroup(),
    require_moveGroupAttrsToElems(),
    require_prefixIds(),
    require_removeAttributesBySelector(),
    require_removeAttrs(),
    require_removeComments(),
    require_removeDesc(),
    require_removeDimensions(),
    require_removeDoctype(),
    require_removeEditorsNSData(),
    require_removeElementsByAttr(),
    require_removeEmptyAttrs(),
    require_removeEmptyContainers(),
    require_removeEmptyText(),
    require_removeHiddenElems(),
    require_removeMetadata(),
    require_removeNonInheritableGroupAttrs(),
    require_removeOffCanvasPaths(),
    require_removeRasterImages(),
    require_removeScriptElement(),
    require_removeStyleElement(),
    require_removeTitle(),
    require_removeUnknownsAndDefaults(),
    require_removeUnusedNS(),
    require_removeUselessDefs(),
    require_removeUselessStrokeAndFill(),
    require_removeViewBox(),
    require_removeXlink(),
    require_removeXMLNS(),
    require_removeXMLProcInst(),
    require_reusePaths(),
    require_sortAttrs(),
    require_sortDefsChildren()
  ];
});

// ../../../../node_modules/.bun/svgo@3.3.2/node_modules/svgo/lib/svgo.js
var require_svgo = __commonJS((exports) => {
  var { parseSvg } = require_parser();
  var { stringifySvg } = require_stringifier();
  var { builtin } = require_builtin();
  var { invokePlugins } = require_plugins();
  var { encodeSVGDatauri } = require_tools();
  var pluginsMap = {};
  for (const plugin of builtin) {
    pluginsMap[plugin.name] = plugin;
  }
  var resolvePluginConfig = (plugin) => {
    if (typeof plugin === "string") {
      const builtinPlugin = pluginsMap[plugin];
      if (builtinPlugin == null) {
        throw Error(`Unknown builtin plugin "${plugin}" specified.`);
      }
      return {
        name: plugin,
        params: {},
        fn: builtinPlugin.fn
      };
    }
    if (typeof plugin === "object" && plugin != null) {
      if (plugin.name == null) {
        throw Error(`Plugin name should be specified`);
      }
      let fn = plugin.fn;
      if (fn == null) {
        const builtinPlugin = pluginsMap[plugin.name];
        if (builtinPlugin == null) {
          throw Error(`Unknown builtin plugin "${plugin.name}" specified.`);
        }
        fn = builtinPlugin.fn;
      }
      return {
        name: plugin.name,
        params: plugin.params,
        fn
      };
    }
    return null;
  };
  var optimize = (input, config) => {
    if (config == null) {
      config = {};
    }
    if (typeof config !== "object") {
      throw Error("Config should be an object");
    }
    const maxPassCount = config.multipass ? 10 : 1;
    let prevResultSize = Number.POSITIVE_INFINITY;
    let output = "";
    const info = {};
    if (config.path != null) {
      info.path = config.path;
    }
    for (let i = 0;i < maxPassCount; i += 1) {
      info.multipassCount = i;
      const ast = parseSvg(input, config.path);
      const plugins = config.plugins || ["preset-default"];
      if (!Array.isArray(plugins)) {
        throw Error("malformed config, `plugins` property must be an array.\nSee more info here: https://github.com/svg/svgo#configuration");
      }
      const resolvedPlugins = plugins.filter((plugin) => plugin != null).map(resolvePluginConfig);
      if (resolvedPlugins.length < plugins.length) {
        console.warn("Warning: plugins list includes null or undefined elements, these will be ignored.");
      }
      const globalOverrides = {};
      if (config.floatPrecision != null) {
        globalOverrides.floatPrecision = config.floatPrecision;
      }
      invokePlugins(ast, info, resolvedPlugins, null, globalOverrides);
      output = stringifySvg(ast, config.js2svg);
      if (output.length < prevResultSize) {
        input = output;
        prevResultSize = output.length;
      } else {
        break;
      }
    }
    if (config.datauri) {
      output = encodeSVGDatauri(output, config.datauri);
    }
    return {
      data: output
    };
  };
  exports.optimize = optimize;
});

// ../../../../node_modules/.bun/svgo@3.3.2/node_modules/svgo/lib/svgo-node.js
var require_svgo_node = __commonJS((exports) => {
  var os = __require("os");
  var fs = __require("fs");
  var { pathToFileURL } = __require("url");
  var path = __require("path");
  var { optimize: optimizeAgnostic } = require_svgo();
  var importConfig = async (configFile) => {
    let config;
    if (configFile.endsWith(".cjs")) {
      config = __require(configFile);
    } else {
      const { default: imported } = await import(pathToFileURL(configFile));
      config = imported;
    }
    if (config == null || typeof config !== "object" || Array.isArray(config)) {
      throw Error(`Invalid config file "${configFile}"`);
    }
    return config;
  };
  var isFile = async (file) => {
    try {
      const stats = await fs.promises.stat(file);
      return stats.isFile();
    } catch {
      return false;
    }
  };
  var loadConfig = async (configFile, cwd = process.cwd()) => {
    if (configFile != null) {
      if (path.isAbsolute(configFile)) {
        return await importConfig(configFile);
      } else {
        return await importConfig(path.join(cwd, configFile));
      }
    }
    let dir = cwd;
    while (true) {
      const js = path.join(dir, "svgo.config.js");
      if (await isFile(js)) {
        return await importConfig(js);
      }
      const mjs = path.join(dir, "svgo.config.mjs");
      if (await isFile(mjs)) {
        return await importConfig(mjs);
      }
      const cjs = path.join(dir, "svgo.config.cjs");
      if (await isFile(cjs)) {
        return await importConfig(cjs);
      }
      const parent = path.dirname(dir);
      if (dir === parent) {
        return null;
      }
      dir = parent;
    }
  };
  exports.loadConfig = loadConfig;
  var optimize = (input, config) => {
    if (config == null) {
      config = {};
    }
    if (typeof config !== "object") {
      throw Error("Config should be an object");
    }
    return optimizeAgnostic(input, {
      ...config,
      js2svg: {
        eol: os.EOL === `\r
` ? "crlf" : "lf",
        ...config.js2svg
      }
    });
  };
  exports.optimize = optimize;
});

// src/css-manifest.ts
var COLORS = {
  slate: { 50: "#f8fafc", 100: "#f1f5f9", 200: "#e2e8f0", 300: "#cbd5e1", 400: "#94a3b8", 500: "#64748b", 600: "#475569", 700: "#334155", 800: "#1e293b", 900: "#0f172a", 950: "#020617" },
  gray: { 50: "#f9fafb", 100: "#f3f4f6", 200: "#e5e7eb", 300: "#d1d5db", 400: "#9ca3af", 500: "#6b7280", 600: "#4b5563", 700: "#374151", 800: "#1f2937", 900: "#111827", 950: "#030712" },
  zinc: { 50: "#fafafa", 100: "#f4f4f5", 200: "#e4e4e7", 300: "#d4d4d8", 400: "#a1a1aa", 500: "#71717a", 600: "#52525b", 700: "#3f3f46", 800: "#27272a", 900: "#18181b", 950: "#09090b" },
  neutral: { 50: "#fafafa", 100: "#f5f5f5", 200: "#e5e5e5", 300: "#d4d4d4", 400: "#a3a3a3", 500: "#737373", 600: "#525252", 700: "#404040", 800: "#262626", 900: "#171717", 950: "#0a0a0a" },
  stone: { 50: "#fafaf9", 100: "#f5f5f4", 200: "#e7e5e4", 300: "#d6d3d1", 400: "#a8a29e", 500: "#78716c", 600: "#57534e", 700: "#44403c", 800: "#292524", 900: "#1c1917", 950: "#0c0a09" },
  red: { 50: "#fef2f2", 100: "#fee2e2", 200: "#fecaca", 300: "#fca5a5", 400: "#f87171", 500: "#ef4444", 600: "#dc2626", 700: "#b91c1c", 800: "#991b1b", 900: "#7f1d1d", 950: "#450a0a" },
  orange: { 50: "#fff7ed", 100: "#ffedd5", 200: "#fed7aa", 300: "#fdba74", 400: "#fb923c", 500: "#f97316", 600: "#ea580c", 700: "#c2410c", 800: "#9a3412", 900: "#7c2d12", 950: "#431407" },
  amber: { 50: "#fffbeb", 100: "#fef3c7", 200: "#fde68a", 300: "#fcd34d", 400: "#fbbf24", 500: "#f59e0b", 600: "#d97706", 700: "#b45309", 800: "#92400e", 900: "#78350f", 950: "#451a03" },
  yellow: { 50: "#fefce8", 100: "#fef9c3", 200: "#fef08a", 300: "#fde047", 400: "#facc15", 500: "#eab308", 600: "#ca8a04", 700: "#a16207", 800: "#854d0e", 900: "#713f12", 950: "#422006" },
  lime: { 50: "#f7fee7", 100: "#ecfccb", 200: "#d9f99d", 300: "#bef264", 400: "#a3e635", 500: "#84cc16", 600: "#65a30d", 700: "#4d7c0f", 800: "#3f6212", 900: "#365314", 950: "#1a2e05" },
  green: { 50: "#f0fdf4", 100: "#dcfce7", 200: "#bbf7d0", 300: "#86efac", 400: "#4ade80", 500: "#22c55e", 600: "#16a34a", 700: "#15803d", 800: "#166534", 900: "#14532d", 950: "#052e16" },
  emerald: { 50: "#ecfdf5", 100: "#d1fae5", 200: "#a7f3d0", 300: "#6ee7b7", 400: "#34d399", 500: "#10b981", 600: "#059669", 700: "#047857", 800: "#065f46", 900: "#064e3b", 950: "#022c22" },
  teal: { 50: "#f0fdfa", 100: "#ccfbf1", 200: "#99f6e4", 300: "#5eead4", 400: "#2dd4bf", 500: "#14b8a6", 600: "#0d9488", 700: "#0f766e", 800: "#115e59", 900: "#134e4a", 950: "#042f2e" },
  cyan: { 50: "#ecfeff", 100: "#cffafe", 200: "#a5f3fc", 300: "#67e8f9", 400: "#22d3ee", 500: "#06b6d4", 600: "#0891b2", 700: "#0e7490", 800: "#155e75", 900: "#164e63", 950: "#083344" },
  sky: { 50: "#f0f9ff", 100: "#e0f2fe", 200: "#bae6fd", 300: "#7dd3fc", 400: "#38bdf8", 500: "#0ea5e9", 600: "#0284c7", 700: "#0369a1", 800: "#075985", 900: "#0c4a6e", 950: "#082f49" },
  blue: { 50: "#eff6ff", 100: "#dbeafe", 200: "#bfdbfe", 300: "#93c5fd", 400: "#60a5fa", 500: "#3b82f6", 600: "#2563eb", 700: "#1d4ed8", 800: "#1e40af", 900: "#1e3a8a", 950: "#172554" },
  indigo: { 50: "#eef2ff", 100: "#e0e7ff", 200: "#c7d2fe", 300: "#a5b4fc", 400: "#818cf8", 500: "#6366f1", 600: "#4f46e5", 700: "#4338ca", 800: "#3730a3", 900: "#312e81", 950: "#1e1b4b" },
  violet: { 50: "#f5f3ff", 100: "#ede9fe", 200: "#ddd6fe", 300: "#c4b5fd", 400: "#a78bfa", 500: "#8b5cf6", 600: "#7c3aed", 700: "#6d28d9", 800: "#5b21b6", 900: "#4c1d95", 950: "#2e1065" },
  purple: { 50: "#faf5ff", 100: "#f3e8ff", 200: "#e9d5ff", 300: "#d8b4fe", 400: "#c084fc", 500: "#a855f7", 600: "#9333ea", 700: "#7e22ce", 800: "#6b21a8", 900: "#581c87", 950: "#3b0764" },
  fuchsia: { 50: "#fdf4ff", 100: "#fae8ff", 200: "#f5d0fe", 300: "#f0abfc", 400: "#e879f9", 500: "#d946ef", 600: "#c026d3", 700: "#a21caf", 800: "#86198f", 900: "#701a75", 950: "#4a044e" },
  pink: { 50: "#fdf2f8", 100: "#fce7f3", 200: "#fbcfe8", 300: "#f9a8d4", 400: "#f472b6", 500: "#ec4899", 600: "#db2777", 700: "#be185d", 800: "#9d174d", 900: "#831843", 950: "#500724" },
  rose: { 50: "#fff1f2", 100: "#ffe4e6", 200: "#fecdd3", 300: "#fda4af", 400: "#fb7185", 500: "#f43f5e", 600: "#e11d48", 700: "#be123c", 800: "#9f1239", 900: "#881337", 950: "#4c0519" },
  white: { DEFAULT: "#ffffff" },
  black: { DEFAULT: "#000000" },
  transparent: { DEFAULT: "transparent" }
};
var SPACING = {
  "0": "0px",
  px: "1px",
  "0.5": "0.125rem",
  "1": "0.25rem",
  "1.5": "0.375rem",
  "2": "0.5rem",
  "2.5": "0.625rem",
  "3": "0.75rem",
  "3.5": "0.875rem",
  "4": "1rem",
  "5": "1.25rem",
  "6": "1.5rem",
  "7": "1.75rem",
  "8": "2rem",
  "9": "2.25rem",
  "10": "2.5rem",
  "11": "2.75rem",
  "12": "3rem",
  "14": "3.5rem",
  "16": "4rem",
  "20": "5rem",
  "24": "6rem",
  "28": "7rem",
  "32": "8rem",
  "36": "9rem",
  "40": "10rem",
  "44": "11rem",
  "48": "12rem",
  "52": "13rem",
  "56": "14rem",
  "60": "15rem",
  "64": "16rem",
  "72": "18rem",
  "80": "20rem",
  "96": "24rem",
  full: "100%",
  auto: "auto"
};
var FONT_SIZES = {
  xs: ["0.75rem", "1rem"],
  sm: ["0.875rem", "1.25rem"],
  base: ["1rem", "1.5rem"],
  lg: ["1.125rem", "1.75rem"],
  xl: ["1.25rem", "1.75rem"],
  "2xl": ["1.5rem", "2rem"],
  "3xl": ["1.875rem", "2.25rem"],
  "4xl": ["2.25rem", "2.5rem"],
  "5xl": ["3rem", "1"],
  "6xl": ["3.75rem", "1"],
  "7xl": ["4.5rem", "1"],
  "8xl": ["6rem", "1"],
  "9xl": ["8rem", "1"]
};
var BORDER_RADIUS = {
  none: "0px",
  sm: "0.125rem",
  DEFAULT: "0.25rem",
  md: "0.375rem",
  lg: "0.5rem",
  xl: "0.75rem",
  "2xl": "1rem",
  "3xl": "1.5rem",
  full: "9999px"
};
function escapeSelector(cls) {
  return cls.replace(/[.:/[\]#%()@!]/g, "\\$&");
}
function getColor(colorName, shade) {
  const palette = COLORS[colorName];
  if (!palette)
    return null;
  return palette[shade || "DEFAULT"] || palette["500"] || null;
}
function hexToRgba(hex, alpha) {
  const r = parseInt(hex.slice(1, 3), 16);
  const g = parseInt(hex.slice(3, 5), 16);
  const b = parseInt(hex.slice(5, 7), 16);
  return `rgba(${r}, ${g}, ${b}, ${alpha})`;
}
function generateRule(className) {
  const escaped = escapeSelector(className);
  const bgMatch = className.match(/^bg-(\w+)(?:-(\d+))?(?:\/(\d+))?$/);
  if (bgMatch) {
    const [, color, shade, opacity] = bgMatch;
    const colorValue = getColor(color, shade);
    if (colorValue) {
      const value = opacity ? hexToRgba(colorValue, parseInt(opacity) / 100) : colorValue;
      return {
        selector: `.${escaped}`,
        declarations: `background-color: ${value}`
      };
    }
  }
  const textColorMatch = className.match(/^text-(\w+)(?:-(\d+))?$/);
  if (textColorMatch) {
    const [, color, shade] = textColorMatch;
    if (!["xs", "sm", "base", "lg", "xl", "2xl", "3xl", "4xl", "5xl", "6xl", "7xl", "8xl", "9xl", "left", "center", "right", "justify"].includes(color)) {
      const colorValue = getColor(color, shade);
      if (colorValue) {
        return {
          selector: `.${escaped}`,
          declarations: `color: ${colorValue}`
        };
      }
    }
  }
  const textSizeMatch = className.match(/^text-(xs|sm|base|lg|xl|2xl|3xl|4xl|5xl|6xl|7xl|8xl|9xl)$/);
  if (textSizeMatch) {
    const [fontSize, lineHeight] = FONT_SIZES[textSizeMatch[1]];
    return {
      selector: `.${escaped}`,
      declarations: `font-size: ${fontSize}; line-height: ${lineHeight}`
    };
  }
  if (className === "text-left")
    return { selector: `.${escaped}`, declarations: "text-align: left" };
  if (className === "text-center")
    return { selector: `.${escaped}`, declarations: "text-align: center" };
  if (className === "text-right")
    return { selector: `.${escaped}`, declarations: "text-align: right" };
  if (className === "text-justify")
    return { selector: `.${escaped}`, declarations: "text-align: justify" };
  const paddingMatch = className.match(/^p([xytblr])?-(.+)$/);
  if (paddingMatch) {
    const [, dir, size] = paddingMatch;
    const value = SPACING[size];
    if (value) {
      let declarations;
      switch (dir) {
        case "x":
          declarations = `padding-left: ${value}; padding-right: ${value}`;
          break;
        case "y":
          declarations = `padding-top: ${value}; padding-bottom: ${value}`;
          break;
        case "t":
          declarations = `padding-top: ${value}`;
          break;
        case "r":
          declarations = `padding-right: ${value}`;
          break;
        case "b":
          declarations = `padding-bottom: ${value}`;
          break;
        case "l":
          declarations = `padding-left: ${value}`;
          break;
        default:
          declarations = `padding: ${value}`;
      }
      return { selector: `.${escaped}`, declarations };
    }
  }
  const marginMatch = className.match(/^-?m([xytblr])?-(.+)$/);
  if (marginMatch) {
    const isNegative = className.startsWith("-");
    const [, dir, size] = marginMatch;
    let value = SPACING[size];
    if (value) {
      if (isNegative && value !== "0px" && value !== "auto") {
        value = `-${value}`;
      }
      let declarations;
      switch (dir) {
        case "x":
          declarations = `margin-left: ${value}; margin-right: ${value}`;
          break;
        case "y":
          declarations = `margin-top: ${value}; margin-bottom: ${value}`;
          break;
        case "t":
          declarations = `margin-top: ${value}`;
          break;
        case "r":
          declarations = `margin-right: ${value}`;
          break;
        case "b":
          declarations = `margin-bottom: ${value}`;
          break;
        case "l":
          declarations = `margin-left: ${value}`;
          break;
        default:
          declarations = `margin: ${value}`;
      }
      return { selector: `.${escaped}`, declarations };
    }
  }
  const widthMatch = className.match(/^w-(.+)$/);
  if (widthMatch) {
    const size = widthMatch[1];
    const value = SPACING[size] || (size === "screen" ? "100vw" : null);
    if (value) {
      return { selector: `.${escaped}`, declarations: `width: ${value}` };
    }
    const fractionMatch = size.match(/^(\d+)\/(\d+)$/);
    if (fractionMatch) {
      const percent = (parseInt(fractionMatch[1]) / parseInt(fractionMatch[2]) * 100).toFixed(6);
      return { selector: `.${escaped}`, declarations: `width: ${percent}%` };
    }
  }
  const heightMatch = className.match(/^h-(.+)$/);
  if (heightMatch) {
    const size = heightMatch[1];
    const value = SPACING[size] || (size === "screen" ? "100vh" : null);
    if (value) {
      return { selector: `.${escaped}`, declarations: `height: ${value}` };
    }
  }
  if (className === "min-h-screen")
    return { selector: `.${escaped}`, declarations: "min-height: 100vh" };
  if (className === "min-w-full")
    return { selector: `.${escaped}`, declarations: "min-width: 100%" };
  if (className === "max-w-full")
    return { selector: `.${escaped}`, declarations: "max-width: 100%" };
  if (className === "max-w-screen-xl")
    return { selector: `.${escaped}`, declarations: "max-width: 1280px" };
  if (className === "max-w-screen-lg")
    return { selector: `.${escaped}`, declarations: "max-width: 1024px" };
  if (className === "max-w-7xl")
    return { selector: `.${escaped}`, declarations: "max-width: 80rem" };
  if (className === "max-w-6xl")
    return { selector: `.${escaped}`, declarations: "max-width: 72rem" };
  if (className === "max-w-5xl")
    return { selector: `.${escaped}`, declarations: "max-width: 64rem" };
  if (className === "max-w-4xl")
    return { selector: `.${escaped}`, declarations: "max-width: 56rem" };
  if (className === "max-w-3xl")
    return { selector: `.${escaped}`, declarations: "max-width: 48rem" };
  if (className === "max-w-2xl")
    return { selector: `.${escaped}`, declarations: "max-width: 42rem" };
  if (className === "max-w-xl")
    return { selector: `.${escaped}`, declarations: "max-width: 36rem" };
  if (className === "max-w-lg")
    return { selector: `.${escaped}`, declarations: "max-width: 32rem" };
  if (className === "max-w-md")
    return { selector: `.${escaped}`, declarations: "max-width: 28rem" };
  if (className === "max-w-sm")
    return { selector: `.${escaped}`, declarations: "max-width: 24rem" };
  if (className === "max-w-xs")
    return { selector: `.${escaped}`, declarations: "max-width: 20rem" };
  const roundedMatch = className.match(/^rounded(?:-([a-z0-9]+))?(?:-(tl|tr|bl|br|t|r|b|l))?$/);
  if (roundedMatch) {
    const [, size, corner] = roundedMatch;
    const value = BORDER_RADIUS[size || "DEFAULT"];
    if (value) {
      let declarations;
      switch (corner) {
        case "tl":
          declarations = `border-top-left-radius: ${value}`;
          break;
        case "tr":
          declarations = `border-top-right-radius: ${value}`;
          break;
        case "bl":
          declarations = `border-bottom-left-radius: ${value}`;
          break;
        case "br":
          declarations = `border-bottom-right-radius: ${value}`;
          break;
        case "t":
          declarations = `border-top-left-radius: ${value}; border-top-right-radius: ${value}`;
          break;
        case "r":
          declarations = `border-top-right-radius: ${value}; border-bottom-right-radius: ${value}`;
          break;
        case "b":
          declarations = `border-bottom-left-radius: ${value}; border-bottom-right-radius: ${value}`;
          break;
        case "l":
          declarations = `border-top-left-radius: ${value}; border-bottom-left-radius: ${value}`;
          break;
        default:
          declarations = `border-radius: ${value}`;
      }
      return { selector: `.${escaped}`, declarations };
    }
  }
  const borderMatch = className.match(/^border(?:-([xytblr]))?(?:-(\d+))?$/);
  if (borderMatch) {
    const [, dir, width] = borderMatch;
    const value = width ? `${width}px` : "1px";
    let declarations;
    switch (dir) {
      case "x":
        declarations = `border-left-width: ${value}; border-right-width: ${value}`;
        break;
      case "y":
        declarations = `border-top-width: ${value}; border-bottom-width: ${value}`;
        break;
      case "t":
        declarations = `border-top-width: ${value}`;
        break;
      case "r":
        declarations = `border-right-width: ${value}`;
        break;
      case "b":
        declarations = `border-bottom-width: ${value}`;
        break;
      case "l":
        declarations = `border-left-width: ${value}`;
        break;
      default:
        declarations = `border-width: ${value}`;
    }
    return { selector: `.${escaped}`, declarations: `${declarations}; border-style: solid` };
  }
  const borderColorMatch = className.match(/^border-(\w+)(?:-(\d+))?(?:\/(\d+))?$/);
  if (borderColorMatch) {
    const [, color, shade, opacity] = borderColorMatch;
    if (!["x", "y", "t", "r", "b", "l"].includes(color)) {
      const colorValue = getColor(color, shade);
      if (colorValue) {
        const value = opacity ? hexToRgba(colorValue, parseInt(opacity) / 100) : colorValue;
        return { selector: `.${escaped}`, declarations: `border-color: ${value}` };
      }
    }
  }
  const gapMatch = className.match(/^gap(?:-([xy]))?-(.+)$/);
  if (gapMatch) {
    const [, dir, size] = gapMatch;
    const value = SPACING[size];
    if (value) {
      let declarations;
      switch (dir) {
        case "x":
          declarations = `column-gap: ${value}`;
          break;
        case "y":
          declarations = `row-gap: ${value}`;
          break;
        default:
          declarations = `gap: ${value}`;
      }
      return { selector: `.${escaped}`, declarations };
    }
  }
  const spaceMatch = className.match(/^space-([xy])-(.+)$/);
  if (spaceMatch) {
    const [, dir, size] = spaceMatch;
    const value = SPACING[size];
    if (value) {
      const prop = dir === "x" ? "margin-left" : "margin-top";
      return {
        selector: `.${escaped} > :not([hidden]) ~ :not([hidden])`,
        declarations: `${prop}: ${value}`
      };
    }
  }
  const staticUtilities = {
    flex: "display: flex",
    "inline-flex": "display: inline-flex",
    block: "display: block",
    "inline-block": "display: inline-block",
    inline: "display: inline",
    hidden: "display: none",
    grid: "display: grid",
    "inline-grid": "display: inline-grid",
    contents: "display: contents",
    table: "display: table",
    "flex-row": "flex-direction: row",
    "flex-row-reverse": "flex-direction: row-reverse",
    "flex-col": "flex-direction: column",
    "flex-col-reverse": "flex-direction: column-reverse",
    "flex-wrap": "flex-wrap: wrap",
    "flex-wrap-reverse": "flex-wrap: wrap-reverse",
    "flex-nowrap": "flex-wrap: nowrap",
    "flex-1": "flex: 1 1 0%",
    "flex-auto": "flex: 1 1 auto",
    "flex-initial": "flex: 0 1 auto",
    "flex-none": "flex: none",
    grow: "flex-grow: 1",
    "grow-0": "flex-grow: 0",
    shrink: "flex-shrink: 1",
    "shrink-0": "flex-shrink: 0",
    "items-start": "align-items: flex-start",
    "items-end": "align-items: flex-end",
    "items-center": "align-items: center",
    "items-baseline": "align-items: baseline",
    "items-stretch": "align-items: stretch",
    "self-auto": "align-self: auto",
    "self-start": "align-self: flex-start",
    "self-end": "align-self: flex-end",
    "self-center": "align-self: center",
    "self-stretch": "align-self: stretch",
    "justify-start": "justify-content: flex-start",
    "justify-end": "justify-content: flex-end",
    "justify-center": "justify-content: center",
    "justify-between": "justify-content: space-between",
    "justify-around": "justify-content: space-around",
    "justify-evenly": "justify-content: space-evenly",
    "justify-items-start": "justify-items: start",
    "justify-items-end": "justify-items: end",
    "justify-items-center": "justify-items: center",
    "justify-items-stretch": "justify-items: stretch",
    static: "position: static",
    fixed: "position: fixed",
    absolute: "position: absolute",
    relative: "position: relative",
    sticky: "position: sticky",
    "inset-0": "inset: 0",
    "inset-auto": "inset: auto",
    "top-0": "top: 0",
    "right-0": "right: 0",
    "bottom-0": "bottom: 0",
    "left-0": "left: 0",
    "z-0": "z-index: 0",
    "z-10": "z-index: 10",
    "z-20": "z-index: 20",
    "z-30": "z-index: 30",
    "z-40": "z-index: 40",
    "z-50": "z-index: 50",
    "z-auto": "z-index: auto",
    "overflow-auto": "overflow: auto",
    "overflow-hidden": "overflow: hidden",
    "overflow-visible": "overflow: visible",
    "overflow-scroll": "overflow: scroll",
    "overflow-x-auto": "overflow-x: auto",
    "overflow-y-auto": "overflow-y: auto",
    "overflow-x-hidden": "overflow-x: hidden",
    "overflow-y-hidden": "overflow-y: hidden",
    "font-thin": "font-weight: 100",
    "font-extralight": "font-weight: 200",
    "font-light": "font-weight: 300",
    "font-normal": "font-weight: 400",
    "font-medium": "font-weight: 500",
    "font-semibold": "font-weight: 600",
    "font-bold": "font-weight: 700",
    "font-extrabold": "font-weight: 800",
    "font-black": "font-weight: 900",
    italic: "font-style: italic",
    "not-italic": "font-style: normal",
    underline: "text-decoration-line: underline",
    overline: "text-decoration-line: overline",
    "line-through": "text-decoration-line: line-through",
    "no-underline": "text-decoration-line: none",
    uppercase: "text-transform: uppercase",
    lowercase: "text-transform: lowercase",
    capitalize: "text-transform: capitalize",
    "normal-case": "text-transform: none",
    "whitespace-normal": "white-space: normal",
    "whitespace-nowrap": "white-space: nowrap",
    "whitespace-pre": "white-space: pre",
    "whitespace-pre-line": "white-space: pre-line",
    "whitespace-pre-wrap": "white-space: pre-wrap",
    "break-normal": "overflow-wrap: normal; word-break: normal",
    "break-words": "overflow-wrap: break-word",
    "break-all": "word-break: break-all",
    truncate: "overflow: hidden; text-overflow: ellipsis; white-space: nowrap",
    "cursor-auto": "cursor: auto",
    "cursor-default": "cursor: default",
    "cursor-pointer": "cursor: pointer",
    "cursor-wait": "cursor: wait",
    "cursor-text": "cursor: text",
    "cursor-move": "cursor: move",
    "cursor-not-allowed": "cursor: not-allowed",
    "pointer-events-none": "pointer-events: none",
    "pointer-events-auto": "pointer-events: auto",
    "select-none": "user-select: none",
    "select-text": "user-select: text",
    "select-all": "user-select: all",
    "select-auto": "user-select: auto",
    visible: "visibility: visible",
    invisible: "visibility: hidden",
    "opacity-0": "opacity: 0",
    "opacity-5": "opacity: 0.05",
    "opacity-10": "opacity: 0.1",
    "opacity-20": "opacity: 0.2",
    "opacity-25": "opacity: 0.25",
    "opacity-30": "opacity: 0.3",
    "opacity-40": "opacity: 0.4",
    "opacity-50": "opacity: 0.5",
    "opacity-60": "opacity: 0.6",
    "opacity-70": "opacity: 0.7",
    "opacity-75": "opacity: 0.75",
    "opacity-80": "opacity: 0.8",
    "opacity-90": "opacity: 0.9",
    "opacity-95": "opacity: 0.95",
    "opacity-100": "opacity: 1",
    transition: "transition-property: color, background-color, border-color, text-decoration-color, fill, stroke, opacity, box-shadow, transform, filter, backdrop-filter; transition-timing-function: cubic-bezier(0.4, 0, 0.2, 1); transition-duration: 150ms",
    "transition-none": "transition-property: none",
    "transition-all": "transition-property: all; transition-timing-function: cubic-bezier(0.4, 0, 0.2, 1); transition-duration: 150ms",
    "transition-colors": "transition-property: color, background-color, border-color, text-decoration-color, fill, stroke; transition-timing-function: cubic-bezier(0.4, 0, 0.2, 1); transition-duration: 150ms",
    "transition-opacity": "transition-property: opacity; transition-timing-function: cubic-bezier(0.4, 0, 0.2, 1); transition-duration: 150ms",
    "transition-shadow": "transition-property: box-shadow; transition-timing-function: cubic-bezier(0.4, 0, 0.2, 1); transition-duration: 150ms",
    "transition-transform": "transition-property: transform; transition-timing-function: cubic-bezier(0.4, 0, 0.2, 1); transition-duration: 150ms",
    "duration-75": "transition-duration: 75ms",
    "duration-100": "transition-duration: 100ms",
    "duration-150": "transition-duration: 150ms",
    "duration-200": "transition-duration: 200ms",
    "duration-300": "transition-duration: 300ms",
    "duration-500": "transition-duration: 500ms",
    "duration-700": "transition-duration: 700ms",
    "duration-1000": "transition-duration: 1000ms",
    "ease-linear": "transition-timing-function: linear",
    "ease-in": "transition-timing-function: cubic-bezier(0.4, 0, 1, 1)",
    "ease-out": "transition-timing-function: cubic-bezier(0, 0, 0.2, 1)",
    "ease-in-out": "transition-timing-function: cubic-bezier(0.4, 0, 0.2, 1)",
    "animate-none": "animation: none",
    "animate-spin": "animation: spin 1s linear infinite",
    "animate-ping": "animation: ping 1s cubic-bezier(0, 0, 0.2, 1) infinite",
    "animate-pulse": "animation: pulse 2s cubic-bezier(0.4, 0, 0.6, 1) infinite",
    "animate-bounce": "animation: bounce 1s infinite",
    transform: "transform: translateX(var(--tw-translate-x)) translateY(var(--tw-translate-y)) rotate(var(--tw-rotate)) skewX(var(--tw-skew-x)) skewY(var(--tw-skew-y)) scaleX(var(--tw-scale-x)) scaleY(var(--tw-scale-y))",
    "transform-none": "transform: none",
    "object-contain": "object-fit: contain",
    "object-cover": "object-fit: cover",
    "object-fill": "object-fit: fill",
    "object-none": "object-fit: none",
    "object-scale-down": "object-fit: scale-down",
    "shadow-sm": "box-shadow: 0 1px 2px 0 rgb(0 0 0 / 0.05)",
    shadow: "box-shadow: 0 1px 3px 0 rgb(0 0 0 / 0.1), 0 1px 2px -1px rgb(0 0 0 / 0.1)",
    "shadow-md": "box-shadow: 0 4px 6px -1px rgb(0 0 0 / 0.1), 0 2px 4px -2px rgb(0 0 0 / 0.1)",
    "shadow-lg": "box-shadow: 0 10px 15px -3px rgb(0 0 0 / 0.1), 0 4px 6px -4px rgb(0 0 0 / 0.1)",
    "shadow-xl": "box-shadow: 0 20px 25px -5px rgb(0 0 0 / 0.1), 0 8px 10px -6px rgb(0 0 0 / 0.1)",
    "shadow-2xl": "box-shadow: 0 25px 50px -12px rgb(0 0 0 / 0.25)",
    "shadow-inner": "box-shadow: inset 0 2px 4px 0 rgb(0 0 0 / 0.05)",
    "shadow-none": "box-shadow: 0 0 #0000",
    ring: "box-shadow: var(--tw-ring-offset-shadow), var(--tw-ring-shadow), var(--tw-shadow, 0 0 #0000)",
    "ring-0": "--tw-ring-offset-shadow: var(--tw-ring-inset) 0 0 0 var(--tw-ring-offset-width) var(--tw-ring-offset-color); --tw-ring-shadow: var(--tw-ring-inset) 0 0 0 calc(0px + var(--tw-ring-offset-width)) var(--tw-ring-color)",
    "ring-1": "--tw-ring-offset-shadow: var(--tw-ring-inset) 0 0 0 var(--tw-ring-offset-width) var(--tw-ring-offset-color); --tw-ring-shadow: var(--tw-ring-inset) 0 0 0 calc(1px + var(--tw-ring-offset-width)) var(--tw-ring-color)",
    "ring-2": "--tw-ring-offset-shadow: var(--tw-ring-inset) 0 0 0 var(--tw-ring-offset-width) var(--tw-ring-offset-color); --tw-ring-shadow: var(--tw-ring-inset) 0 0 0 calc(2px + var(--tw-ring-offset-width)) var(--tw-ring-color)",
    "outline-none": "outline: 2px solid transparent; outline-offset: 2px",
    outline: "outline-style: solid",
    "outline-dashed": "outline-style: dashed",
    "outline-dotted": "outline-style: dotted",
    "outline-double": "outline-style: double",
    "list-none": "list-style-type: none",
    "list-disc": "list-style-type: disc",
    "list-decimal": "list-style-type: decimal",
    "list-inside": "list-style-position: inside",
    "list-outside": "list-style-position: outside",
    "sr-only": "position: absolute; width: 1px; height: 1px; padding: 0; margin: -1px; overflow: hidden; clip: rect(0, 0, 0, 0); white-space: nowrap; border-width: 0",
    "not-sr-only": "position: static; width: auto; height: auto; padding: 0; margin: 0; overflow: visible; clip: auto; white-space: normal",
    "aspect-auto": "aspect-ratio: auto",
    "aspect-square": "aspect-ratio: 1 / 1",
    "aspect-video": "aspect-ratio: 16 / 9",
    container: "width: 100%",
    "columns-1": "columns: 1",
    "columns-2": "columns: 2",
    "columns-3": "columns: 3",
    "columns-4": "columns: 4",
    "grid-cols-1": "grid-template-columns: repeat(1, minmax(0, 1fr))",
    "grid-cols-2": "grid-template-columns: repeat(2, minmax(0, 1fr))",
    "grid-cols-3": "grid-template-columns: repeat(3, minmax(0, 1fr))",
    "grid-cols-4": "grid-template-columns: repeat(4, minmax(0, 1fr))",
    "grid-cols-5": "grid-template-columns: repeat(5, minmax(0, 1fr))",
    "grid-cols-6": "grid-template-columns: repeat(6, minmax(0, 1fr))",
    "grid-cols-12": "grid-template-columns: repeat(12, minmax(0, 1fr))",
    "grid-rows-1": "grid-template-rows: repeat(1, minmax(0, 1fr))",
    "grid-rows-2": "grid-template-rows: repeat(2, minmax(0, 1fr))",
    "grid-rows-3": "grid-template-rows: repeat(3, minmax(0, 1fr))",
    "grid-rows-4": "grid-template-rows: repeat(4, minmax(0, 1fr))",
    "grid-rows-5": "grid-template-rows: repeat(5, minmax(0, 1fr))",
    "grid-rows-6": "grid-template-rows: repeat(6, minmax(0, 1fr))",
    "col-auto": "grid-column: auto",
    "col-span-1": "grid-column: span 1 / span 1",
    "col-span-2": "grid-column: span 2 / span 2",
    "col-span-3": "grid-column: span 3 / span 3",
    "col-span-4": "grid-column: span 4 / span 4",
    "col-span-5": "grid-column: span 5 / span 5",
    "col-span-6": "grid-column: span 6 / span 6",
    "col-span-full": "grid-column: 1 / -1",
    "row-auto": "grid-row: auto",
    "row-span-1": "grid-row: span 1 / span 1",
    "row-span-2": "grid-row: span 2 / span 2",
    "row-span-3": "grid-row: span 3 / span 3",
    "row-span-full": "grid-row: 1 / -1",
    "content-center": "align-content: center",
    "content-start": "align-content: flex-start",
    "content-end": "align-content: flex-end",
    "content-between": "align-content: space-between",
    "content-around": "align-content: space-around",
    "content-evenly": "align-content: space-evenly",
    "place-content-center": "place-content: center",
    "place-content-start": "place-content: start",
    "place-content-end": "place-content: end",
    "place-items-center": "place-items: center",
    "place-items-start": "place-items: start",
    "place-items-end": "place-items: end",
    "place-self-center": "place-self: center",
    "place-self-start": "place-self: start",
    "place-self-end": "place-self: end",
    "place-self-auto": "place-self: auto"
  };
  if (staticUtilities[className]) {
    return { selector: `.${escaped}`, declarations: staticUtilities[className] };
  }
  return null;
}
function generateVariantRule(className) {
  const variantMatch = className.match(/^(hover|focus|active|focus-within|focus-visible|disabled|group-hover|dark):/);
  if (!variantMatch)
    return null;
  const variant = variantMatch[1];
  const baseClass = className.slice(variant.length + 1);
  const baseRule = generateRule(baseClass);
  if (!baseRule)
    return null;
  const escaped = escapeSelector(className);
  switch (variant) {
    case "hover":
      return { ...baseRule, selector: `.${escaped}:hover` };
    case "focus":
      return { ...baseRule, selector: `.${escaped}:focus` };
    case "active":
      return { ...baseRule, selector: `.${escaped}:active` };
    case "focus-within":
      return { ...baseRule, selector: `.${escaped}:focus-within` };
    case "focus-visible":
      return { ...baseRule, selector: `.${escaped}:focus-visible` };
    case "disabled":
      return { ...baseRule, selector: `.${escaped}:disabled` };
    case "group-hover":
      return { ...baseRule, selector: `.group:hover .${escaped}` };
    case "dark":
      return { ...baseRule, selector: `.dark .${escaped}`, mediaQuery: "(prefers-color-scheme: dark)" };
    default:
      return null;
  }
}
function generateResponsiveRule(className) {
  const responsiveMatch = className.match(/^(sm|md|lg|xl|2xl):/);
  if (!responsiveMatch)
    return null;
  const breakpoint = responsiveMatch[1];
  const baseClass = className.slice(breakpoint.length + 1);
  const variantRule = generateVariantRule(baseClass);
  const baseRule = variantRule || generateRule(baseClass);
  if (!baseRule)
    return null;
  const escaped = escapeSelector(className);
  const breakpoints = {
    sm: "(min-width: 640px)",
    md: "(min-width: 768px)",
    lg: "(min-width: 1024px)",
    xl: "(min-width: 1280px)",
    "2xl": "(min-width: 1536px)"
  };
  return {
    ...baseRule,
    selector: variantRule ? baseRule.selector.replace(`.${escapeSelector(baseClass)}`, `.${escaped}`) : `.${escaped}`,
    mediaQuery: breakpoints[breakpoint]
  };
}
function generateCSSForClass(className) {
  const responsiveRule = generateResponsiveRule(className);
  if (responsiveRule)
    return responsiveRule;
  const variantRule = generateVariantRule(className);
  if (variantRule)
    return variantRule;
  return generateRule(className);
}
function generateCSSForClasses(classNames) {
  const rules = [];
  const mediaRules = new Map;
  for (const className of classNames) {
    const rule = generateCSSForClass(className);
    if (rule) {
      if (rule.mediaQuery) {
        const existing = mediaRules.get(rule.mediaQuery) || [];
        existing.push(rule);
        mediaRules.set(rule.mediaQuery, existing);
      } else {
        rules.push(rule);
      }
    }
  }
  let css = "";
  for (const rule of rules) {
    css += `${rule.selector} { ${rule.declarations} }
`;
  }
  for (const [mediaQuery, mediaQueryRules] of mediaRules) {
    css += `@media ${mediaQuery} {
`;
    for (const rule of mediaQueryRules) {
      css += `  ${rule.selector} { ${rule.declarations} }
`;
    }
    css += `}
`;
  }
  return css;
}
function generateCriticalCSS() {
  return `/* Critical CSS - always included */
*, ::before, ::after { box-sizing: border-box; border-width: 0; border-style: solid; border-color: #e5e7eb; }
html { line-height: 1.5; -webkit-text-size-adjust: 100%; -moz-tab-size: 4; tab-size: 4; font-family: ui-sans-serif, system-ui, sans-serif, "Apple Color Emoji", "Segoe UI Emoji", "Segoe UI Symbol", "Noto Color Emoji"; font-feature-settings: normal; font-variation-settings: normal; }
body { margin: 0; line-height: inherit; }
hr { height: 0; color: inherit; border-top-width: 1px; }
abbr:where([title]) { text-decoration: underline dotted; }
h1, h2, h3, h4, h5, h6 { font-size: inherit; font-weight: inherit; }
a { color: inherit; text-decoration: inherit; }
b, strong { font-weight: bolder; }
code, kbd, samp, pre { font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace; font-size: 1em; }
small { font-size: 80%; }
sub, sup { font-size: 75%; line-height: 0; position: relative; vertical-align: baseline; }
sub { bottom: -0.25em; }
sup { top: -0.5em; }
table { text-indent: 0; border-color: inherit; border-collapse: collapse; }
button, input, optgroup, select, textarea { font-family: inherit; font-size: 100%; font-weight: inherit; line-height: inherit; color: inherit; margin: 0; padding: 0; }
button, select { text-transform: none; }
button, [type='button'], [type='reset'], [type='submit'] { -webkit-appearance: button; background-color: transparent; background-image: none; }
:-moz-focusring { outline: auto; }
:-moz-ui-invalid { box-shadow: none; }
progress { vertical-align: baseline; }
::-webkit-inner-spin-button, ::-webkit-outer-spin-button { height: auto; }
[type='search'] { -webkit-appearance: textfield; outline-offset: -2px; }
::-webkit-search-decoration { -webkit-appearance: none; }
::-webkit-file-upload-button { -webkit-appearance: button; font: inherit; }
summary { display: list-item; }
blockquote, dl, dd, h1, h2, h3, h4, h5, h6, hr, figure, p, pre { margin: 0; }
fieldset { margin: 0; padding: 0; }
legend { padding: 0; }
ol, ul, menu { list-style: none; margin: 0; padding: 0; }
textarea { resize: vertical; }
input::placeholder, textarea::placeholder { opacity: 1; color: #9ca3af; }
button, [role="button"] { cursor: pointer; }
:disabled { cursor: default; }
img, svg, video, canvas, audio, iframe, embed, object { display: block; vertical-align: middle; }
img, video { max-width: 100%; height: auto; }
[hidden] { display: none; }

/* Keyframe animations */
@keyframes spin { to { transform: rotate(360deg); } }
@keyframes ping { 75%, 100% { transform: scale(2); opacity: 0; } }
@keyframes pulse { 50% { opacity: .5; } }
@keyframes bounce { 0%, 100% { transform: translateY(-25%); animation-timing-function: cubic-bezier(0.8,0,1,1); } 50% { transform: none; animation-timing-function: cubic-bezier(0,0,0.2,1); } }
`;
}
function buildCSSManifest(classNames) {
  const rules = {};
  if (classNames) {
    for (const className of classNames) {
      const rule = generateCSSForClass(className);
      if (rule) {
        if (!rules[className]) {
          rules[className] = [];
        }
        rules[className].push(rule);
      }
    }
  }
  return {
    version: "1.0.0",
    generatedAt: new Date().toISOString(),
    rules,
    variants: {
      sm: "(min-width: 640px)",
      md: "(min-width: 768px)",
      lg: "(min-width: 1024px)",
      xl: "(min-width: 1280px)",
      "2xl": "(min-width: 1536px)"
    },
    critical: generateCriticalCSS()
  };
}
function extractClassesFromTree(tree) {
  const classes = new Set;
  function walk(node) {
    if (typeof node === "string")
      return;
    if (!node || typeof node !== "object")
      return;
    const n = node;
    const className = n.props?.className || n.props?.class;
    if (typeof className === "string") {
      className.split(/\s+/).forEach((c) => c && classes.add(c));
    }
    if (Array.isArray(n.children)) {
      n.children.forEach(walk);
    }
  }
  walk(tree);
  return classes;
}
// src/asset-manifest.ts
import { readdir, readFile, stat } from "fs/promises";
import { join, extname, relative } from "path";
var DEFAULT_OPTIONS = {
  maxInlineSize: 50 * 1024,
  convertToWebP: false,
  webpQuality: 80,
  optimizeSvg: true,
  recursive: true
};
var MIME_TYPES = {
  ".svg": "image/svg+xml",
  ".png": "image/png",
  ".jpg": "image/jpeg",
  ".jpeg": "image/jpeg",
  ".gif": "image/gif",
  ".webp": "image/webp",
  ".avif": "image/avif",
  ".ico": "image/x-icon",
  ".bmp": "image/bmp"
};
var SUPPORTED_EXTENSIONS = new Set(Object.keys(MIME_TYPES));
async function optimizeSvg(svgContent) {
  let optimized = svgContent.replace(/<\?xml[^?]*\?>/g, "").replace(/<!--[\s\S]*?-->/g, "").replace(/>\s+</g, "><").replace(/\s+([a-z-]+)=""/gi, "").replace(/\s+data-[a-z-]+="[^"]*"/gi, "").trim();
  try {
    const { optimize } = await Promise.resolve().then(() => __toESM(require_svgo_node(), 1));
    const result = optimize(optimized, {
      multipass: true,
      plugins: [
        "preset-default",
        "removeDimensions",
        {
          name: "removeAttrs",
          params: { attrs: ["data-name", "class"] }
        }
      ]
    });
    return result.data;
  } catch {
    return optimized;
  }
}
async function fileToDataUri(filePath, options) {
  const ext = extname(filePath).toLowerCase();
  const mimeType = MIME_TYPES[ext];
  if (!mimeType)
    return null;
  const buffer = await readFile(filePath);
  let content = buffer;
  let optimized = false;
  let finalSize = buffer.length;
  if (buffer.length > (options.maxInlineSize || DEFAULT_OPTIONS.maxInlineSize)) {
    console.warn(`    Skipping ${filePath}: too large (${(buffer.length / 1024).toFixed(1)}KB)`);
    return null;
  }
  if (ext === ".svg" && options.optimizeSvg !== false) {
    const svgContent = buffer.toString("utf-8");
    const optimizedSvg = await optimizeSvg(svgContent);
    content = Buffer.from(optimizedSvg, "utf-8");
    finalSize = content.length;
    optimized = true;
  }
  const base64 = Buffer.isBuffer(content) ? content.toString("base64") : Buffer.from(content).toString("base64");
  return {
    dataUri: `data:${mimeType};base64,${base64}`,
    size: finalSize,
    optimized
  };
}
async function scanDirectory(dir, recursive) {
  const files = [];
  try {
    const entries = await readdir(dir, { withFileTypes: true });
    for (const entry of entries) {
      const fullPath = join(dir, entry.name);
      if (entry.isDirectory() && recursive) {
        const subFiles = await scanDirectory(fullPath, recursive);
        files.push(...subFiles);
      } else if (entry.isFile()) {
        const ext = extname(entry.name).toLowerCase();
        if (SUPPORTED_EXTENSIONS.has(ext)) {
          files.push(fullPath);
        }
      }
    }
  } catch (error) {
    console.warn(`    Could not scan directory: ${dir}`);
  }
  return files;
}
async function buildAssetManifest(options) {
  const opts = { ...DEFAULT_OPTIONS, ...options };
  const assets = {};
  let totalSize = 0;
  let totalCount = 0;
  console.log(`
\uD83D\uDCE6 Building asset manifest from: ${opts.assetsDir}`);
  try {
    await stat(opts.assetsDir);
  } catch {
    console.warn(`    Assets directory not found: ${opts.assetsDir}`);
    return {
      version: "1.0.0",
      generatedAt: new Date().toISOString(),
      assets: {},
      totalSize: 0,
      totalCount: 0
    };
  }
  const files = await scanDirectory(opts.assetsDir, opts.recursive ?? true);
  console.log(`   Found ${files.length} asset file(s)`);
  for (const filePath of files) {
    const result = await fileToDataUri(filePath, opts);
    if (!result)
      continue;
    const relativePath = "/" + relative(opts.assetsDir, filePath).replace(/\\/g, "/");
    const ext = extname(filePath).toLowerCase();
    assets[relativePath] = {
      originalPath: filePath,
      dataUri: result.dataUri,
      size: result.size,
      format: ext.slice(1),
      optimized: result.optimized
    };
    totalSize += result.size;
    totalCount++;
    console.log(`    ${relativePath} (${(result.size / 1024).toFixed(1)}KB${result.optimized ? ", optimized" : ""})`);
  }
  console.log(`
   Total: ${totalCount} assets, ${(totalSize / 1024).toFixed(1)}KB`);
  return {
    version: "1.0.0",
    generatedAt: new Date().toISOString(),
    assets,
    totalSize,
    totalCount
  };
}
function getAssetDataUri(manifest, path) {
  const normalizedPath = path.startsWith("/") ? path : "/" + path;
  return manifest.assets[normalizedPath]?.dataUri || null;
}
function resolveAssetsInTree(tree, manifest) {
  function walk(node) {
    if (typeof node === "string")
      return node;
    if (!node || typeof node !== "object")
      return node;
    const n = node;
    const newProps = { ...n.props };
    if (typeof newProps.src === "string" && !newProps.src.startsWith("data:")) {
      const dataUri = getAssetDataUri(manifest, newProps.src);
      if (dataUri) {
        newProps.src = dataUri;
      }
    }
    if (n.type === "link" && typeof newProps.href === "string") {
      const ext = extname(newProps.href).toLowerCase();
      if (SUPPORTED_EXTENSIONS.has(ext)) {
        const dataUri = getAssetDataUri(manifest, newProps.href);
        if (dataUri) {
          newProps.href = dataUri;
        }
      }
    }
    if (typeof newProps.style === "object" && newProps.style !== null) {
      const style = newProps.style;
      if (style.backgroundImage) {
        const urlMatch = style.backgroundImage.match(/url\(['"]?([^'")\s]+)['"]?\)/);
        if (urlMatch && !urlMatch[1].startsWith("data:")) {
          const dataUri = getAssetDataUri(manifest, urlMatch[1]);
          if (dataUri) {
            style.backgroundImage = `url('${dataUri}')`;
          }
        }
      }
      newProps.style = style;
    }
    const newChildren = Array.isArray(n.children) ? n.children.map(walk) : n.children;
    return {
      type: n.type,
      props: Object.keys(newProps).length > 0 ? newProps : undefined,
      children: newChildren
    };
  }
  return walk(tree);
}
async function inlineSvg(filePath, options = {}) {
  const content = await readFile(filePath, "utf-8");
  let svg = await optimizeSvg(content);
  if (options.addAriaHidden) {
    svg = svg.replace("<svg", '<svg aria-hidden="true"');
  }
  if (options.className) {
    if (svg.includes('class="')) {
      svg = svg.replace(/class="([^"]*)"/, `class="$1 ${options.className}"`);
    } else {
      svg = svg.replace("<svg", `<svg class="${options.className}"`);
    }
  }
  if (options.removeIds) {
    const prefix = `svg-${Date.now().toString(36)}`;
    svg = svg.replace(/id="([^"]+)"/g, `id="${prefix}-$1"`);
    svg = svg.replace(/url\(#([^)]+)\)/g, `url(#${prefix}-$1)`);
    svg = svg.replace(/href="#([^"]+)"/g, `href="#${prefix}-$1"`);
  }
  return svg;
}
// src/font-manifest.ts
import { readdir as readdir2, readFile as readFile2, stat as stat2 } from "fs/promises";
import { join as join2, extname as extname2, basename } from "path";
var DEFAULT_OPTIONS2 = {
  maxInlineSize: 100 * 1024,
  preferredFormats: ["woff2", "woff", "ttf", "otf"]
};
var FONT_MIME_TYPES = {
  ".woff2": "font/woff2",
  ".woff": "font/woff",
  ".ttf": "font/ttf",
  ".otf": "font/otf",
  ".eot": "application/vnd.ms-fontobject"
};
var FONT_FORMAT_STRINGS = {
  ".woff2": "woff2",
  ".woff": "woff",
  ".ttf": "truetype",
  ".otf": "opentype",
  ".eot": "embedded-opentype"
};
var SUPPORTED_EXTENSIONS2 = new Set(Object.keys(FONT_MIME_TYPES));
var WEIGHT_MAP = {
  thin: 100,
  hairline: 100,
  extralight: 200,
  ultralight: 200,
  light: 300,
  regular: 400,
  normal: 400,
  book: 400,
  medium: 500,
  semibold: 600,
  demibold: 600,
  bold: 700,
  extrabold: 800,
  ultrabold: 800,
  black: 900,
  heavy: 900
};
function parseFontFilename(filename) {
  const name = basename(filename).replace(/\.[^.]+$/, "");
  const parts = name.split(/[-_]/);
  let family = parts[0];
  let weight = 400;
  let style = "normal";
  for (let i = 1;i < parts.length; i++) {
    const part = parts[i].toLowerCase();
    if (WEIGHT_MAP[part]) {
      weight = WEIGHT_MAP[part];
    } else if (/^\d{3}$/.test(part)) {
      weight = parseInt(part, 10);
    }
    if (part === "italic" || part.includes("italic")) {
      style = "italic";
    } else if (part === "oblique" || part.includes("oblique")) {
      style = "oblique";
    }
    for (const [weightName, weightValue] of Object.entries(WEIGHT_MAP)) {
      if (part.startsWith(weightName)) {
        weight = weightValue;
        if (part.includes("italic")) {
          style = "italic";
        }
      }
    }
  }
  return { family, weight, style };
}
function fontKey(family, weight, style) {
  return `${family}-${weight}-${style}`;
}
async function fontToDataUri(filePath) {
  const buffer = await readFile2(filePath);
  const ext = extname2(filePath).toLowerCase();
  const mimeType = FONT_MIME_TYPES[ext];
  if (!mimeType) {
    throw new Error(`Unsupported font format: ${ext}`);
  }
  const base64 = buffer.toString("base64");
  return `data:${mimeType};base64,${base64}`;
}
function generateFontFaceCSS(entry) {
  const lines = ["@font-face {"];
  lines.push(`  font-family: '${entry.family}';`);
  lines.push(`  font-weight: ${entry.weight};`);
  lines.push(`  font-style: ${entry.style};`);
  lines.push(`  font-display: swap;`);
  lines.push(`  src: url('${entry.dataUri}') format('${entry.format}');`);
  if (entry.unicodeRange) {
    lines.push(`  unicode-range: ${entry.unicodeRange};`);
  }
  lines.push("}");
  return lines.join(`
`);
}
async function scanFontsDirectory(dir) {
  const files = [];
  try {
    const entries = await readdir2(dir, { withFileTypes: true });
    for (const entry of entries) {
      const fullPath = join2(dir, entry.name);
      if (entry.isDirectory()) {
        const subFiles = await scanFontsDirectory(fullPath);
        files.push(...subFiles);
      } else if (entry.isFile()) {
        const ext = extname2(entry.name).toLowerCase();
        if (SUPPORTED_EXTENSIONS2.has(ext)) {
          files.push(fullPath);
        }
      }
    }
  } catch (error) {
    console.warn(`    Could not scan fonts directory: ${dir}`);
  }
  return files;
}
async function buildFontManifest(options) {
  const opts = { ...DEFAULT_OPTIONS2, ...options };
  const fonts = {};
  let totalSize = 0;
  let totalCount = 0;
  console.log(`
\uD83D\uDD24 Building font manifest from: ${opts.fontsDir}`);
  try {
    await stat2(opts.fontsDir);
  } catch {
    console.warn(`    Fonts directory not found: ${opts.fontsDir}`);
    return {
      version: "1.0.0",
      generatedAt: new Date().toISOString(),
      fonts: {},
      fontFaceCSS: "",
      totalSize: 0,
      totalCount: 0
    };
  }
  const files = await scanFontsDirectory(opts.fontsDir);
  console.log(`   Found ${files.length} font file(s)`);
  const fontGroups = new Map;
  for (const filePath of files) {
    const { family, weight, style } = parseFontFilename(filePath);
    const key = fontKey(family, weight, style);
    const existing = fontGroups.get(key) || [];
    existing.push(filePath);
    fontGroups.set(key, existing);
  }
  for (const [key, groupFiles] of fontGroups) {
    const sorted = groupFiles.sort((a, b) => {
      const extA = extname2(a).toLowerCase();
      const extB = extname2(b).toLowerCase();
      const indexA = opts.preferredFormats.indexOf(extA.slice(1));
      const indexB = opts.preferredFormats.indexOf(extB.slice(1));
      return (indexA === -1 ? 999 : indexA) - (indexB === -1 ? 999 : indexB);
    });
    const filePath = sorted[0];
    const ext = extname2(filePath).toLowerCase();
    const stats = await stat2(filePath);
    if (stats.size > (opts.maxInlineSize || DEFAULT_OPTIONS2.maxInlineSize)) {
      console.warn(`    Skipping ${basename(filePath)}: too large (${(stats.size / 1024).toFixed(1)}KB)`);
      continue;
    }
    const { family, weight, style } = parseFontFilename(filePath);
    const dataUri = await fontToDataUri(filePath);
    fonts[key] = {
      family,
      weight,
      style,
      format: FONT_FORMAT_STRINGS[ext],
      dataUri,
      size: stats.size,
      unicodeRange: opts.unicodeRanges?.[family]
    };
    totalSize += stats.size;
    totalCount++;
    console.log(`    ${family} ${weight} ${style} (${(stats.size / 1024).toFixed(1)}KB)`);
  }
  const fontFaceCSS = Object.values(fonts).map(generateFontFaceCSS).join(`

`);
  console.log(`
   Total: ${totalCount} fonts, ${(totalSize / 1024).toFixed(1)}KB`);
  return {
    version: "1.0.0",
    generatedAt: new Date().toISOString(),
    fonts,
    fontFaceCSS,
    totalSize,
    totalCount
  };
}
function getFontFaceCSS(manifest, families) {
  if (!families || families.length === 0) {
    return manifest.fontFaceCSS;
  }
  const familySet = new Set(families.map((f) => f.toLowerCase()));
  return Object.values(manifest.fonts).filter((font) => familySet.has(font.family.toLowerCase())).map(generateFontFaceCSS).join(`

`);
}
var UNICODE_RANGES = {
  latin: "U+0000-00FF, U+0131, U+0152-0153, U+02BB-02BC, U+02C6, U+02DA, U+02DC, U+2000-206F, U+2074, U+20AC, U+2122, U+2191, U+2193, U+2212, U+2215, U+FEFF, U+FFFD",
  latinExtended: "U+0100-024F, U+0259, U+1E00-1EFF, U+2020, U+20A0-20AB, U+20AD-20CF, U+2113, U+2C60-2C7F, U+A720-A7FF",
  greek: "U+0370-03FF",
  cyrillic: "U+0400-045F, U+0490-0491, U+04B0-04B1, U+2116",
  vietnamese: "U+0102-0103, U+0110-0111, U+0128-0129, U+0168-0169, U+01A0-01A1, U+01AF-01B0, U+1EA0-1EF9, U+20AB",
  numbersOnly: "U+0030-0039, U+002C, U+002E",
  emoji: "U+1F600-1F64F, U+1F300-1F5FF, U+1F680-1F6FF, U+1F1E0-1F1FF"
};
function generateFontStackCSS(manifest, stacks) {
  let css = manifest.fontFaceCSS + `

`;
  for (const [variable, { primary, fallbacks }] of Object.entries(stacks)) {
    const stack = [
      `'${primary}'`,
      ...fallbacks.map((f) => f.includes(" ") ? `'${f}'` : f)
    ].join(", ");
    css += `--${variable}: ${stack};
`;
  }
  return css;
}
// src/prerender.ts
function escapeHtml(str) {
  return str.replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;").replace(/"/g, "&quot;").replace(/'/g, "&#039;");
}
function renderTree(node) {
  if (typeof node === "string") {
    return escapeHtml(node);
  }
  const { type, props = {}, children = [] } = node;
  const htmlTags = new Set([
    "div",
    "span",
    "p",
    "h1",
    "h2",
    "h3",
    "h4",
    "h5",
    "h6",
    "a",
    "button",
    "img",
    "svg",
    "section",
    "header",
    "footer",
    "main",
    "nav",
    "aside",
    "article",
    "ul",
    "ol",
    "li",
    "form",
    "input",
    "textarea",
    "select",
    "option",
    "label",
    "table",
    "thead",
    "tbody",
    "tr",
    "th",
    "td",
    "video",
    "audio",
    "source",
    "canvas",
    "iframe",
    "strong",
    "em",
    "code",
    "pre",
    "blockquote",
    "hr",
    "br",
    "figure",
    "figcaption",
    "picture",
    "time",
    "mark"
  ]);
  const voidElements = new Set([
    "img",
    "input",
    "br",
    "hr",
    "meta",
    "link",
    "source",
    "area",
    "base",
    "col",
    "embed",
    "param",
    "track",
    "wbr"
  ]);
  const attrs = [];
  for (const [key, value] of Object.entries(props)) {
    if (key === "children")
      continue;
    if (value === undefined || value === null)
      continue;
    if (key === "className") {
      attrs.push(`class="${escapeHtml(String(value))}"`);
    } else if (key === "htmlFor") {
      attrs.push(`for="${escapeHtml(String(value))}"`);
    } else if (typeof value === "boolean") {
      if (value)
        attrs.push(key);
    } else if (key === "style" && typeof value === "object") {
      const styleStr = Object.entries(value).map(([k, v]) => `${k.replace(/[A-Z]/g, (m) => "-" + m.toLowerCase())}: ${v}`).join("; ");
      attrs.push(`style="${escapeHtml(styleStr)}"`);
    } else if (key.startsWith("data-") || key.startsWith("aria-")) {
      attrs.push(`${key}="${escapeHtml(String(value))}"`);
    } else if (typeof value === "string" || typeof value === "number") {
      attrs.push(`${key}="${escapeHtml(String(value))}"`);
    }
  }
  const attrStr = attrs.length > 0 ? " " + attrs.join(" ") : "";
  if (htmlTags.has(type)) {
    if (voidElements.has(type)) {
      return `<${type}${attrStr}>`;
    }
    const childContent = children.map((c) => renderTree(c)).join("");
    return `<${type}${attrStr}>${childContent}</${type}>`;
  }
  return children.map((c) => renderTree(c)).join("");
}
function markInteractiveNodes(node, context) {
  const interactiveComponents = new Set([
    "Button",
    "Input",
    "Select",
    "Textarea",
    "Form",
    "Modal",
    "Dialog",
    "Dropdown",
    "Menu",
    "Popover",
    "Accordion",
    "Tabs",
    "Carousel",
    "Slider",
    "ChatWidget",
    "EmotionWheel",
    "DashboardWidget"
  ]);
  const newProps = { ...node.props };
  if (interactiveComponents.has(node.type)) {
    const id = `aeon-${Date.now().toString(36)}-${Math.random().toString(36).slice(2, 6)}`;
    newProps["data-aeon-interactive"] = "true";
    newProps["data-aeon-component"] = node.type;
    newProps["data-aeon-id"] = id;
    context.interactiveNodes.push({
      id,
      type: node.type,
      hydrationMode: "lazy"
    });
  }
  const newChildren = node.children?.map((child) => {
    if (typeof child === "string")
      return child;
    return markInteractiveNodes(child, context);
  });
  return {
    ...node,
    props: Object.keys(newProps).length > 0 ? newProps : undefined,
    children: newChildren
  };
}
function generateHydrationScript(context, env = {}) {
  const hasInteractive = context.interactiveNodes.length > 0;
  const speculationScript = `
// Aeon Speculation - Pre-render predicted pages for instant navigation
const sp={c:new Map(),o:null,
init(){if(this.o)return;this.o=new IntersectionObserver(e=>e.forEach(en=>{if(en.isIntersecting){this.o.unobserve(en.target);this.pr(en.target.pathname)}}),{rootMargin:'200px'});document.querySelectorAll('a[href^="/"]').forEach(l=>this.o.observe(l));this.pp()},
async pr(r){if(this.c.has(r)||location.pathname===r)return;try{const res=await fetch(r+'?_aeon_pr=1',{headers:{'X-Aeon-Prerender':'1'}});if(res.ok){const html=await res.text();this.c.set(r,{html,t:Date.now()})}}catch{}},
async nav(r){const p=this.c.get(r);if(p&&Date.now()-p.t<300000){document.open();document.write(p.html);document.close();history.pushState({aeon:1},'',r);setTimeout(()=>sp.init(),0);return true}return false},
pp(){const pred=[...document.querySelectorAll('a[href^="/"]')].slice(0,3).map(l=>l.pathname);pred.forEach(r=>this.pr(r))}
};
document.addEventListener('click',async e=>{const l=e.target.closest('a[href^="/"]');if(!l||e.metaKey||e.ctrlKey)return;if(await sp.nav(l.pathname))e.preventDefault()});
window.addEventListener('popstate',e=>{if(e.state?.aeon){const p=sp.c.get(location.pathname);if(p){document.open();document.write(p.html);document.close();setTimeout(()=>sp.init(),0)}}});
sp.init();`;
  const hydrationScript = hasInteractive ? `
// Aeon Hydration - Lazy load interactive components
const h=async(e)=>{const c=e.dataset.aeonComponent;try{const m=await import('/_aeon/c/'+c+'.js');m.hydrate(e)}catch(err){console.error('[aeon] Failed to hydrate:',c,err)}};
const io=new IntersectionObserver((es)=>{es.forEach(e=>{if(e.isIntersecting){io.unobserve(e.target);h(e.target)}})},{rootMargin:'100px'});
document.querySelectorAll('[data-aeon-interactive]').forEach(e=>io.observe(e));` : "";
  const aeonConfig = JSON.stringify({
    env,
    components: context.interactiveNodes.map((n) => n.type)
  });
  return `<script type="module">
window.__AEON__=${aeonConfig};${speculationScript}${hydrationScript}
</script>`;
}
function prerenderPage(session, options) {
  const startTime = Date.now();
  const context = {
    cssClasses: new Set,
    assets: new Set,
    fonts: new Set,
    interactiveNodes: []
  };
  const markedTree = markInteractiveNodes(session.tree, context);
  const resolvedTree = resolveAssetsInTree(markedTree, options.assetManifest);
  const cssClasses = extractClassesFromTree(resolvedTree);
  cssClasses.forEach((c) => context.cssClasses.add(c));
  const componentCSS = generateCSSForClasses(cssClasses);
  const criticalCSS = generateCriticalCSS();
  const fontCSS = getFontFaceCSS(options.fontManifest, options.fontFamilies);
  const fullCSS = `${criticalCSS}
${fontCSS}
${componentCSS}`;
  const htmlContent = renderTree(resolvedTree);
  const hydrationScript = options.addHydrationScript !== false ? generateHydrationScript(context, options.env) : "";
  const title = session.data.title || "AFFECTIVELY";
  const description = session.data.description || "";
  const html = `<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>${escapeHtml(title)}</title>
  ${description ? `<meta name="description" content="${escapeHtml(description)}">` : ""}
  <style>${fullCSS}</style>
</head>
<body>
  <div id="root">${htmlContent}</div>
  ${hydrationScript}
</body>
</html>`;
  const renderTime = Date.now() - startTime;
  return {
    route: session.route,
    html,
    css: fullCSS,
    size: html.length,
    renderedAt: new Date().toISOString()
  };
}
async function prerenderAllPages(sessions, options) {
  const startTime = Date.now();
  const pages = [];
  let totalSize = 0;
  console.log(`
\uD83D\uDCC4 Pre-rendering ${sessions.length} page(s)...`);
  for (const session of sessions) {
    const page = prerenderPage(session, options);
    pages.push(page);
    totalSize += page.size;
    console.log(`    ${session.route} (${(page.size / 1024).toFixed(1)}KB)`);
  }
  const totalTime = Date.now() - startTime;
  console.log(`
   Total: ${pages.length} pages, ${(totalSize / 1024).toFixed(1)}KB in ${totalTime}ms`);
  console.log(`   Avg per page: ${(totalSize / pages.length / 1024).toFixed(1)}KB`);
  return { pages, totalSize, totalTime };
}
function generatePreRenderSeedSQL(pages, version) {
  const lines = [
    "-- Pre-rendered pages",
    `-- Generated: ${new Date().toISOString()}`,
    `-- Version: ${version}`,
    `-- Total pages: ${pages.length}`,
    "",
    "-- Clear existing pre-rendered pages",
    "DELETE FROM rendered_pages WHERE version != '" + version + "';",
    ""
  ];
  for (const page of pages) {
    const escapedHtml = page.html.replace(/'/g, "''");
    lines.push(`INSERT OR REPLACE INTO rendered_pages (route, html, version, rendered_at) VALUES ('${page.route}', '${escapedHtml}', '${version}', '${page.renderedAt}');`);
  }
  return lines.join(`
`);
}
function generateManifestSeedSQL(cssManifest, assetManifest, fontManifest, version) {
  const lines = [
    "-- Render manifests",
    `-- Generated: ${new Date().toISOString()}`,
    `-- Version: ${version}`,
    "",
    "-- Clear existing manifests",
    "DELETE FROM render_manifests WHERE version != '" + version + "';",
    ""
  ];
  const cssJson = JSON.stringify(cssManifest).replace(/'/g, "''");
  const assetJson = JSON.stringify(assetManifest).replace(/'/g, "''");
  const fontJson = JSON.stringify(fontManifest).replace(/'/g, "''");
  lines.push(`INSERT OR REPLACE INTO render_manifests (type, version, manifest) VALUES ('css', '${version}', '${cssJson}');`);
  lines.push(`INSERT OR REPLACE INTO render_manifests (type, version, manifest) VALUES ('assets', '${version}', '${assetJson}');`);
  lines.push(`INSERT OR REPLACE INTO render_manifests (type, version, manifest) VALUES ('fonts', '${version}', '${fontJson}');`);
  return lines.join(`
`);
}
function generatePreRenderMigrationSQL() {
  return `-- Pre-rendered pages table
-- Generated: ${new Date().toISOString()}

CREATE TABLE IF NOT EXISTS rendered_pages (
  route TEXT PRIMARY KEY,
  html TEXT NOT NULL,
  version TEXT NOT NULL,
  rendered_at TEXT NOT NULL,
  created_at TEXT DEFAULT CURRENT_TIMESTAMP
);

CREATE INDEX IF NOT EXISTS idx_rendered_pages_version ON rendered_pages(version);

-- Render manifests table
CREATE TABLE IF NOT EXISTS render_manifests (
  type TEXT PRIMARY KEY,
  version TEXT NOT NULL,
  manifest TEXT NOT NULL,
  created_at TEXT DEFAULT CURRENT_TIMESTAMP
);
`;
}
export {
  resolveAssetsInTree,
  prerenderPage,
  prerenderAllPages,
  inlineSvg,
  getFontFaceCSS,
  getAssetDataUri,
  generatePreRenderSeedSQL,
  generatePreRenderMigrationSQL,
  generateManifestSeedSQL,
  generateFontStackCSS,
  generateCriticalCSS,
  generateCSSForClasses,
  generateCSSForClass,
  extractClassesFromTree,
  buildFontManifest,
  buildCSSManifest,
  buildAssetManifest,
  UNICODE_RANGES
};
